<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE proceeding SYSTEM "proceeding.dtd">
<proceeding ver="6.0" ts="04/10/2010">
<conference_rec>
	<conference_date>
		<start_date></start_date>
		<end_date></end_date>
	</conference_date>
	<conference_loc>
		<city><![CDATA[]]></city>
		<state></state>
		<country></country>
	</conference_loc>
	<conference_url></conference_url>
</conference_rec>
<series_rec>
	<series_name>
		<series_id>SERIES382</series_id>
		<series_title><![CDATA[International Conference on Computer Graphics and Interactive Techniques]]></series_title>
		<series_vol></series_vol>
	</series_name>
</series_rec>
<proceeding_rec>
	<proc_id>133994</proc_id>
	<acronym>SIGGRAPH '92</acronym>
	<proc_desc>Proceedings of the 19th annual conference</proc_desc>
	<conference_number></conference_number>
	<proc_class>conference</proc_class>
	<proc_title>Computer graphics and interactive techniques</proc_title>
	<proc_subtitle></proc_subtitle>
	<proc_volume_no></proc_volume_no>
	<isbn>0-89791-479-1</isbn>
	<issn></issn>
	<eissn></eissn>
	<copyright_year>1992</copyright_year>
	<publication_date>07-01-1992</publication_date>
	<pages>420</pages>
	<plus_pages></plus_pages>
	<price><![CDATA[]]></price>
	<other_source>ACM member price $40</other_source>
	<publisher>
		<publisher_id>PUB27</publisher_id>
		<publisher_code>ACMNY</publisher_code>
		<publisher_name>ACM</publisher_name>
		<publisher_address>2 Penn Plaza, Suite 701</publisher_address>
		<publisher_city>New York</publisher_city>
		<publisher_state>NY</publisher_state>
		<publisher_country>USA</publisher_country>
		<publisher_zip_code>10121-0701</publisher_zip_code>
		<publisher_contact>Bernard Rous</publisher_contact>
		<publisher_phone>212 869-7440</publisher_phone>
		<publisher_isbn_prefix></publisher_isbn_prefix>
		<publisher_url>www.acm.org/publications</publisher_url>
	</publisher>
	<sponsor_rec>
		<sponsor>
			<sponsor_id>SP932</sponsor_id>
			<sponsor_name>ACM Special Interest Group on Computer Graphics and Interactive Techniques</sponsor_name>
			<sponsor_abbr>SIGGRAPH</sponsor_abbr>
		</sponsor>
	</sponsor_rec>
	<categories>
		<primary_category>
			<cat_node>I.3.0</cat_node>
			<descriptor/>
			<type/>
		</primary_category>
	</categories>
	<ccs2012>
		<concept>
			<concept_id>0.10010147.10010371</concept_id>
			<concept_desc>CCS->Computing methodologies->Computer graphics</concept_desc>
			<concept_significance>100</concept_significance>
		</concept>
		<concept>
			<concept_id>0.10010147.10010371</concept_id>
			<concept_desc>CCS->Computing methodologies->Computer graphics</concept_desc>
			<concept_significance>500</concept_significance>
		</concept>
	</ccs2012>
	<general_terms>
		<gt>Algorithms</gt>
		<gt>Design</gt>
		<gt>Human Factors</gt>
		<gt>Performance</gt>
		<gt>Standardization</gt>
		<gt>Theory</gt>
	</general_terms>
	<chair_editor>
		<ch_ed>
			<person_id>PP40041417</person_id>
			<author_profile_id><![CDATA[81100411412]]></author_profile_id>
			<orcid_id></orcid_id>
			<seq_no>1</seq_no>
			<first_name><![CDATA[James]]></first_name>
			<middle_name><![CDATA[J.]]></middle_name>
			<last_name><![CDATA[Thomas]]></last_name>
			<suffix><![CDATA[]]></suffix>
			<affiliation><![CDATA[Battelle Pacific Northwest Labs, Richland, WA]]></affiliation>
			<role><![CDATA[Editor]]></role>
			<email_address><![CDATA[]]></email_address>
		</ch_ed>
	</chair_editor>
	<ccc>
		<copyright_holder>
			<copyright_holder_name>ACM</copyright_holder_name>
			<copyright_holder_year>1992</copyright_holder_year>
		</copyright_holder>
	</ccc>
</proceeding_rec>
<content>
	<article_rec>
		<article_id>133999</article_id>
		<sort_key>19</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>1</seq_no>
		<title><![CDATA[A telecomputer]]></title>
		<page_from>19</page_from>
		<page_to>23</page_to>
		<doi_number>10.1145/133994.133999</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=133999</url>
		<categories>
			<primary_category>
				<cat_node>H.4.3</cat_node>
				<descriptor/>
				<type/>
			</primary_category>
			<other_category>
				<cat_node>H.1.2</cat_node>
				<descriptor>Human factors</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>C.2.0</cat_node>
				<descriptor>Data communications</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>H.5.1</cat_node>
				<descriptor></descriptor>
				<type></type>
			</other_category>
			<other_category>
				<cat_node>I.3.0</cat_node>
				<descriptor></descriptor>
				<type></type>
			</other_category>
			<other_category>
				<cat_node>K.4.3</cat_node>
				<descriptor></descriptor>
				<type></type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10002951.10003227.10003251</concept_id>
				<concept_desc>CCS->Information systems->Information systems applications->Multimedia information systems</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003456.10003457.10003567</concept_id>
				<concept_desc>CCS->Social and professional topics->Professional topics->Computing and business</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010583.10010588</concept_id>
				<concept_desc>CCS->Hardware->Communication hardware, interfaces and storage</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003120.10003121</concept_id>
				<concept_desc>CCS->Human-centered computing->Human computer interaction (HCI)</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003033</concept_id>
				<concept_desc>CCS->Networks</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002951.10003260.10003282.10003286</concept_id>
				<concept_desc>CCS->Information systems->World Wide Web->Web applications->Internet communications tools</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Human Factors</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>PP39074891</person_id>
				<author_profile_id><![CDATA[81332493735]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Jim]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Clark]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Silicon Graphics, Inc.]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 Computer Gra~hics, 26, 2, JUIV1992 A TeleComputer Jim Clark Silicon Graphics, Inc. As digital computing 
costs decline over the next ten years, computer technology s most widespread use will be in consumer 
applications. The future digital television screen will be a natural visual control center for many new 
applications, such as normal television entertainment, virtual reality games, home control systems, interactive 
books, magazines and newsprirt~ and telephonic, televideo and data communications. A client-server network 
environment can exist in which the network is the merged cable-tv/telephone system, the client is a home 
telecomputer that controls the images seen, and the server is a multi-mdla computer system that is integral 
to the cable head-end or telecommunications central-office. 1 In this paper, I attempt to define the 
functionality of a telecomputer so that the broadest set of applications is possible. Introduction. Multi-meda 
means the integration of audio, video, graphics and computing into a single digital environment. It promises 
many new applications that can utilize this combination of techno 10gies. Most people expect the integration 
to come in next generation personal computers, and many computer companies are working to this end. But 
for the ordinary consumer, a more likely possibility is that a telecomputer will bridge the gap between 
television and multi-media computing. Think of this multi-media player as the digital equivalent of the 
cable-tv decoder --it will be the consumer s computer. It s central role will continue to be entertainment, 
such as movies, tv programs and interactive games, but it can also be capable of many functions, including: 
-textbooks that teach through graphic simulation and animation coupled with audio and videm -media reaieval 
from databases and libraries -newspaper and magazine retrieval -multiparticipant virtual reality games 
-digital television entertainment services -digital audio retrieval -media mail -video telephones A low-cost 
telecomputer in the home is important before authors will invest in writing interactive books. And interactive 
media services on demand, such as magazines, newspapers, books, encyclopedias, games, and digital audio/video 
entertainment, need a digital media player in the home before the services can develop. Computer Industry 
Milestone. The computer industry can benefit enormously by defining telecomputer building blocks so that 
they can be used in standard multi-media computers. This will ensure compatibility between the consumer 
and computing worlds --the client and the server. Also, the distribution volumes of consumer electronics 
can dramatically decrease the cost of computers, enabling portable (tele)computers far more powerful 
than possible today. Perrrussi{m10copywlthou!Iectill or pm (It [hISnmteritil ISgrunted provided thut 
the copies we nn[ miuk or d]str]bu[ed for direct conmwrcial whuntage. the ACM copyright notice and the 
title (i the publicwimr and IIS date qrptar. wrd notwc is given th~t copying is by permlssltm ~WIhe A\\twl:itwr 
Ihr Ctmputirrg Mwhincry, Tn copy otbcrv i.e. or I(I rcpuhllsb. requires ii ICCmd,(~r spccitic parrrissmn 
 A telecomputer s main elements will come from the technologies of networking, computer systems, computer 
graphics, image processing and semiconductors, all with a focus on the economies of scale of consumer 
electronics. But to achieve a low~st telecomputer for the cost of today s cable-tv decoder electronics, 
intermediate parts suppliers, distributors, gate array manufacturers, and expensive packaging common 
m the computer industry will be circumvented. Success might even require that a single company be able 
to integrate almost everything, from semiconductor fabrication to the telecomputer itself. The computer 
industry, especially the workstation segment, haa an advantage because it haa already started to develop 
multi-media technology. Today s dominant consumer electronics companies do not yet fully grasp the range 
of digital imaging and graphics technologies necessary to create digital televisions, which helps explain 
why they continue to focus on analog approaches to HDTV. Teleprocessing Power. An enormous amount of 
processing power is required to decode an incoming, high­resolution digital television signal. It will 
need to be scaled to a different output screen resolution and decompressed in real­time, and pay-per-view 
services will require encryption. The scaling function done generally requires significant image­processing 
power to properly sample and filter the incoming image. Compression and encryption are just as demsutdmg. 
The main message of this paper is that the power required for this is essentially the same 55 that required 
for virtual-reality quality 3D graphics. Moreover, building a telecomputer with the additional graphics 
capability cart enable a broad range of markets that art ordinary digital television can not. The goal 
here is to functionally define and rationalize a $200 building block module that has the required capability. 
It is a combination of RISC processing power with multiple parallel data paths, caches, program memories, 
double-buffered full­color screen memories with z-buffer, generalized ultra high­speed interconnect for 
I/O, and suitable specialized hardware support for image processing, encryption, compression, and real-time 
2D and 3D high-end, textured graphics. The goal is achievable in 2-3 years. Semiconductor yields for 
foriay s most advanced CPU s allow about 100,000 mansistors/dollar in high-volume ~ ~ --the cost to 
J 1992 ACM-()-X9791-479-I 92/[)070019 $01.s0 SIGGRAPH 92 Chicago, July 26-31, 1992 the semiconductor 
company to fabricate the silicon chip and test it, By the end of the decade this number will approach 
one million. Lkewise, the ~ ~ of memory is about 50,000 Bytes/dollar today, and it will approach 500 
kByte/S by the end of the decade. Four million transistors devoted to RISC, encryption, compression, 
graphics and image processing would make a digital teleprocessor comfortably capable of everything discussed 
in this paper. Today, this can be combined with up to 20 megabytes of image memory, for HDTV resolutions, 
and packaged economically on a single low-power module for under $600 silicon mamtfaeturing cost. Within 
two to three years, this number will fall below $200 end be compelling.  The Basic Technologies. Four 
basic technologies are required for multi-media: digital audio, digital video firnage processing, computer 
graphics and general-purpose processing. Digital Audio. Digital audio is the most thoroughly understood 
technology because of compact disks, which store two channels of 16-bit samples at the rate of 44 kHz, 
or 88 kBytes/sec/channel bandwidth. Sony Corporation has shown that 4:1 compression achievable with no 
perceptible loss, so 22 ~ yteslsecfchannel is probably minimum to keep high­fidelity. Processing at this 
data rate is not difficult compared to the date rates of digital video. Digital Video. Digital television 
transmission standards have been slow to develop. I think much of the reason for this is because the 
problem is viewed from traditional analog television perspectives. Those involved don t fully comprehend 
the benefits and capabilities of digital imaging. Much of the motivation for this paper is to give a 
computer graphics perspective to this, beeause I am convinced that the computer graphics community can 
solve many of the issues confronting the development of digital television. Transmission/Reception Decoupling. 
Analog systems are always in lock-step. For example, the vertical retrace pulse is tmmsmitted and after 
a freed phase delay related to the speed of signal travel to the receiver, it causes a retrace of the 
receiver. Sirrderly, if scan-lines are interlaced at trensmissiom the receiver must put them immediately 
to the screen in interlaced form as they arrive. In effect, buffering analog is very difficult. In contres~ 
a digital television receiver s input parameters can be completely decoupled from its output to the viewing 
device. This means interleaving, for example, is not even related to transmission. A complete incoming 
digital tv frame would be stored in a frame buffer memory before it is outpu~ i.e. it would be double-buffered. 
The complete frame data might even be transmitted over a fiber-optic link carrying several hundred other 
channels multiplexed onto the same carrier, which of course would require storing fragments of the image 
in a buffer until the complete fhme is received. It might tdso be encrypted for selective pay-per-view 
reception and compressed to save bandwidth, both of which require real-time processing on the incoming 
data. It might even be transmitted in a special color space. All of these can be altered by the telecomputer 
processor (teleprocessor) before display on the screen. Resolution Decoupling. In a digital system, the 
transmitted resolution can be totally decoupled from the displayed resolution. Digital subssmpling or 
supersempling and filtering can be done by a teleprocessor if neee-ssary to suite any output resolution 
or scan-line interlace discipline. NTSC, PAL end digital standards D1 and D2 can easily be generated, 
no matter what the resolution of the incoming signal, for compatibility with existing standards. A digital 
receiver with the right processor cart easily be made to filter a digital video transmission format to 
generate any output format. Compatibility with existing technology can be complete. The transmission 
resolution can be made imelevant. What s Important. Ignoring specifics related to the transmission network 
and protocols, a fairly smell set of specrlcations are necessary for digital video transmission -resolution 
-pixel aspect ratio number of bits pa pixel ~ encodiig of these bits (HSV, RGB, ...) -sequential or interlaced 
lines -compression algorithm used -encryption technique USed -and frame transmission rate. Even some 
of these are unnecessary. For example, the pixel aspect ratio should be square. Nothing is gained from 
ratios other than 1:1 except for compatibility with the analog High­vision format out of Japan, and uniform 
horizontal and vertical computer generated lines are more important than conformity with en unestablished 
analog broadcast approach. Vertical and horizontal computer generated lines should be the same. There 
also is no compelling reason to transmit scan lines in an interleaved manner, since input and output 
are naturally decoupled. The fact that this has been part of the HDTV &#38;bate points to the limitations 
of an analog perspective. If the output display requires interlaced scan lines, es with NTSC, the telccomputer 
processor will do this at output time. Sequential input simplifies everything and loses nothing. Soft 
Digital Transmission Parameters. The remaining soft parameters should be transmitted to the digital receive~ 
1. Resolution 2. Encoding and Bits/pixel 3. Frame Rate 4. Encryption Algorithm 5. Compression Algorithm 
  1. Resolution.. Transmission resolution should be completely independent of the display resolution 
on the output device. Any resolution should be allowed. High Definition Television (HIYTV) resolutions 
now being considered by the FCC range from roughly 1000x7OO to about 2WMX1OOO. Aspect ratios of 16x9 
are important for movie transmission, so perhaps the ideal high-definition resolution is 182OX1O24. The 
important thing is that the transmission resolution should depend on the source material, and nothing 
else --it should be soft. The telecomputer should map ~ input resolution (up to some Computer Graphics, 
26, 2, July 1992 maximum, of course) to ~ output resolution. Normally, input and output aspect ratios 
would be the same, but a window on the television might be of any size, and subssmpling or superssmpling 
is necessary for different resolutions or aspect ratios. Any teleprocessor must be able to do these image 
processing functions. 2. Encoding. The particular color-space encoding and number of bits per color-space 
component should be specified by the transmitter, because some formats might yield better compression. 
Yet the output display might require a different format. The receiver s teleprocessor should accept a 
range of possible formats and number of bits per component. Conversion to output format should be automatically 
handled by the teleprocessing engine using a simple 3x3 color space transformation. 3 Fnmne Rate. The 
update rate for animated images varies according to the source, and it should always be transmitted to 
the receiver. For example, 30 frames per second is common for today s analog video, 24 is common for 
movies recorded on film, and 12 is common for anirnat~ cimtoons. Any rate should be allowed --10 frrunes/sec 
might be adequate for videophones, for example. To save transmission bandwidth, the update rate should 
be part of the soft transmission parameters. Then the source material can be transmitted at its rate, 
not always at 30 frames/see as with analog video --this is mother form of compression that costs nothing. 
Also, just as in today s workstations, the telecomputer can synchronize the output refresh rate with 
the updote rute using conventional frame interleaving techniques. 4. Encryption. Encryption television 
and future provides selective access as pay-pw-view, and it many types of on-line with telecomputing. 
will be essential for digital telecommunications. Encryption to television programming, such will provide 
needed security for transactions that will be possible Public key encryption technologies, such as RSA 
are a natural fit. The teleprocessor should be able to encrypt and decode all transmissions and receptions 
at real-time rates, in addition to its other tasks. Specialized acceleration hardware will be necessary 
to do this in real-time, 5. Compression Algorithms. Compression is an area of considerable confusion 
and high expectation. Two things are driving it. First, cable television companies look to forthcoming 
digital optical fiber with compression as a solution to their bandwidth and signal degradation problems. 
Second, virtually all computer companies wish to compress video so that it can be stored and retrieved 
in real-time on CD-ROM S. Cable companies want to replace analog with a better product. Computer companies 
want video clips for multi-media. This has limitations. Trying to force a CD to store and retrieve video 
at audio rates of 1.408 Mbits/see is asking a lot. Perhaps as much effort should be exerted to cause 
a new VideoCD standard to be created. This could then replace old, sequential video tape, and consumer 
market volumes could be used to leverage into existence a powerful new storage mechanism. MPEG I is supposed 
to compress a 352x24, 30 frames/see signal into a 1 Mbit/see transmission rate, plus another 200k bits/see 
for sound. For general entertain ent quality, this seems unrealistic. MPEG II allows 5 to 10 Mbits/see 
on 720x480 resolution. Even this is only about one half to one blt ~r pixel. MPEG II seems overly complicated. 
h compresses 8x8 tiles of the image using a Discrete Cosine Transform (DCT), combined with Huffmsn encoding 
and a time consuming, semch-based, predictive tracking algorithm that is applied to these tiles during 
compression to try to predict their frame to frame trajectory, as in a scene with a panning camera. Not 
only does this seem overly ad hoc, but also the tiling pattern is evident in fast moving scenes. For 
entertainment, the consumer will not tolerate anything that actually looks worse than old analog technology 
--CDs would have failed if digital audio had been worse than 33 rpm records. Although MPEG 11 will be 
useful for multi­media, it might not be adequate for digital video entertainment. The important thhg, 
however, is not the specifications for MPEG II, or any other compression scheme. Rather, it is that compression 
is an embryonic technology, and better compress ion methods wi 11 be invented. Moreover, there will be 
a variety of compression algorithms, some high­compression where it can be tolerated and others low. 
compression --perhaps even lossless --to maintain the highest quality, as for example in Sony s 4:1 audio 
compression. The proper approach is to build mechanisms in the teleprocessor to accelerate core elements 
of compression, such as perhaps cosine transforms and pattern recognition, but allow the general-purpose 
processor to control the algorithm. The decompression algorithm itself might even be downloaded before 
transmission. The challenge for the present is to invent a range of algorithms covering high to low compression 
applications. If the objective were simply to specify a High-resolution Digital Television --HDTV--we 
could stop here and ignore advanced computer graphics. Current television has no graphics ability. But 
new markets are available, such as education and virtual-reality games, that will make the transition 
to digital tv more compelling for the consumer. Moreover, the real-time compute power and memory bandwidth 
required to sample, filter, store, retrieve, compress and encrypt digital video signals is essentially 
adequate for real-time 3D color graphics. Computer Graphics. Two approaches to computer graphics have 
developed over the last decade. The first is bit-mappeW graphics, which is _ single-buffered, black and 
white, one bit,lpixel, 2D, page­image oriented graphics, commonly found on an Apple Macintosh or Sun 
Workstation. It has revolutionized desktop publishing but is inappropriate for dynamic media. The other 
graphics approach is @na~ double-buffered, real-time, color, 3D, simulation oriented graphics commonly 
found on workstations from Silicon Graphics. As previously outlined, simple digital videa requires dynamic, 
double-buffered, full-color frame storage and real-time image processing capability. This power is shared 
with real-time 3D graphics. For example, filtering, sampling and mapping SIGGRAPH 92 Chicago, July 26-31, 
1992 incoming digital images from one resolution to another is identical to the computations required 
for anti-aliesed mapping of textures onto three dimensional surfaces. It is natural to minimize the graphics 
primitives in a telecomputer to the essentials. Today s graphics systems have lots of bells and whistles, 
but the four most important geometric graphics primitives are: -characters -points -lines -and surfaces. 
 These primitives should be -arbitrarily scald rotated end translated -illuminated t%om multiple light 
sources -and have textures and transparencies mapped onto them in real-time to provide a very general 
geometric graphics environment. Add image processing capability to -point-sample geometry -filter and 
accumulate images -store, retrieve end map anti-eliesed textures. The result is a graphics environment 
virtually as complete as the most expensive systems available today. Note that characters, like points, 
lines and surfaces, are geometric, yet all real-time graphics systems made in the last ten years have 
treated characters as images --previously rendered objects. As a result, only specific font sizes are 
available, end generalized rotations, scaling and other operations have not been possible in real-time. 
Geometric outline fonts are now commonplace, however, and they should be rendered in real-time like any 
other geometry. Additional herdwere will be necessary to enable a smeenful of characters to be rendered 
m a frame time, but fully interactive reel-time print media wi~ need iL The Teleprocesaor. Today s workstations 
in complete form are too complex for a telecomputer, but some things should be in common between them. 
The most crucial for compatibility is the CPU instruction set end the multi-media environment. This doesn 
t mean, however, that we put a workstation or PC in every television. UNIX, MS-DOS, NT , X-windows interfaces 
and keyboards are complicated end mean nothing for the most common consumsr uses. RISC Core. The programs 
that run on a telecomputer require a CPU, end the most efficient CPU is a Reduced Instruction Set CPU. 
It doesn t waste silicon space with microcO&#38; for unused instructions. Also, for a given semiconductor 
technology, CISC CPUS will ~ically mn slower end use more power. A RISC CPU allows more space to be used 
for graphics, compression, encryption and network protocol hardware. What would be an ideal RISC CPU 
cotilguration for graphics and image processing? A RISC CPU with 4 data paths, each with 32-bit integer 
end floating-point capability, each data path capable of multiply-add in one cycle, clocked m excess 
of 100 MHz. This would enable 800 million arithmetic operations per seam~ which would help achieve virtual-reality 
graphics speeds. The CPU would tdso need caches and program memory sufficient for holding the essential 
algorithms, and it would have to control network IKl and the graphics, compression and encryption eccekators. 
It should also be compatible with a widely available RISC processor used in workstations, in order to 
leverage the available digital media development tools. Operating System. A completely new Real-time 
Execution­onty operating System will be required, because no current operating system environment is 
efficient enough to do real­time image processing, graphics, compressi~ encryption end digital audio 
in a small amount of memory. UNIX and Microsoft s various OS flavors are too complex, and their features 
are unnecessary in a low-cos~ consumer multi-me&#38;a player . On the other hand, applications require 
a complete development environment. This means that conventional workstation/PC platforms will need a 
compatibility mode to support the Real-time Execution OS for program development and debugging. The Memory 
System. Cument DRAM organizations are wrong for digital image generation, and computer graphics systems 
designers have struggled with this for over ten years. The market opportunity presented by tehcomputers, 
however, is sufficiently large to fmelly motivate memory manufacturers to make high-density memories 
with a specialized organization for telecomputers, rather than just continuing to make chips that are 
wmpatible with the previous generation DRAM s. he main problem is bandwidth. The solution requires changes 
in DRAM design that are motivated by this new high-volume application. Thii paper cannot address the 
potential erchhecture of this new memory, but it is a very important requirement. For this paper end 
associated tallG I ll assume the right memory is available. Basic Memory Requirements. A digital television 
image requires a minimum of about 2 bytes per pixel to store a static image. Using dithering tedmiques, 
it is possible to get by with somewhat less, but I believe the effort required to reduce the memory by 
a few percent is not worth i~ because of the rate of decline in memory prices. Two buffers are required 
for a dynamic image, so 4 bytes/pixel are the minimum. How much more storage does 3D graphics require? 
For the simplest case --no texture mapping --a total of about 4 bytes/pixel is required for z-buffer, 
transparency coefficient alpha and tags for window management. This doubles the memory requirements of 
a basic digital tv. Conventional NTSC resolutions will fit within a 640x512 pixel image memory of 327,680 
pixels. A basic digital tv with NTSC output would therefore need 1.32 MBytes, and the simplest 3D telecomputer 
requires twice this, not counting program storage. Advanced 3D Capability. Adding texture mapping dramatically 
increases the realism of 3D images, thus enabling virtual-reality quality. The additional memory needed 
depends upon the sizes and number of different texture maps. If 2 bytes/pixel are needed to store an 
image, 4 bytes/pixel are required for a fill-screen texture map using traditional MIP-map techniques 
for deslissing treatment. But even very small, cyclic texture maps can considerably emich a 3D scene, 
so 4 bytes/pixel is considerable texture storage. A typical telecomputer with NTSC output resolution 
would therefore have 1.32 MByte of memory for image buffers, 1.32 MByte for z-buffer and transparency, 
1.32 MBytes for textures and perhaps 2 MBytes of program memory. The total memory costs today for a virtual-reality, 
3D telecomputer with NTSC output would be under $120, and cart be under $30 in the mid 90 s. High-resolution 
Digital Television (HDTV). Digital television and telecomputers wilI finally allow variable transmission 
resolutions that can be different from receiver resolutions. Transmission resolutions can then be determined 
according to source material, not fixed for all time as with an analog system. Receiver resolution is 
variable too. The incoming picture might be subsampled to fh within a small window on the receiver s 
screen. The maximum resolution of the output CRT (or flat-panel display) determines the size of memory 
needed in the image buffer. Higher resolution input signals are filtered, sampled and stored in the image 
buffer as they amive. This requires a minimum of buffering if the incoming signal is not interlaced. 
If all receivers use the same teleprocessor, the main difference between them is evidently the amount 
of memory they have. But as resolution is increased, more pixels require more processing in order to 
maintain the same image processing and graphics update speed. Ideally, we d like a processor/memory module 
that can be replicated to make higher resolutions. Multiple copies would increase not only the memory 
available but also the processing power to change it. A module with 640x512 resolution memory and sufficient 
computing power to handle thk image size would work. First, it is adequate for NTSC output resolutions, 
which means it will work with standard televisions. Secand, four modules would make 1280x1 024, which 
is the commonly used resolution in color workstations. Finally, six modules makes 1920x 1024, which is 
adequate for an 1820x1024 HDTV resolution, with about 100 Kpixels left over. Each of these modules can 
have variable amounts of memory, according to the features desired, from plain digital television to 
virtual-reality capability. Summary and Closing Comments Over the next four to five years, unprecedented 
change will occur in the computer, telecommunications and television industries as multi-media technology 
enters the home via the telecomputer. This will require the development of a digital fiber-optic data 
communications network that replaces both the cable tv system and the telephone system. While this will 
certainly take many years to complete, just as cable systems have grown incrementally, so will dtk new 
system. But it will require the Computer Graphics, 26, 2, July 1992 telecomputer s capability to create 
a demand for the new services. The present local loop of the telephone system and the cable franchise 
for television will become one Multi-media Server Loop. Each loop will represent several tens of thousands 
of clients, each using a tekcomputer. In the loop will be high-speed computer systems for serving audio 
and movies on demand, virtual reality games, digital forms of daily newspapers, weekly and monthly magazines, 
libraries, encyclopedias and interactive books. In time, all media will be available in dynamic form. 
Switching systems for video conferences and telecommunications will be integrated, as well. A combination 
of semiconductor, computer graphics and computer industries have the capability to design a build a telecomputer 
with the power described in this paper. Current consumer electronics companies do not --they are encumbered 
by analog thinking and by preseming an irtstslled base. Yet a telecomputer cart be made so that it can 
still use existing television, as well as grow to higher resolution and higher quality in a modular way. 
The challenge is ours.  
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134001</article_id>
		<sort_key>25</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>2</seq_no>
		<title><![CDATA[A physically based approach to 2&#8211;D shape blending]]></title>
		<page_from>25</page_from>
		<page_to>34</page_to>
		<doi_number>10.1145/133994.134001</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134001</url>
		<categories>
			<primary_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Geometric algorithms, languages, and systems</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Curve, surface, solid, and object representations</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Animation</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.3</cat_node>
				<descriptor></descriptor>
				<type></type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010382</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Image manipulation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010352</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Animation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010372</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Rendering</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010399</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Parametric curve and surface models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010401</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Volumetric models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003752.10010061</concept_id>
				<concept_desc>CCS->Theory of computation->Randomness, geometry and discrete structures</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>P281616</person_id>
				<author_profile_id><![CDATA[81100400673]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Thomas]]></first_name>
				<middle_name><![CDATA[W.]]></middle_name>
				<last_name><![CDATA[Sederberg]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Brigham Young University]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P79529</person_id>
				<author_profile_id><![CDATA[81332502117]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[Eugene]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Greenwood]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Brigham Young University]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Adobe Systems, Inc. Adobe illustrator 88.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_obj_id>907204</ref_obj_id>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Bruce G. Baumgart. Geometric Modeling for Computer Vision. Phd thesis, Stanford University, Computer Science Department, 1974.]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_obj_id>807414</ref_obj_id>
				<ref_obj_pid>965139</ref_obj_pid>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Edwin Catmull. The problems of computer-assisted animation. Computer Graphics, 12(3):348-353, 1978.]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_obj_id>617460</ref_obj_id>
				<ref_obj_pid>616003</ref_obj_pid>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[Shenchang Eric Chert and Richard Parent. Shape averaging and its applications to industrial design. IEEE CGSA, 9(1):47-54, 1989.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_obj_id>807388</ref_obj_id>
				<ref_obj_pid>800248</ref_obj_pid>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[Henry N. Christiansen and Thomas W. Sederberg. Conversion of complex contour line definitions into polygonal element mosaics. Computer Graphics (Proc. SIG- GRAPH), 12(3):187-192, 1978.]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[Computer Support Corporation. Arts t~ Letters 3.01, 1991.]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Corel Systems Corporation, Ottawa, Canada. Corel. Draw! ~.0, 1990.]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_obj_id>359846</ref_obj_id>
				<ref_obj_pid>359842</ref_obj_pid>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[Henry Fuchs, Z. M. Kedem, and S. P. Uselton. Optimal surface reconstruction from planar contours. Comm. ACM, 20(10):693-702, 1977.]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_obj_id>801264</ref_obj_id>
				<ref_obj_pid>800064</ref_obj_pid>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[S. Ganapathy and T. G. Dennehy. A new general triangulation method for planar contours. Computer Graphics (Proc. SIGGRAPH}, 16(3):69-75, 1982.]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[Andrew Glassner. Metamorphosis. preprint, 1991.]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
			<ref>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[Eugene Greenwood. A physically based approach to 2- d shape interpolation. Master's thesis, Brigham Young University, Department of Mechanical Engineering, 1992.]]></ref_text>
				<ref_id>11</ref_id>
			</ref>
			<ref>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[Archie Higdon, Edward It. Ohlsen, William B. Stiles, John A. Weese, and William F. Riley. Mechanics of Materials. John Wiley &amp; Sons, Inc., New York, 1976.]]></ref_text>
				<ref_id>12</ref_id>
			</ref>
			<ref>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[Michael Kass, Andrew Witkin, and Demetri Terzopoulos. Snakes: Active contour models. International Journal of Computer Vision, 1(3):321-331, 1988.]]></ref_text>
				<ref_id>13</ref_id>
			</ref>
			<ref>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[Anii Kaul and Jarek Rossignac. Solid-interpolating deformations: Construction and animation of PIPs. In F.H. Post and W. Barth, editors, Proc. Eurographics '91, pages 493--505. Elsevier Science Publishers B.V, 1991.]]></ref_text>
				<ref_id>14</ref_id>
			</ref>
			<ref>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[E. Keppel. Approximating complex surfaces by triangulation of contour lines. IBM Journal of Research and Development, 19:2-11, 1975.]]></ref_text>
				<ref_id>15</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378495</ref_obj_id>
				<ref_obj_pid>378456</ref_obj_pid>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[David Kurlander and Eric A. Bier. Graphical search and replace. Computer Graphics, 22(4):113-120, 1988.]]></ref_text>
				<ref_id>16</ref_id>
			</ref>
			<ref>
				<ref_seq_no>17</ref_seq_no>
				<ref_text><![CDATA[Micrografx, Inc., Richardson, TX. Designer 3.1.]]></ref_text>
				<ref_id>17</ref_id>
			</ref>
			<ref>
				<ref_seq_no>18</ref_seq_no>
				<ref_text><![CDATA[Software Publishing Corp., Sunnyvale, CA. Harvard Graphics 3. O, 1991.]]></ref_text>
				<ref_id>18</ref_id>
			</ref>
			<ref>
				<ref_seq_no>19</ref_seq_no>
				<ref_text><![CDATA[Naonori Ueda and Satoshi Suzuki. Automatic shape model acquisition using multiscale segment matching. In Proc. lOth ICPR, pages 897--902. IEEE, 1990.]]></ref_text>
				<ref_id>19</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 Computer Graphics, 26,2, July 1992 A Physically Based Approach to 2 D Shape Blending Thomas W. Sederberg 
Eugene Greenwood Brigham Young University  Abstract This paper presents a new afgorithm for smoothly 
blending be­tween two 2-D polygonal shapes. The algorithm is based on a physical model wherein one of 
the shapes is considered to be con­structed of wire, and a solution is found whereby the first shape 
can be bent and/or stretched into the second shape with a min­imum amount of work. The resulting solution 
tends to associate regions on the two shapes which look alike. If the two polY­gons have m and n vertices 
respectively, the afgorithm is O(mn). The algorithm avoids local shape inversions in whkh intermediate 
polygons self-intersect, if such a solution exists. Categories and Subject Descriptors: 1.3.3 [Computer 
Graph­ ics]: Picture/Image Generation; 1.3.5 [Computer Graphics]: Computational Geometry and Object Modeling. 
General Terms: Algorithms Additional Key Words and Phrases: Computer graphics, shape blending, animation, 
physically based algorithms. Introduction The topic of this paper is illustrated in Figures -3. Given 
Figure 1: Shape blend example AcM-o-x97Yl-479 -l/92 /(M)7/cQ25 $01 so  -5 FF Figure 2: Shape blend 
example two polygonal shapes, the problem is to compute a continuous shape transformation from one to 
the other. For example, in Figure 1, the far left and far tight sketches of a chicken are given, and 
the three intermediate shapes are automatically computed with no user interaction. This operation is 
known variously as shape averaging, shape interpolation, metamor­phosis, shape evolving, and shape blending. 
It has widespread application in illustration, animation, and industrial design. 2-D shape blending is 
an increasingly popular feature in man ~;~;;;ial illustration software packages (such as [1], [6], [7% 
Figure 3: Shape blend example Solutions to the 3-D shape interpolation problem have also been proposed 
([4], [1o], [14]). Indeed, the research effort re­ported in this paper initially focused on the 3 D problem. 
However, the authors soon realized that even the 2-D prob­lem had many open questions, such a how can 
a shape blend algorithm avoid chaotic intermediate shapes and how can an ] Engineering Computer Graphics 
Laboratory 368 Clyde Building Brigham Young University Provo, UT 84602 801 378-6330 801 378-2478 FAXH 
tom@tws.ce.byu.edu algorithm recognize similar, t bough not identical, features on the two terminal 
shapes (such as the feet and head of the chicken in Figure 1) and maintain those features throughout 
the blend. We tested several commercial shape blending software pack­ages on some of our shape examples. 
The best of any results for the chicken outline is shown in Figure 4 and the best E to F blend is shown 
in Figure 5. Notice how the chicken feet in Figure 4 degenerate to a self-intersecting scribble. Figure 
4: Shape blend of chicken using commercial software EEFFFF Figure 5: Shape blend of E to F using commercial 
software The algorithm presented in this paper is baaed on a physical model. Imagining that each shape 
is made of a piece of wire, the blend is determined by computing the minimum work re­quired to bend and 
stretch one wire shape into the other. The user can specify some physical properties of the wire, which 
control the relative difficulty with which it can be bent or stretched. A severe penalty is charged for 
blends which expe­rience a local self intersection due to the wire bending through an angle of zero degrees. 
This penalty nearly always prevents the self intersection problem in Figure 4. AU of the blends in this 
paper were generated automatically with no user in­tervention (Figures 4 and 5 by commercial packages, 
the rest by our algorithm) except for initially specifying the physical attributes of the wire. 1.1 Related 
work Shape blending is a problem which has been motivated by several different applications and attacked 
in several different ways. For example, if we envision the family of blend poly­gons aa formin a ruled 
surface in (z, y, t) space, as shown in Figure 6, the sf ape blending problem bears strong similarity 
to the contour triangulation problem [5], [8], [9], [15]. This is the background from which we approached 
the problem, and our solution borrows graph theory concepts from [15] and [8]. The algorithms used in 
the commercial illustration software cited above probably resemble the triangulation algorithms in [5] 
and [9] since these are O(n) in time and memory, thus more suitable for PC applications than ones based 
on raph theory. The first paper on 3-D shape interpolation 4] was moti­ vated by industrial design. It 
tackles the pro [ Iem by slic­ ing the two 3 D shapes into contours, blendlng corresponding contours, 
then reconstructing the 3 D blended surface. More 7 recent solutions, [10] and [14 , are based on Minkowski 
sums. These approaches give impressive results, but leave some room for further investigation. For example, 
two non-convex objects 26 Figure 6: Family of blend polygons as a function oft with similar features 
(such aa a dog and a horse) will lose pro­truding detaUs such as legs during intermediate shapes. In 
fact, the blend of a non-convex object with itself is not a con­stant shape. Problems related to 2 D 
shape blending arise in shape recognition [2], [19] and curve matching for graphical search and replace 
[16 . In these applications, the primary concern is determining Low similar two complete objects are. 
Shape blending also resembles the computer vision problem of con­tour identification, for which one solution 
is based on en­ergy minimization [13], as is the shape blendhg algorithm described herein. When the two 
shapes to be blended are taken to be key frames in a character animation (such as in Figure 1) shape 
blending is similar to inbetweening an important compo­nent of the general problem of computer-assisted 
animation [3). The problem addressed in this paper, inbetweening of poly onal shape outlines, is simpler 
than the more general prob fem of inbetweening complete drawings. 1.2 Overview Section 2 discusses geometric 
aspects of the shape blending problem. The physical work model is discussed in section 3. The minimum 
work solution is found by means of a directed graph, as discussed in section 4. Section 5 presents several 
examples and discusses the relative influence of stretching and bending work. 2 Geometric preliminaries 
Given two polygons P. and PI with the same number of ver­tices, shape blending is accomplished by performing 
a linear interpolation between the corresponding vertices of the two polygons. If PO=[P:, Pf,..., P:]; 
P1 =[P~, P;,..., P:] (1) where P! denote vertices, intermediate polygons in the blend can be defined 
P(t) = uPO + tP1 = [uP:+tP;, uP; +tP; ,,.., uP: +tP:] = [P~(t), P~(t), ,.. ,Pn(t)] (2) where u = 1 -t. 
The motion of three adjacent vertices under­ going a shape blend is shown in Figure 7. Consider the simple 
example in Figure 8, where the vertex numbers are labeled. Each intermediate shape is determined by linearly 
interpolating each node as shown. The paths for vertices 1 and 3 are shown in dotted lines. Computer 
Graphics, 26,2, July 1992  izllixY211 225 + (0) B: po pl Pi(.5) y+1(,5) Figure 10: Simple example, 
solution 3 , (.5) / P&#38;q.l (o)  // 11 \ +(1) ~,, ; . . q.l(.i \ B} I+Pi+l(l) q(l) .  ii21151iT3f 
 P:~Pi., (;; P po pl Figure 11: Simple example, solution 4 Figure 7: Blending of three adjacent vertices 
 vertex pass over one another. When this happens, at least part of the sha~e is turnin~ itself inside 
out . Another ex;mple of ii-behaved intermediate angles is shown in Figure 13. Here, the terminaf angles 
at vertices 4 and 6 are both 90°, yet those angles in the intermediate blends po pl exceed 130°. Also, 
vertex 5 begins and ends on a straight line, yet that line becomes noticeably bent during the blend oper­ation. 
 L5k?3L51-t5fi!2 Figure 8: Simple example, solution 1 Figures 12 and 13 suggest two angle constraints 
that should be imposed on blend solutions. First, if at all possible we should avoid If the vertices 
are renumbered, a shape blend such ss in Oi(t) = O O<t<l (3) Figure 9 can be obtained. at each vertex, 
since that implies that an intermediate shape is self-intersecting. Second, it seems preferable, when 
possible, for each intermediate angle to be bounded by its terminaf angles. That is, @i(i!) should change 
monotonically from @i(0) t08:(l). It happens that there is an unexpectedly simple representa­tion for 
the angle Oi(t) which greatly aids the understanding  L!IQ!7VYN?3 po and analysis of these two conditions. 
In the following, PI P: XPj ~(Zi,~:) X( Zj, yj)SZiyj zj?/i, Figure 9: Simple example, solution 2 P1. 
Pj >(Z~,y~).(Zj,~j)-ZiZj +!/iyj, Different blends can be achieved if we insert new vertices in each 
polygon. In Figure 10, a vertex labeled 5 is inserted in PO and a vertex labeled I is inserted in P1 
as shown. Another variation is obtained by adding two new vertices at the same point. In Figure 11, vertices 
labeled 5 and 6 are Letting u = 1 t, the angle O(t) can be computed inserted in P. and vertices labeled 
1 and 2 are inserted in PI as shown. Typically, two polygons to be blended do not initially have the 
same number of vertices, and even if they do, the corre­spondence will not generally produce a pleasing 
blend. The examples in Figures 8 11 suggest that the principle task in where B: = P$_l P: and F: = P~+l 
P$ m shown inshape blending is that of adding vertices to each polygon such that each polygon ends up 
with the same number of vertices, Figure 7. Recalling that and the resulting vertex correspondences produce 
the desired blend. PI x P2 sin(LPl,O, P2) = So, how can an algorithm automatically decide, with little 
IIP,II IIP211; or no human intervention, where to add the vertices? Sec­tion 2.] shows two geometric 
conditions that an algorithm can identify and try to avoid, and section 3 discusses a physical model 
which can further guide an algorithm. 2.1 Angles +-p.61z-Jy Consider the solution to the step problem 
shown in Figure 12. This blend serves little useful purpose (except to illustrate shape blending gone 
awry), because the angle at the circled vertex goes to zero, so that the two edges meeting at that Figure 
12: Simple example, solution 5 27 I 30° Figure 13: Simple example, solution 6 PI . P2 COS(LP1,O, P2) 
= IIPIII llP~ll; PI x P2 tan(LPl, O,Pz) = P1. P2 (F~(l -t)+ F;t) X (Bf(l -t) +B;t)tan(ei(~)) = (F~(~ 
_ t) + Fit) . (B~(l -t) + ~t) (5) Y0).. . .0 L \\ QI 290° Q , Pi i+ 1 4! j­1 q(o.5) = 337° Pi ~! Pi+I 
q(o) = 30° b q-1 ~(0.75) = 311° Pi Pi+, q(o.% = 5° b %.1 ~(l)= 290° = Yo(l ~o(l t)2 +Y12t(l ~)2 + ~lz~(l 
 t) + y# t) +z2~2 (6) Figure 15: Oi(t) goes to zero where Equation 6 can be interpreted Q(t) = (Zo, 
yo)(l t)2 + = Qo(l t)2+Q12t(1 As illustrated in Figure 14, Q that Oi(t) = L((l, O), (O, O), Q(t (8) 
as a degree two B6zier curve (ZI, ~I)2t(1 t) + (Z2, y2)t2 -t)+ Q2i2. (9) t) has the important property 
). Thus, ~~(t) = O only if Q(t) \ Figure 16: Oi(t) is not monotonic where Q(o) = 30° ~(0.25) = 45° 
do= QO XQ1; QO X Q2 dl = I d2 = Q1;Q2. Oi(t) changes monotonically if and only if equation 10 haa no 
real roots in the unit interval.    4p.,qpi+,:3 The work model in section 3.2 requires us to compute 
the angle change Adi. If triangle AQOQI Q2 does not contain 9(0.5) = 60: ~(0.75) = 76° = P&#38; the then 
A8i = 180°. origin, I@i(l) 8~(0)1 mod If triangle AQOQ1 Q% does contain the origin, it s possible for 
AOi to Figure 14: Relationship between Oi(t) and Q(t) intersects the positive z axis (as shown in Figure 
15). Angle monotonicity is assured if no line through the origin intersects Q(t) more than once as shown 
in Figure 16). The angle function Oi(t) = L[( 1, O), O,O), Q(t)] haa four possible extrema: 01(0), di(l), 
Oi(tl), or \ i(t2) where tl and t2 satisfy the equation (Q(t) o) x Q (t) = This produces a cubic polynomial 
which to a quadratic polynomial in Bernstein d(t) = di)(l t)z + d~2t(l i) exceed 180 as illustrated 
in Figure cient conditions for A6i to exceed contain the origin, quadratic formula 360° A@i = l.L(Qo, 
{ and d? dod2 < in equation 10). IZ(QO, (0,0), Q2)I (0,0), Q2)l O. always degree reduces form: +d2t2 
= o; (lo) where 1 If 8i(i needs to deviation QO, (0,0), Q2) < 180°. 17. Necessary and suffi­180° is 
for AQOQ1 Q2 to 0 (the discriminant of the Thus, if d; dOd2<0 and AQoQ~Q2 ~ (o, o) otherwise (11) is 
not monotonic, the development in section 3.2, \ know how ~ar Oi(t) deviates from monotonicity. This 
is a non-negative angle denoted by A6~ as shown Computer Graphtcs, 26, 2, JUIV1992  6(0.5) = 140 Q(O.75) 
= 70° fl(l.o) = @ Figure 17: AOi exceeds 180 in Figure 18(a) for a single deviation, and Figure 18(b) 
for a double deviation. (a) (b) Figure 18: Measurement of A8~ for non-monotonic O;(t) 2.2 Coincident 
vertices Coincident vertices are a common occurrence which invite spe­cial attention. When n adjacent 
vertices on one polygon lie at the same point, n 1 edges on the other polygon collapse to that point. 
Since Z(Pi -1, Pi, Pi+l ) is undefined if Pi is coincident with either of its neighbors, the angle change 
when such a case is involved in a shape blend is also undefined, as is the bending work discussed in 
section 3.2. Our tests verify that the following heuristic for assessing angle change when vertices are 
coincident gives good results. We imagine that coincident vertices actually lie evenly spaced along the 
base of an infinitesimal isosceles triangle, as shown in Figure 19. In this case, 6 z = 194= 90° + ~ 
and f13= 180° in radians. In general, if vertices Pi, . . . . Pj are co­inciderrt, Oi =81 =90°+ ~ and(?i+l 
=f?i+2 = . =oj_I = 180°. In Figure 20, all three vertices of one polygon are coincident. However, as 
portrayed in Figure 19, those vertices are treated as though they are infinitesimally spaced along a 
line segment. Thus, in such cases, control point Q2 (or Qo) of the Q curve will always be located an 
infinitesimal distance from the origin along the z axis. Figure 21 shows the Q curve for vertex i = 2 
in Figure 20. In this case, Q2 lies an infinitesimal distance from the origin along a ray 110° from the 
+Z axis as shown, and A6 = 38°. Figure 22 shows an example of coincident vertices in which an inter mediate 
angle goes to zero. close-up Figure 19: Treatment of coincident vertices I I P,  (id i/&#38;4+Pi~p \o 
100° q(o) = 00° ~(0.25) = 03° P, Ai+ ~&#38;l+, ,,.1 P, Pi+, Oaa ~(0.5) = 108° q(o.75) = 121° Figure 
20: Q curve for three coincident vertices 3 Physically based model Section 2 defined the shape blending 
problem to be one of de­ciding where to add vertices to two polygons so that interme­diate polygons in 
the blend could be defined by interpolating corresponding vertices on the given polygons. The decision 
on where to add vertices must be guided by some heuristic. The heuristic we propose is to model polygon 
PO M a piece of wire made of some idealized metal. The best shape blend is the one which requires the 
least work to deform PO into P1 through bending and stretching. This section discusses a simplified model 
for aasessing the work involved in moving each vertex and line segment through the shape blend. Section 
4 shows how to compute a globally optimal le~t work solution for all possible vertex correspon ­dences. 
We distinguish between work which causes bending, and work which causes stretching. Stretching work is 
computed for each line segment (that is, each adjacent pair of vertices) whereas bending work is computed 
for each adjacent pair of line segments (that is, for each set of three adjacent vertices).   3.1 Stretching 
work A force F will stretch an actual wire of length Lo [12] an arnouut .. ­ (12) where ,4 is the cross 
sectional area and E is the modulus of rlas/icity, a constant of the material (for example, E for steel 
29 [12]. In this case, an exponent of 1 more closely expresses the work expended. Thus, we make one 
final modification to our stretching work equation: e. (15) a = (1 -c,)min(!o~;l~!cs max(Lo, L1)  *,y 
+ p~ i+ where k~, c~, and e, are user definable constants. i-i- In physical reality, these work equations 
only make sense if the wire is getting longer (Ll > Lo), not if it is gettin shorter  ~ Q(O)= 148° ~(0.25) 
= 45 (Ll < Lo). For our purposea, we compute both stretc f mg and compressing work using equation 15. 
Section 4 calls for notation which expresses which se ment f of wire is being stretched. Letting LO = 
IlPi, PiOI and L1= IIPjl I jell, we denote by %7 + h? + n7 pi+ q(o.s)= 139° ;(0.75)= 129°~i) = 110° 
k,lL1 -Lole W,([io, jo], [ii, jl]) = (1 -c,)min(Lo, L1) +c, max(Lo, L1) $)16 Figure 21: Q curve for two 
coincident vertices the stretching work required to map PiO Pil to PjO jl, where il=iooril=io+ land jl=joorjl=jo+l. 
3.2 Bending work Analogous to the equation for stretching work developed in section 3.1, work which causes 
bending is defined in equation 18 for angle Z(P~O, P~l, P~2) bending into angle Z(P;O, P;, ,P}2): 1 ~(0) 
= 63° Q(O.25)= 29° wb([if), ~()],[i~,~l],[lz,jz]) = (17) kb(&#38;? + m@6 *)eb if 8 t) never goes to zero 
{ k~(AO + mbA8*)eb +pb if 8 t) does go to zero [ where AO and A@* are measured in radians and are defined 
in sections 2.1 and 2.2. kb, mb, eb, and pb are user definable constants. The constant kb indicates bending 
stiffness, mb penahzes angles which are not monotonic, eb is an exponent which plays a role similar to 
es, and pb penalizes angles from going to zero. Figure 22: Coincident vertices with 8(.5) = O 3.3 Normalization 
is 29,000,000 psi). The work expended in stretching a real Notice that the work due to bending is independent 
of the sizepiece of wire an amount 6 is [12] of the shapes. Thus, if the two shapes are scaled uniformly, 
the bending work computation does not change. However, b2AE the stretching work varies with the scale 
of the shapes. To w= . (13) 2L0 make the constants k~ and es independent of scale, it is a good idea 
to map each shape to a unit rectangle, scaling the Since AE is a const ant for the wire, for our purposes 
we replace same amount in z and y, so that the largest dimension of it with a single user-definable stretching 
stiffness constant the bounding box is one. It is important to scale uniformly, ks, If Lo istheinitial 
length ofa section of wire, and if L1 or else the angles will change, along with the bending work is 
its final length, equation 13 will compute different values computation. It is noteworthy that uniform 
scaling of the shapes doesif the initial and final shapes are swapped ( ~ in one case affect the Q(t) 
curves, but not the bending work computation. and $&#38; in the other). Furthermore, if an edge conapses 
to a If P1 is scaled by a constant c, then Q. is unchanged, Q1 is single vertex (i.e., Lo = O), equation 
13 requires infinite work. scaled by C, and Q2 is scaled by c*. This creates a different These two considerations 
motivate the following modification Q(t) curve, but the angle function L((O, 1), (O, O), Q(t))= @(t) 
to equation 13: does not change. (Ll -LO)2 (14) = 8(1 -c,)min(Lo, L1) +c, msx(Lo, L1) 3.4 Numerical 
examples This section provides two numerical examples of the work re­cent rols the penalty for edges 
collapsing to points, where 6 = L1 Lo and cs is a user definable constant which quired to transform 
a unit isosceles right triangle into a unit square. In Figure 23, there is no stretching work in line 
seg- The exponent 2 in equations 13 and 14 assumes the wire is ments O 1 and 3 4 and no bending work 
in angle O. Thelinearly elastic, which is the case if the wire has not stretched very much. If excessive 
st retching occurs, less work is required 11-fil=t stretching work in legs 1 2 and 2 3 is each k~ to 
elongate the wire because it undergoes plastic deformation *.(1 -C,)+ l. C. The bending work in angles 
1 and 3 is each k~(~)eb and in vertex 2 is k~(~)eb. Thus, the total work is .293 WI = 2k. + 2kb.785e 
+ k~l.571eb, -(18) .707 + .293c$ Figure 23: Work computation example, blend 1 In Fieure 24. there is 
also no stretchin~ work in line se~­ments O -1 and 3 4 and no bending work in angle O. Tie stretching 
work in hne segment 1 2 M h ~.(l_c, +l.c,  ~ -F-=$ and in line 2 3 is k~ The bending work in an­ * gles 
1 and 2, based on section 2.2, is kb [(~~ + ~) $] = kb (~) b. Angle 3 has a A@ of m/4 and hence a bending 
work ofkb~eb. Thus, the total work to perform the transformation in Figure 24 is .414 W2 = k, ;+ + kb[2(.393)eb 
+ .785 ]. (19) 1 + .414C, ) ( MMNm po pl Figure 24: Work computation example, blend 2 By selecting 
different coefficients ks, kb, es, eb, and cs, we can coerce either blend to have a smaller work requirement. 
Forexample ifk, = kb= .5,e, = eb= 1and ~, = 0.5, ItTl = 1.91 and W2 = 1,96. However, if we change k, 
= 0.4 and kb = 0.6, then W1 = 2.16 and W2 = 1.88. So, if the wire stretches more easily than it bends, 
blend 2 uses less work. Least work solution This section presents a method for determining whereto insert 
vertices so that the shape transformation is accomplished with the least work. This method determines 
a globally optimal least work SCE lution for all ~ossible correspondences of ezistina vertices, so vertices 
can only be inserted at existing vertices. As a prepro­cessing step, additional vertices can be added 
to break up long line segments. The reason the optimization search is restricted to existing vertices 
is that otherwise it becomes a non-linear constrained optimization problem whose solution is very ex­pensive 
and whose global optimality is difficult to verify. By contrast, the discrete solution presented here 
can be solved in 0(~7zrr) time in the number of respective vertices, and global optimality is assured. 
Computer Graphics, 26, 2, July 1992 One of the first papers written on contour triangulation, [15], employs 
a directed graph to compute an optimal trian­gulation between a pair of contour lines. [8] further refined 
the use of the directed graph for that problem. Our leaat work o Iution is primarily based on those two 
excellent papers. This section briefly reviews the use of directed raphs, giving only enough detail to 
explain how the ideas in r8] are adapted. Given two polygons PO = [P:, P~, ., ., P%] and P* = [P:, P;, 
. . . . P:], all vertex correspondences can be repre­sented in an m x n rectangular matrix, or graph 
. The columns of the graph represent vertices on PO and the rows of the graph represent vertices on P 
1. The point at which column i meets row j signifies a correspondence between P: and P;. Denote by [i, 
j] a correspondence between P! and P}, which can be represented on the graph as a dot at the junction 
of column i and row j. A complete shape transformation re­quires every vertex in PO to correspond to 
it least one vertex in P1 and vice versa. Furthermore, we only allow [i, ] to be a correspondence if 
[i l,j], [i)j 1], or [i I,j 1i is also a correspondence else intermediate polygons in the shape 
transformation would split apart. Given that [0, O] = [m, n is a correspondence, a complete solution 
can be represent eJ on the raph as a string of dots starting at [0, O] and ending at [m, n , with each 
subsequent dot positioned one step East, T South, or Southeast from the preceding dot. This is illus­trated 
in Figure 25, where the dots are connected by arrows. We will refer to such a sequence of dots as a path, 
denoted by PO 0123456789 0 1 2 3 4 5 6 7 8 9 Figure 25: Graph representation of a shape transformation 
{Co, cl, ,Ck). In Figure 25, co = [0,0], C3 = [2,3], etc. Note that k is the number of vertices in each 
intermediate polygon in the blend, with max(rn, n) < k<m +n. We do not allow a South step to be immediately 
followed by an East step, or an East step to be followed by a South step, because such a combination 
is more expensive than a single Southemt step, except possibly under unusual work co efficient. The main 
re~on for this rule is to save some com­putation. Thus, we may say that a path must travel in a Southeasterly 
direction, and make no 90° turns. Consider how to evaluate the bending and stretching work for the example 
in Figure 25. Stretching work is computed for each pair of neighboring dots on the path (cl_ 1, c1), 
since each such pair of dots on the path represents two points on PO transforming to two points on P1 
Bending work must be com­puted using three neighboring dots on the path (cl 1, cl, C{+l ), since an angle 
change involves three points on PO moving to three points on P1. For-large m = n, there are O (~) = O 
(~) legal paths. However, using a graph, the least work solution can be determined by visiting each junction 
only once (O(m2) 31 computation expense). The basic strategy proceeds by con­sidering polygon fragments 
consisting of vertices O, . . . . i of PO and vertices O, ..., j of PI. Denote these polygon fragments 
PO(i) and P1 (j). We wish to compute the minimum work required to transform PO(i) into P1 (j), according 
to the work equations in section 3. In gra h theory language, we want to find the path which connects 
rO, O] to [i, j] using the minimum amount of work, denoted W (i, j). This is easily accomplished using 
the simple observation that if we know the minimum work vrdues W(i 1, j), W(i, j 1), and W(i 1, j 
-1), then W(i, j) must equal one of those three predecessors plus the in­cremental work involved in connecting 
that predecessor with [i,j . J o accomplish this, we must actually concern ourselves with three values 
of W(i, j), denoted by Wt (i, j), W\(i, j), and W+ (i, j), which indicate the minimum work required to 
trans­form PO(i) into Pi(j) if [i,j 1], [i l,j -1], or [i l,j] respectively is the preceding dot on 
the path. These three values are required because each bending work computation relies on three dots 
on the path. We thus proceed by sssign­ing Wt (O, O) = W+(O, O) = WN (O, O) = O and computing for j= 
o,... ,nandfori= O,..., m (i and j not both = O): W_(i, j) = W,([i l,j], [i, j]) + (20) mh{w+-(1 l,j)+ 
Wb([l 2,j], [i l,j], [I, j]), W\(i l,j) + W&#38;([i Z,j l]![i l,j]t[i, j])} Wt(i, j) = W,([i, j 
 1],[i, jl) + (21) min{t f T(i, j 1) + W&#38;([i, j 2], [i, j l], [i, j]), W~(i, j 1)+ W~([i l,j 
 2], [i, j 11,[ijd)} WR(i, j) = W,([i l,j l], [i, j])+ (22) min{WT(i l,j l)+wb([i l,j 2], [i l,j 
 l], [i, j]), W~(i l, j l)+Wb([i 2, j 2], [1 -l,j-l], [i, j]), W+(i l, j l)+W*([l 2, j l], [i l, j l], 
[l, j])} where wb [ii, jl], [;z, jz], [is, js]) = co for al <0 or jl <0. The vi ue min(w+(m, n), W\(m, 
n), kk T(m, fl)) is the global least work. This is of secondary interest~ what we re­aliy want to know 
is what path results in this mmimum work. The path is determined by backtracking through the graph, a 
process discussed in [8]. Actually, our backtrackhg is slightly more complicated because each graph node 
must keep track of three backpointers, one for each direction from which the node can be approached in 
the backtrack. 4.1 Implementation There is no need to store more than two rows of W+ (i, j), WN (i, j), 
WT(i, j) information. Once a complete row of work values has been computed, the previous row can be discarded. 
The algorithm u stated goes to a lot of effort to assure that it has found a path of globally minimal 
work. In par­ticular, the bending work costs much more to compute than does the stretching work, since 
each node in the graph can represent the middle vertex of seven different angle changes. A much more 
economical (three times faster!) implementation is possible, which no longer assures a global minimum 
work solution, but which provides virtually identical results to the rigorous algorithm dicussed above. 
The simplified al orithm uses only one value of W (i, j) (instead of calculating $ t (t, j ), W\(i, j), 
and W+ (i, j)) as follows. For purposes of discussion, if point [i, j] lies on a path, the preceding 
point on the path is indicated using the functions west(i, j and north(i, j . If the preceding oint is 
directly 1[ West of i,j], then west i,j) = 1 and north i,j) = O. If the preceding point is straig ( t 
up from [i, j], then west(i, j) = O 32 and north (i, j) = 1. If the preceding point is North-West of 
[i, j], then west(i, j) = 1 and north(i, j) = 1. Define Wo = W(i l, j)+ W,([i l,j], [i, jl)+ (23) Wb([i 
-1 wes~(i l,j), j nor~h(i l, j)], [i-l, j], [i, j]) Wl = W(i, j 1) + W,([i, j l], [:, jl) + (24) 
wb([i west(l, j l), j l nor~h(i, j l)], [i, j-l], [i, j]) W2 = W(i l, j 1)+ W8([: l, j l], [i, j])+ 
(25) W~([i l west(i l,j l), j l north(i l,j 1)], [i-l, j-l], [i, j]) where W. is undefined for i = O, 
WI is undefined for j = O, and W2 is undefined for i = O or j = O. Then ifwo~ wl, w2 : W(i, j) = wo; 
west(i, j) = 1; north(i, j) = O (26) if W1 ~ WO,W2 : W(i, j) = w1; west(i, j) = O; north(i, j) = 1 (27) 
if W2 ~ WO,W1 : W(i, j) = wz; west(i, j) = 1; north(i, j) = 1 (28) The algorithm for computing the least 
work solution amounts to setting,W(O, O) = O and from equations 23 28 computing W(I, j); t = 0,. ... 
m; j = 0,. ... n. W(m, n) is then the optimal total least work, and the north and west information can 
be used to backtrace the path which leads to this least work SOIUtion. We recommend using this simplified 
algorithm, because it is easier to implement, it runs three times faster than the theoretically precise 
algorithm, and the results are visually similar. 4.2 Starting points The above discussion assumes that 
point P: corresponds to point Pi. A globally minimum work solution for any initial correspondence can 
be computed in O(mn inn) time (see [8]). The example in Figure 9 shows a zero work solution which was 
found by considering all possible starting correspondences. All the other Figures in the paper had the 
initial correspondence specified. 5 Examples and discussion The work equations in section 3 contain 
seven user definable constants: k~, kb, e8, eb, pb, mb, and Ca. k8 and kb can be restricted to the unit 
interval. Table 1 shows the coefficients used by our algorithm to blend the figures in this paper. The 
meaning of diagonal deviation dd is discussed in section 5.2. Figures 8-11 underscore the inherent ambiguity 
of the shape blending problem. Without human guidance, no al­gorithm could discern which of these four 
solutions is ap propriate, since one can think of specific instances in which each of them might be preferred. 
Note that for these shape pairs, parameter adjustment can achieve the different desired results. As mentioned, 
the only user intervention for the ex­amples in this paper is the specification of starting points and 
of the seven constants. However, it is easy to contrive exam­ples where no set of seven constants will 
produce a prescribed blend (such ss in Figure 26, which consists of a combination of Figures 8 and 11). 
In some cases, it may be needful for the user to specify a few other correspondences as well. lgure dd 
lks h es eb Pb b Csn 0 F Table : Coefficients for various example figures Figure 26: Unattainable example 
Figure 27: Cow to deer Computer Graphics, 26.2, July 1992 Figure 27 shows a blend from a cow to a deer. 
Notice that some of the antlers cross each other in the intermediate shapes. A high value of pb prevents 
local self-intersections (angles going to zero) but not global self intersections. Figure 28 involves 
excessive movement of the dancer s arm. Due to the linear motion between corresponding vertices, the 
arm shortens as it moves. Figure 28: Dancer 5.1 Preprocessing The heuristic described in this paper relies 
on a reasonable initial distribution of polygon vertices. For example, Figure 2 requires additional vertices 
to be inserted along some of the straight segments of the F shape in order to provide a pleasing correspondence 
with the base of the E. Since the work equations are more realistic for distinct ver­tices than for coincident 
vertices, the algorithm tends to work best if the two polygons have roughly the same number of ver­tices. 
This tends to reduce the number of coincident vertices in the final solution, since there must be a minimum 
of Im rzl coincident vertices. 5.2 Speedups We timed an example in which each polygon has 100 vertices, 
and the execution time on an IBM RS6000 Model 530 worksta­tion is 8 seconds using unoptimized code. Using 
the simplified alorithm in section 4.1, the execution time is 3 seconds. In most cases, the graph of 
the Ieaxt work solution has a path (see Figure 25) which does not deviate very far from the diagonal 
of the graph. Recall that a polygon PO with m vertices and a polygon P] with n vertices create a graph 
with m columns and n rows. The amount which graph point c[i, j] deviates from the graph diagonal is ij 
 (29)rnn The diagonal deviation of an entire path is dd= max i -i, (30) [i,j]~path ~ n The cow-to-deer 
blend path (see Figure 27) is shown in Fig­ure 29. Its diagonal deviation of .245 is the largest of any 
of the examples in this paper (see Table 1). Thus, instead of searching the entire rectangular graph, 
the Iesst work solution can generally be determined by visiting only those elements of the graph within 
a distance dd from the diagonal. 33 po pl Figure 29: Cow to deer least work path; diagonal deviation 
Future Work This research seems to have generated more questions than it has answered. The authors are 
currently looking at several follow-up problems. For example, to make this process useful for key frame 
animation and morphing, an interior preserving map is needed for interpolating raster images which are 
en­closed by the terminal polygons. We are currently studying how well Schwartz-Christoffel transformations 
solve this prob­lem. How do we deal with cases where a scene composed of m number of polygons blends 
into a scene composed of n poly­gons, perhaps including holes? Ideas from [5] may help decide. What about 
using periodic B-splines instead of polygons? An easy answer is to simply polygonize ~he ,curves and. 
ap ply the current algorithm? but a more satwfymg answer M to develop energy minimization methods which 
work directly on the curves. The caJculus of variations may provide help here. All the blends in this 
paper involve moving corresponding vertices along linear paths. This can create some undesirable effects, 
such as the withering arm in blend 4 of Figure 28. Q curves are easily extended to express angle change 
and seg­ment length when vertices travel along B6zier curves of any degree. Study is underway in identifying 
curved paths which relieve the withering arm problem. The work model assumes that each wire has uniform 
stiff­ness. There may be merit to specifying that some portions of the wire are more stiff than others, 
suggesting a relative dis­couragement towards altering those portions. For example, in the cow-to-deer 
blend, it may be helpful to assign a smaller stiffness to the antlers than to the rest of the deer. Of 
course, extending this algorithm to polygonal surfaces in 3-D is a worthwhile goal. Applications to other 
fields such as pattern and signature recognition are also being studied. More detail on the material 
in this paper can be found in [II]. Acknowledgements Peisheng Gao sketched several of the illustrations 
in the paper. Thanks to Andrew Glassner for motivating discussions and for the initial shapes in Figure 
3. Bruce Brereton provided valu­able assistance in evaluating commercial illustration software that supports 
blending, This work was supported under NSF grant DMC-8657057, and under a grant from IBM. References 
[1] Adobe Systems, Inc. Adobe Illustrator 88. [2] Bruce G. Baumgart. Geometric Modeling jor Computer 
Vision. Phd thesis, Stanford University, Computer Sci­ence Department, 1974. [3] Edwin Catmull. The 
problems of computer-assisted ani­mation. Computer Graphics, 12(3):348 353, 1978. [4] Shenchang Eric 
Chen and Richard Parent. Shape av­eraging and its applications to industrial design. IEEE CG8A, 9(1):47-54, 
1989, [5] Henry N. Christiansen and Thomss W. Sederberg. Con­version of comcdex contour tine definitions 
into DokzG nrd element m~saics. Computer Graphics (Pro:. ~~G-GRAPH), 12(3):187-192, 1978. [6] Computer 
Support Corporation. Arts &#38; Letters 9.01, 1991. [7] Corel Systems Corporation, Ottawa, Canada. Cor-d-Draw! 
2.0, 1990. [8] Henry Fuchs, Z. M. Kedem, and S. P. Uselton. Opti­mal surface reconstruction from planar 
contours. Comm. ACM, 20(10):693-702, 1977. [9] S. Ganapathy and T. G. Dennehy. A new general triangu­lation 
method for planar contours. Computer Graphics (Proc. SIGGRAPH), 16(3):69-75, 1982. [10] Andrew Glassner. 
Metamorphosis. preprint, 1991. [11] Eugene Greenwood. A physically based approach to 2­d shape interpolation. 
Master s thesis, Brigham Young University, Department of Mechanical Engineering, 1992. [12] Archie Higdon, 
Edward H. Ohksen, William B. Stiles, John A. Weese, and William F. Riiey. Mechanics of Ma­terials. John 
Wiley &#38; Sons, Inc., New York, 1976. [13] Michael Kass, Andrew Witkin, and Demetri Terzopoulos. Snakes: 
Active contour models. International Journal oj Computer Vision, 1(3):321-331, 1988. [14] A nil Kaul 
and Jarek Rossignac. Solid-interpolating de­formations: Construction and animation of PIPs. In F.H. Post 
and W. Barth, editors, Proc. Eurographics 9I, pages 493 505. Elsevier Science Publishers B.V, 1991. 
[15] E. Keppel. Approximating complex surfaces by triangu­lation of contour lines. IBM Journal of Research 
and Development, 19:2-11, 1975. [16] David Kurlander and Eric A. Bier. Graphical search and replace. 
Computer Graphics, 22(4):113 120, 1988. [17] Micrografx, Inc., Richardson, TX. Designer 3. I. [18] Software 
Publishing Corp., Sunnyvale, CA. Harvard Graphics 3.0, 1991. [19] Naonori Ueda and Satoshi Suzuki. Automatic 
shape model acquisition using multiscale segment matching. In Proc. 10th ICPR, pages 897 902. IEEE, 1990. 
    
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134003</article_id>
		<sort_key>35</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>3</seq_no>
		<title><![CDATA[Feature-based image metamorphosis]]></title>
		<page_from>35</page_from>
		<page_to>42</page_to>
		<doi_number>10.1145/133994.134003</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134003</url>
		<keywords>
			<kw><![CDATA[computer animation]]></kw>
			<kw><![CDATA[image processing]]></kw>
			<kw><![CDATA[interpolation]]></kw>
			<kw><![CDATA[shape transformation]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Animation</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Curve, surface, solid, and object representations</descriptor>
				<type>S</type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010401</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Volumetric models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010399</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Parametric curve and surface models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010352</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Animation</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
			<gt>Performance</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>P279716</person_id>
				<author_profile_id><![CDATA[81100373833]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Thaddeus]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Beier]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Silicon Graphics Computer Systems201 I Shoreline Blvd. Mountain View CA]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>PP14216072</person_id>
				<author_profile_id><![CDATA[81100627916]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[Shawn]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Neely]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Pacific Data Images, 1111 Karlsbad Drive, Sunnyvale CA]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_obj_id>808573</ref_obj_id>
				<ref_obj_pid>800031</ref_obj_pid>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Barr, A.H., Global and Local Deformations of Solid Primitives. in Proc. SIGGRAPH '84" (Minneapolis, July 23-27, 1984), Published as "Computer Graphics", 18(3) (July 1984), pp:. 21-30.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378512</ref_obj_id>
				<ref_obj_pid>378456</ref_obj_pid>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Forsey, D. R., Bartels, R. H., Hierarchical B-Spline Refinement. In Proc. SIGGRAPH 88 (Atlanta, August 1-5, 1988). Published as "Computer Graphics'", 22(4) (August 1988), pp. 205-211]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Holzmann, G.J,, PICO .. A Picture Editor. "AT&amp;T Technical JouornaI", 66(2) (MarchLApril 1987), pp. 2-13.]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_obj_id>576098</ref_obj_id>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[Holzmanm, G J. "Beyond Photography: The Digital Darkroom". Prentice Hall, 1988.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[Kaul, A., Rossignac, J., "Solid-Intpolating Deformations: Constructions and Animation of PIPs," Prceedings of EUROGRAPH- ICS '91, September 1991, pp. 493-505]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[Kert, J.,Parent R., Carlson, W, "Establishing Correspondences by Topological Merging: A New Approach to 3-D Shape Transformation" Proceedings of Graphics Interface '91, June 1991, pp.271- 278]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Oakle. V., "Dictionary of Film and Television Terms". Barnes &amp; Noble Books., 1983.]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_obj_id>37424</ref_obj_id>
				<ref_obj_pid>37401</ref_obj_pid>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[Oka, M., Tsutsui, K., Akio, O., Yoshitaka, K., Takashi, T., Real- Time Manipulation of Texture-Mapped Surfaces. In "Proc. SIG- GRAPH 87" (Anaheim, July 27-31., 1987), Published as "Computer Graphics", 21(4) (July 1987), pp. 181-188.]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Oveveld,, C.W.A.M. Van A Technique for Motion Specification.Visual Computer" March 1990]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_obj_id>357320</ref_obj_id>
				<ref_obj_pid>357318</ref_obj_pid>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[Reeves, W.T., Particle system: A Technique for Modeling a Class of Fuzzy Objects. "ACM Transactions on Graphics", 2(2) (April 1983). (Reprinted in "Proc. SIGGRAPH '83" (Detroit July 25-29, 1983). Published as "Computer Graphics", 17(3) (July 1983), pp, 359-376.)]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
			<ref>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[Rosenfeld,. M., Special Effects Production with Computer Graphics and Video Techniques. ln "SIGGRAPH "87 Course Notes #8-Special Effects with Computer Graphics"' (Anaheim, July 27- 31, 1987).]]></ref_text>
				<ref_id>11</ref_id>
			</ref>
			<ref>
				<ref_obj_id>15903</ref_obj_id>
				<ref_obj_pid>15922</ref_obj_pid>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[Sederberg, T.W. and Parry, .S.R., Free-Form Deformation of Solid Geometric Models. IN "Proc. SIGGRAPH '86" (Dallas, August 18-22, I986). Published as "Computer Graphics" 20(4) (August 1986) pp. 151-160.]]></ref_text>
				<ref_id>12</ref_id>
			</ref>
			<ref>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[Shay., J.O., Humpback to the Future. "Cinefex 29" (February 1987), p.p. :4-19.]]></ref_text>
				<ref_id>13</ref_id>
			</ref>
			<ref>
				<ref_obj_id>37433</ref_obj_id>
				<ref_obj_pid>37401</ref_obj_pid>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[Smith, A.R., Plaear 2-Pass Texture Mapping and Warping. In 'Proc. SlGGRAPH '87" (Anaheim, July 27-31, 1987). Published as "Computer Graphics", 21(4) (July 1987),. pp.263-272]]></ref_text>
				<ref_id>14</ref_id>
			</ref>
			<ref>
				<ref_obj_id>528718</ref_obj_id>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[Wolberg, G., "Digital Image Warping'. IEEE Computer Society Press, 1990).]]></ref_text>
				<ref_id>15</ref_id>
			</ref>
			<ref>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[Wolberg, G., Skeleton Based Image Warping, "Visual Computer", Volume 5, Number 1/2, March 1989. pp 95-108]]></ref_text>
				<ref_id>16</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 Comtruter GraDhics, 262, Julv 1992 Feature-Based Image Metamorphosis 7 llcI1ldljll\ Bcicr Silicon 
Graphics C (mlpulcr Systc]ms 201 I Shorclirm Blvd. Moun(ain View CA 94043 .$//1 /)4 11/v( ( /v Pxi 
tic Ekild lnlagc~ I 1I 1 Karlstxi Drive. Sunny\alc CA 94)X9 Abstract Kc> u cwds: ( tnnpulcr Aninwi(m. 
Interpolation. lnwgc f%~ccsilng. Sh;ipc 1 r~illit(~rlll:ilit)ll. 2 Introduction 2.1 Conventional Metamorphosis 
Techniques Mc[:ml(wpht)iii twlween lWo or mor c imafys (wer lime i) u uwi ul \ i~u;ii tcchniquc. (Jflen 
uwd f orCducaliomd (n tMCid;liMllpur- Cnt pt>wi. 1 l-:idi(ional Iilmmahing techniques for (his cflcc[ 
include ~ lckcr c ut~(iuc h LISu chwwwr cxhibi(ing ch:mgm while running thr(mgll ;! toreil and prosing 
behind several trws ) tind op[ic:d cro\\­diswdv< . in which onc image is f:ide(i out while wwther is 
sinwlt:l­nLNNI\l)f :idcdin (Mith makeup ch:mge. tippliwcm, or nhjecl subs[i ­[u[I(m ). Sc\ ~ riilclawic 
horror lilm~ illu$tfiite [he process: who ctwld hnycl ~hc b:lir-tai~ing (fiiniform;ilml of the Woitman. 
or the drw m:itic lllct;itll(~rpll(~sii from Dr. Jchyll [o Mr. Hyde ? This pupcr prcwmls ii c(mtcnlp{mmy 
w~lu(i(m to the vi~u:d translonmrtion pnh lL nl. fiIh In: the cutIIng appro:~~h to Ihc limit giws us 
the techniqw 01 il(q>-nl~xi(m :minmtion. in which the subject is progres~ively tran\­I [mncd mrd ph(~togr:tphed 
tme fr:mw at a ;imc. This process c:m give the Ixmcrl ul illusi(m of cmltinu(ms rnetamwphosis. but it 
require~ much skill and IS\cr! tedi~ms worh. Moreover. stop-motion tr~uully wfl cm t r(ml the prt~hlcm 
()( \ iiu;il itrobing by not prm iding the nl~~li~mblur n(mn:lll! :i~w}ciatcd wi(h rowing film suh,jecls. 
A m(~­lmn-c~mlrt)lled variwrt ctillcd gmm{)ti{m (In which the frame-h) f rmnc \uhjccl) art! photogrtiphcd 
while mwlrrg) can provide [he pr{)permotion Murtocretite timorc ntitwd effect. but the cornplcxlty (i 
the m(deli. moti(m hfirdww. wrd required skill$ hecnmc~ mm >~,rcaw. 2.2 3D Computer Graphics Techniques 
We ctin uw technology in other V.U!SI(}help build u rnc[amorphoii~ 1(x)1.For cxwnplc, w can usc computer 
gruphic~ to rnodcl and rcndcl-lm;igcs which trim~fornl ()~cr time. onc ~ippr(xich in~(~lwi the reprcwntatlon 
of a pair ot threc-dtmen­\ioniil [~biects ;ISa collecti(m (}Ipol}gon~. The vcrticw of the first oh,jec( 
:Ir; then d]splwwd (wr time to coincldc in po~ition u Ith ~x~rrcsponding icrtice~ of the wumd (hject, 
v.ith color and olhcr :ittrihutes similwl~ irwrpnltitcd. The chief prohlern wlth (his [cuh­n]quc ii the 
difficulty in eittiblishing a de~lrahle YWCAc(m_c\fx)n­dcncc: thii ~)f tcnimpow inconvenient cmrstrainti 
on the gw]mclric rcprcwntu{inn of the objects, wch ;is requiring the wrne number of pt~l}g(nli in c;lch 
model. Even rf thtw c(mditions tire met. problems ilill :mw when the (npologief ~)lthc two objects Lliffcr{\uch 
tI\ when [me (~bject hiis ii hole thrnugh it ), {mwhen the features mu~t M(W in a comple~ vii! (such 
m ~iiding al(mg [he object wrf;w lrom back I() t r(mt). This direct point-lntcrp{)ltitlon technique can 
be effective, ht~wckcr. for transformations in which the data corre~pondcncc and lntcrpol;ition p;lths 
are slmplc. For cxtimplc, the technique wiL\ \uccc\\t ully used for the in[erpolatlon of ~ regular grid 
nf 31> warmed dirto in Star Trek IV: The Voyage Home I I 3). Methods tt)r oul(muitic:illy gener:itin.g 
ctmwptmdlng vertices orpol}gon~ for lnicrpol:ili(m ha~c been dcteloped. [.$1161 [)thcr cnmputcr gr:iphics 
techniques which ctin hc uwd for object mctarnnrphosii include WIid def(mnati[ms IIj [l?] and purtlcle 
i} s[em~ {I()). In cuch u:iw ihc 31) model of the first object ii trwwf(mned I{)h:i~e the shape wrd Surt,icc 
prnpertie~ of the wcond mwicl. and the rcwlting imimutilm is rcnderwl :md rec(mied. 2.3 2D Computer Graphics 
Techniques While three-ciirllcn~ion:tl ohjwt rnctumorphoiis i\ Anatural wdutmn whcn both (~hjccti tire 
cwil} rnodelcd for (hc cornputcr. ()!tcn the complexly of the wbjccts makes this tipprntich imprxtical. 
F nr e~imlplc. men} tipplications ot the CI !CCIrequire lrwrif{mrn;i[i(ms hetwcen c(mlplcx ohject~ wch 
:ii anirnfili. In this caw it is often cwicr to m:inipulate wwrned phot~)griiphf of the went u~lrlg IWO 
dirncnsi(mul image pmccssing techniques than to attempt to model ;ind render the dct:lils of the anirn:il 
s tippewmce for rhe computer. The stmplcit method for changing tmc digital image Into another i~ \Impl> 
to croswliswl~c Iwv.wn Ihcm. The colnr nf c:ich prxcl if SIGGRAPH 92 Chicago, JUIY26-31, 1992 interpolated 
over time from the first image value to the correspond­ing second image value. While this method is more 
flexible than the traditional optical approach (simplifying, for example, different dissolve rates in 
different image areas), it is still often ineffective for suggesting the actual metamorphosis from one 
subject to another. This may be partially due to the fact that we are accustomed to seeing this visual 
device used for another purpose: the linking of two shots, usually signifying a lapse of time and a change 
in place [7]. Another method for transforming one image into another is to use a two-dimensional particle 
system to map pixels from one image onto pixels from the second image. As the pixel tiles move overtime 
the first image appears to disintegrate and then restructure itself into the second image. This technique 
is used in several video effects systems (such as the Quantel Mirage) [11]. Another transformation method 
involves image warping so that the original image appears to be mapped onto a regular shape such as a 
plane or cylinder. This technique has limited application towards the general transformations under consideration 
in this paper, but has the advantage of several real-time implementations for video (such as the Ampex 
ADO) [111. Extensions include mapping the image onto a free-form surface; one system has even been used 
for real­time animation of facial images [8], Other interesting image warps have been described by Holzmann 
[3] [4], Smith [ 14], and Wolberg[16]. 2.4 Morphing We use the term morphing to describe the combination 
of gener­alized image warping with a cross-dissolve between image ele­ments. The term is derived from 
image metamorphosis and should not be confused with morphological image processing operators which detect 
image features. Morphing is an image processing technique typically used as an animation tool for the 
metamorphosis from one image to another. The idea is to specify a warp that distorts the first image 
into the second . Its inverse will distort the second image into the first. As the metamorphosis proceeds, 
the first image is gradually distorted and is faded out, while the second image starts out totally distorted 
toward the first and is faded in. Thus, the early images in the sequence are much like the first source 
image. The middle image of the sequence is the average of the first source image distorted halfway toward 
the second one and the second source image distorted halfway back toward the first one. The last images 
in the sequence are similar to the second source image. The middle image is key; if it looks good then 
probably the entire animated sequence will look good. For morphs between faces, the middle image often 
looks strikingly life-like, like a real person, but clearly it is neither the person in the first nor 
second source images. The morph process consists of warping two images so that they have the same shape 
, and then cross dissolving the resulting images. Cross-dissolving is simple; the major problem is how 
to warp an image. Morphing has been used as a computer graphics technique for at least a decade. Tom 
Brigham used a form of morphing in experi­mental art at NYIT in the early 1980 s. Industrial Light and 
Magic used morphing for cinematic special effects in HWknv and /ndiarra Jones and /he f.asf Crusade, 
All of these examples are given in Wolberg s excellent treatise on the subject[ 15]. Wolberg s book effectively 
covers the fundamentals of digital image warping, culminating in a mesh warping technique which uses 
spline mapping in two dimensions. This technique is both fast and intuitive; efficient algorithms exist 
for computing the mapping of each pixel from the control grid, and a rubber-sheet mental model works 
effec­tively for predicting the distortion behavior. It will be compared to our technique in detail below. 
2.5 Field Morphing We now introduce a new technique for morphing based upon fields of influence surrounding 
two-dimensional control primitives. We call this approach field morphing but will often simply abbreviate 
to morphing for the remainder of this paper.  3 Mathematics of Field Morphing 3.1 Distortion of a Single 
Image There are two ways to warp an image [ 15]. The first, called forward mapping, scans through the 
source image pixel by pixel, and copies them to the appropriate place in the destination image. The second, 
reverse mapping, goes through the destination image pixel by pixel, and samples the correct pixel from 
the source image. The most important feature of inverse mapping is that eve~-pixel in the destination 
image gets set to something appropriate. In the forward mapping case, some pixels in the destination 
might not get painted, and would have to be interpolated. We calculate the image deforma­tion as a reverse 
mapping. The problem can be stated Which pixel coordinate in the source image do we sample for each pixel 
in the destination image? 3.2 Transformation with One Pair of Lines A pair of lines (one defined relative 
to the source image, the other defined relative to the destination image) defines a mapping from one 
image to the other. (In this and all other algorithms and equa­tions, pixel coordinates are BOLD UPPERCASE 
ITALICS, lines are specified by pairs of pixel coordinates, scalars are bold lowercase italics, and primed 
variables (X , u ) are values defined relative to the source image. We use the term line to mean a directed 
line segment.) A pair of corresponding lines in the source and destination images defines a coordinate 
mapping from the destination image pixel coordinate X to the source image pixel coordinate X such that 
for a line PQ in the destination image and P Q in the source image. (X-P) ~ (Q-P) u= (1) IIQ-P112 (X 
-P) Perpendicular (Q -P) v= (2) II Q-PII v Perpendicular (Q P )X =P +U(Q -P )+ (3)  IIQ -P II where 
Perpendicu/aro returns the vector perpendicular to, and the same length as, the input vector. (There 
are two perpendicular vectors; either the left or right one can be used, as long as it is consistently 
used throughout. ) The value u is the position along the line, and v is the distance from the line. The 
value u goes from Oto 1 as the pixel moves from P to Q, and is less than O or greater than I outside 
that range. The value for v is the perpendicular distance in pixels from the line. If there is just one 
line pair, the transformation of the image proceeds as follows: Computer Graphics, 26, 2, July 1992 For 
each pixel X in the destination image tation but different positions specifies a translation of an image. 
All find the corresponding U,V transformations based on a single line pair are affine, but not all find 
the X in the source image for that U,V affine transformations are possible. In particular, uniform scales 
and destinationlmage(X) = sourcelmage(X ) shears are not possible to specify. Q Q Vv x x b1- I u 
P Destination Imw-ze Source Image Figure 1: Single line ptiir In Figure 1, X is the location to sample 
the source image for the pixel at X in the destination image. The location is at a distance v (the distance 
from the line to the pixel in the source image) from the line P Q . and at a proportion u along that 
line. The algorithm transforms each pikel coordinate by a rotation, trans­lation, itnd/or a scale, thereby 
transforming the whole image. All of the pixels along the line in the source image are copied on top 
of the line in the destination image. Because the u coordinate is normalized try the length of the line, 
and the v coordinate is not (it is always distance in pixels), the images is scaled along the direction 
of the lines by the ratio of the lengths of the lines, The scale is only along the direction of the line. 
We have tried scaling the v coordinate by the length of the line, so that the scaling is always uniform, 
but found that the given formulation is more useful. III I II IIII II1 Ill III1III I I I ]iHtlHtli!llllllllllll 
lli\l]lL1/11 ,, Figure 2: Single line pair examples The figure on the upper left is the original image. 
The line is rotated inthe upper right image, translated inthelower left image, and scaled in the lower 
right image, performing the corresponding trans­formations to the image. It is possible to get a pure 
rotation of an image if the two lines are the same length. A pair of lines that are the same length and 
orien­ 3.3 Transformation with Multiple Pairs of Lines Multiple pairs of lines specify more complex 
transformations. A weighting of the coordinate transformations for each line is per­formed. A position 
Xi is calculated for each pair of lines. The displacement Di=Xi -Xis the difference between the pixel 
location inthesource and destination images, anda weighted average of those displacements is calculated. 
The weight is determined by the distance from X to the line, This average displacement is added to the 
current pixel location X to determine the position X to sample in the source image. The single Iine case 
falls out as a special case of the multiple Iinecase, assuming the weight never goes to zero anywhere 
in the image. The weight aisigned to each line should be strongest when the pixel is exactly on the line, 
and weaker the further the pixel is from it. The equation wc use is (4) where length is the length of 
a line. dist is the distancet from the pixel to the line, and a, b, and p are constants that can be used 
to change the relative effect of the lines. If a is barely greater than zero, then if the distance from 
the line to the pixel is zero, the strength is nearly infinite. With this value for a, the user knows 
that pixels on the line will go exactly where he wants them. Values larger than that will yield a more 
smooth warp in,g,but with less precise control. The variable b determines how the relative strength of 
different lines Falls off with distance. If it is large, then every pixel will be affected only by the 
line nearest it. Ifb is zero, then each pixel will be affected by all lines equally. Values of bin the 
range [().5, 2] are the most useful. The value ofp is typically in the range [0, 1]; if it is zero, then 
all lines have the same weight. if it is one, then longer lines have a greater relative weight than shorter 
lines, The multiple line algorithm is as follows: For each pixel X in the destination DSUM = (0,0) rveightsunr 
= () For each line Pi Qi calculate U,V based on Pi Qi calculate X i based on U,V and Pi Qi calculate 
displacement Di = Xi -Xi for this line rfist = shortest distance from X to Pi Qi weight = (fengl~ / (a 
+ dist ))b DSUM +=Di * weight weightsum += weight X = X +DSUM / weightsum destinationlmage(X) = sourceImage(X 
) * Note that because these lines are directed line segments, the distance from a line to a point is 
abs(v) if 0< u <1, the distance from P to the point if u <O, and the distance from Q to the point if 
u >1. SIGGRAPH 92 Chicago, July 26-31, 1992 segments by interpolating the lines from their positions 
in 10 to the positions in 11. Both images 10 and II are distorted toward the position of the lines in 
f. These two resulting images are cross- Q2 1 v QJ x x V2 VI VD 2 U2  x, z P2 U2 UI x u,  X2 2 P2 
\P, P 1P, Destination Image Source Image Figure 3: M IIeline pairs In the above figure, X is the location 
to sample the source image for the pixel at X ~n the destination image. That location is a weighted average 
of the two pixel locations Xl and X2 , computed with respect to the first and second line pair, respectively. 
If the value a is set to zero there is an undefined result if two lines cross, Each line will have an 
infinite weight at the intersection point. We quote the line from Ghostbusters: Don t cross the streams. 
Why? [t would be bad. This gets the point across, and in practice does not seem to be too much of a limitation. 
The animator s mental model when working with the program is that each line has a field of influence 
around it, and will force pixels near it to stay in the corresponding position relative to the line as 
the line animates. The closer the pixels are to a line, the more closely they follow the motion of that 
line, regardless of the motion of other lines. This mental model gives the animator a good intuitive 
feel for what will happen as he designs a metamorphosis. Figure 4: Multiple line pair example With two 
or more lines, the transformation is not simple. The figure on the left is the original image, it is 
distorted by rotating the line above the F around its first point. The whole image is distotted by this 
transformation. It is still not ~ssible to do a uniform scale or a shear with multiple lines. Almost 
any pair of lines results in a non­affine transformation. Still, it is fairly obvious to the user what 
happens when lines are added and moved. Pixels near the lines are moved along with the lines, pixels 
equally far away from two lines are influenced by both of them. 3.4 Morphing Between Tkuo Images A morph 
operation blends between two images, 10 and 11. To do this, we define corresponding lines in/0 and 11. 
Each intermediate frame /of the metamorphosis is defined by creating anew set of line dissolved throughout 
the metamorphosis, so that at the beginning, tbe image is completely IO (undistorted because we have 
not yet begun to interpolate away from the line positions associated with /0). Halfway through the metamorphosis 
it is halfway between 10 and 11, and finally at the end it is completely 11. Note that there is a chance 
that in some of the intermediate frames, two lines may cross even if they did not cross in the source 
images. We have used two different ways of interpolating the lines. The first way is just to interpolate 
the endpoints of each line. The second way is to interpolate the center position and orientation of each 
line, and interpolate the length of each line. In the first case, a rotating line would shrink in the 
middle of the metamorphosis. On tbe other hand, the second case is not very obvious to the user, who 
might be surprised by how the lines interpolate. In any case, letting the user see the interpolated position 
helps him design a good set of begin­ning and end positions. 3.5 Performance For video-resolution images 
(720x486 pixels) with 100 line pairs, this algorithm takes about 2 minutes per frame on a SGI 4D25. The 
runtime is proportional to the number of lines times the number of pixels in the image. For interactive 
placement of the lines, low resolution images are typically used. As is usually the case with any computer 
animation, the interactive design time is the dominant time; it often takes 10 times as long to design 
a metamorphosis than to compute the final frames. 4 Advantages and Disadvantages of this Tech­ nique 
This technique has one big advantage over the mesh warping tech­nique described in Wolberg s book[15]: 
it is much more expressive. The only positions that are used in the algorithm are ones the animator explicitly 
created. For example, when morphing two faces, the animator might draw line segments down the middle 
of the nose, across the eyes, along the eyebrows, down the edges of the cheeks, and along the hairline. 
Everything that is specified is moved exactly as the animator wants them moved, and everything else is 
blended smoothly based on those positions. Adding new line segments in­creases control in that area without 
affecting things too much every­where else. This feature-based approach contrasts with the mesh warping 
tech­nique. In the simplest version of that afgorithm, the animator must specify in advance how many 
control points to use to control the image. The animator must then take those given points and move them 
to the correct locations. Points left unmodified by mistake or points for which the animator could not 
find an associating feature are still used by the warping algorithm. Often the animator will find that 
he does not have enough control in some places and too much in others. Every point exerts the same amount 
of influence as each of the other points. Often the features that the animator is trying to match are 
diagonal, whereas the mesh vertices start out vertical and horizontal, and it is difficult for the animator 
to decide which mesh vertices should be put along the diagonal line. We have found that trying to position 
dozens of mesh points around is like trying to push a rope; something is afways forced where you don 
t want it to go. Wkh our technique the control of the line segments is very natural. Moving a line around 
has a very predict­able effect. Extensions of the mesh warping technique to allow Computer Graphics, 
26, 2, July 1992 refinement of the mesh would muke that technique much more expressive and useful[2]. 
Another problem with the spline mesh technique is that the two-pass algorithm breaks down for large rotational 
distortions (bottleneck problem)[ 14]1151.The intermediate image in the two pass algorithm might be distorted 
to such an extent that information is lost. It is possible do mesh warping with a one-pass algolithm 
that would avoid this problem. The two biggest disadvantages of our feature-based technique are speed 
and control. Because it is global, all line segments need to be referenced for every pixel. This contrasts 
with the spline mesh, which can have local control (usually the 16 spline points nearest (he pixel need 
be considered). Between the lines, sometimes unexpected interpolations are gener­ated, The algorithm 
tries to guess what should happen faraway from the line segments: sometimes it makes a mistake. This 
problem usually munifests i[self as a ghost of a part of tbe image showing up in some unrelated part 
ofthe interpolated image, caused by some unforeseen combination of the specified line segments. A debugging 
tool can bc useful in this case. in which the user can point to a pixel in the in[crpt~luted image and 
the wmrce pixel is displayed, showing where (hat pixel originated. Using this information, the animator 
can uwdly move ii Iinc or add a new one to fix the problem. ~   l~.;i:~ . , . . 1 .1 ,, ,,. Figure 
6: Ghostbusting In Figure 6. [be top left image is the original. Moving the horizontal line down creates 
a ghost above the line. that is made from pixels copied from the top edge of the F. The bottom left image 
shows one fix, shrinking the vertical line to match the horizontal one. If the vertical line must maintain 
its length for some other reason, then the ghost can be eliminated by breaking the vertical line into 
two parts, as shown on the lower right. Animated Sequences It is often useful to morph between two sequences 
of live action, rather than just two still images. The morph technique can easily be extended to apply 
to this problem. Instead of just marking corre­ ~ponding features in the two images. there needs to be 
a set Of line segments at key frames for each sequence of images. These sets of \egments are interpolated 
to get the two sets for a particular frame, and then the above two-image metamorphosis is performed on 
the two frames, one from each strip of live action. This creates much more work for the animator, because 
instead of marking features in just two images he will need to mark features in many key frames in two 
sequences of live action. For example, in a transition between two moving faces, the animator might have 
to draw a line down the nose in each of 10 key frames in both sequences, requiring 20 indi­ vidual line 
segments. However, the increase in realism of metamor­ phosis of live action compared to still images 
is dramatic, and worth the effort. The sequences in the Michael Jackson video, Black or Whife, were done 
this way. 6 Results We have been using this algorithm at Pacific Data Images for the last two years. 
The first projects involved interpolation of still images. Now, almost all of the projects involve morpbing 
of live­ action sequences. While the program is straightforward and fun to use, it still requires a lot 
of work from the animator. The first project using the tool, (the Pl~mou[lr Wj~a~er metamorphosis), involved 
morphs between nine pairs of still Images. It took three animator-weeks to complete the project. While 
it was very quick to get a good initial approximation of a transition, the final tweaking took the majority 
of the time. Of course, it was the first experience any of us had with the tool, so there was some learning 
time in those three animator-weeks. Also, a large amount of time was spent doing traditional special 
effects work on top of the morph feature matching. For example, the images had to be extracted from the 
background (using a digital paint program), some color balancing needed to be done, and the fore­ground 
elements had to be separated form each other (more paint­ing). These elements were morphed separately, 
then matted together. On current morph production jobs at PDI, we estimate that about ~0-40 prcent of 
the time is spent doing the actual metamorphosis design, while the rest of the time is used doing traditional 
special effects. 7 Acknowledgments Tom Brigham of the New York Institute of Technology desetwes credit 
for introducing us to the concept of morph. The magicians at Industrial Light and Magic took the idea 
to a new level of quality in several feature films, and provided inspiration for this work. Jamie Dixon 
at PDI was a driving force behind the creation of the tools, and the rest of the animators at PDI have 
been the best users that we can imagine. The great animation created with this program is mostly their 
work, not ours. Finally, Carl Rosendahl, Glenn Entis, and Richard Chuang deserve credit for making Pacific 
Data Images the creative, fun environment where great new things can happen, and for allowing us to publish 
details of a very profitable algorithm.    SIGGRAPH 92 Chicago, July 26-31, 1992  8 References 
[l] Barr, A.H., Global and Local Deformations of Solid Primitives. In Proc. SIGGRAPH 84 (Minneapolis, 
July 23-27, 1984). Pub- lished as Computer Graphics , 18(3) (July 1984), pp. 21-30. [2] Forsey, D. R., 
Bartels, R. H., Hierarchical B-Spline Refinement. In Proc. SIGGRAPH 88 (Atlanta, August l-5, 1988). Published 
as Computer Graphics , 22(4) (August 1988), pp. 205211 [3] Holzmann, G.J., PICO ---A Picture Editor. 
AT&#38;T Technical Journal , 66(2) (March/April 1987), pp. 2-13. [4] Holzmann, G.J., Beyond Photography: 
The Digital Darkroom . Prentice Hall, 1988. [5] Kaul, A., Rossignac, J., Solid-Interpolating Deformations: 
Con-structions and Animation of PIPS, Proceedings of EUROGRAPH- ICS 91, September 1991, pp. 493-505 [6] 
Kent, J.,Parent, R., Carlson, W. Establishing Correspondences by Topological Merging: A New Approach 
to 3-D Shape Transfor-mation , Proceedings of Graphics Inte$ace 91, June 1991, pp. 27 l- 278 [7] Oakley, 
V., Dictionary of Film and Television Terms . Barnes &#38; Noble Books, 1983. [8] Oka, M., Tsutsui, K., 
Akio, O., Yoshitaka, K., Takashi, T., Real- Time Manipulation of Texture-Mapped Surfaces. In Proc. SIG-GRAPH 
87 (Anaheim, July 27-3 1,1987). Published as Computer Graphics , 21(4) (July 1987), pp. 181-188. [9]0verveld, 
C.W.A.M. Van A Technique for Motion Specifica- tion. Visual Computer . March 1990 [lo] Reeves, W.T., 
Particle Systems: A Technique for Modeling a Class of Fuzzy Objects. ACM Transactions on Graphics , 2(2) 
(April 1983). (Reprinted in Proc. SIGGRAPH 83 (Detroit, July 25-29,1983). Published as Computer Graphics 
, 17(3) (July 1983), pp. 359-376.) [ 1 l] Rosenfeld, M., Special Effects Production with Computer Graphics 
and Video Techniques. In SIGGRAPH 87 Course Notes #8 -Special Effects with Computer Graphics (Anaheim, 
July 27- 31,1987). [ 12] Sederberg, T.W. and Parry, S.R., Free-Form Deformation of Solid Geometric Models. 
In Proc. SIGGRAPH 86 (Dallas, Au-gust 18-22, 1986). Published as Computer Graphics , 20(4) (Au- gust 
1986), pp. 151-160. [13] Shay, J.D., Humpback to the Future. Cinefex 29 (February 1987), pp. 4-19. [ 
141 Smith, A.R., Planar 2-Pass Texture Mapping and Warping. In Proc. SIGGRAPH 87 (Anaheim, July 27-3 
1,1987). Published as Computer Graphics , 21(4) (July 1987), pp. 263-272. [ 151 Wolberg, G., Digital 
Image Warping . IEEE Computer Soci-ety Press, 1990. [ 161 Wolberg, G., Skeleton Based Image Warping, 
Visual Comput- er , Volume 5, Number l/2, March 1989. pp 95-108 42 Fi ure 17 A sequence from Mic4 ael 
Jackson s Black or White (Courtesy MJJ Productions)  
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134004</article_id>
		<sort_key>43</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>4</seq_no>
		<title><![CDATA[Scheduled Fourier volume morphing]]></title>
		<page_from>43</page_from>
		<page_to>46</page_to>
		<doi_number>10.1145/133994.134004</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134004</url>
		<keywords>
			<kw><![CDATA[Fourier transformation]]></kw>
			<kw><![CDATA[morphing]]></kw>
			<kw><![CDATA[sampled volumetric models]]></kw>
			<kw><![CDATA[smooth interpolation]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Curve, surface, solid, and object representations</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>F.2.1</cat_node>
				<descriptor>Computation of transforms (e.g., fast Fourier transform)</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.6</cat_node>
				<descriptor>Graphics data structures and data types</descriptor>
				<type>S</type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010147.10010371.10010387.10010394</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Graphics systems and interfaces->Graphics file formats</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002950.10003714.10003715.10003717</concept_id>
				<concept_desc>CCS->Mathematics of computing->Mathematical analysis->Numerical analysis->Computation of transforms</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010399</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Parametric curve and surface models</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010401</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Volumetric models</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
			<gt>Design</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>PP40024462</person_id>
				<author_profile_id><![CDATA[81100166298]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[John]]></first_name>
				<middle_name><![CDATA[F.]]></middle_name>
				<last_name><![CDATA[Hughes]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Department of Computer Science, Box 1910, Brown University, Providence, RI]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_obj_id>357310</ref_obj_id>
				<ref_obj_pid>357306</ref_obj_pid>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Blinn, J.F. A Generalization of Algebraic Surface Drawing. ACM TOG, 1(3):235-256, 1982.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122757</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Bloomenthal, J. and Shoemake, K. Convolution Surfaces. Computer Graphics, 25(4):251-256, July 1991. Proceedings of SIG- GRAPH '91 (Las Vegas, Nevada, July 29 - August 2, 1991).]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Carolco Productions. Terminator 2, 1991.]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[G. WyviIl, C. McPheeters and Wyvill, B. Data Structures for Soft Objects. The Visual Computer, 2(4):227-234, August 1986.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122747</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[Galyean, T. and Hughes, J. Sculpting: An Interactive Volumetric Modeling Technique. Computer Graphics, 25(4):267-274, July 1991. Proceedings of SIGGRAPH '91 (Las Vegas,Nevada, July 29 - August 2, 1991).]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 Comfmter Graphics, 26,2, July 1992 Scheduled Fourier Volume Morphing* John F. Hughes Department of 
Computer Science, Box 1910, Brown University Providence, RI 02906. (401) 863-7638; jfh@cs.brown.edu 
Abstract We describe an easily implemented and computationally feasible method for smoothly transitioning 
from one sampled volumetric model to another. This induces a transition between isosurfaces of the two 
models. The technique is based on interpolating smoothly between the Fourier transforms of the two volumetric 
models and then transforming the results back. A linear interpolation between the transformed datasets 
yields unsatisfactory results in some cases. Weuse a schedule for the interpolation in which the high 
frequencies of the first model are gradually removed, the low frequencies are interpolated to those of 
the second, and the high frequencies of the second model are gradually added in. Such scheduling yields 
more satisfactory results. We give several examples and comment briefly on preprocessing models to make 
the morphing smoother. CR Categories: 1.3.5 [Computer Graphics]: Computational Ge­ometry and Object Modeling; 
Curve, surface, solid, and object rep­resentations; Hierarchy and geometric transformations; 1.3.6 [Com­puter 
Graphics]: Graphics data stntctures and data types. Additional Keywords: Fourier transformation. mo~hing, 
smooth interpolation, sampled volumetric models.  Introduction A vohrmetric model is an entity that 
can provide a value at each point in 3-space, either by computing the value of some analyticaffy ex­pressed 
function or by computing a value indirectly from some other description. They are being used more frequently 
as workstation memories grow and processor speeds increase. Such volumetric models may come from external 
sources, such as MRI, or they may be created directly with the intent of modeling shapes [1] [2] [5]. 
In the latter case, the shape being constructed is typically an isosur­@e of a function on 3-space. For 
Blinn s blobby objects [1] and Wyvill et. al. s soft objects [4], the function on 3-space is derived 
from the model indirectly; for sampled data, such as that stored in sculpted models [5], the function 
values at the sample points are known exactly, and the values elsewhere must be interpolated. If we have 
two volumetric models, we can interpolate from one to the other directly: if the first model gives a 
function g(z, y, z) on 3-space and the second gives a function h(z, y, z), then we can .This work was 
supported in part by grants from NSF, DARPA, IBM, NCR, Sun Microsystems, DEC, and HP. Permlssmn 10 cnpy 
without fee all m part of this material is granted provided that the copies are not made or distributed 
for direct commercial advanc+ge.the ACM copyright notice and the titk of the publication and its date 
appear. and notice is given that copying is by permissmrrof the Association for Computing Machinery. 
To copy otherwlie. or to republish, requires a fee and/or specific permission. define a function K~(z, 
y,z) = (1 t)g(z, g, z) + t h(z, y, z). By looking at the functions Kt for values of t between O and 
1, we get models that could reasonably be said to be between the two original models]. Computing the 
isosurfaces of K, for a sequence oft values gives a sequence of surfaces that change from the surface 
represented by the first model to that represented by the second, or a rnorphing2 between the models. 
This is difficult to do with conventional polygonal or splirre-based models, because of the possibly 
different topologies of the starting and ending models. This simple form of morphing yields an irsteresting 
interpolation between the models, but difficulties can arise, in part from the high-frequency components 
of the sampled data and in part from the nature of the data values away from the particular isosurface 
level (see Section 4). We therefore use a slightly more complex interpolation between the models, involving 
Fourier transforms, which we describe in the next section. The examples in this paper are all based on 
32 x 32 x 32 volume data, primarify for speed and because of the storage requirements for larger datasets. 
The operations involved in blending datasets or rendering an image from a dataset of size n x n x n are 
of order n~, so the time spent in the Fourier transforms (O(n3 log n)) is not substantially greater than 
that spent in other operations. 2 Implementing Volumetric Morphing Very roughly speaking, high-frequency 
components of the function represented by sampled data tend to generate small wiggles in the isosurfaces 
of the function. In a two-dimensional analogy, a contour line for the ocean surface has more wiggles 
on a windy day (when there are lots of ripples) than on a calm one (when only large swells remain). Figure 
1 shows this situation in one dimension: in part [a) showing a function with some high-frequencies, the 
set of points at a constant height consists of many points, while in part (b), a function made up of 
just one low-frequency term, the set of points at a constant height consists of just a few widely spaced 
points. Because interpolating between the wiggles on one object and on another seems unimportant compared 
to the larger-scale process of interpolating between the general shape of one object and of another, 
we have devised a slightly more subtle scheme for interpolation. We take the first sampled volumetric 
model, gradually remove the high frequencies, interpolate over to the low frequencies of the second model, 
and then blend in the high frequencies of the second model. (See Figures 5 7 for examples. ) The order 
in which the high frequencies are removed and the blending is done we call the schedule; its exact design 
is discussed in Section 3. The range of values in the models should be the same, e.g., from O to 1; the 
isosurfaces will beat the halfway level, i.e., at 0.5. The word morph is derived from metamorphosis, 
or mor­phogenesis. Morphing was originally used to describe manipu­lation of images rather than the 
underlying models [3]. ACM-()-89791-479-1/92/007/0043 $01.50 SIGGRAPH 92 Chicago, July 26-31, 1992 
1    wJ-----I 1 (a) (b) Figure 1: The level sets of two different functions and their Fourier transforms. 
To understand this scheduled blending mathematically, suppose that we have a function S1(t, ~., ~u, j.) 
that describes how much of the information at frequency (~~, ~Y, ~.) should remain from the tit model 
at time t, and another such function .% for the second model. Then, letting 3 denote the fast Fourier 
&#38;ansform and once again using g and h to denote our two sampled volumetric datasets, we define the 
blended version of g and h, according to the schedules S1 and S2, to be K, = F-](S, (t, fz, fy, fz)~(9) 
+ 15 2(~>jz, ~Y, ~z)~(h))) In explicit terms, the pseudocode is the following: Compute G . FFT of dataset 
g Compute H . FFT of dataset h for several values of t between O and 1[ for (fx . -omega; fx <. omega 
; fx++l ( for ( fy = -0me9a; fy <= 0me9a ; fy++l ( for (fz = -omega; fz <= omega ; fz++l ( K[fx][fy][fz] 
. G[fx][fy][fz] * S_l (t, fX, fY, fZ) + H[fx][fyl[fz] * S_2 (t, fX, fy, fz); I } compute k . inverse 
FFT of K I If we let J = I.fzl+lf,l+ Ifzl (1) denote the total frequency of a component of the signal, 
then our schedule functions can be rewritten as S1(t, J), representing the fraction of the signal at 
total frequency J that should be present at time t, and the pseudocode (for datasets of size n x n x 
n) becomes this: Compute G = FFT of dataset g Compute H . FFT of dataset h for several values of t between 
O and 1{ for (i. 0;i<n; i++) { fol II=0;Ixn; I++) ( for(k.0:k. n:k++) { Ki], j, k) . G(I, j, k) *S_llt, 
J) + HII,],k) bS_2[t,J); 1 } t compute k . inverse FFT of K ) where the dependence of J on the frequencies 
$=, iv, and ~z, is given by Equation 1, and the relationship between ~=, j~, and ~z and i, j, and k, 
which depends on the implementation of the FFT. 3 The Design of the Schedule The simplest schedule (the 
one described in the introduction) was Sl(t, .1) = l t (2)  St(t, J) = 1 .$(t, J) (3) Equation 3 can 
be used in genera$ that is to say, we can simply design S1 and let .92 be determined from it by Equation 
3. In fact if the sum of S1 and St is not 1, then in particular the DC3 term of 3The DC term is the j. 
= jY = ~= = O term in the Fourier transform, and comesponds to the average vahse of the data. 44 S(t, 
J) A 1.0 \ \ \ \ \ \t=.65 \ \t= .95 \ J 3n/2 Figure 2: A blending function with W = 32. the signal will 
not be blended uniformly. Assuming for the moment that this DC term is the same at both ends, the failure 
of Equation 3 would cause a change in the average value of the volume data. If the isosurface vrdue is 
constan~ then changing tlis average value has the same neteffect as keeping the average value the same 
and vw~g the isosurface level. The resu lts can be problematic: if we make the isosurface level too high, 
we may get no isosurface at all. (In Figure 1, this would correspond to moving the horizontal lines up, 
so that they miss the graphs of the functions altogether). By contras~ Equation 2 is not particularly 
general. Strict linear interpolation is just one of many possibilities. For example, the schedule used 
in producing the pictures here is a(t, J)= (w+ ;)(k#)-# (4) S(t, 3) = max(O, min(a(t, J), 1.0)) (5) S,(t, 
J) = S(t, J) (6) Sz(t, J) = 1 S(t, J) (7) where the parameter W determines the shape of the fu nction4. 
We call W the notch width. The idea in the desi~n of the function S was to have it look like a constant 
function on-tie interval [0, ~] when t = O, and then get a notch in its right end (representing high 
frequencies) as t increases. Figure 2 shows this schedule function when W = 32 as t takes on the vahses 
.05, .35, .65, and .95. Figure 3 shows the schedule, but with W = 16. From these, we see that this schedule 
implements the plan described in Section 2 it tirst biros down the high frequencies of the 6rst model, 
then blends the low frequencies over to become those of the second model, and then adds in the high frequencies 
of the second model. Varying the width of the notch W affects the rate at which this blending takes place. 
For a wide notch, the low frequencies may begin to be blended before all the high frequencies are gone 
from the first mode~ so that the overall shapes begin to interpolate while the details of the models 
are still present. For a narrow notch, the high frequencies (and even some of the middle frequencies) 
of the first model are gone well before the low­frequency blending starts. This means that the tirst 
model becomes softer or blobbier before it begins to change its overall shape to that of the second model, 
which then begins to show its fine details and features. The precise schedule required to make the model 
change at the right rate can depend on the model. For example, Figure 4 shows 4~e numkr ~ 15 the lmgest 
possible vahre for J: frequencY (O, 0,0) is ~ steps away from (~, ~, ~), which is the highest frequency 
in the dataset. Computer Graphics, 26, 2, July 1992 S(t, J) 4 1,0 8 \ \ \ \ \t= .65 \ t = .95 \  
 k . J 3n/2 Figure 3: A blending function with W = 16 two functions p and q whose level sets look identical 
at some level e, even though their values away from e are quite different. Analogous behavior in three 
dimensions leads to different underlying models with the same isosrrrfaces. Interpolating from p to another 
function r gives different results, even with the same schedule, from interpo­lating from q to r. Thus 
one must either do some experimentation with different schedules for two particular models, or else alter 
the models a priori so that one knows how the values away from the isosurface look, We discuss one way 
of doing this next. 4 Problems with Data Normally when one extracts an isosurface from a dataset, the 
values far from the isosurface level are unimportant. In volume morphing, however, they may play a part. 
For example, in the sphere-to-torus morphing shown in the accompany ingvideotape, it is important the 
the torus have moderately high density (though less than 0.5, of course) in the hole, so that the hole 
will fill in smoothly during the morphing, instead of having the ring shrink rapidly to a thin band and 
disappear all at once. The function describing the sphere decays rapidly outside the sphere, which accounts 
for the sudden bulge that appears about a quarter of the way through the morphing. 1) Figure 4: TWO functions 
whose level sets are identical hut whose values elsewhere are very different. The problem of making a 
model better behaved away from an isosurface can be partly solved by techniques from image process­ing, 
but there is much work left to be done. We mention just one method here. We create a new dataset from 
the original as follows: for each point, determine the shortest path along the integer lattice to a point 
of the isosurface. Call this distance d. Then let newValue = 0.5 + k dsgn{oldValue 0.5) for some value 
of k that causes the value to fade away from 0,5 at the desired rate. 5 Remarks If one does a long sequence 
of the morphing transformations de­scribed in this paper, passing among a sequence of volumetric datasets, 
high frequencies will be present at certain moments (the keyframes ) and will be absent the rest of the 
time, at least if a filter with a narrow notch is used. The effect thus produced a sort of sequential 
crystallization into different forms-could be useful to an animator, but it may also be distracting. 
Some method of splin­ing the blending schedules may be able to reduce this emphasis of key frames, except 
at the start and finish. The approach taken here has been to try to remove the features of the model 
and then interpolate the gene~al shape. Clne can, instead, add features randomly, by adding high-frequency 
noise to the data, then interpolate the underlying volumes and tinally reduce the high­frequency noise. 
This tends to cause the surface to ripple and even to have bits break off and then later reassemble. 
In this case, the morphing between the details of the models is hidden behind noise; rather than having 
tbe details of the model fade into a blob, they become hidden in a forest of noise. The accompanying 
video shows this kind of noisy morphing between a two-holed tot-us and a teapot, Vohrme morphing is not 
a general solution to interpolation. For example, a metamorphosis between two identical objects, one 
dis­placed from the other, is nol a smooth translation. Finally, we should remark that until volumetric 
and surface-based modeling methods are unified, we see no way to apply this technique to anything but 
volumetric models. We therefore look forward to the unification of volumetric models with surface-based 
techniques. 6 Conclusion Despite the complexity (or at least the size) of sampled volumetric models, 
tbe task of changing smoothly between widely varying topologies is particularly easy in this case. With 
appropriate texture mapping, the results can he quite impressive, The method described m this paper can 
be implemented in a few hours. 7 Acknowledgments Thanks to Brian Cole for continually interesting me 
in Fourier trans­forms. Tinsley Galyean at MIT, and members of the Brown Com­puter Graphics Group, particularly 
Tom Tree, Brook Conner, and Scott Snibbe, made many helpful suggestions. Finally, the work would not 
have been possible without the generous support of our sponsors.  References [1] Blinn, J.F. A Generalization 
of Algebraic Surface Drawing. ACM TOG, 1(3):235-256, 1982. [2] Bloomenthal, J. and Shoemake, K. Convolution 
Surfaces. Com­pufer Graphics, 25(4):25 1-256, July 1991. Proceedings of SIG-GRAPH 91 (Las Vegas, Nevada, 
July 29-August 2, 1991). [3] Carolco Productions, Terminator 2, 1991. [4] G. Wyvill, C. McPheeters and 
Wyvill, B, Data Structures for Soft Objects, The Visual Compu[er, 2(4):227 234, August 1986. [5] Galyean. 
T. and Hughes, J. Sculpting: An Interactive Volumet­ric Modeling Technique. Computer Graphics, 25(4):267-274, 
July 1991, Proceedings of SIGGRAPH 91 (Las Vegas, Nevada, July 29-August 2, 1991). SIGGRAPH 92 Chlcago, 
July 26-31, 1992 Figure 5: A sculpted teapot becomes a cube. Figure 7: A spherical isosurface becomes 
toroidal. 
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134007</article_id>
		<sort_key>47</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>5</seq_no>
		<title><![CDATA[Shape transformation for polyhedral objects]]></title>
		<page_from>47</page_from>
		<page_to>54</page_to>
		<doi_number>10.1145/133994.134007</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134007</url>
		<keywords>
			<kw><![CDATA[computer animation]]></kw>
			<kw><![CDATA[computer-aided geometric design]]></kw>
			<kw><![CDATA[interpolation]]></kw>
			<kw><![CDATA[shape transformation]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Geometric algorithms, languages, and systems</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Curve, surface, solid, and object representations</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Animation</descriptor>
				<type>S</type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010147.10010371.10010352</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Animation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010399</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Parametric curve and surface models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010401</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Volumetric models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003752.10010061</concept_id>
				<concept_desc>CCS->Theory of computation->Randomness, geometry and discrete structures</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
			<gt>Design</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>P132683</person_id>
				<author_profile_id><![CDATA[81332508768]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[James]]></first_name>
				<middle_name><![CDATA[R.]]></middle_name>
				<last_name><![CDATA[Kent]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Department of Computer and Information Science, Advanced Computing Center for the Arts and Design, The Ohio State University, Columbus, Ohio]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>PP14134146</person_id>
				<author_profile_id><![CDATA[81100379189]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[Wayne]]></first_name>
				<middle_name><![CDATA[E.]]></middle_name>
				<last_name><![CDATA[Carlson]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Department of Computer and Information Science, Advanced Computing Center for the Arts and Design, The Ohio State University, Columbus, Ohio]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P242699</person_id>
				<author_profile_id><![CDATA[81100414668]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>3</seq_no>
				<first_name><![CDATA[Richard]]></first_name>
				<middle_name><![CDATA[E.]]></middle_name>
				<last_name><![CDATA[Parent]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Department of Computer and Information Science, Advanced Computing Center for the Arts and Design, The Ohio State University, Columbus, Ohio]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Bethel E. and Uselton, S. Shape Distortion in Computear-Assisted Keyframe Animation. In State of the Art in C~~rnputer An/mat/on. Magnenat-Thalmann, N. and Thalmann, D., eds., Springer-Verlag, New York, 1989, 215-224.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Bier, E. and Sloan, K. Two-Part Texture Mappings. IEEE Computer Graplu'cs and Applications 6, 9 (Sept. 1986), 40-53.]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Carlson, W. An Advanced Data Generation System for Use in Complex Object Synthesis For Computer Display. Proceedings of Graphics Interface "82 (1982) 197-204.]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_obj_id>617460</ref_obj_id>
				<ref_obj_pid>616003</ref_obj_pid>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[Chen, E., and Parent, R. Shape Averaging and Its Applications to Industrial Design. IEEE Computer Grapl~'cs and Applicat/ons 9, 1 (Jan. 1989)47-54.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_obj_id>108363</ref_obj_id>
				<ref_obj_pid>108360</ref_obj_pid>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[Ekoule, A., Peyrin, E and Odet, C. A Triangulation Algorithm from Arbitrary Shaped Multiple Planar Contours. ACM Transactions on Graphics 1{7, 2 (April, 1991) 182- 199.]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[Haumann, D. and Parent, R. The Behavioral Test-Bed: Obtaining Complex Behavior from Simple Rules. Visua/Computer 4, 6 (Dec. 1988) 332-347.]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_obj_id>102344</ref_obj_id>
				<ref_obj_pid>102313</ref_obj_pid>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Hong, T., Magnenat-Thalmarm, N. and Thalmann, D. A General Algorithm for 3-D Shape Interpolation in a Facet-Based Representation. Proceedings of Graphics Interface '88 (June 1988) 229-235.]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[KauL A. and Rossignac, J. Solid-Interpolating Deformations: Construction and Animation of PIPs. Proceedings of Eurographics '91. In Computers and Graphics (1991).]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Kent, J, Parent, R. and Carlson, W. Establishing Correspondences by Topological Merging: A New Approach to 3-D Shape Transformation. Proceedz'n&amp;s of Graphics Interface "91 (Calgary, Alberta, June, 1991) 271-278.]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[Parent, R. Shape Transformation by Boundary Representation Interpolation: A Recursive Approach to Establishing Face Correspondences. Technical Retx~ OSU-CISRC-2/91-TR7. Computer and Information Science Research Center. The Ohio State University (1991).]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
			<ref>
				<ref_obj_id>617722</ref_obj_id>
				<ref_obj_pid>616021</ref_obj_pid>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[Payne, B. and Toga, A. Distance Field Manipulation of Surface Models. IEEE Computer Graphics and Applications 12, 1 (Jan. 1992) 65-71.]]></ref_text>
				<ref_id>11</ref_id>
			</ref>
			<ref>
				<ref_obj_id>4333</ref_obj_id>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[Preparata, E and Shamos, M. Computational Geometry - An Introduct/on. Springer-Verlag, New York, 1985.]]></ref_text>
				<ref_id>12</ref_id>
			</ref>
			<ref>
				<ref_obj_id>39974</ref_obj_id>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[SeideL R. Output-Size Sensitive Algorithms for Constructive Problems in Computational Geometry. Ph.D. Thesis, Comell University, 1986.]]></ref_text>
				<ref_id>13</ref_id>
			</ref>
			<ref>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[Terzides, C. Transformational Design. Knowledge Aided Architectural Problem Solving and Design, NSF Project #DMC- 8609893, F'mal Report, (June 1989).]]></ref_text>
				<ref_id>14</ref_id>
			</ref>
			<ref>
				<ref_obj_id>807462</ref_obj_id>
				<ref_obj_pid>800250</ref_obj_pid>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[Weiler, K. Polygon Comparison Using a Graph Relxesentation. ~ings of SIGGRAPH '80 (Seattle, Washington, July 1980). In Computer Graphics 14, 3, (Aug. 1980), 10-18.]]></ref_text>
				<ref_id>15</ref_id>
			</ref>
			<ref>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[Weiler, K. Topology as a Framework for Solid Modeling. Proceedings of Graphics Interface "84, (May, 1984).]]></ref_text>
				<ref_id>16</ref_id>
			</ref>
			<ref>
				<ref_obj_id>528718</ref_obj_id>
				<ref_seq_no>17</ref_seq_no>
				<ref_text><![CDATA[Wolberg, G. Digital Image Warping. 1EEE Computer Society Press, Los Alamitos, CA, 1990.]]></ref_text>
				<ref_id>17</ref_id>
			</ref>
			<ref>
				<ref_seq_no>18</ref_seq_no>
				<ref_text><![CDATA[Wyvill, B. Metamorphosis of Implicit Surfaces. Notes from SIGGRAPH "90 Course 23. Modeling and Animating with Implicit Surfaces, (Dallas, Texas, Aug. 1990).]]></ref_text>
				<ref_id>18</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 Computer Graphics, 26, 2, July 1992 Shape Transformation for Polyhedral Objects James R. Kent Wayne 
E. Carlson Richard E. Parent Department of Computer and Information Science Advanced Computing Center 
for the Arts and Design The Ohio State University Columbus, Ohio 43210 Abstract Techniques that transform 
one two-dimensionaf image into another have gained widespread use m recent yeara. Extending these tech­niques 
to transform pairs of 3D objects, as opposed to 2D images of the objects, providea several advsntagea, 
including the ability to sn­imate the objects independently of the transformation. This paper presents 
an algorithm for computing such transformations. The al­gorithm merges the topological structures of 
a pair of 3D polyhedral models into a common vertex/edgeJface network. This allows trsms­formations from 
one object to the other to be easily computed by in­terpolating between corresponding v@ex positions. 
 Keywords: ComputerAnimation, Computer-AidedGeo­metric Design, Interpolation, Shape Trans­formation. 
CR Categories: 1.3.5 [Computer Graphics]: Computational Geomefry and Object Modeling; 1.3.7 ­[Computer 
Graphics]: Three-Dimensional Graphics and Realism 1.0 Introduction In recent years, image processing 
techniques, popularly known as morphing , have achieved widespread use in the entertainment in­dustxy. 
Morphirtg involves the transformation of one 2D image into another 2D image. These techniques involve 
first specifying some function that map points from one image onto points of the other image, then simultaneously 
interpolating the color and the position of corresponding points to generate intermediate images. When 
viewed in sequence, these intermediate images produce an anima­tion of the first image changing into 
the seared. Variations of these techniques have beem used to create astonishing special effects for commercisds, 
music videos, and movies. While morphing is useful for mmy applications, the fact Ihat the in­termediate 
stages of the transformation are images with no 3D ge­ometry limits its use. In order to fully realize 
the benefits of transformations in animation and design, 3D models of the objects must be transformed, 
instead of just 2D images of these objects. Transforming 3D models as opposed to imagw allows for the 
ob­jects to be animated independently of the trartsformatio~ using computer animation tec~lques such 
as key frsming. In addition, 3D transformations can be used in design to create objects that combine 
features of the original objects ([4], [8], [14]). This paper presents an algorithm that, given two 3-D 
polyhedral models, generates two new models that have the same sh~ as the original ones, but that allow 
transformations from one to another to be easily computed. A previous paper [9] described an early version 
of the algorithm that was limited to star-shapedt plyhedral solids. Since then, the algorithm has been 
extended to aflow for transfor­mations between more complex polyhedral models. In additiorL the computational 
complexity and robusmess of the afgorithm have been improved. After some fundamental concepts are defined 
in Section 2, a de­scription of the sh~ transformation problem for 3D objects is giv­ en m Section 3. 
This is followed by a brief review of previously published research in Section 4. Section 5 provi&#38;s 
a detailed de­scription of the afgorithm. Section 6 addresses interpolation issues, including transforming 
non-geometric stwibutes, such as surface cmlor. Sample transformations are presented in Section 7. The 
paper concludes with a discussion of open issues and future research in Section 8. 2.0 Fundamental Concepts 
fn order to dkuss the shape transformation problem, it is useful to carefully define a few key terms. 
Throughout this discussion the term objec~ will be used to refer to an entity that has a 3D surface geometry. 
The shupe of an object refers to the set of points in object space that comprise the object s surface. 
The term model will be used to refer to any complete &#38;scription of the shape of an object. Thus, 
a single object may have many different models that describe its shape. Following the terminology used 
by Weiler in [16], topofogy refers to the vertex/edge/face network of a model. Geotrse(ry refers to an 
instance of a topology for which the vertex coordinates have been specified. Vertices, edges, and faces 
are collectively referred to as topological elements. Some concepts from mathematical topology also need 
to be de­fined. Two objects are said to be homomorphic, or topologically equivuletst, if a continuous, 
invertible, one-to-one mapping between 1. Star-shaped refers to models for which at least one interior 
point, p, exists such that any semi-infinite ray originating at p intersects the surface of the object 
at exactly one point. , lyy~ AcM-()-x9791-47Y-1192/(n)7/(KM7 $01 50 47 pointa on the surface of the 
two objects exists. Such a mapping is referred to as a homccwnorphi.wn. Finally, an object is said to 
be Eu­Ur-vufid if its topology obeys the generalized Euler formula: V-E+ F=2-2G where V, E, and F are, 
respectively, the number of vertice~ edges, and faces of the topological network and G is the number 
of psa­sages through the object (i.e. its genus).   3.0 The Shape fkansformationProblem A common approach 
to transforming one shape into another is to divide the problem into two steps. The first step is to 
eatabliih a mapping from each point on one surface to some point on the sec­ond surface. Once these eorreapmdences 
have been establish~ the second step is to create a sequenee of intermediate models by inter­polating 
corresponding points from their position on the surface of one object to their position on the surface 
of the other. The first step will be referred to as the correspodvtce problem and the semnd step will 
be referred to as the interpdufion problem. The two prob lems are interrelated since tbe method used 
to solve the interpola­tion problem is dependent upon the manner in which the correspondences are established. 
This paper presents a solution to the cmeapondence problem for Eulm-valiA genus O, polyhedral objects. 
By restricting ourselves to polyhedral objects, the correspondence step does not need to explic­itly 
specify the mapping for eve~ point on the surface. A sufficient solution is to specify correspondences 
for eaeh vertex of the mod­els. The interpolation problem is then solved by interpolating the positions 
of corresponding vertices. Since the main contribution of this paper is an tdgorithm for establishing 
correspondences, the ma­prity of the paper is concerned with the solution to the correspon­dence problem. 
Issues that arise during the interpolation are briefly diSCUSSed in Section 6.0. 4.0 PreviousWork As 
mentioned in Section 1.0, morphing techniques for trartsform­ing images have demonstrated remarkable 
results and have achieved widespread use. Wolberg provides an excellent introduc­tion to image morphing 
in [17]. These techniques rely on the user to specify pairs of points in the two images that correspond 
Several approaches to three-dimensional shape transformation have been published Wyvill [18] describes 
a transformation algorithm for implicit surfaeea (i.e. blobby objects). Brute force approaehea for polyhedral 
models, such as that described by Tenzides [ 14], es­sentially require the user to specifi, for every 
vertex, a correspond­ing vertex from the other model. Hong et al. [7] propose a solution for polyhedra 
based on matching the faces of the objects whose cen­troids are closest. Bethel &#38; Uselton [1] &#38;scribe 
an algorithm that adds degenerate vertices and faces to two polyhedra until a common topology is achieved 
Chen &#38; Parent [4] present a transformation algorithm for pieawise liiear 2D contours, then briefly 
address an extension for 3D lofted objects. Parent [10] describes a solution for polyhedra that establishes 
correspondeawes by splitting the surface of the models into pairs of sheets of faces, then recursively 
subdi­viding them until the topology of each pair is identical. Katd &#38; Ros­signac [8] transform pairs 
of polyhedra by computing the Minkowski sum of sealed versions of the models. By gradually scaling one 
model from 100% to O% while simultaneously scsliig the other horn O% to 100%, a transformation is obtained. 
Payne&#38; Toga [11] first convert each polyhedra into a d~tance-field volumet­ric representation interpolate 
the values at each point of the 3D vol­ume, then tind a new isosur-ke that represents some combination 
of the original objects. Techniques that make use of the topology and geometry of the mod­els tend to 
yield better results. For example, since Hong et al. and Payne &#38; Toga do not make Ml use of the topological 
information, the surfacea of the models generated at intermediate steps are not guaranteed to remain 
connected. Similarly, Bethel &#38; Uselton and Parent rely primarily on tbe topology to establish correspondences, 
ignoring most of the geometric information. This often reds inse.. verelydistortedintermediate models. 
Kaul &#38; Rossign~ s technique, as well as the one described in this pap. make full use of both the 
topology and the geometry of the models, resulting in intermediate models that have connected sur­faces 
and that exhibit small amounts of distortion. One Fincipal ad­ vantage of the method &#38;scribed herein 
is that our correspondence algorithm describes a homomorphism. This provides a straightfor­ward method 
for interpolating the surface attributes of the objects along with the geometry. In additi~ it seems 
likely tltat our ap­proach can be more easily extended to allow for greater user control over the transformation. 
 5.0 An Algorithmfor Establishing Correspondences Suppose that two genus O solid objects are specified. 
Now, imagine that it wexe pssible to irdIate these objects with air like balloons until they became spherical. 
Each point on the surface of each ob­ject maps onto a unique point on the surface of the sphere, Associ­ating 
each point fknn one object with the point from the other object that maps to the same point on the sphere 
establishes a one-to+ne correspondence between points on the surface of the two objects. The above observations 
form the basis for the correspondence slgo­nthm. l%s~ the surke of each ob~t is pojected onto a unit 
sphere. This mapping is used to identi~ correspondences between points on the two original objects by 
associating pairs of points that map to the same location on the sphere. This approach can p@en­tially 
be applied for non-polyhedral genus O objects (e.g. spline sur­face models) as long as a mapping horn 
the surface of the object to the surface of the unit sphere can be found. Bier and Sloan [2] describe 
a similar apFoach for solving the prob­lem of wrapping a 2D texture onto a 3D object. The tit step maps 
the texture onto an intermediate surface, such as a sphere or a cyl­inder. The second step maps the intermediate 
surface to the surfwe of the 3D object. Unfortunately, the techn@es used to map the in­terme&#38;ate 
surface to the 3D object are not always one-to-one, and thus are not appropriate for our application. 
This section describes an implementation of the correspondence al­gmithm for genus Oplyhedral solids. 
The first step is to project the topology of both models onto the unit sphere. Nex~ the two topol­ogies 
are merged by clipping the projected f-s of one model to the projected faces of the other. The merged 
topology is then mapped onto the surfwe of both original models. This generates two new models that have 
the same shape as the original two models, but that share a common topology. This allows a transformation 
between the two shapes to be easily computed by interpolating the coordi­nates of eaeh pair of ~rrespondmg 
vertices. F@re 1 shows a pair of models and the same pair with the merged topologies mapped onto their 
surfaces Throughout the dmcussi~ the original objects are refereed to as A and B. The original polyhedral 
models of these objects are referred to as Ma and Mb M, has vertices, V,, edges, E,, and faces, F,. Sim­ilarly, 
Mb has vertices, V&#38; edges, ~, and faces, F&#38; The projection of M, and Mb onto the unit sphere 
are referred to as (Ma)P and Wdp r=p=tiveht Witi VIXtiCCX(v,~ ad (Vb)p. ~~ referring to a specific topological 
element of one of the models, lower case letters will be used. For example, ea refers to a specific edge 
of ob­ject M,, and (VIJP refers to a speafic projected vertex of Mb The results of the correspondence 
algorithm (i.e. the two new models of A and B that share a common topology) are referred to as M,* and 
Mb*o @@ Models with Merged Original Models Topology Mapped onto Surface Figure 1 -An Example of The Correspondence 
Algorithm 5.1 Projection Methods The firstalgorithm the sur­ step of the comspondence is to project 
face of the two polyhedra onto the surface of the unit sphere. The projection must satia~ two conditions. 
First, it must be one-to-one, so that each point on the surface of the object projects to a unique point 
on the surface of the sphere. Second, the projection must be continuous in the sense that points withii 
a small radius of a given point project to within a small radius of the projection of that point. Any 
method for projecting an object that satisfies these two condi­tions is acceptable. The projected polyhedral 
models are completely specified by the to­pology of the original model together with the coordinates 
of the projected vertices. This enables the projected models to be saved, eliminating the need to recompute 
them each time the model is used. Since the correspondences between the models are established by their 
mappings onto the sphere, different mappings result in differ­ent transformations. Thus, providing different 
projection methods gives the user some degree of control over the transformation. Sec­tions 5.1.1 through 
5.1.4 describe a collection of projection meth­ods that allow a wide variety of polyhedral models to 
be transformed. While no completel y general methed has been found, the techniques presented work for 
a large number of commonly en­countered types of models. 5.1.1 Convex and Star-Shaped Objects The definition 
of a star-shaped polyhedral object is that at least one interior point of the polyhedron exists from 
which all the vertices of the object are visible. This definition suggests a method for project­ing such 
an object. FM~ specify such an interior poin~ O, to be the center of the objec~ and translate the object 
so that O coincides with Computer Graphics, 26,2, July 1992 the origin. Then, move each vertex in or 
out sdong the ray from O through the vertex until it lies at unit distance from O. A suitable center 
point can be algorithmically selected by first com­puting the intersection of the interior half spaces 
of all the planes of the faces of the model. The resulting volume is called the kxmel of the polyhedral 
model. If the original plyhedron is star-shaped, its kernel is a non-empty convex polyhedron. Averaging 
the vertices of the kernel yields a suitable center point for the projection. The com­plexity of computing 
the kernel of a three-dimensional polyhedron is O(NlogN) [12]. Since the choice of center point affects 
the location of the projected vertices, providing the ability to select a center point gives the user 
some control over the transformation. Verifying that the selected point satisfies the vertex visibility 
condition can be performed in O(N) time by testing that the outward normal of each face is direct­ed 
away born the point. Note that convex polyhedra we a special case of s~-shaped poly­hedra for which all 
interior points satisfy the visibility condition. Thus, for convex polyhedrz any interior point maybe 
specified as the center. Some of the projection methods described in the following sections project the 
model onto a convex polyhedron (usually the convex hull of the object). To complete the projection to 
the sphere, the star­shaped projection is applied to this convex polyhedron.  5.1.2 Methods Using Model 
Knowledge Polyhedral models are often constructed using techniques such as revolving a contour about 
an axis, or exlruding a planar polygon along a line [3]. By using information about how the model is 
cors­stmcted, efficient methods for pojecting the object to the unit sphere can be found. This approach 
naturally lends itself to an ob­ject-oriented methodology, where ProjectToSphere could be one of the 
methods attached to an object. The class of polyhedral models known as objects of revolution con­sist 
of a set of planar contours (ribs) arranged at angular increments around an axis. Such a mcdel can be 
pro@ted to a sphere in O(N) time by positioning the points of each rib along a longitudinal arc of the 
sphere whose north/south axis matches the axis of the mod­el. Each arc should lie in the plane of the 
rib, have its endpoints on the axis, and be on the same side of the axis as the rib. Two methods for 
spacing the rib points along a semicircle have been developed. The first positions them so that the arc 
lengths be­tween points on the semicircle are proportional to the distance be­tween the corresponding 
points on the rib. The sewnd method first projects the rib onto its convex hull using a recursive method 
simi­lar to that described by Ekoule et al. in [5]. Once the rib is mapped onto its convex hull, each 
point is moved in or out to the unit sphcze along a ray from the midpoint of the axis through the point. 
Any technique that maps a rib to a semicircle can be used for spac­ing the points with diff=ent transformations 
resulting. However, methods that FeServe geometric information from the original model, such as the two 
described above, generally lead to more aes­thetic transformations. Another common class of polyhedral 
models, known as extruded objects, are generated by moving a planar polygon along a straight line, sweeping 
out a solid volume. Two copies of the polygon are used to cap the ends of the object. This class of models 
can be pro­jected by mapping each of the two caps to its convex huU, using Ek­oule s method as above. 
The resulting convex model can be projected to the unit sphere using the star-shaped projection from 
Section 5.1.l. It is important to note that the above techniques work for any model that can be &#38;scribed 
in an appropriate farmm whether or not the obje@ was originally modeled using the described techiiiques. 
For example, data from 3D digitizers can often be easily converted into the object of revolution format. 
 5.13 Phyaicaily-Baaed Methoda As mentioned in Section 5.0, the inspiration for the shape transfor­mation 
algorithm rnvolves an analogy with inflating ?lte objects liie a balloon. This idea led to experimentation 
with projection methods based upon physically-based simulation. The goal is to have the simulation convert 
the object into a convex object with the same to­pology while preserving as much of the geomernc information 
con­tained in the model as possible. The simulations, based on the work of Haumsnn [6], treat the surface 
of the model as a flexible object. Each vertex of the topology is modeled as a msss and each edge of 
the topology as a spring. Several types af simulations were tried. One approach was to model the forces 
involved in inflating a balloon. Weak spring forces were applied along the edges together with internal 
air pressure forces. The air pressure forces had a magnitude that was proportional to the area of each 
face and were applied to the centroid of each face in the direction of its outward normal. For some models, 
this approach worked well, but in general, the simulation dld not always produce a convex model. This 
was usually due to the presence of cycles of short edges in the models. When stretched, these edges generated 
large forces that resisted fhrther s~etchmg. In addition, vertices would tend to drift aroun~ which diminished 
the relationship be­tween the geometry of the original objects and theii projections. Another approach 
that has been more successful is to first determine which vertices of the model lie on its convex hull. 
Fining these points, and treating the non-hull vertices as free masses cormected by spiirtgs along the 
edges to each other and to the hull verticxx, a simulation is run to snap the model outward to its convex 
hull. Setting the strengths of the springs to be inversely propartiomd to their original lengths preserves 
the ratios of edge lengths as much ss possible. IrI addition, fixing the hull vertices minimizes the 
&#38;ift­ing problem. Although this approach generally works better than the firsL it does not work for 
arbitrary models. In performing the above experiments, ane scenario that consistently yields the desired 
results was discovered. This situation occurs whenever a concave region of the model is completely surrounded 
by a planar convex ring of edges that lie on the convex hull. Run­ning a simulation by fixing the vertices 
that lie an this ring, and treating the network of edges and vertices that lie inside as a mass/ spring 
system quickly snaps out the interior into the plane of the surrounding ring. In the following, this 
scenario will be referred to as a surrounded region . To better understand this situati~ consider the 
foUowing analogy. Suppose you were to build a plsnar, convex wooden frame with a nail pounded into each 
corner. Nex~ attach a mesh of robber bands to the nails. No matter how one pulls upon the rubber band 
mesh as soon as it is let go, it snaps back into the plane of the wooden frame. In this analogy, the 
wooden iktme corresponds to the surrounding ring of edges. The nails comespond to the vertices of the 
surround­ing ring. The edges of the interior netwark are the rubber bands, and the vertices correspond 
to places where rubber bands are joined. An approach that shows promise for solving the projection problem 
for arbitrary genus Opolyhedra is to attempt to divide the projection into a set of subproblems, each 
of which involves a surrounded re­gion. A heuristic approach to subdividing the problem irt this msn­ner 
is to use the faces of the convex hull of the model to &#38;line the set of surrounded regions as follows. 
Start by com@ng the convex hull of a mcdel. Nex~ tind a set of non-intersecting paths of edges that connect 
each pair of vertices connected by an edge of the hull. Fkudly, space the points of each path along the 
ccurespondmg hull edge. If a set of non-intersecting paths has been found each face of the convex hull 
will now detine a surrounded region. Although this algorithm works for many models, it is not too difikult 
to create models for which no appropriate set of paths can be found. Further research is being conducted 
into algorithmically tinding a suitable subdivision for arty genus Opolyhedra. Figure 2 shows a polygonal 
model of a goblet in the upper left. The set of paths of edges found by the algorithm are shown in the 
upper right. Spacing the vertices of each path along the corresponding edge of the convex hull yields 
the object in the lower left. The re­sults of the simulation are shown in the lower right. Lrtthis case, 
the simtdation causes the network of vertices and edges that form the tiI&#38; of the goblet s bowl to 
snap aut onto the phme defined by the run af the goblet T p, :-(T u Figure 2- Snappin~ an ObJect to 
its Convex Hull 5.1.4 Hybrid Methods In addition to the projection methods described in the proceeding 
three sections, two other techniques have been developed that com­bine model knowledge with physical 
simulation. Lofted and tubular objects consist of a series of planar contours that are joiied along a 
(possibly curved) path. Cambining the methods of Section 5.1.2 and 5.1.3 generates an algorithm for projecting 
this class of models. Select two adjacent contours. If the contours are not convex, project them to their 
cmnvex hull using Ekouie s meth­cd. The two contours define a pair af smounded regions as de­scribed 
in Section 5.1.3. Running a rubber-band mesh simulation witit the contour @rtts fixed causes the interior 
of each region to snap onto the plane of the contour. Figure 3 shows a tubulsr object with the selected 
contours highhghted and the same ob~t after the simulation is completed. Two features of this teduique 
may not be evident. FirsL the two contours do not have to contain an equal number of points. The only 
requirement is both contours are a simple planar polygon. Secmd the entire procedure can be performed 
with na user interaction, pro­vided that knowledge of the manner in which the models are stored is available. 
However, it is desirable that the user be allowed to specify the pair of contours which are to remain 
fixed. Computer Graphics, 26, 2, July 1992 . Convex Model close-up Bottom of of Created by Convex Model 
Snapping Oli&#38;ii: Object  Ngure 3- Snapping a lltbttlar Model The second hybrid method involves 
the user directly specitjing the surrounded regiona of the model. For example, to project a model of 
a man, the user might .spe@ rings of edges around each arm at the shoulder, around each leg at the hip, 
and around the head at the base of the neck. A rubber-band mesh simulation is then run to snap in the 
extremities. It is up to the user to select surrounded re­gions that result in a convex model after the 
simulation is per­formed. Techniques for assisting the user in specifying the regions are ctumntly being 
investigated. Using this technique, the surrounded regions appear to grow out of the other model during 
the transformation. This interesting effect is due to the fact that points on the ends of the extremities 
have much larger distances to cover than do those at the base, and hence move at a greater velocity. 
5.2 The Merging Algorithm Onw both models have been projected, the second step of the cor­respondence 
algorithm is to merge the topologies of the two models by clipping the projected facea of one object 
to the projected faces of the other. In an earlier paper [9], an 0(N2) algorithm based on Weiler s polygon 
clipping algorithm ([15]) is described. The algo­rithm requires each projected edge of one model to be 
intersected with each projected edge of the other. Since the edgea of the project­ed models map onto 
great circles of the unit sphere, these computa­tions involve finding the intersection of pairs of circular 
arcs. This algorithm works well for merging the projected topologies of objects that are not overly complex. 
However, for large models (> 1000 vertices) small numerical inaccuracies in the arc intersection calculations 
often result in an improper ordering of the intersection points along an edge. Since the algorithm is 
dependent upon main­taining a valid topological structure, improper ordering can cause the merging pceaa 
to fail. The original merging algorithm was rdso quite slow. If the number of edges of the models are 
N, and Nb, respectively, in the worst case, there are of,NaNb) intersections. However, for most models, 
since the faces are spread out across the entire surface of the sphere, an edge from one model only intersects 
a small number of edgea of the other model. Thus, in the vast majority of cases, the number of intersections 
is much less than NaNb, This suggests that an algo­rithm whose execution time is &#38;pendent upon the 
number of inter­sections could significantly reduce the overall execution time. This observation led 
to the development of a new merging algo­rithm that is faster and more robust than the original one described 
in [9]. The improvements are the result of exploiting the topological information contained in the models. 
The algorithm is similar in na­ture to the planar overlay algorithm described by Seidel in [13]. The 
following paragrapha describe the steps of this new algorithm and analyze its complexity. The &#38;scription 
assumes that the faces of the model have been triangulated prior to execution. It also as­sumes that 
no projected vertices of the two models are coincident, and that no pojected vertex of one model lies 
on a projected edge of the other. These degenerate cases can be handled by simple ex­tensions of the 
basic algorithm. Figure 4 contains a pseudocode description of the algorihm. The peudocode assumes that 
arrays are used to store structures for each vertex, edge, and face of the models. For each vertex, this 
structure contains the original and projected locations of the vertex, as well (step 1) Read in the Topology 
and Geometry of !4s and Mb, as well as the Coordinates of the Projected Vertices, (V, )p and (Vb)[. 
Translate the model-s so their cen­ters are at t e origin. (at+ 2) VI, <--first vertex of Ma MaPTOBIVI@] 
<--face of (~)p that contains (vI.) Add the edges originating at VII to Work List 1 (W 1 Mark those 
edges Used While (WL) is Not Empty e, <--next edge of WL Via, v2a c--endpoints of ela fb <--MapToB 
[via] Add edges of fb to Candidate List (CL) While CL 1s Not Empty b --next edge of CL Intersect ea 
and eb If Successful Add Intersection Point, i, to Model Create links from ea and eb to i fb <--Pace 
of won other side of eb Add two other edqes of eb to CL End If End While MapToB [V2a] <--fb Add the unused 
edges oriqlnating at v2a to WL Mark those edges Used End While (atop 3) For each edge, eb, of Mb Vlb, 
V2b <--endpoints of eb Sort the intersections of eb using topological Information from Ma Set MapTOAIVlb] 
and MapToA [V2b] to faCeS Con­taining VII and V2b, respectively End For (at* 4) For each vertex, v,, 
of Ma Calculate the barycentric coordinates of (v,) with respect to the projected vertex COOKJ i­nates 
of the face, MaPTOB[Va], of f4b Use these barycentric coordinates and original vertex coordinates of 
the face, ?4apToB[v~l to determine where Va maps to on the SUrfaCe of Mb End For (atop 5) Repeat Step 
4 for each vertex of t%, using the faces stored in array MapToA to identify the face of ~ that contains 
each vertex of ~ (atop 6) Output the combined geometry and topology of both models, W* and Mb* Figure 
4-Pseudocode for the Merging Algorithm as the edges beginning at that vertex, stored in clockwise order. 
Each edge structure includes the hikes of the two endpoints and the indices of the two faces it separatea. 
The edge structure also cOn­tains a pointer to the list of intersections of that edge. The face struc­ture 
includes the indices of the three vertices and the three edges that comprise the face. In addition to 
these structures, as each inter­section point if found it is stored in an array of structures that cOn­tain 
the indices of the two edges that intenw% the parametric vslues of the intersection point relative to 
those edges, and pointers used to order the intersections along the edge. -­ edge from (Ma~ Vertices 
from (Ma&#38; are labelled with UPPERCASE letters Vertices from (M~P are labelled with lowercase letters 
Light edges are from (M, , Dark edges are from (lk&#38;~ Bold edges are those for w i ch intersections 
are computed  Figure S -Calculating the Intersections of an Edge The first step is straightforward 
and can be performed in O(N) time. Step 2 rnvolvea intersecting each edge of (k!a)P with a subset of 
the edges of (M~P as ihstrated in figure 5. FwsL vertex v* of (Ma~ is &#38;terrnined to lie inside face 
f.~ of (Mb . This can be done in O(N) time by casting a ray from the origin k ough VA and tinding the 
face of (Mb) it intersects. Once this is donq the edges originst­ing at vA are ad$ed to a list of edges 
to be proce.s~ the work list. Assume em is fhe fist edge on ~s list. !$ince it k known ht vA lies on 
face fab of (MJ , the tirst intersection of that edge must be with one of the edgea of that face. Thus, 
eab eat, and ~ from (M~P are added to a list of candidate edges that ew might intersect. In ttus case, 
em intersects e~ he topology of Mb can be used to deter­mine that em cresses over to face f~ at the intemection 
point. Thus, edges ~ and e~ are added to the candidate list. Similarly, at the intersection of ea and 
em, edge em mosses onto face fd= and edges em and eh are added to the caddate list. At the intersection 
of ede and em, edge e*~ crosses onto fSCe f~, and edges e~ snd   -% ~;edge -.L $ . ---­ k­ y  $;, 
Numerical mom in the intersection calculations may indicate that the ordering of the intersection points 
is a-bd-c. Using topological information about the intersected edges yields the correct ordering a-b-cd, 
based upon the faces along the edge, flg-f23-fT1-f9T-f~ It also indicates which faces contain the end@nts 
of the edge being intersected (i.e. f19 snd f%). Figure 6-Sorting the Intera@ons ~ are added to the csndldate 
list. Sime em does rmt intersect ei­ther of these edges, vertex vB must ~e on f= fd~ This f~t is re­corded 
and the edges originating at vB are added to the work list. This continues until the work list is empty. 
Step 3 of the algorithm sorts the intersection of each edge of (~~ using topological information from 
(Ma~ to ensure that the cmier­ing is valid. As shown in Figure 6, basing the sort on this infortna­tion 
avoids incxmsistenciea in the topology due to small numerical emors in the intersection calculations. 
This step is also used to de­termine which face of (Ma)P contains each vertex of (M~r Steps 4 and 5 use 
the information that indicates which face of ~$ contains each vtxtex of (M,)r and vice versq to determine 
where the vertices of one model map onto the surface of the other. This is done using barycentric coordinates 
as shown in Figure 7. Step 6 rn­volves trtming out of the faces of the mmbined models using the original 
topologies and the sorted intersections of each edge and can be performed m O(N) time. (V2)P V2 u = ().1 
VI (Vl)p .V=O.5 . w= 0.4 afl V3Find barycentric (V3)P coordkates (BC) Use BC to psition of vertex with 
respect vertex on originaf modelto projected face of (U* V1+V*V2+W*V3) the other model igure 7-Determining 
the Vertex Locations 5.2.1 Analysis of the Merging Algorithm Steps 1,4,5, and 6 can all lx performed 
in O(N) time. The timere­ quired to complete Steps 2 and 3 is dependent upon the number of edges that 
intersect and is analyzed below. As in previous sections, N, and Nb represent the number of edges of 
Ma and Mb In step 2, each edge of Ma is intersected with exactly 3 + 2 * ~ edg­es, where ~ is the number 
of intersections of the edge. Since this must be done for each edge, the total number of intersections 
is 3 * Na + 2 * Iu, where ~ is fhe total number of edgedge intersec­tions. Thus the running time of step 
2 is O(N, + ~. For complex models, the distribution of the faces on the sphere ensures that ~t << NaNb 
In step 3, the intersections of each edge of ~ must be sorted. If ~ is the number of intersections of 
an edge, the sorting of that edge requires time CM&#38;logu. Since in the worst case, each edge can be 
intersected O(NJ times, the worst case complexity is O(NbN,lo­gNa). However, in terms of the total number 
of intersections, since the sum of (f~og~ for each edge is less than or equal to ~log~~, the complexity 
is ~log~. Thus, the overall complexity of the algorithm in terms of output size equals that of step 3, 
O~log~). Although in the worst case, ~ is 0(N2), the distribution of the edges on the sphere causes ~ 
to be much smaller than this in most cases.  deacrilxd in Section 5.1.3. In the lower sequence, the 
hybrid meth­od for tubular objects described in Section 5.1.4 WSS used to Pruject the S . The object 
of revolution method was used to project the dig­itized head in both sequences. The two sequenms illustrate 
that rsd­ically different results are possible by altering the projection method used. Figute 11 shows 
three columns, each of which represents a Eansfor­mation betweem a a pair of objects of revolution. The 
objects in the middle of each column are the models obtained at the 25%, 50%, and 75% points of the transformation. 
The base objects of the left and middle columns are objects of revolution. The base object of the rightmost 
column is an extruded 6-pointed star. As a H note, the following statistics for the transformations in 
Figures 8 to 11 are provided to support the claim made in Section 5.2.1 that the total number of intersections, 
~, is much leas than N,Nb for complex models. N, Nb NaNb It ~t Figure 8 1.8K 2.7K 4.9M 6.5K Figure 9 
2.7K 18.7K 50.5M 19.9K Figure 10 -­ top 66 18.4K 1.2M 4.OK -­ bottom 66 18.4K 1.2M 1.9K Figure 11 -­ 
left 864 18.7K 16.2M 14.7K -­ middle 102 18.7K 1.9M 5.OK -­ right 72 18.7K 1.3M 3.9K  8.0 Future Research 
Future research will focus on three areas. FrsG extensions of tie al­gorithm to handle wider classes 
of polyhedra will be investigated. For gems O objects, this involves developing new ways to project the 
surface of a model onto a sphere. For non-genus O objects, cut­ting the objects to eliminate the passages 
through therm or replacing the sphere with a representadve manifold (e.g. a toNs for objects with one 
hole) are possibdities. The second area of interest is to examine the ~oblem of self-inter­sections during 
the interpolation. A good solution to this problem has applicability for many other problems that involve 
interpola­ti~ not just shape tmmsforrnation. The third ma of rnveatigation involves providing user control 
of the transformation. The remarkable reattlts obtained by morphing are pssible because the user maintains 
complete control over the transformation. Unlike the other published techniques for 3D shape ~ansfommtiort, 
the algorithms presented in this paper allow some umtrol over the transformation through mechanisms such 
as select­ing the center of the object and choosing the projection technique. However, to achieve results 
equivalent to those obtained by mor­phing imttg~ techniques that provi&#38; a tier level of control eves 
the transformation are needed. One possibility is to add a watping step after the models sre mapped to 
the sphere, but before the topol­ogies are merged. Acknowledgments We wish to thank the Department of 
Computer and Information Sci­ence, the Advanced Computing Center for the Arts and Design and the Ohio 
Supercomputez Center for the use of their facilities, and Hewlett-Pecksrd end AT &#38; T for equipment 
grsnts that make this research possible. We also wish to thank Dr. Rephael Wenger, Kevin Rodger~ Steve 
May, and Stephen Spencer for useful i&#38;ss and criticism, and Rofessor Charles Csuri for the use of 
his head. Bibliography 1. Bethel. E. and Usel~ S. Shape Distortion in Computer-As­sisted Keyfreme Animation. 
In State of the Art in Catywter An&#38;zion. Magnenst-Thelm~ N. and Thalmsnn, D., eds., Springer-Verhg, 
New York. 1989,215-224. 2. Bier, E. and Slo~ K. We-Part Texture Mappings. IEEE Computer Graphics mtdApplication.r6, 
9 (SqX. 1986), 40-53. 3. CarlsoYL W. An Advanced Data Generation System for Use in Complex Object Synthesis 
For Computer Display. Proceed­ings of Graphics Inter@ce 82 (1982) 197-204. 4. Chen, E., and PsrenL R. 
Shape Averaging end Its Applications to Industrial Des@. IEEE Computer Grophics and Applicu­tio~ 9, 1 
(Jan. 1989) 47-54. 5. Ekotde, A., Pefi F. and ode~ C. A Triangulation Algorithm fium Arbitrary Shaped 
Multiple planar Contours. ACM TrurM­atiotuonGrqvhtks 10,2 (April, 1991) 182-199. 6. H~ D. and ParenL 
R. l heBehavioral Test-Bed Obtain­ing Complex Behavior tiom Simple Rules. Viiuul Conywter 4, 6 (Dec. 
1988) 332-347. 7. Hong, T., Magnenat-lltslmann, N. and lltalrn~ D. A Gen­eral Algorithm for 3-D Shape 
Interpolation in a Facet-Based Representation. Proceedings of Graphics Interjhce 88 (June 1988) 229-235. 
 8. Kau~ A. and Rossignac, J. Solid-Jnterpolating Deformations: Construction end Animation of PIPs. Fmceediigs 
of Euro­graphics 91. In Computers and Graphics (1991). 9. KenL J, Parent, R. and Csrlso~ W. Establishing 
Correspon­dences by Topological Merging: A New Approach to 3-D Shape Transformation. Proceedings of Grqohics 
Interjizce 91 (Calgary, Albert% June, 1991) 271-278. 10. Paren~ R. Shape Transformation by Boundary 
Rqmaentation Intapolatiorx A Recursive Approach to Establishing Face Correspon&#38;ncea. Technical Reprt 
OSU-CISRC-24?21-TR7. Computer and Information Science Research Center. The Ohio State University (1991). 
 11 Payme, B. and Tog% A. Distance Field Manipulation of Sur­face Models. IEEE Conputer GrWhics and 
Applications 12, 1 (Jan. 1992) 65-71. 12. Reparaw F. and Shsmo% M. Computational Geometry -An Introduction. 
Springm-Verlag, New York, 1985. 13. seide~ R. Output-Size Sensitive Algorithm for Constructive Problem 
in CotqrwtatM Geametry. Ph.D. Theais, Cornell University, 1986. 14. Terridea, C. Trensformstionsl Design. 
Knowledge Ai&#38;d Ar­chitectural Problem Salving and Design, NSF project #DMC­8609893, Fmsl Repo~ (June 
1989). 15. Weiler, K. Polygon Comparison Usrng a Graph Represertta­tion. Proceedings of SIGGRAPH 80 
(Seattle Washington, Jdy 1980). In Computer Gruphics 14,3, (Aug. 1980), 10-18. 16. Weiler, K. Topology 
as a Framework for Solid Modeling. Pro­ceedings of Grophics Int@zce %4, (May, 1984). 17. Wolberg, G. 
Digital Image Wmping. IEEE Computer Society Press, Los Alsmitos, CA, 1990. 18. Wyvill, B. Metamo~hosis 
of Implicit Surfaces. Notes @n SKXXAPH 90Course 23-Modeling and Animating with Im­plicit Surjhces, (Dallas, 
Texas, Aug. 1990).   
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134008</article_id>
		<sort_key>55</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>6</seq_no>
		<title><![CDATA[Re-tiling polygonal surfaces]]></title>
		<page_from>55</page_from>
		<page_to>64</page_to>
		<doi_number>10.1145/133994.134008</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134008</url>
		<keywords>
			<kw><![CDATA[automatic mesh generation]]></kw>
			<kw><![CDATA[constrained triangulation]]></kw>
			<kw><![CDATA[levels-of-detail]]></kw>
			<kw><![CDATA[model simplification]]></kw>
			<kw><![CDATA[shape interpolation]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.3</cat_node>
				<descriptor>Display algorithms</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Curve, surface, solid, and object representations</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Geometric algorithms, languages, and systems</descriptor>
				<type>S</type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10003752.10010061</concept_id>
				<concept_desc>CCS->Theory of computation->Randomness, geometry and discrete structures</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010399</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Parametric curve and surface models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010401</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Volumetric models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010372</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Rendering</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010382</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Image manipulation</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>PP39080372</person_id>
				<author_profile_id><![CDATA[81100457973]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Greg]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Turk]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Department of Computer Science, University of North Carolina at Chapel Hill]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_obj_id>147204</ref_obj_id>
				<ref_obj_pid>147156</ref_obj_pid>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Chung, James C., "A Comparison of Head-Tracked and Non-Head-Tracked Steering Modes in the Targeting of Radiotherapy Treatment Beams," 1992 Symposium on Interactive 3D Graphics, Cambridge, Massachusetts, 29 March - I April 1992, pp. 193-196.]]></ref_text>
				<ref_id>Chung 92</ref_id>
			</ref>
			<ref>
				<ref_obj_id>360354</ref_obj_id>
				<ref_obj_pid>360349</ref_obj_pid>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Clark, James H., "Hierarchical Geometric Models for Visible Surface Algorithms," Communications ofthe ACM, Vol. 19, No. 10, pp. 547-554.]]></ref_text>
				<ref_id>Clark 76</ref_id>
			</ref>
			<ref>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Cosman, M. and R. Schumacker, "System Strategies to Optimize CIG Image Content," Proceedings of the Image H Conference, Scottsdale, Arizona, 10-12 June, 1981.]]></ref_text>
				<ref_id>Cosman &amp; Schumacker 81</ref_id>
			</ref>
			<ref>
				<ref_obj_id>801253</ref_obj_id>
				<ref_obj_pid>965145</ref_obj_pid>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[Crow, Franklin C., "A More Flexible Image Generation Environment," Computer Graphics, Vol. 16, No. 3 (SIGGRAPH '82), pp. 9-18.]]></ref_text>
				<ref_id>Crow 82</ref_id>
			</ref>
			<ref>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[De Floriani, L., B. Falcidieno and C. Pienovi, "Delaunay-based Representations of Surfaces Defined over Arbitrarily Shaped Domains," Computer Vision, Graphics and image Processing, Vol. 32, pp. 127-140.]]></ref_text>
				<ref_id>De Floriani et al 85</ref_id>
			</ref>
			<ref>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[DeHaemer, Michael J., Jr. and Michael J. Zyda, "Simplification of Objects Rendered by Polygonal Approximations," Computers &amp; Graphics, Vol. 15, No. 2, pp. 175-184.]]></ref_text>
				<ref_id>DeHaemer &amp; Zyda 91</ref_id>
			</ref>
			<ref>
				<ref_obj_id>44231</ref_obj_id>
				<ref_obj_pid>44227</ref_obj_pid>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Ho-Le, K.," Finite Element Mesh Generation Methods: A Review and Classification," Computer Aided Design, Vol. 20, No. 1, pp. 27-38.]]></ref_text>
				<ref_id>Ho-Le 88</ref_id>
			</ref>
			<ref>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[Holloway, Richard, untitled technical presentation, University of North Carolina at Chapel Hill, December 1991.]]></ref_text>
				<ref_id>Holloway 91</ref_id>
			</ref>
			<ref>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Novins, Kevin, personal communication.]]></ref_text>
				<ref_id>Novins 92</ref_id>
			</ref>
			<ref>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[O'Neill, Barrett, Elementary Differential Geometry, Academic Press, 1966, New York.]]></ref_text>
				<ref_id>O&#8217;Neill 66</ref_id>
			</ref>
			<ref>
				<ref_obj_id>4333</ref_obj_id>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[Preparata, Franco P. and Michael Ian Shamos, Computational Geometry: An Introduction, Springer- Verlag, 1985, New York.]]></ref_text>
				<ref_id>Preparata &amp; Shamos 85</ref_id>
			</ref>
			<ref>
				<ref_obj_id>15906</ref_obj_id>
				<ref_obj_pid>15886</ref_obj_pid>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[Schmitt, Francis J. M., Brian A. Barsky and Wen- Hui Du, "An Adaptive Subdivision Method for Surface-Fitting from Sampled Data," Computer Graphics, Vol. 20, No. 4 (SIGGRAPH 86), pp. 179-188.]]></ref_text>
				<ref_id>Schmitt et al 86</ref_id>
			</ref>
			<ref>
				<ref_obj_id>134010</ref_obj_id>
				<ref_obj_pid>133994</ref_obj_pid>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[Schroeder, William J., Jonathan A. Zarge and William E. Lorensen, "Decimation of Triangle Meshes," Computer Graphics, Vol. 26 (SIGGRAPH 92, these proceedings).]]></ref_text>
				<ref_id>Schroeder et al 92</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122749</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[Turk, Greg, "Generating Textures on Arbitrary Surfaces Using Reaction-Diffusion," Computer Graphics, Vol. 25, No. 4 (SIGGRAPH 91) pp. 289-298.]]></ref_text>
				<ref_id>Turk 91</ref_id>
			</ref>
			<ref>
				<ref_obj_id>801126</ref_obj_id>
				<ref_obj_pid>800059</ref_obj_pid>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[Williams, Lance, "Pyramidal Parametrics," ComputerGraphics, Vol. 17, No. 3 (SIGGRAPH 83), pp. 1-10.]]></ref_text>
				<ref_id>Williams 83</ref_id>
			</ref>
			<ref>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[Zimmerman, Stephen A., "Applying Frequency Domain Constructs to a Broad Spectrum of Visual Simulation Problems," Evans &amp; Sutherland Technical Document, Presented at the IMAGE IV Conference, Phoenix, Arizona, 23-26 June, 1987.]]></ref_text>
				<ref_id>Zimmerman 87</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 z Computer Graphics, 26, 2, July 1992 Re-Tiling Polygonal Surfaces Greg Turk Department of Computer 
Science University of North Carolina at Chapel Hill Abstract This paper presents an automatic method 
of creating surface models at several levels of detail from an original polygonal description of a given 
object. Representing models at various levels of detail is important for achieving high frame rates in 
interactive graphics applications and also for speeding-up the off-line rendering of complex scenes. 
Unfortunately, generating these levels of detail is a time-consuming task usually left to a human modeler. 
This paper shows how a new set of vertices can be distributed over the surface of a model and connected 
to one anolher to create a re-tiling of a surface that is faithful to both the geometry and the topology 
of the original surface, The main contributions of this paper are: I ) a robust method of connecting 
together new vertices over a surface, 2) a way of using an estimate of surface curvature to distribute 
more new vertices at regions of higher curvature and 3) a method of smoothly interpolating between models 
that represent the same object at different levels of detail. The key notion in the re-tiling procedure 
is the creation of an intermediate model called the mufual fessellafion of a surface that contains both 
the vertices from the original model and the new points that are to become vertices in there-tiled surface. 
The new model is then created by removing each original vertex and locally re-triangulating the surface 
in a way that matches the local connectedness of the initial surface. This technique for surface re­tessellation 
has been successfully applied to iso-surface models derived from volume data, Connolly surface molecular 
models and a tessellation of a minimal surface of interest to mathematicians. CR Categories and Subject 
Descriptors: 1.3.3 [Computer Graph­ics]: Picture/Image Generation Display algorithms; 1.3.5 [Com­puter 
Graphics]: Computational Geometry and Object Modelling Curve, surface, solid, and object representations. 
 Additional Key Words and Phrases: model simplification, auto­matic mesh generation, constrained triangulation, 
levels-of-detail, shape interpolation. Pcrml,w{m [o ct~pywlthnut ICCtill m part nt (his material is grunted 
pr{wtkt that the copies wc not made {Jrdisfrihukd fm dmxt conmwrciul mtvantugc. the ACM copyright notice 
and the title of the puhltcati,m id its dtitc appctir, A nnticc is given th~t cnpying is hy permi,sitm 
fi the Associ~twnIhr Comput!ngMachinery To cnpy nthcrwwc.{wICJrcpuhlish,requiresa fw and/c>rspecitic 
~rmtssnm ACM-t)-tW791-479 -l/92/0 t)7/ot)55 SOI.so  1 Introduction This paper shows how a simplified 
polygonal model can be automati­cally created from an initial polygonal description of an object. We 
use the term re-riling to describe the process of simplifying a polygonal model. The notion of representing 
a model at multiple levels of detail is a common thread that runs through much work in computer graphics 
and image processing. These levels of detail can be found in a number of forms, such as multiple collections 
of polygons, different collections of bicubic surface patches or vari­ously filtered levels of a raster 
image. There are several benefits to having more than one representation of an object. One benefit is 
that it is often unnecessary to use a fully-detailed model of an object during rendering if the object 
will cover a small portion of the screen. Using a smaller model can significantly shorten the time it 
takes to render an image. It is this ability to increase the rendering rate, especially for interactive 
applications, that motivates the work pre­sented in this paper. Another benefit of having more than one 
representation of an object is that this is often a graceful way to avoid sampling problems when rendering 
an image, Probably the best­known example of this in computer graphics is the texture anti­aliasing work 
of Lance Williams [Williams 83]. A third reason for using multiple levels of detail is that features 
of an object can be classified by following the features through successively more coarse representations 
of the object. This method of feature recog­nition appears in much of the recent work being done in image 
processing and pattern recognition. Computer graphics has yet to make much use of feature tracking and 
elimination, and we will return to this issue in the future work section of this paper. Polygonal descriptions 
of objects are currently the most widely-used forms of model representation in computer graphics. One 
reason for this is the availability of graphics workstations that can rapidly render polygons. Another 
reason is that there area large numbers of techniques for translating a given model into apdygonal dataset. 
For these and other reasons, it is likely that polygonal representations of objects will continue to 
be important to computer graphics. This serves as motivation for finding automatic methods of creating 
new polygonal models of the same object that have a fewer number of polygons than the original description. 
Because there is such a wide range of objects that can be represented by polygonal tessellations, it 
may be impossible to tindone technique that can do a good job of re-tiling any given polygon dataset. 
For instance, techniques that are successful at reducing the number of polygons in a model of a building 
may not necessarily be applicable tore-tiling of medical datasets such as those derived from CT scans. 
This paper s re-tiling method is best suited to models that represent curved surfaces. Examples of such 
models include iso-surfaces from medical data and from molecular graphics, smooth mathematically­defined 
manifolds and digitized or hand-modelled organic forms such as animals or people. This technique is poorly 
suited to models that have well-defined comers and sharp edges such as buildings, furniture and machine 
parts. This paper begins with an overview of related work in creating levels of detail, and, in particular, 
work that deals with polygonal models. The rest of the paper describes the basic steps taken to re-tile 
a given model and several extensions to this basic method. The first section on re-tiling describes how 
to distribute a given number of points evenly over a polygonal surface. These points will eventually 
become the vertices of the new model. Next, the notion of mutual tessellation followed by vertex removal 
is presented as a robust method of completely replacing the original set of vertices with the new points. 
This is how a completely new triangulation of the model is created. The next section shows how local 
estimates of maximum curvature can be used to concentrate more new vertices at regions that need more 
points to faithfully represent the surface. The paper then describes how the polygons from a more fine 
representation of an object can be flattened onto the surface of a more coarse polygonal model. Using 
this method, we can interpolate between this flattened version of the model and the original high-detail 
representation to give a smooth transition between the coarse and the fine versions of an object. The 
next section describes how re-tiled models can aid the interactive task of radiation treatment planning. 
The final section discusses future topics of research in representing multiple levels of detail in polygonal 
models. 2 Previous Work James Clark s paper on hierarchical geometric models describes the benefits 
of using more than one representation of a model for image rendering [Clark 76]. Clark points out that 
objects that cover a small area of the screen can be rendered from a simplified version of the object 
and that this allows more efficient rendering of a scene. This same benefit of having both simple and 
complex representations of an object is given by Frank Crow in his paper on an image generation environment 
[Crow 82]. Crow gives the example of a chair that is represented in high detail, medium detail and very 
low detail. The three models in his example were created by hand, but Crow suggests that creating the 
lower levels of detail is a process that should be automated. A guaranteed frame-rate is essential in 
flight simulators, and for this reason models of objects such as airplanes are often made at several 
levels of detail by hand [Cosman &#38; Schumacher81 ]. The creation of lower levels of detail has been 
automated for some well-behaved polygonal datasets. Lance Williams showed how a regular mesh of quadrilaterals 
can be used to represent surfaces such as a human face, and how such meshes can be filtered down to smaller 
resolutions in the same manner as he used for texture filtering [Williams 83]. This is similar to how 
flight simulators use coarse versions of terrain data when a ground feature is faraway and use a more 
detailed terrain model when the feature is closer to the viewer. The flight simulator literature describes 
how new features of the terrain can be gradually introduced as the viewer moves closer by first adding 
new vertices in the plane of a temain polygon and then moving each vertex s elevation smoothly until 
it reaches the correct elevation [Zimmerman 87]. With a gridded terrain model it is easy to know which 
vertices need to be joined to form new polygons when anew vertex is added or when an old vertex is removed. 
This problem is more difficult for polygonal models with arbitrary topology. Another polygonal data format 
that has been automatically re-tiled is the laser-scanned data from Cyberware Laboratories of Monterey, 
California. Their digitizing method results in a large collection of regularly joined quadrilaterals. 
Schmitt and co-workers have adaptively fit bicubic patches to such models by starting with a rough approximation 
of the surface and then adaptively refining the surface 56 at locations where the model is not yet well 
fit [Schmitt 86]. This method generates models at varying levels of detail by specifying a set of increasingly 
fine tolerance levels for the surface fit. Extensions to this method have been explored to adapt the 
technique to creating polygonal models and to more closely bound the error [DeHaemer &#38; Zyda 91]. 
DeHaemer and Zyda s methods reduced a 112,128 polygon image of a human head to 12,82 I polygons. As with 
terrain data, the Cyberware format makes it easy to decide which vertices become neighbors when a vertex 
is added or removed. To reduce the large numbers of polygons often found in medical data, Kevin Novins 
implemented a method of identifying and removing vertices that are in relatively flat portions of a polygonal 
object [Novins 92]. His program examines the variance in surface normals of triangles that share a given 
vertex and uses this to decide which vertices to remove. When a vertex is removed, the region immedi­ately 
surrounding the vertex is re-triangulated. The user gives a target number of vertices and the program 
removes vertices until this number is reached. Schroeder and his co-workers have also used an approach 
of vertex removal and local re-triangulation for simplifying polygonal models [Schroederet al 92]. They 
remove vertices that are within a distance tolerance of a plane that approximates the surface near the 
vertex. Their method also identifies sharp edges and sharp comers and makes sure that such features are 
retained in order to better represent the original data. They show how these techniques can be used to 
drastically reduce the number of polygons in large medical and terrain models and still retain feature 
detail. There is a large body of literature on automatic mesh generation for use in finite element techniques. 
An overview of this work is given in [Ho-Le 88]. Here the problem is how to sub-divide the surface or 
volume of an object to provide a mesh over which some physical properties of the material can be simulated, 
such as heat dissipation or stress and strain. It is assumed that all the edges and faces of a model 
are to be accurately reflected in the re-meshed version of the object. This is the main difference between 
meshes used in finite element methods versus smooth surface models for rendering in computer graphics. 
The exact placement of vertices and edges in a polygonal representation of a cat are not as important 
as the place­ment of the edges separating the copper and iron portions of a machine part being analyzed 
for heat conductivity. There are some issues, however, that do touch upon the problems that are found 
in mesh generation in both domains. For example, many finite element meshing routines use local re-meshing 
operators to improve the shapes of triangles in an initial mesh. Similar local operations can be used 
to improve re-tilings for computer graphics. There is a good deal of material in computational geometry 
that is relevant to the re-tiling problem. Specifically, the properties of Voronoi regions and the associated 
Delaunay triangulation are relevant to the question of goodness of triangle shape in a triangu­lation 
of a collection of points [De Flonani et al 85]. 3 Choosing New Vertices for Re-Tiling 3.1 Input Surface 
and the Results of Re-Tiling The re-tiling method described in this paper kgins with a polygonal surface 
and creates a triangulation of this surface with a user­specified number of vertices. There are few restrictions 
on the initial polygonal surface. The polygons may be either concave or convex, and may in fact have 
holes. The major restriction is on the number of polygons that share any given edge. The method described 
below is suitable for polygonal models in which each edge is shared by either one or two polygons. If 
a model satisfies this restriction, the algorithm is guaranteed to produce a new model with the same 
topology as the original model. The method will not introduce tears   (a) Figure 2: Problems encountered 
when connecting new vertices. (a) Connecting regions that fold back near one another. (b) Bubbles resulting 
from incorrect joining of vertices. join together a pair of vertices that reside on two such separated 
regions (the thin lines in Figure 2a). Another pitfall is the creation of small surface bubbles , where 
two sets of polygons are created that both tile the same pmtion of a surface (see Figure 2b). Groups 
of polygons that meet at a sharp comer also present difficulties when re­tiling. Two distinct approaches 
were tried for connecting the candidate vertices before the method described below (mutual tessellation) 
was found. Both of these earlier methods failed because they relied on heuristics to choose which candidate 
vertices were neighbors and which of these neighbors should be comected together to form triangles. The 
first of these failed methods used a planar approxima­tion to a point s Voronoi region to determine neighbors. 
The second failed technique used a global greedy algorithm. This method added anew edge to the list of 
edges in there-tiling if it was the shortest edge not already on the list and if it did not intersect 
any other edge in planar approximation to the surface in the area near the edge. Below we will see how 
a local greedy algorithm is used to give a robust re­tiling method. 4.2 Mutual Tessellation The key notion 
in creating a re-tiling of the surface is to form an intermediate polygonal surface, called a mutual 
tessellation, that incorporates both the old vertices of the original surface and the new points that 
are to become vertices in there-tiled surface. After the mutual tessellation is made, the old vertices 
are removed one at a time and the surface is re-tiled locally in a manner such that the new triangles 
accurately reflect the comectedness of the original surface. Creating the mutual tessellation is a straightforward 
task. Each polygon of the original model is replaced by a collection of triangles that exactly tiles 
the polygon but that also incorporates the candidate vertices that lie in the polygon. This re-triangulation 
of a given polygon is performed by first gathering together the vertices of the polygon along with the 
candidate vertices that lie on this polygon. This collection of points (original vertices and candidate 
vertices) is then triangulated, subject to the constraint that the edges of the original polygon are 
to be included in the final triangulation. l%e triangulation is performed in the plane of the given polygon. 
For c example, a square polygon containing exactly one candidate vertex would be removed from the model 
and replaced by a set of four triangles that all meet at the one candidate vertex. If the square face 
contained n candidate vertices then it would be replaced by a set of 2n+2 triangles. The method of constrained 
triangulation used for this paper is greedy triangulation, but this is just one of several ways to form 
such a triangulation [Preparata &#38; Shames 85]. There is no chance for misrepresenting the original 
surface at this stage because each polygon is replaced by a set of triangles that exactly tile the original 
polygon. An added benefit to using mutual tessellation is that the original surface can include concave 
polygons or even polygons with boles since constrained triangulation algorithms easily handle these cases. 
The lower left object of Figure 1 shows the mutual tessellation of the original model shown in the upper 
left portion of the figure. The candidate points that have been used to create this tessellation are 
those shown in the upper right of the same figure. 4.3 Removing Old Vertices The next task is to remove 
the old vertices in a way that guarantees that the newly-created triangles follow the topology of the 
original surface. This can be done by invoking the same triangulation routine that was used to create 
the mutual tessellation. Given an old vertex R to be removed, we collect together all vertices that share 
a triangle with R. Call this collection of neighboring vertices V, and give the name T to the set of 
triangles that the vertices in V share with the vertex R. Then this collection of neighboring vertices, 
wirhou~ the vertex R, are projected onto a plane that is tangent to the surface at f?. Now a few tests 
are made to see if this region can be re-tiled without compromising the topology of the surface. These 
tests are described later. If the tests check out, then the vertices V are triangulated along with the 
additional constraints that all edges of the triangles in T that do not contain R must be included in 
the final triangulation. Call these additional constraint edges the set E. This set of edges E form a 
closed polygon sumounding the vertex R. The triangulation is performed along with the final constraint 
that no new edges are to be introduced outside of the polygon formed by the edges in E. Figure 3a shows 
a vertex R to be removed and its set V of neighbors: A,B, C,D,E, F and G. In this example there are seven 
triangles in the set T, and the set E consists of the edges AB, BC, CD, DE, EF, FG and GA. Figure 3b 
showithe result of removing R and triangulating the neighbors in V to give five new triangles. These 
new triangles completely replace the triangles in the set T, and all the triangles in Tare removed from 
the model. Notice that performing this triangu­lation in a plane assures us that the new triangles match 
the topology of that local portion of the original surface. The newly-created triangles are constrained 
to have a common border that is just the edges in E, so they will be adjacent to the same triangles that 
used to border the triangles in T. F@me 3: Removing a vertex from a mutual tessellation.  Figure 7: 
Improving triangle shape by local re-triangulation. upstage. Figure 7b shows the same vertices, along 
with Q, after local re-tr-iangulation. Any reasonable approximation to a tangent plane to the surface 
at the vertex Q can be used for the plane in which to perform the triangulation. Here again, the same 
two checks should be performed to avoid re-tiling at a fold and to avoid creating edges shared by three 
or more triangles. One or two clean-up passes were used in creating all there-tiled models shown in thk 
paper. The same greedy triangulation routine described earlier was used in this im­provement step. 4.6 
The Special Case of Boundaries The t-e-tiling process can be augmented to handle polygonal models where 
some of the edges belong to only one polygon. Each of the three steps of mutual tessellation, vertex 
removal and clean-up must treat these boundary edges specially. When incorporating candidate vertices 
into a mutual tessellation, any candidate vertex that lies on a boundary edge must be incorporated into 
the boundary of the polygon that is being triangulated instead of into the interior of the polygon. This 
means that such a candidate vertex must be an end­point in two of the constraint edges. During the vertex-removal 
stage, we choose not to remove an old vertex if it is at the comer of a polygon where two boundary edges 
meet that are part of the same polygon. Likewise, a vertex will be retained if more than two boundary 
edges meet at that vertex. If exactly two boundary edges from different polygons meet at a old vertex, 
that vertex may be removed. Figure 8a shows such a vertex R where the edges AR and RE belong only to 
the triangles ABR and RDE, respectively. Figure 8b shows the triangles formed after removing R. 4.7 
Re-Tiling Robustness and Extensions It is worth examining at this point how this re-tiling approach avoids 
the possible pitfalls involved in connecting candidate vertices. The central strength of the above method 
is that it breaks the surface re­tiling problem into many small planar triangulation problems. Pla­nar 
triangulation of vertices with constraints is a well-understood problem from computational geometry. 
Casting the problem into two dimensions avoids the ambiguities found in three dimensions when trying 
to determine if a point is inside a polygon or whether two edges intersect. Constraining each triangulation 
sub-problem to include the edges E surrounding a vertex R that is being removed guarantees us that the 
collection of newly-created triangles will have the same common boundary as the old triangles T. This 
common boundary is just E, the set of constraint edges. These same observa­tions apply to the triangulations 
performed during the clean-up step. One way to think of the re-tiling process is that the mutual tessellation 
allows the vertices and polygons of the original model to act as guides for how different portions of 
the surface will be connected to one another in the re-tiled model. 60 Figure 8: Removing a vertex on 
the boundary of a surface. There is the opportunity within the framework of mutual tessellation and vertex 
removal to choose a measure of triangle quality for the triangulation sub-problems. The re-tilings shown 
in this paper were made with a greedy triangulation routine, where the shortest edges that do not intersect 
already chosen edges are picked to be included in the final triangulation. Mom specifically, although 
the triangula­tion is always performed in a plane, the edge dktances used in the greedy algorithm are 
determined from each vertex s unprotected 3­space position. This greedy algorithm has created well-shaped 
triangles in there-tilings that we have performed. If another measure of triangle goodness is desired 
then another triangulation routine can be incorporated into the basic framework described above. For 
example, one might use a triangulation routine that attempts to maximize the most acute angle in the 
potential collection of triangles [De Floriani et al 85].  5 Surface Curvature 5.1 Curvature Approximation 
The basic method of point-repulsion gives surface re-tilings in which the new triangles are all roughly 
the same size across the model. This is quite adequate for surfaces that do not vary greatly in the amount 
of curvature at different locations. If, however, the variation in surface curvature is relatively large, 
then the features of the surface would be more accurately reflected in a re-tiling by increasing the 
density of vertices in regions of high curvature. Ideally, we would like to have an exact measure of 
curvature from the object that the polygonal model is meant to represent. Often, however, this information 
is not available, either because the object being represented is not available (e.g. the volume data 
was not D  I B Figure 9: Curvature. (a) Radius of curvature in the plane. (b) Approximation to curvature 
in the plane at a vertex.       have a pointer to a list of polygon fragments of several triangles 
from H. These polygon fragments retain the positions of their original 3­space vertices from when they 
were a part of the high-detail model, and they also save their final, flattened position on one of the 
triangles in i!,. Each of these polygon fragments will also remember what original high-detail triangle 
they descended from, and this tag will be used to determine which fragments maybe re-united after the 
process of vertex removal. The polygon tracking process begins as follows. First, each triangle in the 
high-detail model is initialized with a list of polygon fragments that contains just a single element, 
and this element is a copy of the original triangle. Each triangle also retains a list of flattened points 
which is initially empty. Several steps are followed when a high­detail vertex is removed from the model, 
and these steps all take place in the plane. This lets us unambiguously determine where one edge intersects 
another and when a point is inside a given triangle. First, when a high-detail vertex V is removed then 
the triangles surround­ing \/ must be split by the new edges that are introduced by the re­triangulation 
of the area surrounding b . For instance, assume that the four triangles surrounding 1 in Figure 13 will 
be replaced by two triangles that share anew edges AX (dotted line), This new edge splits each of the 
old triangles AWV and VWX into two pieces. The new triangle AWX is given a list containing the two polygon 
fragments that lie within A WX. Similarly, the new triangle AXD keeps the other IWOfragments and the 
undivided polygons AVD and VXD in its list. Now we must determine which of the new triangles A WX orAXD 
the old vertex V should be flattened onto. In this example, the new, flattened position of I is on triangle 
AXD. This same process of vertex removal, triangle splitting and vertex flattening is carried out for 
all the high-detail vertices in the model. The result is a set of low­detail triangles L, each of which 
has a list of fragments from the original triangles of the high-detail model. Some of the fragments in 
a list maybe fragments of the same triangle of the high-detail model, and such fragments may be coalesced 
to give fewer final polygons. Such sibling fragments are found in the same list when a polygon is split 
at an early stage in the fragment tracking process by an edge that is later removed from the model. 6.3 
Performing the Interpolation When the above work is finished, we have a large collection of polygon 
fragments that know where they came from in the original, high-detail model and that also know what their 
current, flattened position is on the surface of the low-detail model. It is now a simple task to interpolate 
the vertices of each of the polygon fragments between these two positions. Atone end of the interpolation 
they will all lie flat on the low-detail model, and together they will have exactly the same shape as 
the low-detail model. At the other end of the interpolation, they have a shape identical with the high-detail 
model. The process of interpolating between these two positions has the effect of inflating the low-detail 
model into the model with more triangles. We have found that linear interpolation between these two positions 
is sufficient to make smooth transitions between models. There are no jumps or discontinuities during 
this interpolation. This provides a seamless way of switching from one level of detail to another. and 
could be useful in both in interactive applications and for rendering frames for animating a complex 
scene. Figure 14 shows this form of shape interpolation between two models that are re-tiled versions 
of the minimal surface shown in Figure 12.  7 An Application of Re-Tiling We have immediate plans 
to use re-tilings of polygonal surfaces in research on radiation-treatment planning being done at the 
Univer­sity of North Carolina at Chapel Hill. Planning the placement of radiation beams for the treatment 
of tumors is an intensely geometric Computer Graphics, 26, 2, July 1992 task lChung 92 ]. The problem 
is how to aim several radiation beams at a tumor while at the same time keeping too much radiation from 
impinging on the organs surrounding the tumor. James Chung has prototype a beam-placement application 
program where the user wears a bead-mounted display and places radiation beams around a polygonal representation 
of the anatomy containing the tumor. The models used to represent the tumor and the surrounding organs 
(lungs, kidneys, etc. ) often contain many thousands of polygons. There is a trade-off that can be made 
between the accuracy of representation of the anatomy and the frame update rate of the display, One possible 
solution is to give the user direct control over this update rate [Holloway 9 I ]. The graphics engine 
would use a more coarse set of polygonal models when the user wishes to make broad motions (e.g. walking 
around the simulated patient) and would then switch to the more detailed models when fine adjustments 
are being made to the final beam placements. We plan to make use of the re-tiling techniques described 
here to provide the variously detailed models.  8 Future Work One possible extension of the re-tiling 
method would be to use information about the direcfion of minimum and maximum curva­ture at each point 
to help guide the local re-triangulation of the surface. The point-repulsion step could take direction 
of higher curvature into account by having the points re pel in a direction­dependent manner. This would 
amount to changing the shape of a point s field of repulsion from a circle to an ellipse. The directional 
curvature measure should also guide which edges between points are created during triangulation. Polygon 
edges should k created preferentially along the direction of lesser curvature. There are several more 
broad issue~ that should be addressed in future work on re-tiling of polygonal models. One issue is whether 
there are better ways to estimate the surface curvature on a polygonal model. Another topic is finding 
measures of how closely matched a given re-tiling is to the original model. Can such a quality measure 
be used to guide the re-tiling process? Perhaps the biggest issue to explore is the opportunity for elimination 
of features at very low levels of detail. How can small features of a model be automatically identified 
and under what conditions is it acceptable to remove a feature completely from a model? For example. 
no triangles need to be used to represent the shape of a person s ear if the size of the person in the 
final image will be three pixels high.  Acknowledgments Many people provided ideas, aid and encouragement 
for this work, and these people include: David Banks, Henry Fuchs, Marc Olano, Penny Rheingans, John 
Rhoades, Brice Tebbs and Terry Yoo. Several of the anonymous reviewers made excellent suggestions for 
improving this paper. Thanks also goes to Kevin Novins and Michael Zyda for discussions about other work 
that has been done in this area. The radiation dose volume data was provided by the UNC Depart­ment of 
Radiation Oncology and tbe iso-dose surface was created by Victoria Interrante and James Chung. The molecular 
model of tbe carbohydrate called Wilma was provided by Mark Zottola. The model of the Costa genus one 
minimal surface was created by James T. Hoffman using his adaptive mesh algorithm and the mathematical 
description of this surface is due to Celso Costa, David Hoffman and William Meeks 111. This work was 
supported by a graduate fellowship from IBM and by the Pixel-Planes Project. Pixel-Planes is funded by 
DARPA Grant No. DAEA 18-90-C-0044, NSF Cooperative Agreement No. ASC 8920219 and ONR Grant No. NOOO14-86-K-0680. 
 References [Chung 92] Chung, James C., A Comparison of Head-Tracked and Non-Head-Tracked Steering Modes 
in the Targeting of Radio­therapy Treatment Beams, 1992 Symposium on Interactive 3D Graphics, Cambridge, 
Massachusetts, 29 March -I April 1992, pp. 193-196. [Clark 76] Clark, James H., Hierarchical Geometric 
Models for Visible Surface Algorithms, Communications of the ACM, Vol. 19, No. 10, pp. 547-554. [Cosman 
&#38; Schumacher 81] Cosman, M. and R. Schumacher, System Strategies to Optimize CIG Image Content: Proceedings 
of rhe Image 11Conference, Scottsdale, Arizona, 10-12 June, 1981. [Crow 82] Crow, Franklin C., A More 
Flexible Image Generation Environment, Computer Graphics, Vol. 16, No. 3 (SIGGRAPH 82), pp. 9-18. [De 
Floriani et al 85] De Flonani, L., B. Falcidieno and C. Pienovi, T3elaunay-based Representations of Surfaces 
Defined over Arbi­trarily Shaped Domains, Computer Vision, Graphics and Image Processing, Vol. 32, pp. 
127-140. [DeHaemer &#38; Zyda 91] DeHaemer, Michael J., Jr. and Michael J. Zyda, Simplification of Objects 
Rendered by Polygonal Approxi­mations, Computers &#38; Graphics, Vol. 15, No. 2, pp. 175-184. [Ho-Le 
88] Ho-Le, K.: Finite Element Mesh Generation Methods: A Review and Classification, Computer Aided Design, 
Vol. 20, No. 1, pp. 27-38. [Holloway 91] Holloway, Richard, untitled technical presentation, University 
of North Carolina at Chapel Hill, December 1991. [Novins 92] Novins, Kevin, personal communication. [0 
Neill 66] O Neill, Barrett, E/emenrary Differential Geometiy, Academic Press, 1966, New York. [Preparata 
&#38; Shames 85] Preparata, Franco P. and Michael Ian Shames, Computational Geometry: An Introduction, 
Springer-Verlag, 1985, New York. [Schmitt et al 86] Schmitt, Francis J. M., Brian A. Barsky and Wen-Hui 
Du, An Adaptive Subdivision Method for Surface-Fitting from Sampled Data; Computer Graphics, Vol. 20, 
No. 4 (SIGGRAPH 86), pp. 179-188. [Schroeder et al 92] Schroeder, William J., Jonathan A. Zarge and William 
E. Lorensen, Decimation of Triangle Meshes, Computer Graphics, Vol. 26 (SIGGRAPH 92, these prweedings). 
[Turk 91] Turk, Greg, Generating Textures on Arbitrary Surfaces Using Reaction-Diffusion, Computer Graphics, 
Vol. 25, No. 4 (SIGGRAPH 91 ) pp. 289-298. [Williams 83] Williams, Lance, Pyramidal Parametric, Com­puter 
Graphics, Vol. 17, No. 3 (SIGGRAPH 83), pp. 1-10. [Zimmerman 87] Zimmerman, Stephen A., Applying Frequency 
Domain Constructs to a Broad Spectrum of Visual Simulation Problems, Evans &#38; Sutherland Technical 
Document, Presented at the IMAGE IV Conference, Phoenix, Arizona, 23-26 June, 1987. 
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134010</article_id>
		<sort_key>65</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>7</seq_no>
		<title><![CDATA[Decimation of triangle meshes]]></title>
		<page_from>65</page_from>
		<page_to>70</page_to>
		<doi_number>10.1145/133994.134010</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134010</url>
		<keywords>
			<kw><![CDATA[computer graphics]]></kw>
			<kw><![CDATA[geometric modeling]]></kw>
			<kw><![CDATA[medical imaging]]></kw>
			<kw><![CDATA[terrain modeling]]></kw>
			<kw><![CDATA[volume modeling]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Curve, surface, solid, and object representations</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Geometric algorithms, languages, and systems</descriptor>
				<type>S</type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003752.10010061</concept_id>
				<concept_desc>CCS->Theory of computation->Randomness, geometry and discrete structures</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010399</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Parametric curve and surface models</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010401</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Volumetric models</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>P299957</person_id>
				<author_profile_id><![CDATA[81100252380]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[William]]></first_name>
				<middle_name><![CDATA[J.]]></middle_name>
				<last_name><![CDATA[Schroeder]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[General Electric Company Corporate Research and Development, ConSolve, Inc]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P147539</person_id>
				<author_profile_id><![CDATA[81100117545]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[Jonathan]]></first_name>
				<middle_name><![CDATA[A.]]></middle_name>
				<last_name><![CDATA[Zarge]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[General Electric Company Corporate Research and Development, ConSolve, Inc]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P299459</person_id>
				<author_profile_id><![CDATA[81100054474]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>3</seq_no>
				<first_name><![CDATA[William]]></first_name>
				<middle_name><![CDATA[E.]]></middle_name>
				<last_name><![CDATA[Lorensen]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[General Electric Company Corporate Research and Development, ConSolve, Inc]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_obj_id>907204</ref_obj_id>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Baumgart, B. O., "Geometric Modeling for Computer Vision," PhD Dissertation, Stanford University, August 1974.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_obj_id>55285</ref_obj_id>
				<ref_obj_pid>55279</ref_obj_pid>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Bloomenthal, J., "Polygonalization of Implicit Surfaces," Computer/g'ded Geometric De~'gn, Vol. 5, pp. 341-355,1988.]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Clinc, H. E., Lorensen, W. E., Ludke, S., Crawford, C. R., and Teeter, B. C., "Two Algorithms for the Three Dimensional Construction of Tomograms," Medical Physics, Vol. 15, No. 3, pp. 320-327, June 1988.]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[DeHaemer, M. j., Jr. and Zyda, M. J., "Simplification of Objects Rendered by Polygonal Approximations," Computers &amp; Graphics, Vol. 15, No. 2, pp 175-184, 1992.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_obj_id>11302</ref_obj_id>
				<ref_obj_pid>11295</ref_obj_pid>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[Dunham, J. O., "Optimum Uniform Pi~ Linear Approximation of Planar Curves," IEEE Trans. on Pattern Analysis and Machine Intdligence, Vol. PAMI--8, No. 1, pp. 67-75, January 1986.]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[Finnigan, R, Hathaway, A., and Lorensen, W., "Merging CAT and FEM," Mechanical Engineering, Vol. 112, No. 7, pp. 32-38, July 1990.]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_obj_id>807444</ref_obj_id>
				<ref_obj_pid>965103</ref_obj_pid>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Fowler, R. J. and Little, J. J., 'Automatic Extraction of Irregular Network Digital Terrain Models," Computer Gn~ics, Vol. 13, No. 2, pp. 199-207, August 1979.]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_obj_id>139912</ref_obj_id>
				<ref_obj_pid>139834</ref_obj_pid>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[Ihm, I. and Naylor, B., "Piecewise Linear Approximations of Digitized Space Curves with Applications," in Scientific Visualization of Physical Phenomena, pp. 545-569, Springer-Verlag, June 1991.]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Kalvin, A. D., Cutting, C. B., Haddad, B., and Noz, M. E., "Constructing Topologically Connected Surfaces for the Comprehensive Analysis of 3D Medical Structures," SPIE Image Processing, Vol. 1445, pp. 247-258, 1991.]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_obj_id>37422</ref_obj_id>
				<ref_obj_pid>37402</ref_obj_pid>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[Lorensen, W. E. and Cline, H. E., "Marching Cubes: A High Resolution 3D Surface Construction Algorithm," Computer Graphics, Vol. 21, No. 3, pp. 163--169, July 1987.]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122742</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[Miller, J. V., Breen, D. E., Lorensen, W. E., O'Bara, R. M., and Wozny, M. J., "Geometrically Deformed Models: A Method for Extracting Closed Geometric Models from Volume Data," Computer Graphics, Vol. 25, No. 3, July 1991.]]></ref_text>
				<ref_id>11</ref_id>
			</ref>
			<ref>
				<ref_obj_id>4333</ref_obj_id>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[Preparata, E P. and Shamos, M. I., Computational Geometry, Springer-Verlag, 1985.]]></ref_text>
				<ref_id>12</ref_id>
			</ref>
			<ref>
				<ref_obj_id>15906</ref_obj_id>
				<ref_obj_pid>15886</ref_obj_pid>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[Schmitt, E J., Barsky, B. A., and Du, W., 'An Adaptive Subdivision Method for Surface-Fitting from Sampled Data," Computer Graphics, Vol. 20, No. 4, pp. 179-188, August 1986.]]></ref_text>
				<ref_id>13</ref_id>
			</ref>
			<ref>
				<ref_obj_id>145754</ref_obj_id>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[Schroeder, W. J., "Geometric Triangulations: With Application to Fully Automatic 3D Mesh Generation," PhD Dissertation, Rensselaer Polytechnic Institute, May 1991.]]></ref_text>
				<ref_id>14</ref_id>
			</ref>
			<ref>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[Terzopoulos, D. and Fleischer, K., "Deformable Models," The Wtsual Computer, Vol. 4, pp. 306-311, 1988.]]></ref_text>
				<ref_id>15</ref_id>
			</ref>
			<ref>
				<ref_obj_id>134008</ref_obj_id>
				<ref_obj_pid>142920</ref_obj_pid>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[Turk, G., "Re-Tiling of Polygonal Surfaces," Computer Graphics, Vol. 26, No. 3, July 1992.]]></ref_text>
				<ref_id>16</ref_id>
			</ref>
			<ref>
				<ref_seq_no>17</ref_seq_no>
				<ref_text><![CDATA[Weiler, K., "Edge-Based Data Structures for Solid Modeling in Curved-Surface Environments," IEEE Computer Graphics and Applications, Vol. 5, No. I, pp. 21--40, January 1985.]]></ref_text>
				<ref_id>17</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 Comwter GraDhics, 26, 2, Julv 1992 Decimation of lkiangle Meshes William J. Schmede~ .kmathan A. Zargw~WWam 
E. Lonmsen General Electric Company Corporate Research and Development ConSolve, Inc ABSTRACT Computer 
graphics applications routinely generate geometric models consisting of large numbers of triangles. We 
present an algorithm that significantly reduces the number of triangles required to model a physical 
or abatract object. The algorithm makes multiple passea over an existing triangle mesh, using local geometry 
and topology to remove vertices that pas a distance or angle criterion. The holes left by the vertex 
removal are patched using a local triangulation proeeas. The decimation algorithm has been implemented 
in a general scientific visualization system as a general network filter. Examples from volume modeling 
and terrain modeling illustrate the results of the decimation algorithm. Keywords: computer graphics, 
geometric modeling, medical imaging, terrain modeling, volume modeling 1 INTRODUCTION The polygon remains 
a popular graphica primitive for computer graphica application. Besides having a simple representation, 
computer rendering of polygons is widely supported by commercial graphics hardware and sotlware. However, 
because the polygon is linear, often thousands or millions of primitives are required to capture the 
details of complex geomet~. Models of this size are generally not practical since rendering speeds and 
memory requirements are proportional to the number of polygons. Consequently applications that generate 
large polygonal meshes often use domain-speeific knowledge to reduce model size. There remain algorithms, 
howwwer, where domain-specific reduction teehniquea are not generally available or appropriate. One algorithm 
that generates many polygons is Mamhing Cuber [10]. Mamhing Cubes is a brute force surfa~ construction 
algorithm that extraets isodensity surfaces from volume data, producing from one to five triangles within 
voxels that contain the surface. AIthough originally developed for medical applications, Mamhing Cuber 
has found more frequent use in scientific visualization where the size of the volume data sets are much 
smaller than those found in medieal applications. A large Author addrew GECRD,KW/C211, 1 River Road, 
Schenectady, NY 12345 schroeder@crd .ge.com computational fluid dynamics volume could have a finite difference 
grid size of order 100 by ltXI by 100, while a typical medical computed tomography or magnetic resonamx 
scanner produeea over 100slices at a resolution of 256 by 256 or 512 by 512 pixels each. Industrial computed 
tomography, used for inspection and analysis, has even greater resolution, varying from 512 by 512 to 
1024 by 1024 pixels. For thexe sampled data sets, isoaurface extraction using Mamhing Cubes can produce 
from 500k to 2,000k triangles. Ewn today s graphics workstations have trouble storing and rendering models 
of this size. Other sampling devices can produce large polygonal model.% range cameras, digital elevation 
data, and satellite data. The sampling resolution of these deviees is also improving, resulting in model 
sizes that rival those obtained from medical scanners. This paper describes an application independent 
algorithm that uses local operations on geometry and topology to reduu the number of triangles in a triangle 
mesh. Although our implementation is for the triangle mesh, it can be directly applied to the more general 
polygon mesh. After describing other work related to model creation from sampled data, we describe the 
triangle decimation process and its implementation. Results from two different geometric modeling applications 
illustrate the strengths of the algorithm. 2 RELATED WORK The decimation algorithm applies to discrete 
modeling the synthesis, analysis and manipulation of objects contained within sampled data. Approaches 
to synthesizing these objects can be either adaptive or filter-based. Adaptive techniques produce more 
primitives in selected areas. For example, Fowler [71creates triangulated irregular networks (TIN) of 
terrain by finding ridges and channels, performing a Delaunay triangulation of these features and then 
adaptively adding points from the dense elevation grids. In implicit modeling, Bloomenthal [2] produces 
isosurfaees from implicit models by adaptively evaluating the implicit equations as long as the surface 
intersects his sampling cubes. In finite element mesh generation, the CATFEM system [6] uses oetree techniques 
to create 3D finite elements directly from volume samples, generating more elements in areas of fine 
detail. Deformable mcxlels [1:, 15] use an initial surface model that is repeatedly deformed to fit the 
implicit surface that exists within a sampled volume. The original model resolution controls the number 
of primitives in the final, deformed model. Fitting techniques approximate a surface with one or more 
primitives using error criteria to measure the goodness of fit. Schmitt [13] starts with rough hi-cubic 
patch approximations to sample data, then subdivides those patches that are not sufficiently close to 
the underlying samples. Recent work by DeHaemer [4] extends this .4CM-()-K9791-479-U9N07W065 S(I.50 
SIGGRAPH 92 Chicaao, Julv 26-31, 1992 work to reduce the number of polygons in a polygonal mesh. lhrk 
[16]uses are-triangulation technique that introduces new points onto a polygonal mesh, and then discards 
the old points to create a new mesh. Filter-based techniqu= start with a large number of samplea or primitiva 
and remove or replace samples to reduce model size. Two naive approachca are sub-sampling and averaging. 
Sub-sampling uses every n hpoint in the data to reduce the size of the data, while averaging resamples 
the data using neighboring points. The bulk of published work on reducing the number ofpnmitivea for 
modeling addresses the two-dimensional approximation of curves with line segments. Dunham [5] compares 
nine techniques for the piecewise linear approximation of 2D planar curves. These algorithms seek approximations 
that satisfy a uniform error criterion. The points produced by each algorithm all lie on the digitized 
curves. Recent wrk [8] uses dynamic programming to approximate 3D space curves. Kalvin et. al. [9] deseribe 
a technique called Adapfive Face Metgr ngthat removes co-planar polygons. They report substantial polygon 
reduction for binary voxel data sets.  3 THE DECIMATION ALGORITHM The fundamental goal of the decimation 
algorithm is to reduce the total number of triangles in a triangle mesh, while preserving as accurately 
as possible important featurea. Here we define a triangle mesh to be a collection of triangles in three-space, 
joined along common edges and vertices. ~ically the topology of the mesh is 2-manifold [17J but non-manifold 
forms are possible and must be treated by the algorithm. Any reduced mesh must meet two requirements 
[14]. First, the reduced mesh must preserve the original topology of the mesh, including non-manifold 
forms. Second, the decimated mesh must form a good geometric approximation to the original mesh. Optionally, 
the vertiees of the decimated mssh can be a subset of the original vertices. Hence new vertices are never 
created, instead relatively unimportant vertices (and associated triangles) are removed from the mesh, 
forming new approximations to the original. This optional requirement, although not essential to forming 
an effective approximation to the original mesh, isuseful in practice because it provides a way to use 
the auxiliary vertex data such as normals or texture coordinates. 3.1 OVERVIEW The decimation algorithm 
is simple. Multiple passes are made over all vertices in the mesh. During a pass, each vertex is a candidate 
for removal and, if it meets the specified decimation criteria the vertex and all triangles that use 
the vertex are deleted. The resulting hole in the mesh is patched by forming a local triangulation. The 
vwtex removal process repeats, with psible adjustment of the decimation criteria, until some termination 
condition is met. Usually the termination criterion is specified as a percent reduction of the original 
mesh (or equivalent), or as some maximum decimation value. The three steps of the algorithm are 1. characterize 
the Icxxdvertex geometry and topology, 2 evaluate the decimation criteria, and 3. triangulate the resulting 
hole.  3.2 CHARACTERIZING LOCAL GEOMETRY / TOPOLOGY The fimt step of the decimation algorithm characterizes 
the local geometV and topology for a given vertex. The outcome of this process determines whether the 
vertex is a potential candidate for deletion, and if it is, which criteria to use. 66 Simple Complex 
Boundary Int&#38;ior Comer Edge Figure 1. Vertex classifications.  V2zNep a Figure 2 Distance to plane. 
Figure 3. Distance to edge. Each vertex may be assigned one of five possible cksificatimw simple, complex, 
boundary, interior edge, or comer vertex. Examples of eaeh type are shown in F@ure 1. A simple wrtex 
is surnmnded by a complete cycle of tnangls, and each edge that uses the vertex is used by exactly tw 
triangles. If the edge is not used by two triangles, or if the vertex is used by a triangle not in the 
eyele of triangles, then the vertex is complex T&#38;se are non-manifold cases. A vertex that is on the 
boundary of a mesh, i.e., within a semi-cycle of triangles, is a boundary vertex. A simple vertex can 
be further classified as an interior edge or comer vertex. These chmsifications are based on the local 
mesh geometry. If the dihedral angle between tvm adjacent triangles is greater than a spedied @ture un~e, 
then a @rum ed~ exists. When a vertex is used by two feature edges, the vertex is an interior edge vertex. 
If one or three or more feature edges use the W-the wxtex is classified a comer vertex. Complex wwticea 
are not deleted t%om the mesh. All other vertices become candidatm for deletion. 3.3 EVALUATING THE DECIMATION 
CRITERIA The characterization step produces an ordered loop of vertices and triangles that use the candidate 
vertex. The evaluation step determines whether the triangk% forming the loop can be deleted and replaced 
by another triangulation exclusive of the original vertex Although the fundamental decimation criterion 
we use is based on wrtex distance to plane or vertex distan~ to edge, others can be applied. Simple vertices 
use the distance to plane criterion (Figure 2). An average plane is constructed using the triangle normals, 
;i , centers, % , and areas Aj,  (1) where the summation is over all triangles in the loop. The distanm 
of the vertex 7 to the plane is then d = Iii @-Y)l . If the vertex is within the specified distance to 
the average plane it may be deleted. Othemvise it is retained. Boundary and interior edge vertices use 
the distance to edge criterion (Figure 3). In this case, the algorithm determines the distance to the 
line defined by the two vertices creating the Computer Graphics, 26, 2, July 1992 boundary or feature 
edge. If the distance to the line is less than d, the vertex can be deleted. It is not always desirable 
to retain feature edges For example, meshes may contain areas of relatively small triangles with large 
feature angles, mntnbuting relatively little to the gEometric approximation. Or, the small triangles 
may be the result of noise in the original mesh. In these situations, comer vertices, which are usually 
not deleted, and interior edge vertices, which are evaluated using the distance to edge criterion, may 
be evaluated using the distance to plane criterion. We call this edge preservation, a user specifiable 
parameter. If a vertex can be eliminated, the loop created by removing the triangles using the vertex 
must be triangulated. For interior edge vertices, the original loop must be split into two halves, with 
the split line connecting the vertices forming the feature edge. If the loop can be split in this way, 
i.e., so that resulting two loops do not overlap, then the loop is split and each piece is triangulated 
separately. 3.4 TRIANGULATION Deleting a vertex and its associated triangles creates one (simple or 
boundary vertex) or two loops (interior edge vertex). Within each loop a triangulation must be created 
whose triangles are non-intersecting and non-degenerate. In addition, it is desirable to create triangles 
with good aspect ratio and that approximate the original loop as clmely as possible. In general it is 
not possible to use a two-dimensional algorithm to construct the triangulation, since the loop is usually 
non-planar. In addition, there are N important characteristics of the loop that can be used to advantage. 
First, if a loop cannot be triangulated, the vertex generating the Imp need not be removed. Second, since 
every Icwp is star-shaped [12], triangulation schemes based on recursive loop splitting are effective. 
The next section describes one such scheme. Once the triangulation is complete, the original vertex and 
its cycle of triangles are deleted. From the Euler relation [12] it follow that removal of a simple, 
comer, or interior edge vertex reduces the mesh by precisely two triangles If a boundary vertex is deleted 
then the mesh is reduced by precisely one triangle. 4 IMPLEMENTATION The decimation algorithm has been 
implemented as a filter in our object-oriented LYMB/VISAGE visualization environment. Usually we apply 
the algorithm repeatedly to eliminate vertices and triangles from a mesh until a specified reduction 
threshold is achieved. The decimation is controlled by slowly adjusting the distance and feature angle 
criterion. It is also possible to limit the total number of iterations, as well as modify other parameters 
such as the triangulation aspect ratio. We often specify an initial distance of zero to first remove 
triangles within strictly planar regions. TW major challenges were addressed to create a successful implementation 
of the decimation algorithm. First, the data structures had to be carefully crafted since the size of 
the data (i.e., millions of triangles) demands both efficient access to and storage of data. Second, 
the triangulation algorithm was designed to be simple and efficient, and to take advantage of the particular 
characteristics of the triangulation process. It should be noted that this algorithm, while expressly 
described with triangle meshes in mind, is directly applicable to polygon m~hes. Only minor modifications 
need be made in the implementation of the data structures and loop evaluation. 4.1 DATA STRU(7WRES The 
data structure must contain at least two pieces of information: the geometry, or coordinates, of each 
vertex, and ,,:,split plane split line ~ % b :.: average plane Figure 4. Spfltting.  I *I the definition 
of each triangle in terms of its three vertices. In addition, because ordered lists of triangles surrounding 
a vertex are frequently required, it is desirable to maintain a list of the triangles that use each vertex. 
Although data stmctures such as Weiler s radial edge [1~ or Baumgart s winged+dge data structure [1] 
can represent this information, our implementation uses a space+ fficient vertex-triangle hierarchical 
ring structure. This data structure contains hierarchical pointers from the triangles down to the vertices, 
and pointers from the vertices back up to the triangles using the vertex. Taken together these potnters 
form a ring relationship. Our implementation uses three lis&#38; a list of vertex coordinates, a list 
of triangle definitions, and another list of lists of triangles using each vertex. Edge definitions are 
not explicit, instead edges are implicitly defined as ordered vertex pairs in the triangle definition. 
 4.2 TRIANGUtATION Although other triangulation schemes can be used, w chose a recursive loop splitting 
prcrcedure. Each loop to be triangulated is divided into tw halves. The division is along a line (i.e., 
the split line) defined from two non-neighboring wrtices in the loop. Each new loop is divided again, 
until only three vertices remain in each loop. A loop of three vertices forms a triangle, that maybe 
added to the mesh, and terminates the recursion process. Because the loop is non-planar and star-shaped, 
the loop split is evaluated using a split plane. The split plane, as shown in Figure 4, is the plane 
orthogonal to the average plane (Eqn. 1) that contains the split line. In order to determine whether 
the split forms two non-overlapping loops, the split plane is used for a half-space comparison. That 
is, if every point in a candidate loop is on one side of the split plane, then the tuw Icmp do not overlap 
and the split plane is aweptable. Of course, it is easy to create examples where this algorithm will 
fail to produce a successful split. In such cases we simply indicate a failure of the triangulation process, 
and do not remove the vertex or surrounding triangle from the mesh. TWically, however, each loop maybe 
split in more than one way. In this case, the best splitting plane must be selected. Although many possible 
measures are available, we have been suuxs.sful using a criterion based on aspect ratio. The aspect ratio 
is defined as the minimum distance of the loop vertices to the split plane, divided by the length of 
the split line. The best splitting plane is the one that yields the maximum aspect ratio. Constraining 
this ratio to be greater than a specified value, e.g., 0.1, produces ameptable meshes. Certain special 
cases may occur during the triangulation prmxss. Repeated decimation may produce a simple closed surface 
such as a tetrahedron. Eliminating a vertex in this case would modify the topology of the mesh. Another 
special case occurs when tunnels or topological holes are present in the mesh. The tunnel may eventually 
be reduced to a triangle in cross section. Eliminating a vertex from the tunnel boundary then eliminates 
the tunnel and creates a non-manifold situation. These cases are treated during the triangulation process. 
As new triangles are created, checks are made to insure that duplicate triangles and triangle edges are 
not created. This preserves the topology of the original mesh, since new connections to other parts of 
the mesh cannot occur. 67 SIGGRAPH 92 Chicago, July 26-31, 1992  5 RESULTS TW different applications 
illustrate the triangle decimation algorithm. Although eaeh application uses a different scheme to create 
an initial mesh, all results were produced with the same decimation algorithm. 5.1 VOLUME MODELING The 
first application applies the decimation algorithm to ismurfaces created from medieal and industrial 
computed tomography scanners. Maxhing Cuber was run on a256by2S6 pixel by 93 slice study. Over 560,0Ml 
triangles were required to model the bone surface. Earlier work [3] reported a triangle reduction strategy 
that used averaging to reduee the number of triangles on this same data set. Unfortunately, averaging 
applies uniformly to the entire data set, blurring high frequency features. Figure 5 shows the resulting 
bone isosurfaces for O%, 75Y0,and 90% decimation, using a decimation threshold of US the voxel dimension. 
Figure 6 shows decimation results for an industrial CT data set eompriaing3(Ml slices, 512 by 51Z the 
largest we have processed to date. The isosurfaee created from the original blade data contains 1.7 million 
triangles. In fact, w could not render the original mdel because w exceeded the swap space on our graphica 
hardware. Even tier decimating 90% of the triangles, the serial number on the blade dovetail is still 
evident. 5.2 TERRAIN MODELING We applied the decimation algorithm to two digital elevation data sets 
Honolulu, Hawaii and the Mariner Valley on Mars. In both examples we generated an initial mesh by creating 
two triangles for each uniform quadrilateral element in the sampled data. The Honolulu example illustrates 
the polygon savings for models that have huge flat areas. First w applied a decimation threshold of zero, 
eliminating over 30% of the co-planar triangles. Increasing the threshold removed 9CW0 of the triangles. 
Figure 7 shows the resulting M %o and 90% triangulations. Notice the transitions from large flat areas 
to fine detail around the shore line. The Mars example is an appropriate test because we had aaess to 
sub-sampled resolution data that could be compared with the decimated models. The data represents the 
western end of the Mariner Valley and is about 1000km by 500km on a side. Figure 8 compares the shaded 
and wireframe modets obtained via sub-sampling and decimation. The original model was 480 by288 samples 
The sub-sampled data was 240 by 144. After a 77% reduction, the decimated model contains fewer triangles, 
yet shows more fine detail around the ridges. 6 CONCLUSIONS The decimation algorithm significantly reduees 
the number of triangles required to model an object to a given level of detail. Using local topological 
and geometric operations, the algorithm makes multiple passes over a triangle mesh, removing vertices 
and triangulating the resulting holes until user-specified decimation criteria are satisfied. The three 
step algorithm affords the opportunity to experiment with other data structures, surface appratimation 
metrics, and triangulation schemes. For example, the tit step of the decimation could be modified to 
allow the user to tag some wrtices as not-removable. Also, other non-geometric vertex data such as scalar 
quantities could be used to control the decimation. We have successfully applied the algorithm to tw 
visualization areas: volume and terrain modeling. We expect that some surface-based analysis techniques, 
such as boundary element methods or radiosity, will also benefit from the model reductions w have achieved. 
Here, the computational reduction will be even more significant, since the complexity of analysis is 
often more than linear with the number of primitives. 7 ACKNOWLEDGEMENTS Joe Ross, GE Aircmft Engines, 
supplied the turbine blade data. Lee Moore, Webster Research Center, Xerox Corporation, provided the 
digital elevation data to the UseNet community through anonymous ftp access. The Mars dat% also obtained 
from Xeroxi is courtesy of the NASA Goddard s National Space Science Data Center (NSSDC), the US Geological 
Survey Astrogecdogy Division, Ftagstaff, Arizona, and the NASA Ames Aerospaee Human Factors Division 
Visuali@ion for Planetary Exploration project. REFERENCES [1] Baumgart, B. G., Geometric Modeling for 
Computer Vision, PhD Dissertation, Stanford University, August 1974. [2] Bbomenthal, J., Polygonalization 
of Implicit Surfaces, ComputerAided Geomettic Design, Vol. 5, pp. 341-355,1988. [3] Cline, H. E., I.mrensen, 
W. E., Ludke, S., Crawford, C. R., and Tater, B. C., TW Algorithms for the Three Dimensional CknNruction 
of Tomograms; MediculPhysics, Vol. 15, No. 3, pp. 320-327, June 1988. [4] DeHaemer, M. J., Jr. and Zyd% 
M. J., Simplification of Objeets Rendered by Polygonal Approximations, Computexs &#38; Gm@ks, Vol. 15, 
No. 2, pp 175-184, 1992 [5] Dunham, J. G., Optimum Uniform Pieeewise Linear Approximation of Planar Curves, 
IEEE Tm. on Pzttem Atudysrk and MacAine Intellijyme, Vol. PAMI-8, No. 1, pp. 67-75, January 1986. [6] 
Finnigan, F?,Hathaway, A., and Lorcnsen, W., Merging CAT and FEM~Mechaniea/Engineering, Vol. 112,No, 
7,pp. 32-38, July 1990. Fowler, R. J. and Little, J. J., Automatic Extraction of m Irregular Network 
Digital Terrain Models, Computer Gmphics, Vol. 13, No. ~ pp. 199-207, August 1979. [8] Ihm, I. and Naylor, 
B., Piemvise IinearApproximations of Digitized Space Curves with Applications, in Scientific Viiualizatwn 
of H@@/ I%enomena, pp. 545-569, Sm%m?er-Verlae. June 1991. [9] Kalvi;, A. D., fitting, C; B., Haddad, 
B., and Noz, M. E., Constructing Topologieally Conneeted Surfaces for the Comprehensive Analysis of 3D 
Medical Structures, SPIE Image Ptoee.win~ vol. 1445, pp. 247-258, 1991. [10] Lorenacn, W. E. and Cline, 
H. E., MarchingCu&#38; A High Resolution 3Q Surface Construction Algorithm, Computer Gruphks, Vol. 21, 
No. 3, pp. 163-169, July 1987. [11] Miller, J. V., Breem, D. E., Lorensen, W. E., OBara, R. M., and Wozny, 
M. J., Geometrically Deformed Models: A Method for Extracting Closed Geometric Models from Volume Data 
Computer Gmphics, Vol. 25, No. 3, July 1991. [12] Preparat&#38; 1?1?and Shames, M. I., Computational 
Geomet~, Spnnger-Verlag, 1985. [13] Schmitt, E J., Bamky, B. A., and Du, W., An Adaptive Subdivision 
Method for Surface-Fitting from Sampled Data, Computer Gmphics, Vol. 20, No. 4, pp. 179-188, August 1986. 
[14] Schroeder, W. J., Geometrie Tkiangulatiomx Whh Application to Fully Automatic 3D Mesh Generation, 
PhD Dissertation, Rensselaer Polytechnic Institute, May 1991. [15] Terzopoulcm, D, and Fleiseher, K, 
Deformable Models, The V.&#38;d Computer, Vol. 4, pp. 306-311, 1988. [16] llrrlq G., Re-Tiling of Polygonal 
Surfaces, Computer Gmphics, Vol. 26, No. 3, July 1992 [171 Weiler, K., Edge-Based Data Structures for 
solid Modeling in Curved-Surface Environments, IEEE ComputerGm&#38;icsandAp#ictiiom,Voi. 5, No. 1, pp. 
21-40, Januay 1985. Computer Graphics, 26, 2, July 1992 SIGGRAPH 92 Chicago, July 26-31, 1992   
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134011</article_id>
		<sort_key>71</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>8</seq_no>
		<title><![CDATA[Surface reconstruction from unorganized points]]></title>
		<page_from>71</page_from>
		<page_to>78</page_to>
		<doi_number>10.1145/133994.134011</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134011</url>
		<keywords>
			<kw><![CDATA[geometric modeling]]></kw>
			<kw><![CDATA[range data analysis]]></kw>
			<kw><![CDATA[surface fitting]]></kw>
			<kw><![CDATA[three-dimensional shape recovery]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Curve, surface, solid, and object representations</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Geometric algorithms, languages, and systems</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.4.8</cat_node>
				<descriptor>Range data</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.4.5</cat_node>
				<descriptor></descriptor>
				<type></type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010147.10010178.10010224.10010225.10010227</concept_id>
				<concept_desc>CCS->Computing methodologies->Artificial intelligence->Computer vision->Computer vision tasks->Scene understanding</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010178.10010224.10010245.10010254</concept_id>
				<concept_desc>CCS->Computing methodologies->Artificial intelligence->Computer vision->Computer vision problems->Reconstruction</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003752.10010061</concept_id>
				<concept_desc>CCS->Theory of computation->Randomness, geometry and discrete structures</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010178.10010224.10010245</concept_id>
				<concept_desc>CCS->Computing methodologies->Artificial intelligence->Computer vision->Computer vision problems</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010401</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Volumetric models</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010399</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Parametric curve and surface models</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
			<gt>Theory</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>P112851</person_id>
				<author_profile_id><![CDATA[81100397561]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Hugues]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Hoppe]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[University of Washington, Seattle, WA]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>PP39045514</person_id>
				<author_profile_id><![CDATA[81100493833]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[Tony]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[DeRose]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[University of Washington, Seattle, WA]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>PP17009957</person_id>
				<author_profile_id><![CDATA[81100301736]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>3</seq_no>
				<first_name><![CDATA[Tom]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Duchamp]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[University of Washington, Seattle, WA]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>PP39075751</person_id>
				<author_profile_id><![CDATA[81452609404]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>4</seq_no>
				<first_name><![CDATA[John]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[McDonald]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[University of Washington, Seattle, WA]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P298076</person_id>
				<author_profile_id><![CDATA[81100357122]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>5</seq_no>
				<first_name><![CDATA[Werner]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Stuetzle]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[University of Washington, Seattle, WA]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[E.L. Allgower and P. H. Schmidt. An algorithm for piecewise linear approximation of an implicitly defined manifold. SlAM Journal of Numerical Analysis, 22:322-346, April 1985.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_obj_id>358850</ref_obj_id>
				<ref_obj_pid>358841</ref_obj_pid>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[J.L. Bentley. Multidimensional divide and conquer. Comm. ACM, 23(4):214--229, 1980.]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_obj_id>67193</ref_obj_id>
				<ref_obj_pid>67188</ref_obj_pid>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Y. Breseler, J. A. Fessler, and A. Macovski. A Bayesian approach to reconstruction from incomplete projections of a multiple object 3D domain. IEEE Trans. Pat. Anal. Mach. InteU., 11 (8):840-858, August 1989.]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[James F. Brinkley. Knowledge-driven ultrasonic threedimensional organ modeling. IEEE Trans. Pat. Anal. Mach. lntell., 7(4):431-441, July 1985.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_obj_id>88575</ref_obj_id>
				<ref_obj_pid>88560</ref_obj_pid>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[David P. Dobkin, Silvio V. E Levy, William P. Thurston, and Allan R. Wilks. Contour tracing by piecewise linear approximations. ACM TOG, 9(4):389-423, October 1990.]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[John A. Eisenman. Graphical editing of composite bezier curves. Master's thesis, Department of Electrical Engineering and Computer Science, M.I.T., 1988.]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[T.A. Foley. interpolation to scattered data on a spherical domain. In M. Cox and J. Mason, editors, Algorithms for Approximation l}, pages 303-310. Chapman and Hall, London, 1990.]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[Michael R. Garey and David S. Johnson. Computers and Intractability. W. H. Freeman and Company, 1979.]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[T. Hastie and W. Stuetzle. Principal curves. JASA, 84:502- 516, 1989.]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_obj_id>550113</ref_obj_id>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[Averill M. Law and W. David Kelton. Simulation Modeling and Analysis. McGraw-Hill, Inc., second edition, 1991.]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
			<ref>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[Marshal L. Merriam. Experience with the cyberware 3D digitizer. In NCGA Proceedings, pages 125-133, March 1992.]]></ref_text>
				<ref_id>11</ref_id>
			</ref>
			<ref>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[David Meyers, Shelly Skinner, and Kenneth Sloan. Surfaces from contours: The correspondence and branching problems. In Proceedings of Graphics Interface '91, pages 246-254, June 1991.]]></ref_text>
				<ref_id>12</ref_id>
			</ref>
			<ref>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[Doug Moore and Joe Warren. Approximation of dense scattered data using algebraic surfaces. TR 90-135, Rice University, October 1990.]]></ref_text>
				<ref_id>13</ref_id>
			</ref>
			<ref>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[Doug Moore and Joe Warren. Adaptive mesh generation ii: Packing solids. TR 90-139, Rice University, March 1991.]]></ref_text>
				<ref_id>14</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122743</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[Shigeru Muraki. Volumetric shape description of range data using "blobby model". Computer Graphics (SIGGRAPH '91 Proceedings), 25(4):227-235, July 1991.]]></ref_text>
				<ref_id>15</ref_id>
			</ref>
			<ref>
				<ref_obj_id>617657</ref_obj_id>
				<ref_obj_pid>616017</ref_obj_pid>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[Gregory M. Nielson, Thomas A. Foley, Bernd Hamann, and David Lane. Visualizing and modeling scattered multivariate data. IEEECG&amp;A, 11(3):47-55, May 1991.]]></ref_text>
				<ref_id>16</ref_id>
			</ref>
			<ref>
				<ref_seq_no>17</ref_seq_no>
				<ref_text><![CDATA[Barrett O'Neill. Elementary Differential Geometry. Academic Press, Orlando, Florida, 1966.]]></ref_text>
				<ref_id>17</ref_id>
			</ref>
			<ref>
				<ref_obj_id>37420</ref_obj_id>
				<ref_obj_pid>37402</ref_obj_pid>
				<ref_seq_no>18</ref_seq_no>
				<ref_text><![CDATA[Vaughan Pratt. Direct least-squares fitting of algebraic surfaces. Computer Graphics (SIGGRAPH '87 Proceedings), 21(4): 145-152, July 1987.]]></ref_text>
				<ref_id>18</ref_id>
			</ref>
			<ref>
				<ref_obj_id>617702</ref_obj_id>
				<ref_obj_pid>616020</ref_obj_pid>
				<ref_seq_no>19</ref_seq_no>
				<ref_text><![CDATA[Emanuel Sachs, Andrew Roberts, and David Stoops. 3-Draw: A tool for designing 3 D shapes. {EEE Computer Graphics and Applications, 11(6):18-26, November 1991.]]></ref_text>
				<ref_id>19</ref_id>
			</ref>
			<ref>
				<ref_obj_id>77587</ref_obj_id>
				<ref_seq_no>20</ref_seq_no>
				<ref_text><![CDATA[Hanan Samet. Applications of Spatial Data Structures. Addison-Wesley, 1990.]]></ref_text>
				<ref_id>20</ref_id>
			</ref>
			<ref>
				<ref_seq_no>21</ref_seq_no>
				<ref_text><![CDATA[Philip J. Schneider. Phoenix: An interactive curve design system based on the automatic fitting of hand-sketched curves. Master's thesis, Department of Computer Science, U. of Washington, 1988.]]></ref_text>
				<ref_id>21</ref_id>
			</ref>
			<ref>
				<ref_seq_no>22</ref_seq_no>
				<ref_text><![CDATA[R. B. Schudy and D. H. Ballard. Model detection of cardiac chambers in ultrasound images. Technical Report 12, Computer Science Department, University of Rochester, 1978.]]></ref_text>
				<ref_id>22</ref_id>
			</ref>
			<ref>
				<ref_seq_no>23</ref_seq_no>
				<ref_text><![CDATA[R.B. Schudy and D. H, Ballard. Towards an anatomical model of heart motion as seen in 4-d cardiac ultrasound data. In Proceedings of the 6th Conference on Computer Applications in Radiology and Computer.Aided Analysis of Radiological Images, 1979.]]></ref_text>
				<ref_id>23</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122745</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>24</ref_seq_no>
				<ref_text><![CDATA[Stan Sclaroff and Alex Pentland. Generalized implicit functions for computer graphics. Computer Graphics (SIGGRAPH '91 Proceedings), 25(4):247-250, July 1991.]]></ref_text>
				<ref_id>24</ref_id>
			</ref>
			<ref>
				<ref_seq_no>25</ref_seq_no>
				<ref_text><![CDATA[G. Taubin. Estimation of planar curves, surfaces and nonplanat space curves defined by implicit equations, with applications to edge and range image segmentation. Technical Report LEMS-66, Division of Engineering, Brown University, 1990.]]></ref_text>
				<ref_id>25</ref_id>
			</ref>
			<ref>
				<ref_obj_id>913592</ref_obj_id>
				<ref_seq_no>26</ref_seq_no>
				<ref_text><![CDATA[B. C. Vemuri. Representation and Recognition of Objects From Dense Range Maps. PhD thesis, Department of Electrical and Computer Engineering, University of Texas at Austin, 1987.]]></ref_text>
				<ref_id>26</ref_id>
			</ref>
			<ref>
				<ref_obj_id>16323</ref_obj_id>
				<ref_obj_pid>16319</ref_obj_pid>
				<ref_seq_no>27</ref_seq_no>
				<ref_text><![CDATA[B. C. Vemuri, A. Mitiche, and J. K. Aggarwal. Curvaturebased representation of objects from range data. Image and Vision Computing, 4(2): 107-114,1986.]]></ref_text>
				<ref_id>27</ref_id>
			</ref>
			<ref>
				<ref_seq_no>28</ref_seq_no>
				<ref_text><![CDATA[13. Wyvill, C. McPheeters, and B. Wyvill. Data structures for soft objects. The Visual Computer, 2(4):227-234, August 1986.]]></ref_text>
				<ref_id>28</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 z Computer Graphics, 26, 2, July 1992 Surface Reconstruction Hugues Hoppe* Tony John McDonald$ University 
Seattle, Abstract We describe and demonstrate an algorithm that takes as input an unorganized set of 
points {xl, . . . . x.} c IR3 on or near an un­known manifold M, and produces as output a simplicial 
surface that approximates M. Neither the topology, the presence of bound­aries, nor the geometry of M 
are assumed to be known in advance all are inferred automatically from the data. This problem natu ­rally 
arises in a variety of practical situations such as range scanning an object from multiple view points, 
recovery of biological shapes from two-dimensional slices, and interactive surface sketching. CR Categories 
and Subject Descriptors: 1.3.5 [Computer Graphics]: Computational Geometry and Object Modeling. Additional 
Keywords: Geomernc Modeling, Surface Fitting, Three-Dimensional Shape Recovery, Range Data Analysis. 
 Introduction Broadly speaking, the class of problems we are interested in can be stated as follows: 
Given partial information of an unknown sur­face, construct, to the extent possible, a compact representation 
of the surface. Reconstruction problems of this sort occur in diverse scientific and engineering application 
domains, including: s Surfaces from range data: The data produced by laser range scanning systems is 
typically a rectangular grid of distances from the sensor to the object being scanned. If the sensor 
and object are fixed, only objects that are point viewable can be fuily digitized. More sophisticated 
systems, such as those pro­duced by Cyberware Laboratory, Inc., are capable of digitizing cylindrical 
objec~ by rotating either the sensor or the object. However, the scanning of topologically more complex 
objects, . Depatient of Computer Science and Engineering, FR-35 t Department of Mathematics, GN-50 $Depan.mentof 
Statistics, GN-22 This work was supported in part by Beflcore, the Xerox Corporation, IBM, Hewlett-Packard, 
the Digital Equipment Corporation, the Depart­ment of Energy under grant DE-FG06-85-ER25006, the National 
Llbraty of Medicine under grant NIH L&#38;4-04174, and the National Science Founda­tion under grants 
CCR-8957323 and DMS-9 103002. Permission to copy without fee all or part O( this material is grmrted 
provided that the copies are nol mate ur distributed for direct commercial advantage, (he ACM copyright 
notice and the title of the pufrlicatmn and Its date appear. and rmtice M given that copying is by fxrmlssion 
of the Aswcta[ion for Computing Machinery. To copy otherwise. or 10 republish. requires a fee and/or 
specitic permission.  from Unorganized Points DeRose* Tom Duchampt Werner Stuetzle~ of Washington WA 
98195 including those as simple as a coffee cup with a handle (a sur­face of genus 1), or the object 
depictedirt Figure 1a (a surface of genus 3), cannot be accomplished by either of these meth­ods. To 
adequately scan these objects, multiple view points must be used. Merging the data generated from multiple 
view points to reconstruct a polyhedral surface representation is a non-trivial task [11]. Surfaces from 
corriours: In many medicai studies it is com­mon to slice biological specimens into thin layers with 
a mi­crotome. The outlines of the structures of interest are then digitized to create a stack of contours. 
The problem is to reconsmct the three-dimensional smtctures tlom the stacks of two-dimensional contours. 
Although this problem has re­ceived a good deal of attention, there remain severe limitations with current 
methods. Perhaps foremost among these is the difficulty of automatically dealing with branching structures 
[3, 12]. Itieractive surface sketching: A number of researchers, in­cluding Schneider [21] and Eisenman 
[6], have investigated the creation of curves in IFt2 by tracing the path of a stylus or mouse as the 
user sketches the desired shape. Sachs et al. [19] describe a system, called 3-Draw, that permits the 
cre­ation of free-form curves in IR3 by recording the motion of a stylus fitted with a Polhemus sensor. 
This can be extended to the design of free-form surfaces by ignoring the order in which positions are 
recorded, allowing the user to move the stylus ar­bitrarily back and forth over the surface. The problem 
is then to construct a surface representation faithful to the unordered collection of points. Reconstruction 
algorithms addressing these problems have typi­cally been crafted on a case by case basis to expioit 
partiaf smtcture in the data. For instance, algorithms solving the surface from con­tours problem make 
heavy use of the fact that data are organize-d into contours (i.e., closed polygons), and that the contours 
lie in paral­lel planes. Similarly, specialized algorithms to reconstruct surfaces from multiple view 
point range data might exploit the adjacency relationship of the data points within each view. In contras~ 
our approach is to pose a unifying general problem that does not assume any structure on the data points. 
This approach has both theoretical and practical merit. On the theoretical side, abstracting to a general 
probiem often sheds iight on the truiy criticai aspects of the problem. On the practical side, a single 
algorithm that solves the general problem can be used to solve any specific problem instance. [[~Iwz 
AcM-1)-x9791-479-l/92/M)7/(x)71 $01.50 1.1 Terminology By a surface we mean a compac~ connected, orientable 
two­dimensional manifold, possibly with boundary, embedded in lR3° (cf. O Neilf [17]). A surface without 
boundary will be called a closed surface. ff we want to emphasize that a surface possesses a non-empty 
boundary, we will call it a bordered surface. A piecewise liiear surface with triangular faces will be 
referred to as a simpli­ciai surfme. We use IIx II to denote the Euclidean length of a vector x, and 
we use d(X, Y) to denote the Hausdorff distance between the sets of points X and Y (the Hausdorff distance 
is simply the distance between the two closest points of X and Y). Letx= {x,,..., x.} be sampled data 
points on or near an unknown surface M (see Figure lb). To capture the error in most sampling processes, 
we assume that each of the points x, E X is of the form x: = yt + ei, where yi c M is a point on the 
unknown surface and ei c lR3 is an error vector. We call such a sample X 6-noisy if [Iel II s 6 for all 
i. A value for 6 can be estimated in most applications (e.g., the accuracy of the laser scanner). Features 
of M that are smalf compared to 6 will obviously not be recoverable. It is also impossible to recover 
features of M in regions where insufficient sampling has occurred. In particular, if M is a bordered 
surface, such as a sphere with a disc removed, it is impossible to distinguish holes in the sample from 
holes in the surface. To capture the intuitive notion of sampling density we need to make another definition: 
Let Y {yl ,. ... Y~} c M be a (noiseless) sample of = a surface M. The sample Y is said to be p-dense 
if any sphere with radius p and center in M contains at least one sample point in Y. A 6-noisy sample 
{xl,... , x.} C IR3 of a surface M is said to be p­dense if there exists a noiseless pdense sample{ yl, 
. . ., Y* } c M such thatx, =y, +e,, lle,ll~6, i=l, . . ..n. 1.2 Problem Statement The goal of surface 
reconstruction is to determine a surface M (see Figure 2f3 that approximates an unknown surface M (Figure 
1a), using a sample X (Ftgure lb) and information about the sampling process, for example, bounds on 
the noise magnitude 6 and the sant­pling density p. We are cturently working to develop conditions on 
the original surface M and the sample X that are sufficient to allow M to be reliably reconstructed. 
As that work is still preliminary, we are un­able to give guarantees for the afgorithm presented here. 
However, the algorithm has worked welI in practiu where the results can be compared to the original surface 
(see Section 4).  2 Related Work 2.1 Surface Reconstruction Surface reconstruction methods can be classified 
according to the way in which they represent the reconstmcted surface. Impficit reconstruction methods 
attempt to find a smooth func­ tion f : IR3 ~ lR such that {xl ,.. .,xn}is close totfte zero set Z(t). 
They differ with respect to the form of ~ and the measure of closeness, Ratt[18] and Taubin [25] minimize 
the sum of squared Hausdorff distances from the data points to the zero set of a poly­ nomial in three 
variables. Muraki [15] takes ~ to be a linear combi­ nation of three-dimensional Gaussian kemefs with 
different means and spreads. His goodness-of-fit function measures how close the values of j at the data 
poin~ are to zero, and how well the unit nor­ mals to the zero set of j match the normals estimated from 
the data. Moore and Warren [13] fit a piecewise polynomial recursively and then enforce continuity using 
a technique they callfiee form blend­ ing. 72 fn contrast to implicit reconstruction techniques, parametic 
re­construction techniques represent the reconstructed surface as a topological embedding ~(A) of a 2dimensional 
parameter domain A into IR3. Previous work has concentrated on domain spaces with simple topology, i.e. 
the plane and the sphere. Hastie and Stuet­zle [9] and Vemun [26, 27] dwcuss reconsmtction of surfaces 
by a topological embedding f(A) of a planar region A into IR3. Schudy and Ballard [2Z 23] md Brinkley 
[4] consider the reconstruction of surfaces that are slightfy deformed spheres, and thus choose A to 
be a sphere. Sclaroff and Pentland [24] describe a hybrid im­plicit/parametric method for fitting a deformed 
sphere to a set of points using deformations of a superqttadric. Compared to the techniques mentioned 
above, our method has several advantages . It requires only an unorganized collection of points on or 
near the surface. No additional information is needed (such as nor­maf information used by Muraki s method). 
 . Unlike the parametric methods mentioned abov~ it can recon­struct surfaces of arbhry topology. . 
Unlike previously suggested implicit methods, it deals with boundaries in a natural way, and it does 
not generate spurious surface components not supported by the data.  2.2 Surface Reconstruction vs 
Function Recon­struction Terms like surface fitting appear in reference to two distinct classes of problems: 
surface reconstruction and function recon­struction. The goal of surface reconstmction was stated earlier. 
The goal of function reconstruction may be stated as foflows: Given a surface h4, a set {x, E M}, and 
a set {y, E El}, determine a function ~ : M ~ Et, such that f(x, )x w. The domain surface M is most commonly 
a plane embedded in IR3, in which case the problem is a standard one considered in ap­proximation theo~. 
The case where M is a sphere has also been extensively treated (cf. [7]). Some recent work under the 
titfe sur­faces on surjaces addresses the case when M is a general curved surface such as the skin of 
an airplane [16]. Function reconstruction methods can be used for surface recon­struction in simple, 
speciaf cases, where the surface to be recon­structed is, roughly speakiig, the graph of a function over 
a known surface M. Itis important to recognize just how limited these spe­ciaf cases are for example, 
not evety surface homomorphic to a sphere is the graph of a function over the sphere. The point we want 
to make is that function recons~ction must not be misconstrued to solve the general surface reconstruction 
problem.  3 A Description of the Algorithm 3.1 Overview Our surface reconstruction algorithm consists 
of two stages. In the first stage we define a function ~ : D ~ IR, where D c IR3 is a region near the 
data, such that ~ estimates the signed geometric distance to the unknown surface M. The zero set Z(f) 
is our esti­mate for M. In the second stage we use a contouring afgorithm to approximate Z(j) by a simpliciaf 
surface. Although the unsigned distance function [~1 would be easier to estimate, zero is not a regular 
value of Ifl. Zero is, however, a regular value of j, and the implicit function theorem thus guarantees 
that our approximation Z(f) is a manifold. The key ingredient to defining the signed distance function 
is to associate an oriented plane with each of the data points. These tan­genl planes serve as local 
linear approximations to the surface. Al­though the construction of the tangent planes is relatively 
simple, the selection of their orientations so as to define a globally consis­tent orientation for the 
surface is one of the major obstacles facing the algorithm. As indicated in Figure 2b, the tangent planes 
do not directly define the surface, since their union may have a compli­cated non-manifold smscture. 
Rather, we use the tangent planes to define the signed distance function to the surface. An example of 
the simplicial surface obtained by contouring the zero set of the signed distance function is shown in 
Figure 2e. The next several sections develop in more detail the successive steps of the algorithm. 3.2 
l%rtgent Plane Estimation The first step toward defining a signed distance function is to com­pute an 
oriented tangent plane for each data point. The tangent plane Tp(x, ) associated with the data point 
xi is represented as a point o,, called the center, together with a unit normal vector n,. The signed 
distance of an arbitrary point p E IR3 to Tp(x, ) is defined to be dish(p) = (p o,) . n,. The center 
and normal for Tp(x, ) are determined by gathering together the k points of X nearest to x,; this set 
is denoted by Nbhd(x, ) and is called the k­neighborhood of x,. (We currently assume k to be a user-specified 
parameter, although in Section 5 we propose a method for determin­ing k automatically.) The center and 
unit normal are computed so that the plane {dis~ (p) = O} is the least squares best fitting plane to 
Nbhd(x, ). That is, the center o, is taken to be the centzoid of Nbhd(x, ), and the normal n, is determined 
using principal compo­nent analysis. To compute n,, the covariance matrix of Nbhd(xi ) is formed. This 
is the symmetric 3 x 3 positive semidefinite matrix Cv= ~ (y-ot)C3(Y-sh) y~Nbhd(X, ) where @ denotes 
the outer product vector operatorl. If ~! ~ ~~ ~ J: denote the eigenvaiues of CV associated with unit 
eigenvectors V:, V?, t:, respectively, we choose f~, to be either t: or O:. The selection determines 
the orientation of the tangent plane, and it must be done so that nearby planes are consistently oriented 
,  3.3 Consistent Tangent Plane Orientation Suppose two data points x,, XJ E X are geometrically close. 
Ide­ally, when the data is dense and the surface is smooth, the corre­sponding tangent planes Tp(x, ) 
= (o,, n,) and Tp(xJ) = (o,, fij) are nearly parallel, i.e. n, tij ~ +1. If the planes are consistently 
oriented, then n, n] x +1; otherwise, either n, or n] should be flipped. The difficulty in finding a 
consistent global orientation is that this condition should hold between all pairs of sufficiently close 
data points. We can model the problem as graph optimization. The graph con­tains one node N, per tangent 
plane Tp(x, ), with an edge (i, j) between N, and Nj if the tangent plane centers o, and o, are suffi­ciently 
close (we will be more precise about what we mean by suffi­ciently close shortly). The cost on edge (i, 
j ) encodes tie degree to which N, and NJ are consistently oriented and is taken to be n,. f~j. The problem 
is then to select orientations for the tangent planes so as to maximize the total cost of the graph. 
Unfortunately, this problem can be shown to be NP-complete via a reduction to MAXCXJT [8]. To efficiently 
solve tie orientation problem we must therefore resort to an approximation algorithm. Before describing 
the approximation algorithm we use, we must decide when a pair of nodes are to be connected in the graph. 
Since 1If a and b have components a , and b] respectively, then the matrix a ISIb has a,bj as its tj-th 
entry. Computer Graphics, 26,2, July 1992 the surface is assumed to consist of a single connected componen~ 
the graph should be connected. A simple connected graph for a set of points that tends to connect neighbors 
is the Euclidean Minimum Spanning Tree (EMST). However, the EMST over the tangent plane centers {01, 
. . . . on} (Figure 1c) is not sufficiently dense in edges to serve our purposes. We therefore enrich 
it by adding a number of edges to it. Specifically, we add the edge (i, j) if either o, is in the k-neighborhood 
of OJ, or o, is in the k-neighborhood of o, (where k-neighborhood is defined over {01,..., on } as it 
was for X). The resulting graph (Figure Id), called the Riemmrnian Graph, is thus constructed to be a 
connected graph that encodes geometric proximity of the tangent plane centers. A relatively simple-minded 
algorithm to orient the planes would be to arbitrarily choose an orientation for some plane, then prop­agate 
the orientation to neighboring planes in tie Riemannian Graph. In practice, we found that the order in 
which the orienta­tion is propagated is important. Figure 3b shows what may result when propagating orientation 
solely on the basis of geometric prox­imity; a correct reconsmtction is shown in Figure 3C. Intuitively, 
we would like to choose an order of propagation that favors propa­gation horn T p(x, ) to Tp(x, ) if 
the unoriented planes are nearly parallel. This can be accornp~shed by assigning to each edge (i, j) 
in the Riemannian Graph the cost 1 @ ftj 1. In addition m being non-negative, this assignment has the 
property that a cost is small if the unoriented tangent planes are nearly parallel. A favorable prop­ 
agation order can therefore be achieved by traversing the minimal spanning lree (MST) of the resulting 
graph. This order is advarrta­geous because ittends to propagate orientation stfong directions of low 
curvature in the data, thereby largely avoiding ambiguous situa­tions encountered when trying to propagate 
orientation across sharp edges (as at the tip of the cat s ears in Figure 3b). In the MST shown in Figure 
2a, the edges are colored according to their cos~ with the brightly colored edges corresponding to regions 
of high variation (where n, n] is somewhat less than 1). To assign orientation to an initial plane, the 
unit normal of the plane whose center has the hugest z coordinate is forced to point toward the +Z axis. 
Then, rooting the tree at this initial node, we traverse the tree in depth-first order, assigning each 
plane an or­ientation that is consistent with that of its parent. That is, if during traversal, the current 
plane 7 p(x, ) has been assigned the orientation fit and TP(x7 ) is the next plane to be visited, then 
n, is replaced with n, ifn, .tij < 0. This orientation algorithm haa been used in all our examples and 
has produced correct orientations in all the cases we have run. The resulting oriented tangent planes 
are represented ass haded rectan­gles in Figure 2b.  3.4 Signed Distance Function The signed distance 
f(p) from an arbitmy point p E IR3 to a known surface M is the distance between p and the closest point 
z E M, multiplied by *1, depending on which side of the surface p lies. In reali~ AI is not known, but 
we can mimic this proce­dure using the oriented tangent planes as follows. First we find the tangent 
plane Tp(x, ) whose center o, is closest to p. This tangent plane is a local linear approximation to 
M, so we take the signed distance f(p) to M to be the signed distance between p and its projection z 
onto Tp(x, ); that is, ~(p) = dis~(p) = (p o,). n, If M is known not to have boundaries, this simple 
rule works well. However, the rule must be extended to accommodate surfaces that might have boundaries. 
Recall that the set X = {XI, . ,x. ) is assumed to be a p-dense, 6-noisy sample of M. If there was no 
noise, we could deduce that a point z with d(z, X ) > p cannot SIGGRAPH 92 Chicago, July 26-31, 1992 
 be a point of M since that would violate X being p-dense. Intu­itively, the sample points do not leave 
holes of radius larger than p. ff the sample is $-noisy, the radius of the holes may increase, but by 
no more than 6. We therefore conclude that a point z cannot be a point of M if d(z, X) > p + 6. If the 
projection z of p onto the closest tangent plane haa d(z, X ) > p +6, we take f(p) to be undefined. Undefined 
vahtes are used by the contouring afgorithm of Section 3.5 to identify boundaries. Stated procedurally, 
our signed distance function is defined as: i -index of tangent plane whose center is closest to p { 
Compute z as the projection of p onto Tp(xi) } ZtCSi-((p -O, )fli)ti, if d(z,X) <p+ 6 then eke /(P) 
-(P Oi) .fli {= *lip -211} + undefined endff f(P) The simple approach outlkted above creates a zero 
set Z(f) that is piecewise linear but contains discontinuities. The discontinuities result from the implicit 
partitioning of space into regions within which a single tangent plane is used to define the signed distance 
function. ( These regions are in fact the Voronoi regions associ­ated with the centers o,.) Fortunately, 
the discontinuities do not ad­versely affect our algorithm. The contouring algorithm discussed in the 
next section will discretely sample the function f over a portion of a 3dimensionaf grid near the data 
and reconstruct a continuous piecewise linear approximation to Z(f). 3.5 Contour h-acing Contour tracing, 
the extraction of an isosurface from a scalar func­tion, is a well-studied problem [1, 5, 28]. We chose 
to implement a variation of the marching cubes algorithm (cf. [28]) that samples the function at the 
vertices of a cubical lattice and finds the contour intersections within tetrahedral decompositions of 
the cubical cells. To accurately estimate boundaries, the cube size should be set so that edges are of 
length less than p + 6. In practice we have often found it convenient to set the cube size somewhat larger 
than this value, simply to increase the speed of execution and to reduce the number of biangular facets 
generated. The algorithm only visits cubes that intersect the zero set by push­ing onto aqueueonly the 
appropriate neighboring cubes (Figure 2c). In this way, the signed distance function f is evaluated only 
at points close to the data. Figure 2d ilhts~ates the signed distance function by showing line segments 
between the query points p (at the cube vertices) and their associated projected points z. As suggested 
in Section 3.4, no intersection is reported within a cube if the signed distance function is undefined 
at any vertex of the cube, thereby giving rise to boundaries in the simplicial surface. The resulting 
simplicial surface can contain triangles with arbi­trarily poor aspect ratio (Figure 2e). We alleviate 
this problem us­ing a post-processing procedure that collapses edges in the surface using an aspect ratio 
criterion.2 The final result is shown in Fig­ure 2f. Alternatively, other contouring methods exist that 
cart guar­antee bounds on the triangle aspect ratio [14]. 2~e ~ge~ am keptina priority queue; the criterion 
to minimize is the product of the edge lengrh times the minimum inscribed radius of ita two ad­jacent 
faces. Testa are also performed LOensure that edge colfapses preserve the topological type of she surface. 
74  4 Results We have experimented with the reconstruction method on data sets obtained from several 
different sources. In all cases, any s~cture (including ordering) that might have been present in the 
point sets was discarded. Meshes : Points were randomly sampled from a number of exist­ing simplicial 
surfaces3. For instance, the mesh of Figure 3a was randomly sampled to yield 1000 unorgsmized points, 
and these in turn were used to reconstruct the surface in Figure 3c. This particular case illustrates 
the behavior of the method on a bordered surface (the cat has no base and is thus homomorp­hic to a disc). 
The reconstructed knot (original mesh from Rob Scharein) of Figure 3d is an example of a surface with 
simple topology yet complex geometrical embeddmg. Ray lkaced Points : To simulate laser range imaging 
from mul­tiple view points, CSG models were ray traced from multiple eye points. The ray tracer recorded 
the point of first intersec­tion along each ray. Eight eye points (the vertices of a large cube centered 
at the object) were used to generate the point set of Figure lb from the CSG object shown in Figure la. 
This is the point set used in Section 3 to illus~ate the steps of the algorithm (Figures 1a-2 f). Range 
Images : The bust of Speck (Figure 3e) was reconstructed from pointa taken from an actual cylindrical 
range image (gen­erated by Cyberware Laboratory, Inc.). Only 25~0 of the orig­inal points were used. 
Contours : Points from 39 planar (horizontal) slices of the ~ scan of a femur were combined together 
to obtain the surface of Figure 3f. The algorithm s parameters are shown in the next table for each of 
the examples. The execution times were obtained on a 20 MIPS workstation. The parameter p + ii and the 
marching cube cell size are both expressed as a fraction of the object s size. The parameter p + 6 is 
set to infinity for those surfaces that are known to be closed. .0 Object n k p+6 cefl size (seCo:&#38;; 
cat 1000 15 .06 1/30 19 knot 1000O 20 co 1/50 137 mechpart 4102 12 1/40 54 speck 21760 8 .; 1/80 514 
femur 18224 40 .06 1/50 2135 5 Discussion 5.1 Tangent Plane Approximation The neighborhood /Vbhd(X, 
) of a data point x, is defined to con­sist of its k nearest neighbors, where k ia currently assumul 
to be an input parameter. In the case where the data contains little or no noise, k is not a critical 
parameter since the output has been empiri­cally observed to be stable over a wide range of setrings. 
However, it would be best if k could be selected automatically. Furthermore, allowing k to adapt locally 
would make less stringent the require­ment that the data be uniformly distributed over the surface. To 
select and adapt k, the algorithm could incrementally gather points while monitoring the changing eigenvafues 
of the covariance matrix (see Section 3.2). For small values of k, data noise tends to domi­nate, the 
eigenvahses are similar, and the eigenvectora do not reveal the surface s true tangent plane. At the 
other extreme, as k becomes af)is~re~ inverse tmnsfom sampling [1O,page 469] on tri~gle am was used to 
select face indices from the mesh, and uniform sampling was used within rftefaces. large, the k-neighborhoods 
become less localized and the surface curvature tends to increase the thickness ,4: of the neighborhood. 
Another possible criterion is to compare A: to some local or global estimate of data noise. Although 
we have done some initial-exper­imentation in this direction, we have not yet fully examined these options. 
If the data is obtained born range images, there exists some knowledge of surface orientation at each 
data point. Indeed, each data point is known to be visible from a particular viewing direction, so tha~ 
unless the surface incident angle is large, the point s tangent plane orientation can be inferred from 
that viewing direction. Our method could exploit this additional information in the tangent plane orientation 
step (Section 3.3) by augmenting the Riemannisn Graph with an additional pseudo-node and n additional 
edges. 5.2 Algorithm Complexity A spatial partitioning Abstract Data Type greatly improves perfor­mance 
of many of the subproblems discussed previously. The crit­ical subproblems are (with their standard time 
complexity): . EMST graph (O(n2 )) . k-nearest neighbors to a given point (O(rs + k log n.))  c nearest 
tangent plane origin to a given point (O(n)) Hierarchical spatial partitioning schemes such as octrees 
[20] and k-D trees [2] can be used to solve these problems more effi­ ciently. However, the uniform sampling 
density assumed in our data allows simple spatial cubic partitioning to work efficiently. The axis-aligned 
bounding box of the points is partitioned by a cubi­ cal grid. Points are entered into sers comesponding 
to the cube to which they belong, and these sets are accessed through a hash table indexed by the cube 
indices. It is difficult to analyze the resulting improvements analytically, but, empirically, the time 
complexity of the above problems is effectively reduced by a factor of n, except for the k-nearest neighbors 
problem which becomes O(k). As a result of the spatial partitioning, the Riemannian Graph can be constructed 
in O(nk) time, Because the Riemannian Graph has O(n) edges (at most n + n k), the MST computation used 
in find­ing the best path on which to propagate orientation requires only O(n log n) time. Traversal 
of the MST is of course O(n). The time complexity of the contouring algorithm depends only on the number 
of cubes visited, since the evaluation of the signed distance function ~ at a point p can be done in 
constant time (the closest tartgent plane origin o, to p and the closest data point Xj to the projected 
point z can both be found in constant time with spatial partitioning).  6 Conclusions and Future Work 
 We have developed an algorithm to reconstruct a surface in three­dimensional space with or without boundary 
from a set of unorga­nized points scattered on or near the surface. The algorithm, based on the idea 
of determining the zero set of an estimated signed dis­tance function, was demonstrated on data gathered 
horn a variety of sources. It is capable of automatically infernng the topological type of the surface, 
including the presence of boundary curves. The algorithm can, in principle, be extended to reconstruct 
man­ifolds of co-dimension one in spaces of srbitr~ dimension; that is, to reconswuct d 1 dimensional 
manifolds in d dimensional space. Thus, essentially the same algorithm can be used to recon­struct curves 
in the plane or volumes in four-dimensional space. The output of our reconstruction method produced the 
correct topology in all the examples, We are mying to develop formal guar­antees on the correctness of 
the reconstruction, given constraints on Computer Graphics, 26, 2, July 1992 the sample and the original 
surface. To further improve the geomet­ric accuracy of the fi~ and to reduce the space required to store 
the reconstruction, we envision using the output of our algorithm as the starting point for a subsequent 
spline surface fitting procedure. We are currently investigating such a method based on a nonlinear least 
squares approach using triangular B4zier surfaces.  References [1] 3. L. Allgower and P. H. Schmidt. 
An algorithm for piecewise inear approximation of an implicitly defined manifold. SIAM ~ournal of Numerical 
Analysis, 22:322 346, April 1985. [2] . L. Bentley. Multidimensional divide and conquer. Comm. !CM, 
23(4):214-229, 1980. [3] K Breseler, J. A. Fessler, and A. Macovski. A Bayesiarr ap­xoach to reconstruction 
from incomplete projections of a mul­iple object 3D domain. IEEE Trans. Pat. Anal. Mach. Intell., ~1(8):840-858, 
August 1989. [4] 1lames F. Brinkley. Knowledge-driven ultnsonic three­iimensional organ modeling. IEEE 
Traiu. Pat. And. Mach. hlell., 7(4)431+41, July 1985. [5] David P. Dobkin, Silvio V. F. hwy, William 
P. Thurston, and Mlan R. Wilks. Contour tracing by piecewise linear approxi­mations. ACIU TOG, 9(4):389423, 
October 1990. [6] John A. Eisenman. Graphical editing of composite bezier curves. Master s thesis, Department 
of Elecaical Engineer­ing and Computer Science, M. I.T., 1988. [7] T.A. Foley. Interpolation to scattered 
data on a spherical do­main. In M. Cox and J. Mason, editors, AlgorMrnsfor Ap­woxinurtion II, pages 303 
3 10. Chapman and Hafl, London, 1990. [8] Michael R. Garey and David S. Johnson. Computers and In­fracfabifity. 
W. H. Freeman and Company, 1979. [9] T. Hastie and W. Stuetzle. Principaf curves. JASA, 84:502­516, 1989. 
[10] Averill M. Law and W. David Kelton. .$itnulatwn Modeling and Analysis. McGraw-Hill, Inc., second 
edition, 1991. [11] Marshal L. Merriam. Experience with the cyberware 3D dig­itizer. In NCGA Proceedings, 
pages 125-133, March 1992. [12] David Meyers, Shelly Skinner, and Kenneth Sloan. Surfaces from contours: 
The correspondence and branching problems. In Proceedings of Graphics Irsterfwe 91, pages 246-254, June 
1991. [13]I Doug Moore and Joe Warren. Approximation of dense scat­tered data using algebraic surfaces. 
TR 90-135, Rice Univer­sity, October 1990. [14:I Doug Moore and Joe Warren. Adaptive mesh generation 
ii: Packing solids. TR 90-139, Rice University, March 1991. [15] Shigeru Muraki. Volumetric shape description 
of range data using blobby model . Computer Graphics (SIGGRAPH 91 Proceedings), 25(4):227-235, July 1991. 
[16] Gregory M. Nielson, Thomas A. Foley, Bemd Hsrnann, and David Lane. Visualizing and modeling scattered 
multivariate data. IEEE CGKd, 11(3):47-55, May 1991. [17] Barrett O Neill. Elementary DljierentialGeornetry. 
Academic Press, Orlando, Florida, 1966. [18] Vaughan Pratt. Direct least-squares fitting of algebraic 
sur­faces. Computer Graphics (SIGGRAPH 87 Proceedings), 21(4):145-152, July 1987. [19] Emanuel Sachs, 
Andrew Roberts, and David Stoops. 3-Draw: A tool for designing 3D shapes. IEEE Co~uferGraphics and Applications, 
11(6): 18-26, November 1991. [20] Hanan Samet. Applica!ionr of Spalial Data Structures. Addison-Wesley, 
1990.  Computer Graphics, 26, 2, July 1992 ing cut Figure 2: Reconstruction of ray-traced CSG object 
(continued). SIGGRAPH 92 Chlcago, July 26-31, 1992 omplex Figure 3: Reconstruction examples. 
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134014</article_id>
		<sort_key>79</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>9</seq_no>
		<title><![CDATA[Smoothing polyhedra using implicit algebraic splines]]></title>
		<page_from>79</page_from>
		<page_to>88</page_to>
		<doi_number>10.1145/133994.134014</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134014</url>
		<categories>
			<primary_category>
				<cat_node>G.1.1</cat_node>
				<descriptor>Smoothing</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>F.2.2</cat_node>
				<descriptor>Geometrical problems and computations</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Geometric algorithms, languages, and systems</descriptor>
				<type>S</type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10003752.10010061</concept_id>
				<concept_desc>CCS->Theory of computation->Randomness, geometry and discrete structures</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003752.10010061.10010063</concept_id>
				<concept_desc>CCS->Theory of computation->Randomness, geometry and discrete structures->Computational geometry</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003752.10010061</concept_id>
				<concept_desc>CCS->Theory of computation->Randomness, geometry and discrete structures</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002950.10003714.10003715.10003722</concept_id>
				<concept_desc>CCS->Mathematics of computing->Mathematical analysis->Numerical analysis->Interpolation</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>P42739</person_id>
				<author_profile_id><![CDATA[81100323675]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Chandrajit]]></first_name>
				<middle_name><![CDATA[L.]]></middle_name>
				<last_name><![CDATA[Bajaj]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Department of Computer Sciences, Purdue University, West Lafayette, Indiana]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P116574</person_id>
				<author_profile_id><![CDATA[81100063327]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[Insung]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Ihm]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Department of Computer Sciences, Purdue University, West Lafayette, Indiana]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_obj_id>93805</ref_obj_id>
				<ref_obj_pid>93803</ref_obj_pid>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Afield, P.,. Scattered Data Interpolation in Three or More Variables. In T. Lyche and L. Schumaker, editors, Mathematical Methods in Computer Aided Geometric Design, pages 1-34. Academic Press, 1989.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Anupam, A., and Bajaj, C., and Royappa, A. The SHAS- TRA Distributed and Collaborative Geometric Design Environment. Computer Science Technical Report, CAPO-91-38, Purdue University, 1991.]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_obj_id>709400</ref_obj_id>
				<ref_obj_pid>646870</ref_obj_pid>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Bajaj, C. Geometric modeling with algebraic surfaces. In D. Handscomb, editor, The Mathematics of Surfaces III, pages 3--48. Oxford Univ. Press, 1988.]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[Bajaj, C. Electronic Skeletons: Modeling Skeletal Structures with Piecewise Algebraic Surfaces. In Curves and Surfaces in Computer Vision and Graphics 11, pages 230-237, Boston, MA, 1991.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_obj_id>120081</ref_obj_id>
				<ref_obj_pid>102377</ref_obj_pid>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[Bajaj, C., and Ihm, I. Algebraic surface design with Hermite interpolation. ACM Transactions on Graphics, 19(1 ):61-91, January 1992.]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_obj_id>18533</ref_obj_id>
				<ref_obj_pid>18528</ref_obj_pid>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[Beeker, E. Smoothing of Shapes Designed with Free Form Surfaces. Computer Aided Design, 18(4):224-232, 1986.]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_obj_id>801160</ref_obj_id>
				<ref_obj_pid>964967</ref_obj_pid>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Chiyokura, H., and Kimura, E Design of SoLids with Freeform Surfaces. Computer Graphics, 17(3):289-298, 1983.]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[Chui, C. Multivariate Splines. Regional Conference Series in Applied Mathematics, 1988.]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_obj_id>93817</ref_obj_id>
				<ref_obj_pid>93803</ref_obj_pid>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Dahmen, W. Smooth piecewise quadratic surfaces. In T. Lyche and L. Schumaker, editors, Mathematical Methods in Computer Aided Geometric Design, pages 181-193. Academic Press, Boston, 1989.]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[Dahmen, W. and Michelli, C. Recent Progress in Multivariate Splines. In L. Schumaker C. Chui and J. Word, editors, Approximation Theory IV, pages 27-121. Academic Press, 1983.]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
			<ref>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[deBoor, C., and Hollig, K., and Sabin, M. High Accuracy Geometric Hermite Interpolation, Computer Aided Geometric Design, 4(00):269-278, 1987.]]></ref_text>
				<ref_id>11</ref_id>
			</ref>
			<ref>
				<ref_obj_id>18691</ref_obj_id>
				<ref_obj_pid>18690</ref_obj_pid>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[Farin, G. Triangular Bemstein-B~zier patches. Computer Aided Geometric Design, 3:83-127, 1986.]]></ref_text>
				<ref_id>12</ref_id>
			</ref>
			<ref>
				<ref_obj_id>116110</ref_obj_id>
				<ref_obj_pid>116105</ref_obj_pid>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[Garrity, T., and Warren, J. Geometric continuity. Computer Aided Geometric Design, 8:51-65, 1991.]]></ref_text>
				<ref_id>13</ref_id>
			</ref>
			<ref>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[Golub, G., and Van Loan, C. Matrix Computation. The Johns Hopkins Univ. Press, Baltimore, MD, 1983.]]></ref_text>
				<ref_id>14</ref_id>
			</ref>
			<ref>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[Gregory, J., and Charrot, P. A C'l Triangular Interpolation Patch for Computer Aided Geometric Design. Computer Graphics and Image Processing, 13:80-87, 1980.]]></ref_text>
				<ref_id>15</ref_id>
			</ref>
			<ref>
				<ref_obj_id>93829</ref_obj_id>
				<ref_obj_pid>93803</ref_obj_pid>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[Hagen, H., and Pottmann, H. Curvature Continuous Triangulax Interpolants. Mathematical Methods in Computer Aided Geometric Design, pages 373-384, 1989.]]></ref_text>
				<ref_id>16</ref_id>
			</ref>
			<ref>
				<ref_obj_id>5100</ref_obj_id>
				<ref_obj_pid>5096</ref_obj_pid>
				<ref_seq_no>17</ref_seq_no>
				<ref_text><![CDATA[Herron, G. Smooth Closed Surfaces with Discrete Triangular Interpolants. Computer Aided Geometric Design, 2(4):297- 306, 1985.]]></ref_text>
				<ref_id>17</ref_id>
			</ref>
			<ref>
				<ref_seq_no>18</ref_seq_no>
				<ref_text><![CDATA[Hollig, K. Multivariate Splines. SIAM J. on Numerical Analysis, 19:1013-1031, 1982.]]></ref_text>
				<ref_id>18</ref_id>
			</ref>
			<ref>
				<ref_obj_id>144875</ref_obj_id>
				<ref_seq_no>19</ref_seq_no>
				<ref_text><![CDATA[Ihm, I.,. Surface Design with Implicit Algebraic Surfaces. PhD thesis, Purdue University, August 1991.]]></ref_text>
				<ref_id>19</ref_id>
			</ref>
			<ref>
				<ref_seq_no>20</ref_seq_no>
				<ref_text><![CDATA[Lee, E. The rational B6zier representation for conics. In G. Farin, editor, Geometric Modeling : Algorithms and New Trends, pages 3-19. SIAM, Philadelphia, 1987.]]></ref_text>
				<ref_id>20</ref_id>
			</ref>
			<ref>
				<ref_obj_id>63727</ref_obj_id>
				<ref_obj_pid>63726</ref_obj_pid>
				<ref_seq_no>21</ref_seq_no>
				<ref_text><![CDATA[Liu, D., andHoschek, J. GCt Continuity Conditions Between Adjacent Rectangular and Triangular Bezier Surface Patches. Computer Aided Design, 21:194-200, 1989.]]></ref_text>
				<ref_id>21</ref_id>
			</ref>
			<ref>
				<ref_obj_id>37422</ref_obj_id>
				<ref_obj_pid>37402</ref_obj_pid>
				<ref_seq_no>22</ref_seq_no>
				<ref_text><![CDATA[Lorensen, W., and Cline, H. Marching Cubes: A High Resolution 3D Surface Construction Algorithm. Computer Graphics, 21:163-169, 1987.]]></ref_text>
				<ref_id>22</ref_id>
			</ref>
			<ref>
				<ref_seq_no>23</ref_seq_no>
				<ref_text><![CDATA[Moore, D., and Warren, J. Approximation of dense scattered data using algebraic surfaces. In Proc. of the 24th Hawaii Intl. Conference on System Sciences, pages 681-690, Kauai, Hawaii, 1991.]]></ref_text>
				<ref_id>23</ref_id>
			</ref>
			<ref>
				<ref_seq_no>24</ref_seq_no>
				<ref_text><![CDATA[Nielson, G. A Transfinite Visually Continuous Triangular lnterpolant. In O. Farin, editor, Geometric Modeling Applications and New Trends. SIAM, 1986.]]></ref_text>
				<ref_id>24</ref_id>
			</ref>
			<ref>
				<ref_seq_no>25</ref_seq_no>
				<ref_text><![CDATA[Patrikalakis, N., and Kriezis, G. Representation of piecewise continuous algebraic surfaces in terms of B-splines. The V/sua/ Computer, 5(6):360-374, Dec. 1989.]]></ref_text>
				<ref_id>25</ref_id>
			</ref>
			<ref>
				<ref_obj_id>96535</ref_obj_id>
				<ref_obj_pid>96526</ref_obj_pid>
				<ref_seq_no>26</ref_seq_no>
				<ref_text><![CDATA[Peters, J. Local Cubic and BiCubic CI Surface Interpolation with Linearly Varying Boundary Normal. Computer Aided Geometric Design, 7:499-516, 1990.]]></ref_text>
				<ref_id>26</ref_id>
			</ref>
			<ref>
				<ref_seq_no>27</ref_seq_no>
				<ref_text><![CDATA[Peters, j. Smooth interpolation of a mesh of curves. Constructive Approximation, 7:221-246,1991.]]></ref_text>
				<ref_id>27</ref_id>
			</ref>
			<ref>
				<ref_seq_no>28</ref_seq_no>
				<ref_text><![CDATA[Peters, J. Parametrizing singularly to enclose data points by a smooth parametric surface. In Proc. of Graphics Interface, Calgary, Alberta, June 1991. Graphics Interface '91.]]></ref_text>
				<ref_id>28</ref_id>
			</ref>
			<ref>
				<ref_seq_no>29</ref_seq_no>
				<ref_text><![CDATA[Piper, B. Visually Smooth Interpolation with Triangular Bezier Patches. In G. Farin, editor, Geometric Modeling: Algorithms and New Trends. SIAM, 1987.]]></ref_text>
				<ref_id>29</ref_id>
			</ref>
			<ref>
				<ref_obj_id>355761</ref_obj_id>
				<ref_obj_pid>355759</ref_obj_pid>
				<ref_seq_no>30</ref_seq_no>
				<ref_text><![CDATA[Powell, M., and Sabin, M. Piecewise Quadratic Approximations on Triangles.ACM Trans. on Math. Software,3:316-325, 1977.]]></ref_text>
				<ref_id>30</ref_id>
			</ref>
			<ref>
				<ref_obj_id>4333</ref_obj_id>
				<ref_seq_no>31</ref_seq_no>
				<ref_text><![CDATA[Preparata, F., and Shamos, M. Computational Geometry, Aa Introduction. Springer Verlag, 1985.]]></ref_text>
				<ref_id>31</ref_id>
			</ref>
			<ref>
				<ref_seq_no>32</ref_seq_no>
				<ref_text><![CDATA[Ramshaw, L. Beziers and B-splines as Multiaf6ne Maps. In Theoretical Foundations of Computer Graphics and CAD. Springer Verlag, 1988.]]></ref_text>
				<ref_id>32</ref_id>
			</ref>
			<ref>
				<ref_obj_id>36716</ref_obj_id>
				<ref_obj_pid>36713</ref_obj_pid>
				<ref_seq_no>33</ref_seq_no>
				<ref_text><![CDATA[Sarraga, R. G1 interpolation of generally unrestricted cubic B~zier curves. Computer Aided Geometric Design, 4:23-39, 1987.]]></ref_text>
				<ref_id>33</ref_id>
			</ref>
			<ref>
				<ref_seq_no>34</ref_seq_no>
				<ref_text><![CDATA[Sederberg, T. Piecewise Algebraic Surface Patches. Computer Aided Geometric Design, 2:53-59,1985.]]></ref_text>
				<ref_id>34</ref_id>
			</ref>
			<ref>
				<ref_obj_id>64560</ref_obj_id>
				<ref_obj_pid>64557</ref_obj_pid>
				<ref_seq_no>35</ref_seq_no>
				<ref_text><![CDATA[Seidel, H-P. A New Multiaffine Approach to B-splines. Computer Aided Geometric Design, 6:23-32,1989.]]></ref_text>
				<ref_id>35</ref_id>
			</ref>
			<ref>
				<ref_seq_no>36</ref_seq_no>
				<ref_text><![CDATA[Semple, J., and Roth, L. Introduction to Algebraic Geometry. Oxford University Press, Oxford, U.K., 1949.]]></ref_text>
				<ref_id>36</ref_id>
			</ref>
			<ref>
				<ref_seq_no>37</ref_seq_no>
				<ref_text><![CDATA[Shirman, L., and Sequin, C. Local Surface Interpolation with Bezier Patches. Computer Aided Geometric Design, 4:279- 295, 1987.]]></ref_text>
				<ref_id>37</ref_id>
			</ref>
			<ref>
				<ref_seq_no>38</ref_seq_no>
				<ref_text><![CDATA[Walker, R. Algebraic Curves. Springer Verlag, New York, 1978.]]></ref_text>
				<ref_id>38</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 Computer Graphics, 26,2, July 1992 Smoothing Polyhedra using Implicit Algebraic Splines* Chandrajit 
L. Bajaj Insung Ihm Department of Computer Sciences, Purdue University, West Lafayette, Indiana 479o7 
 Tel: 317-494-6531 Fax: 317-494-0739 bajaj@cs.purdue. edu ihm@cs. purdue.edu  Abstract Polyhedron smoothing 
is an efficient construction scheme for generating complex boundary models of solid physical objects. 
This paper presents efficient algorithms for generating families of curved solid objects with boundaty 
topology related to an input polyhedron. Individual faces of a polyhedron are replaced by low degree 
implicit algebraic surface patches with local support. These quintic patches replace the @ contacts of 
planar facets with C continuity along all irtterpatch boundaries. Selection of suitable instances of 
implicit surfaces as well as local control of the individual surface patches are achieved via simultaneouss 
interpolation and weighted least-squares approximation. Introduction The generation of a C] mesh of 
smooth surface patches or spfines that interpolate or approximate triangulated space data is one of the 
central topics of geometric design. TWo surfaces ~(z, y, z) = O and g(z, y, z) = O meet with Ck-continuity 
along a curve C if and only if there exists hmctions cr(z, g, z) and @(z, y, z) such that all derivatives 
upto order k of of @g equals zero at aU points along C, see for e.g., [13]. Chui [8], Dahmen and Michelli 
[10] and Hollig [18] summarize much of the history of multivariate splines. Prior work on splines have 
traditionally worked with a given planar triangulation using a polynomial finction basis [1, 32, 35]. 
More recently surface fitting has been considered over closed triangulations in three dimensions using 
parametric surface patches [6, 7, 12, 15, 16, 17,21,24,26,27,29,33, 37]. ·Supponed in pati by NSF grants 
CCR 90-00028, DMS 91-01424 and AFOSR contract 91-0276 Perrnissmnto copy wi!hnut fee all or part nf this 
material is gmnted provided {hat the cnpies are nn( made or distributed for direct commercial advantage. 
the ACM copyright rrntw Andthe titk nf the publicatmn and Its date appear. and notice IS given that copying 
is by pcrmissmn nf the Assncwtinn for Cnmputing Machinery. To copy otherwise, or to republish, requires 
a fee and/nr specific permission. Little work has been done on spline bases using implictly de­fined 
algebraic surface patches. Sederberg [34] showed how vari­ous smooth implicit algebnac surfaces in trivariate 
Bernstein basis can be manipulated as functions in Bezier control tetrahedral with finite weights. Patrikalakis 
and Kriezis [25] extended this by con­sidering implicit algebnac surfaces in a tensor product B-spline 
basis. However the problem of selecting weights or specifying knot sequences for C t meshes of implicit 
algebraic surface patches which fit given spatial data, was left open. Dahmen [9] presented a scheme 
for constructing C continuous, piecewise quadric surface patches over a data triangulation in space. 
In his construction each triangular face is split and replaced by six micro quadric triangular patches, 
similar to the splitting scheme of Powell-Sabirt [30]. Dsh­men s technique however works only if the 
original triangulation of the data set allows a transversal system of planes, and hence is quite restricted. 
Moore and Warren [23] extend the marching cubes scheme of [22] and compute a C piecewise quadratic approximat­ion 
(least-squares) to scattered data. They too use a Powell-Sabin like spli~ however over subcubes. In this 
paper we consider an arbitrary spatial triangulation T consisting of vertices p = (z,, V,, z, ) in IR.3 
(or more generally a sirnplicial polyhedron P when the triangulation is closed), with possibly normal 
vectors at the vertex points. We present an algorithm to construct a C1 continuous mesh of low degree 
real algebraic surface patches S, , which respects the topology of the triangulation T or simplicial 
polyhedron 7, and C interpolates aU the vertices. Our technique is compleletly general and uses a single 
implicit surface patch for each triangular face of T of P, i.e. no local splitting of triangular faces. 
Furthermore, our C] interpolation scheme is local in that each triangular surface patch has independent 
degrees of freedom which maybe used to provide local shape control. In this paper, we show how these 
extra parameters may be adjusted and the shape of the patch controlled by using weighted least squares 
approximation from additional points and normals, generated locally for each triangular patch. Algebraic 
surfaces: For our polyhedron smoothing problem we only considered fitting with algebraic surfaces, i.e. 
two dimensional zero sets of polynomial equations. l%is was primarily motivated from the fact that manipulating 
polynomials, as opposed to arbitrary  ACM-(1-89791-479-1/92/()()7/()079 $01.50 analytic functions, 
is computationally more efficient [3]. Further­more, algebraic surfaces provide enough generality to 
accurately model almost all complicated rigid objects. A real algebraic surface Sin ~3 is implicitly 
defined by a single polynomial equation 3: i(z, y, z) = O, where coefficienta of t are over the real 
numbers R. While aU real algebraic surfaces have an implicit definition F only a small subset of these 
real surfaces can also be detinedpsrametricalfy by the triple ~(s, t) : (z = GJ(s, t), y = G2(s)t), z 
= GJ(s, t)) where each Gi, i = 1,2,3, is a rational function (ratio of polynomi­als) in s and t over 
R. The primary advantage of the implicit defi­nition ~ is its cIosure properties under modefing operations 
such as intersection, convolution, offse~ blending, etc. The smaller class of parametrically defined 
algebraic surfaces G(s, t) is not closed under any of these operations. Closure under modeling operations 
allow cascading repetitions without any need of approximation. Further­more, designing with the complete 
class of algebraic surfaces leads to better possibilities (as we show here) of being able to satisfy 
the same geometric design constraints with much lower degree al­ gebraic surfaces. The implicit representation 
of smooth algebraic surfaces also naturally yields haM-spaces F+ : ~(z, y, z) ~ O and ~-: ~(z, y, z) 
<0, a fact quite useful for intersection and offset modeling operations. Finally, since prior approaches 
to scattered data fitting over h-iangulations had focused on the parametric rep­resentation of surfaces 
our aim here was to exhibit that implicitly defined algebraic surfaces were also equalfy (if not more) 
amenable to the task. Why is low degree important ? Let the geomaric degree of an algebraic surface is 
the maximum number of intersections between the surface and a line, counting complex, infinite and multiple 
in­tersections. It is a measure of the wavi-ness of the surface. This geometric degree is the same as 
the degree of the defining polyno­mial ~ of the algebraic surface in the implicit definition, but may 
be as high as nz for a parametrically defined surface with rational functions Gi of degree n. The geometric 
degree of an algebraic space curve is the maximum number of intersections between the curve and a plane, 
counting complex, infinite and multiple inter­sections. A well known theorem of algebraic geometry (Bezout 
s theorem) states that the the geometric degree of an algebraic in­tersection curve of two algebraic 
surfaces may be as large as the product of the geometric degrees of the two surfaces [36]. The use of 
low degree surface patches to construct models of physical objects thus results in faster computations 
for subsequent geometric model manipulation operations such as computer graphics dkplay, animation, and 
physical object simulations, since the time com­plexity of these manipulations is a direct function of 
the degree of the involved curves and surfaces. Furthermore, the number of sirtgulsritiesz (sources of 
numerical ill-conditioning) of a curve of geametric degree m may be as high as rn2 [38]. Keeping the 
degree low of the curves and surfaces thus leads to potentially more robust numerical computations. The 
main results of this paper are: 1. an efficient algorithm in sections 2, 3, 4 which computes 1l%e output 
of one operation acts as the input to snother operation apoisstson the curve where all derivatives are 
zero C smooth models of a convex polyhedron using degree 5 algebraic surface patches, and of an arbitrasy 
polyhedron using al mosf degree 7 algebraic surface patches, 2. a numerically stable method in section 
5 for the simultaneous Ci interpolation and weighted least squares approximation used for both the selection 
of a smooth, single-sheeted solution surface as welf as local shape control, Both our solution surface 
degree bounds 5 and 7 are also signif­icantly better than the geometric degree 18, parametric blcubtc 
surface patch solutions for the same problem achieved by Peters [26]. Note that this comparison is only 
between the prior known fitting algorithm which dtd not additionally split the meshed data and had the 
best degree bound. Details on the implementation of our algorithms and illustrative examples are given 
in the section 6.1.  2 The Polyhedron Smoothing A1go­rithm Inthissection, we present an outline of the 
algorithm to smooth a simple polyhedron P with C] -continuous implicit algebraic surface patches. Algoriihm 
1. Triangulate each of the nosttriangular polygonal faces of the given polyhedron P. Each face of P is 
a simple polygon which can be h-iangttlated by adding non-intersecting inner diagonals[3 1]. See Figure 
2. 2. Specify a single normal vector at each vertex of P. This provides a single tangent plane for all 
patches which shaU interpolate that vertex with C1 continuity. 3. NexC construct a curvilinear wire 
frame by replacing each edge of P with a curve which G] -interpolates the endpoints of the edge and the 
specified normals . Any remaining degrees of freedom of the C interpolator curve are used to select a 
desired shape of the curve and indirectly thereby a desired shape of the smoothing surface patch. See 
Figure 2. 4. Spec@ normal vectors along each of the edge curves. This provides the tangent planes for 
the two incident patches which shall C1 interpolate the edge curves. See Figure 3. 5. Finally, C1 -interpolate 
the three edge curves and curve nor­mals of each face. The remaining degrees of freedom for each individual 
patch are consumed via weighted least squares ap­proximation to achieve a suitably shaped single-sheeted 
al­gebraic surface patch. The resulting surface patches yield a globaUy C smooth curved model for the 
given polyhedron. See Figures 3 and 6.  Details of each of the steps 2 to 5 of the algorithm for specitic 
classes of polyhedra (convex, non-convex) together with explicit degrees of the required curves and surfaces 
are presented in subse­quent sections. Steps 2 to 4 are detailed in section 3 and step 5 in sections 
4. 3 Wireframe Construction 3.1 Choice of Vertex Normals The single normal vector assigned to each veriex 
of the triangu­lated polyhedron P can be chosen independently and quite arbitrar­ily. However the relative 
directions of each adjacent vertex normal pair can affect the degree of the C interpolating edge curve 
which replaces th e stsaight edges of P. Let the two normal vectors at the two end points of an edge 
be called an edge-normal-pair. Certain relative directions of art edge-normal-pair induce an inflection 
point for arty C} interpolating curve. Since conies do not have inflection points one is then forced 
to either switch to cubic curves at the least or to artificially split the edge. Splitting an edge in 
turn induces splitting of the triangular face of P. In this section, we restrict ourselves to surface 
fitting without the splitting of any 12iangular faces of P. We first derive a necessary and sufficient 
condition for the relative directions of an edge-normal-pais to allow a singly connected C conic interpolating 
curve. Here, the interpolation is strict in that the curve s normal at the vertex points and the prescribed 
vertex normal are in the same direction and not opposite. This restriction grrasantees the construction 
wire frames which are free of cusp-like connections. In the following definitions and lemmas we make 
all of this more precise. Definition 3.1 Let I o = no) and Pl = (PI,nl)be an edge­ (po, normal-pair. 
A conic segment S ( Po, Pl ) is said to C1-interpolate Po and Pi if there exists a non-degenerate quadratic 
surface a(quadric) F:azz+byz +czz+dzy+eyz+fzz +gz+hy+iz+j=o such Ihal · S( P., PI ) is a singly connected 
conic segment on F, · POand PI are (he end poin[s of S( Po, Pl ), · [he gradierrf of f(x, y, z) = O al 
PO and p] have (he same directions as no and n 1, respectively. In olher words V~(pO) = and Vf(pl) = 
~nl for cons[antsa, (3 >0. ano For a given point-normal pair P = ((p=, pY, p,), (n., n~, n.)), wehave 
Tp(r, y,z) = n=(z p. ) + nu(y pY)n, (z p. ) = O as the equation of the tangent plane that passes through 
(P. P,, P.) and has a normal direction (nr, nY nz). The UVI­gent plane 7 P ( z, y, z) = O divides space 
into a positive half­space {(z, y, z) c R3\TP(Z, y, z) > O}, and a negative half­ space {(z, y,z) E R31TP(Z, 
y,Z) < O}. Note also, that for a surface ~(z, y,z) if Vf(p=, pv, pz) = cs(nz, ny, nz ) then TP = T((Pr,P,,Px 
)>vf[Pr,PV)P. )). Theorem 3.1 There exists a single connected conic segmenl S(PO, P]) on a non-degenerate 
quadric F (hat C1-interpolates PO= (po, no) and PI = (pl, nl) ifandonlyfTPO(pl). TP, (po) > 0. Proof. 
(*) Let~(z, y, z) = az2+by2+cz2 +dzy+eyz+fzr+ gr + hy + iz + j = O be the non-degenerate quadnc F. From 
def­inition 3.1 of a C interpolating conic segment on F, it follows that Computer Graphics, 26,2, July 
1992 TP, (Pl ) ~R(PO) = %o,vI(m))(PI) ~~(P,,v~(~,))(Po). Wi*out loss of generality, assume that pO = 
(O, 0,0), and p, = (1 ,0, O). SinceV~(z, y,z) = (2az +dy+fz +g,2by +dz+ez+ h,2cz+ ey + ~z + i), V-f(O, 
O,O) = (g, h,i) and Vj(l, O,O) = (2a+g, d+h, ~+i). Hence, ~~,Vj(m))(z, y, Z) = gz+hy+iz, and T(pl,vf(p, 
))(z, y,z) = (2a+g)(z I)+(ri+ lt)y+(f+i)z. From the containment conditions of the two points, f (0,0, 
O) = j=i), and f(l, O, O)=a+g+j =a+g=O. Then, T mlVfb))(PI )T(P,,VI(P,J)(P13) = 9( (2a+9)) = 9(2( 9)+ 
g) = g2 > 0, as g cannot be zero. For if g = O, it would follow thata=g=j =O,and either TPO (pI ) or 
T~ (PO) or both would be zero (i.e. the tangent plane at ~ contains pl or the tan­gent plane at p} contains 
po, both). In each such case the quadric j(z)y, z)= by2+cz2+ dzy+eyz+fzz +hy+iz=O isa degenerate quadnc 
as its intersection with any plane section through POand pI yields a pais of lines (a degenerate conic). 
(*) If TP, (P1) ~P, (PO) > 0, then the conic segment on f(z, Y,z) = L(Z, Y,Z)2 K TPo(z, Y,z) TPI(Z, 
Y,z) = Oor f (z, y, z) = O will C] interpolate the pair POand PI, where L(z, y, z) = O is a plane containing 
po and pI, and K is a constant. 4 The geomeizic interpretation of the inequality ~m (pt ) ,vj(n)) T(P, 
,v~(P, )) (PO) >0 is Wat PO is on the positive (negative) haffs­pace of TP, if and only if PI is on the 
positive (negative) halfspace of TPO.  3.2 Generation of a Conic Wireframe Fisst, we give a definition 
of the term quadric wire. De6nition 3.2 Let C(t) = (~, ~, ~) and N(t) = ~~ ~ ~)be~olrip~esof ~uadra~icrationa, 
puwel­ric polynomials. Then, /he pair W(t) = (C(t), N(t)) is called a quadric wire f there exists a quadric 
q(z, y, z) = O such that q(C(t)) =Oand Vq(C(t)) = rrN(t), for a > Oandall t. The rationale in our construction 
of a quadric wire is that a conic curve is naturally associated with curve normal vectors taken from 
a quadric. Our first step to smoothing a convex polyhedron is to compute a C1 interpolating conic curve 
C(t), from an edge­normal-pair (po, rIO), (P1, m)and a normal npl of a plane Q which contains PO and 
pi. In particular, we set W(O) s (PO, ni ) and W(1) s (P], n! ), 3 and hence use the segment of W(t), 
O s t ~ 1. To compute C(t), the normal vectors and nl aze projected into rto the plane P on which C(t) 
will lie. (See Figure 1). This projection results in a control triangle pO p2 pI. Lee [20] presents 
a compact method for computing a conic curve C (t) from such a contsol biangle. In his formulation, the 
conic is expressed in Bemstein-B4zier form : Wopo(l t)*+2w2p2t(l t) + wlpl~ c(t) = wo(l t)*+2#2t(l 
 t)+wl# where w, >0, i = O, 1,2 are shape control parameters. An often used parameterization, called 
the rho-conic paramelerization, is %y ~, we mean the points are the same, and the normal vectors are 
proportional, maintaining positivity. Figure 1: Computation of a Conic Curve given by the special choice 
=w = (1 P),w = P,P>0. WJO Let pol = (po + PI )/2 be the midpoint of the chord POPI. Then, p has a property 
that C(O.5) pol = p(p2 pol ). From this, we can see that as p is increased, the conic gets more curved. 
In particular, it canbe shown that p = 0.5 for a parabola, O < p <0.5 for ellipses and 0.5 < p < 1.0 
for hyperbolas. 3.3 Assigning Normals along Edge curves Once C(t) is fixed, we find a quadratic surface 
q(z, y, z) = O such that N(t) is proportional to Vg(z, y, z) along C(t) and in­terpolates no and nl. 
Consider a quadric surface q(z, y, z) = COZ2+CI#+C2Z2 +C3Z~+C4~Z+ C5ZZ+C6Z+C?7V+@Z+q =0. q(z, y, z) 
= O has 10 coefficients, and since dividing the surface by any nonzero coefficient does not change the 
surface, there are 9 de­grees of freedom. The first requirement is that q(z, y, z) = O must contain the 
computed conic C(t). The C interpolation algorithm for algebraic surfaces [5] gives 5 linear equations 
in terms of the unknowns Cl for the containment requirement. That 5 constraints on c, are required also 
follows from Bezout s theorem which says if a non-degenerate conic intersects with a quadric at more 
than 4 points, then the conic must lie on the quadnc. Hence, 4 (= 9 5) degrees of freedom in choosing 
c, are lefi and these are used to interpolate the normal vectors at the two end points. Interpolating 
and nl at po and pl, respectively, gives nO 2 more linear constraints which leaves 2 degrees of freedom 
in choosing the quadric. We now explain why specifying one more normal vector at a point on the C+ interpolating 
conic fixes the normal vectors along the entire conic. Consider the gradient vector Vq(z, y, z) of the 
quadric. Its components are linear and the vector function Vq(C(t)) is a degree 2 polynomial parametric 
curve in projective space. Hence, three independent constraints fixes the curve Vg(C(t)) and thereby 
the normal vector along C(t). Using similar reasons as above one obtains the following lemma. Lemma 3.1 
Let W(t) = (C(t), IV(t)) be a quadric wire. Then the quadrics which C1 interpolate W(t) comprises of 
a fwily of surfaces with one degree ofji-eedom. What we do in our implementation in order to 6X the additional 
normal vector on the conic is the following. FirsL the average nol = (no + n])/2 is computed, and then 
rw is projected onto the plane which contains C(t). (All conies are planar). Next we require that the 
projected vector be perpendicular to the tangent at C(O.5) i.e. the vector C (0.5). This then fixes all 
the normal vectors N(t) along C(t). For a convex polyhedron, we can always specify a normal vector at 
each vertex such that the condition in Theorem 3.1 for each edge­normal-pair is satisfied. (For example, 
the average of normal vectors of incident faces of a vertex is one possible choice.) This implies that 
we can always construct a wiretkarne for a convex polyhedron whose curves and associated normal vectors 
are described in terms of quadric rational polynomials. Whether we cw construct a similar conic wireframe 
for non-convex polyhedra is currently unresolved. 3.4 Generation of a Cubic Wireframe The construction 
of a cubic wireframe follows along very sirni-Iar lines as the conic wireframe construction. Each edge 
is now replaced by a polynomial parametric cubic curve, C1 interpolat­ing the vertex-normal pairs of 
the edge. Here no restrictions are imposed on the vertex-normal pairs as was the case for the conic wireframe 
of the earlier section. The construction of this cubic wireframe or cubic mesh of curves, see for example 
[11], is what has been used in the past and previously reported for example in [26]. We therefore omit 
further discussion of this construction and refer the reader to the earlier references.  4 Local Patch 
Generation 4.1 C1 Interpolation of a Quadric IYiangle Definition 4.1 An augmented triangle is an 9-tuple 
T = (P0,pl)P2) no, nl, nz, npht, npln, nplw) w~re t~ points Pi are three vertices of a triangle with 
the corresponding unit normal vec­tors n,, and nplil is the normal of the plane which will contain the 
quadric wire madefiom (pi, n,) and (p,, nJ ). Definition 4.2 A quadric triangle is a triple QT = (We(t), 
WI (t), W2(t)) ofquadricwiressuchthat kVO(l) s W, (0), w,(1) s W2(0),andW2(1) z We(o). Given an augmented 
triangle, each quadric wire is computed as described in the foregoing section. Next the quadric triangle 
is fleshed using a single algebraic surface ~(z, y, z) = O. For this we use the C1 interpolation of Bajaj 
and Ihm [5]. This algorithm takes as input positional and first derivative information of points and 
space curves, given parametrically or implicitly, and characterizes, in terms of the nullspace of a matrix, 
the space of all the algebraic surfaces of a specified degree that C1 interpolates the specified geo­metric 
data. For the quadnc tiangle the C interpolation is applied to all three quadric wires and produces a 
homogeneous linear sys­tem MIx = O,where unknowns x are coefficients of ~(z, y, z) = O, such that any 
algebraic surface with coefficients that are solutions of Computer Graphics, 26,2, July 1992 the system 
Ci interpolates the quadric triangle. The nontrivial solu­ tions in the nulkpace of MI form a family 
of all possible algebraic surfaces of degree n, satis~ing the given input constraints, whose coefficients 
are expressed by homogeneous combinations of q free parameters where q = n. r is the dimension of the 
nullspace. Since dividing ~(z, y, z) = Oby a nonzero number does not change the surface, there are, in 
facL n. r 1 degrees of freedom in choosing an instance surface from the family. Hence, the rank r of 
MI must be less than the number of the coefficients n., should there exist an interpolating surface. 
We now derive general degree bounds for Cl intcrpolatory tri­angular patches with degree m interpolator 
curves and from this obtain lower bounds on the degree of surfaces which C1 inter­polate a quadric triangle. 
Assume that we use a degree n alge­braic surface j(z, y, z) = O to C t interpolate a wire of degree m 
W(t) = (C(t), N(t)). According to Bezout s theorem, mn + 1 constraints on the coefficients of j are required 
for the algebraic sur­face ~ to contain C(t) which is of degree m. Additionally for C continuity, consider 
the restricted normal vector V\(C(t)). Since the degree of each component of Vf(z, y, z) is, at most 
n 1, each component of V~(C(t)) has degree m(n 1). Furthermore, the vector function Vj(C(t)) crN(t)is 
a degree m(n 1) parametric polynomial curve in projective space, with N(t) of degree m and a any polynomial 
of degree at most m ( n 2). Finally, since the surface ~(z, y, z) = O contains C(t) the component of 
the above vector function along the tangent direction of C(t) is already sat­isfied. Hence m(rs 1) + 
1 additional constraints are enough to guarantee C continuity along C(t). Lemma 4.1 Le~ W(t)= (C(t), 
N(t)) beadegreem wire. For an algebraic surface f (z, y, z) = Oof degree n to smoothly interpolate W(t), 
atmos12rnn-m+2(= mn+l+m(n l )+l)independenl linear constraints on the f s coefficients must be satisfied. 
This lemma says that the rank of the matrix for Hermite inter­polation of a degree m wire with a degree 
n surface is at most 2mn m + 2. For C interpolation of a triangular patch, there exists a geometric 
dependency between the three wires which also leads to dependency amongst these linear C constraints. 
FirsL since the curves intersect pairwise, there must be three rank deficiencies between the equations 
from the containment conditions (i.e. three equations are generated twice). For the same reasons there 
must be three rank deficiencies between the equations for the matching of normals. Secondly, at each 
vertex of the curvilinear triangle, two incident curves automatically determine the normal at the vertex. 
It is obvious, from the way the curve wire construction, this vector is proportional to the given unit 
normal vector at the vertex. So, satisfying the containment conditions for the 3 curves guarantees that 
any interpolating surface haa gradient vectors at the three pointa as required. This fact implies that 
there are three rank deficiencies between the linear equations for the containment conditions, and the 
equations for the C1 condition. This yields a total of 9 overaff deficiencies. Lemma 4.2 Ler QT = (WO(t), 
WI(t), W2(t)) beaquadrictrian­gle. The rank of the linear system MJX= Owhich is constructed by the Hermi;e 
interpolation for the algebraic surfae f (z, y, z ) = O of degree n that smoothly fieshes QT, is at most 
12n 9. Proof For C interpolation of aff three quadric wires, 3(4n 2 + 2) = 12n linear equations are 
generated according to Lemma 4.1. Subtracting 9 deficiencies from this yields 12n 9. ~ Since f (z, y, 
z) = O of degree n has ( :3) coefficients, and the rank of the linear system should be less than the 
number of coeffi­cients for a nontrivial surface to exist we see that 5 is the minimum degree required. 
In the quintic case, there are 56 coefficients (55 degrees of freedom) and the rank is at most51, which 
results in a family of interpolating surfaces with at least 4 degrees of freedom in selecting an instance 
surface from the family. Even though some special combination of three quadric wires can be interpolated 
by a surface of degree less than 5, for example, three quadric wires from a sphere, the probability that 
such spatial dependency occurs, given an arbitrary triple of conies with normals, is infinitesimal. Hence, 
we can say that 5 is the minimum degree required with the probability one. Lemma 4.3 Let QT = (WO(t), 
W](t), W2(t)) beacubic!riangle whose wires are cubic rational polynomials. The rank of the linear system 
MIX = O which is constructed by the Hermite interpolation for (he algebraic surface f (r, y, z) = O of 
degree n that smoothly ffeshes QT, is at most 18n 12. Proof For C interpolation of all three degree 
3 wires, 3(6n 3 + 2) = 18n 3 linear equations are generated according to Lemma 4.1. Subtracting 9 deficiencies, 
yields 18rr 12. ~ The minimum degree of the C] interpolating surface is 7. In the quintic case, there 
are 120 coefficients(119 degrees of freedom) and the rank is at most 114, which results in a family of 
interpolating surfaces with at least 5 degrees of freedom in selecting an instance surface from the family. 
Lemma 4.4 Le( QT = (WO(t), Wl(t), WZ(t)) be a quadric /ri­angle with one edge a cubic wire. The rank 
of the linear system MIx= Owhich is constructed by the Hermite interpolation for the a&#38;ebraic surface 
f ( z, y, z) = O of degree n that srnoothlyjleshes QT, isat most 14n 10. Proof For C1 interpolation 
of two quadric wires and a cubic wire, 2(4n 2+ 2) + (6n 3+ 2) = 14n 1linear equations are generated 
according to Lemma 4.1. Sub&#38;acting 9 deficiencies from this yields 14n 10. ~ The minimum degree 
of the C interpolating surface is 6. In the degree 6 case, there are 84 coefficients (83 degrees of freedom) 
and the rank is at most 74, which results in a family of interpolating surfaces with at least 9 degrees 
of freedom in selecting an instance surface from the farnify. bmma 45 Le~ QT = (WO(t), Wl (t), W2(t)) 
beacubic(riangle with one edge a quadric wire. The rank of the linear sys:em Mfl =O which is constructed 
by the Hermite interpolation for the algebraic surface f (z, y, z) = O of degree n that smoothly j?eshes 
QT. is at most 16n -11. Proofi For C1 interpolation of two cubic wires and a quadric wire, 4n 2+ 2)+2(6n 
3+ 2)=16n-2 linearequationsare generated according to Lemma 4.1. Subtracting 9 deficiencies from this 
yields 16n -11. ~ The minimum degree of the C interpolating surface is 7. In the degree 7 case, there 
are 120 coefficients(119 degrees of freedom) and the rank is at most 101, which results in a family of 
interpolating surfaces with at leaat 18 degrees of freedom in selecting an instance surface from the 
family. 4.2 Surface Selection and Local Shape Control The result of a C l interpolation of a quadric 
triangle QT is a family of degree 5 algebraic surfaces ~(z, y, z) = O with at least 4 degrees of freedom. 
Similarly C1 interpolation of a cubic triangle is achieved with a 5 parameter family of degree 7 surfaces. 
These families are expressed as a linear combination of the nontrivial coefficients vectors in the nullspace 
of MI. To select a degree 5 or 7 surface horn their respective families, values must be specified for 
these extra degrees of freedom. We now show how weighted least squares approximation to ad­ditional pointa 
around the triangular patch, can be used for both selecting a suitable non-singular surface from the 
family as well as aslocal shape contmI. Let SO = {vi E R31; = 1,. ., ,/} be a set of points which approximately 
describes a desirable surface patch, (These points can be selected for example from a sphere, paraboloid 
etc., centered around the curvilinear triangle). A linear system MAX = O, where each row of NfA is constructed 
fbm the linear conditions ~(~: ) = Owith x contianing the undetermined coefficients of the family. Conventional 
least squares approxima­tion is to minimize II M x II*over the nuUspace of MI. Though 4 m~fitiing 1] 
MA x II does yield a good distance approxima­tion it does not prevent the resulting surface from self-intersecting, 
pinching or splitting inside the triangle. To rid our solution surfaces of such singularities and provide 
more geometric control , we instead approximate a monotonic tri­variate function w = j(z, y, z) rather 
than just the implicit surface ~(z, V, z) = O, the zero contour of the function. We first generate SO 
= {(~1, n,)li = 1,., /} where vi are approximating points, and ni approximating gradient vectors at vi. 
Then, from this set are reconstruct hvomoresets Sl = {Uil Ui = Vi+CY~g,i= 1, ..., 1}, ~d S-1 = {wl[wl 
= vi ~nl,i = 1,...,/} for some small a > 0. Next we set up the least squares system NfA = b from the 
foUowing three kinds of equations : ~(ut) = O, ~(u, ) = 1, and j(w, ) = 1. These equations give an approximating 
contour level shucture of the function w = ~(z, y, z) near the inside of a quadric triangle. We found 
out that forcing well behaved contour levels rids the selected surfaces of se~-intersection in the spatial 
region enclosed by the points. See Figures 6, 8,9 and 10. 4.3 Compatibility and Non-Singularity Con­straints 
h thissubsection, we briefly discuss why quintic surfaces which C1 -interpolate quadric triangles maybe 
singular at the end vertices. Ihm [19] gives a theorem which presents a necessary regularity condhion 
on C1 interpolating surfaces. Theorem 4.1 Lef Cl (u) and ~(u) be two paratnefric curves wifh parametric 
normal directions N, (u) and Nz(u) such thaf C} (0) = C2(0) = p, and that N1 (0) and A5(0) are proportional. 
Then, any surface S, which interpolates the curves with tangent plane continuity, is singular at p unless 
~ N 0: 0)) = %%? The above theorem implies that enforcing two cumes to have the same normal vectors 
at intersection points, does not guarantee the regularity of an interpolating surface at those points. 
The equation in the theorem is a necessary condition for regularity, indicating tha~ if the given curves 
and their normals do not satisfi the equation, any smoothly interpolating surface must be singular at 
p. In most cases, the above condition is not met when quadric triangles are constructed, and hence we 
obsewe singularities at the vertices. A good side-effect of these vertex singularities is that the vertex 
enclosure problem is automatically resolved. This issue has been also addressed in the literature of 
parametic surface fitting. Peters [27] showed that not every mesh of parametric curves with well-defined 
tangent planes at the mesh points can be interpolated by smooth regularly parametrized surfaces with 
one surface patch per mesh face (also known as the vertex enclosure problem). In [28], he used singularly 
parametrized surfaces to enclose a mesh points when mesh curves emanating from the point do not satisfy 
a constrain~ called the vertex enclosure constraint.  5 Computational Details and Examples 5.1 Solution 
of Interpolation and Least-Squares Matrices For an algebraic surface S : f(z, y, z) = O of degree n, 
the C interpolation conditions of section 4.1 produces a homogeneous linear system MIX = O, MI E R  
v of n, equations and n unknowns where x is a vector of the n. (= (n~3) ) coefficients of S. A matrix 
MA E R X w for least-squares approximation is next construct, simiIar to the construction of MI, for 
the additional points generated around the triangular patch as described in section 4.2. For the case 
of quintic algebraic surface patches we solve the following, simultaneous interpolation and weighted 
least-squares approximation problem below. The case of other low degree (6 or 7) C algebraic surfaces 
is nearly identical, with only moditied sizes of the matrices. minimize II MAX -b 112 subject to MIX 
= O, where MI E R w is a Hermite interpolation matrix, and MA ER.* x%and b E R are matrix and vector, 
respec­tively, for contour level approximation, and x c R%is a vector containing coefficients of a quintic 
algebraic surface f (z, ~, z) = O. To find the nullspace of MI in a computationally stable man­ner, the 
singular value decomposition (SVD) of MI is com­puted [14] where MI is decomposed as MI = .!JXVT where 
Computer Graphics, 26, 2, July 1992 UE R l X IandV E R% %are orthonormal matrices, and X = rfiag(al, 
IYZ,. . . . IY.) E R 1* % is a diagonal matrix with di­ agonal elements al ~ uz ~ . . . ~ u, ~ O (s = 
min{n,,56}). It is known that the rank r of MI is the number of the positive diagonal elements of Z, 
and that the last 56 r columns of V span the nuflspace of Mr. Hence, the nullspace of MI is expressed 
as: {x E R%lx = ~~~r ~ivr+,, V.J~e~e W, E R, and v, is the jth column of V}, or x = Vfi_, w where VW.. 
E R~xI% l M made of the last 56 r columns of V, and w a (56 r)-vector. 4 x = V%_. w compactly ex­ presses 
all the quintic surfaces which Hermite-irrterpolate the three quadnc wires. After substitution for x, 
we lead to II MAX b II = II MA V2_,W -b Il. Then, an orthogonal matrix Q c R  0 is computed such that 
 () RI Q=MAV%-. = R = ~ where RI E RI% ) (~-r) is upper triangular. (This factorization is called a 
Q-R faclm-iza/ion [14]). Now, let Q b= : () where c is the first 56 r elements. Then, II MA V -, W 
 b 112 = IIQTMAVM_rW -Q~b 112=IIRIW -c 112+ II d 112.The solution w can be computed by solving RI w = 
c, from which the final fitting surface is obtained as x = V% rw. 5.2 Examples In prior sections, we 
described how to compute low degree triangular algebraic surface patches from a given augmented curvilinear 
triangle. A polyhedron is smoothed by replacing its faces with the triangular patches meeting each other 
with tangent plane continuity. For the augmented triangles 2 = (~j pl, w, ~0) ~1, nzj nP~ol, np~l , TSPbO)of 
tie faces of a Poly­hedron, the normal data, i.e., three vertex normals and three edge normals, must 
be provided as well as the given three vertices. In some applications, the normal data may come with 
a solid, bu~ in general, only vertices and their facial information are provided. The vertex normal n, 
at each vertex p, cart be computed by averaging the normals of the faces incident to the vertex. Other 
as­signment schemes which rely on the normals arsiing form a sphere or a paraboloid are also possible. 
For a convex triangulation T or polyhedron P, the above choice of normals at vertices always yields compatible 
vertex-normal pairs (as per section 3) for C1 conic irt­terpolation and hence degree five surface patches 
suffice by results in section 4. However the abve simplistic choice of vertex nor­mals may yield incompatible 
vertex-normal paira for a non-convex triangulation or polyhedron. To come up with a compatible vertex 
normal assignment for the non-convex case is an open problem. For 4,A~~entimcd &#38;fom, jn most cases, 
the rank r of MI is 51. However. we keep the variable r because it is possible that there am more dependency 
between boundaty cuwes and nomral vectors though the chances are rare. now, we use a C1 interpolating 
cubic curve whenever an incompat­ible vertex-normal pair arises, as in the non-convex case. Hence in 
this case we may need to use algebraic surface patches of degree 7, (as per section 4). Also, we average 
the normals of the faces incident to each edge (p,, p] ), and take its cross product with the vector 
p, p, to get the edge normal vector npl,~. After the normal data is computed, quadric wires are generated 
for the p value which is interactively controlled by the user. Example 5.1 Construction of Quadric Wire 
Frames Figures 5 and 7 show two quadric wire frames for the same con­vex po1yhedron5 with the p values 
0.4 (yielding ellipses) and 0.75 (yielding hyperbolas), respectively. . Example S.2 Polyhedra Smoothed 
with Quirs/ic Algebraic Sur­faces Each of 32 faces of the polyhedron in Example 5.1 is replaced by a 
quintic implicit algebraic surface which smoothly fleshes its quadric triangle. Figures 6 and 8 respectively 
illustrate the C surface meshes of p = 0.4 and 0.75.0  6 Remarks and Open Problems 6.1 Implementation 
Issues We have presented a method that smooths out a polyhedron with C continuous biangular algebraic 
surface patches. The polyhedron smoothing algorithms have been implemented in our distributed and collaborative 
geometric design environment SHASTRA [z], cur­rently consisting of independent toolkit processes SHILP, 
GANITH and VAIDAK. For polyhedron smoothing, SHILP takes as input a polyhedron P and a user specitied 
p value (for shape control), and computes quadric wires (if the normal condition is satisfied for the 
edge) or cubic wires. Next, for each triangular facet of curves, a GANITH computation is invoked via 
inter process communication and the facet C fitted with a low degree (5 to 7) algebraic sur­face patch. 
Potentially, a separate GAN ITH process can be invoked for each individual facet on a network of workstations, 
to achieve maximal distributed parallelism. See Figure 10. 6.2 Open Problems A number of open problems 
do remain. First we need to devise a more robust way of generating the points and contour levels for 
the least squares approximation of section 4.2. While the heuristics for weighted least square approximation 
usually work well, sometimes we need to manually change, for example, the value of a in S1 and .S_I. 
Secondly, we continue to work on smoothing an arbitrary polyhedron. We feel that quirrtic algebraic surfaces 
are also flexible enough for generating C smooth nonconvex triangular surface patches. In this paper, 
we have shown that degree seven algebraic surfaces are sufficien~ however not necessary. (See Figure 
9 for a 5~is ~lyhedmn is gyrmlonga~d triangular bicupcdawirb its _gu -Iar faces triangulated. C mesh 
of quintic surface patches over a nonconvex combination of qrradric wires.) An open problem is to construct 
a wire frame for a non-convex polyhedron with conic curves. In this paper, we have shown that cubic wires 
are sufficient for the nbn-convex case, however they are not shown to be necessary. On approach to accommodateincompatible 
adjacent normals in the non-convex case is to subdivide edges into sub-edges and thereby faces into subfaces. 
We are currently exploring this approach. Our ultimate goal is to construct arbitrary curved solids with 
the lowest algebraic degree surface patches, and to manipulate them through geometric operations such 
as boolean set operations. This ability will provide a geometric modeling system with a complex way of 
creating and manipulating models of physical objects with various geometries. One current application 
of our polyhedron smoothing algorithms haa been in the smooth reconstmction of skeletal structures from 
three dimensional ~/NMR imaging data, using the SHILP, GANITH and VAIDAK toolkits of our SHASTRA system 
[2], See also [4] for algorithmic details of the skeletal model reconstruction via approximation of the 
imaging data, using relatively sparse number of curved patches. Acknowledgements : We are grateful to 
Vinod Anupam, An­drew Royappa and Dan Schikore for their assistance in the imple­mentation of the smoothing 
algorithms.  References [1] Alfeld, P.,. Scattered Data Interpolation in Three or More Vari­ables. In 
T. Lyche and L. Schumaker, editors, Mathematical Methads in Computer Aided Geometric Design, pages 1-34. 
Academic Press, 1989. [2] Anupam, A., and Bajaj, C., and Royapp~ A. The SHAS-TRA Distributed and Collaborative 
Geometric Design Envi­ronment. Computer Science Technical Repofi CAPO-91-38, Purdue University, 1991. 
[3] Bajaj, C. Geometric modeling with algebraic surfaces. In D. Handscomb, editor, The Mathematics of 
SurfacesIII, pages 3-48. Oxford Univ. Press, 1988. [4] Bajaj, C. Electronic Skeletons: Modeling Skeletal 
Structures with Plecewise Algebraic Surfaces. In Curves and Surfwes in Computer klsion and Graphics II, 
pages 230-237, Boston, MA, 1991. [5] Bajaj, C., and Ihm, I. Algebraic surface design with Hermite interpolation. 
ACM Transactions on Graphics, 19(1161-91, January 1992. [6] Beeker, E. Smoothing of Shapes Designed with 
Free Form Surfaces. Computer Aided Design, 18(4)224-232, 1986. [7] Chiyokura, H., and Kimura, F. Design 
of Solids with Free­form Surfaces. Computer Graphics, 17(3)289-298, 1983. [8] Chui, C. Multivariate Splints. 
Regional Conference Series in Applied Mathematics, 1988. [9] Dahmen, W. Smooth piecewise quadratic surfaces. 
In T. Lyche and L. Schumaker, editors, Mathematical Mel/rods in Com­puter Aided Geometric Design, pages 
181-193. Academic Press, Boston, 1989. 10] Dahmen, W. and Michelh, C. Recent Progress in Muhivariate 
Splines. In L. Schumaker C. Chui and J. Word, editors, Ap­proximation Theory IV, pages 27-121. Academic 
Press, 1983. 11] deBoor, C., and Hollig, K., and Sabin, M. High Accuracy Geometric Hermite Interpolation. 
ComputerAided Geomelric Design, 4(00):269-278, 1987. [12] Farin, G. Triangular Bemstein-B6zier patches. 
Computer Aided Geometric Design, 3:83-127,1986. [13] Garrity, T., and Warren, J. Geomeh-ic continuity. 
Compuler Aided Geometric Design, 8:51-65,1991. [14] Gohtb, G., and Van Loan, C. Matrix Computation. The 
Johns Hopkins Univ. Press, Baltimore, MD, 1983. 15] Gregory, J., and Charro~ P. A C Triangular Interpolation 
Patch for Computer Aided Geometric Design. Computer Graphics and Image Processing, 13:80-87,1980. 16] 
Hagen, H., and Pottmann, H. Curvature Continuous Triangu­lar Interpolants. Mathematical Methods in Computer 
Aided Geometric Design, pages 373-384,1989. [17] Herron, G. Smooth Closed Surfaces with Discrete Triangular 
Interpokmts. Computer Aided Geomelric Design, 2(4):297­306,1985. [18] Hollig, K. Multivariate Splines. 
SIAM J. on Numerical Anal­ysis, 19:1013-1031,1982. [19] Ihm, I.,. Surface Design with Implicit Algebraic 
Surfues. PhD thesis, Purdue University, August 1991. [20] Lee, E. The rational B6zier representation 
for conies. In G. Farin, editor, Geometric Modeling : Algorithms and New Trends, pages 3 19. SIAM, Philadelphi~ 
1987. [21] Liu, D., and Hoschek,J. GC* Continuity Conditions Between Adjacent Rectangular and Triangular 
Bezier Surface Patches. Computer Aided Design, 21:194-200,1989. [22] Lorensen, W., and Cline, H. Marching 
Cubes: A High Resolu­tion 3D Surface Construction Algorithm. Computer Graphics, 21:163 169, 1987. [23] 
Moore, D., and Warren, J. Approximation of dense scattered data using algebraic surfaces. In Proc. of 
Ihe 24th Hawaii h.tl. Conference on System Sciences, pages 681-690, Kauai, Hawaii, 1991. [24] Nielson, 
G. A Transfinite Visually Continuous Trisrrgular Interpohnt. In G. Farin, editor, Geometric Modeling 
Applica­tions arrd New Trends. SIAM, 1986. Figure 8: A C Smooth Polyhedron with Quintic Algebraic Patches 
Figure 5: A Convex Polyhedron with Quadric Wires : p = 0.4 : p = 0.75 Figure 9: Smoothing the Non-Convex 
Polyhedron with Quintic Figure 6: A C Smooth Polyhedron with Quintic Algebraic Patches Algebraic Patches 
: p = 0.4 Figure 10: A Polyhedron Smoothed in the SHASTRA Distributed Figure 7: A Convex Polyhedron with 
Quadric Wires : p = 0.75 and Collaborative Geometric Design Environment 
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134016</article_id>
		<sort_key>89</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>10</seq_no>
		<title><![CDATA[Pump it up]]></title>
		<subtitle><![CDATA[computer animation of a biomechanically based model of muscle using the finite element method]]></subtitle>
		<page_from>89</page_from>
		<page_to>98</page_to>
		<doi_number>10.1145/133994.134016</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134016</url>
		<keywords>
			<kw><![CDATA[character animation]]></kw>
			<kw><![CDATA[finite element method]]></kw>
			<kw><![CDATA[non-linear dynamics]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Animation</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>G.1.8</cat_node>
				<descriptor>Finite element methods</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Curve, surface, solid, and object representations</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>H.1.2</cat_node>
				<descriptor></descriptor>
				<type></type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010399</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Parametric curve and surface models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002950.10003714.10003715.10003718</concept_id>
				<concept_desc>CCS->Mathematics of computing->Mathematical analysis->Numerical analysis->Computations in finite fields</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010401</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Volumetric models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003120.10003121</concept_id>
				<concept_desc>CCS->Human-centered computing->Human computer interaction (HCI)</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010352</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Animation</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
			<gt>Human Factors</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>PP14048697</person_id>
				<author_profile_id><![CDATA[81407593546]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[David]]></first_name>
				<middle_name><![CDATA[T.]]></middle_name>
				<last_name><![CDATA[Chen]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Computer Graphics and Animation Group, The Media Laboratory, Massachusetts Institute of Technology, Cambridge, MA]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>PP39032919</person_id>
				<author_profile_id><![CDATA[81100216523]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[David]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Zeltzer]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Computer Graphics and Animation Group, The Media Laboratory, Massachusetts Institute of Technology, Cambridge, MA]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[N.I. Badler, J. O'Rourke, and H. Toltzis. A spherical representation of a human body for visualizing movement. Proceedings IEEE, 67(10):1397-1402, 1979.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Klaus-Jiirgen Bathe. Finite Element Procedures in Engineering Analysis. Prentice-Hall, 1982.]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[F. D. Caxlson and D. R. Wilkie. Muscle Physiology. Prentice-Hall, Inc., 1974.]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_obj_id>74358</ref_obj_id>
				<ref_obj_pid>74334</ref_obj_pid>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[John E. Chadwick, David R. Haumann, and Richard E. Parent. Layered construction for deformable animated characters. A CM Computer Graphics, 23(3):243-252, 1989.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_obj_id>142565</ref_obj_id>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[David T. Chen. Pump It Up: Computer Animation of a Biomechanically Based Model of Muscle using the Finite Element Method. PhD thesis, MIT, 1992.]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[Scott L. Delp. Surgery Simulation: A Computer Graphics System to Analyze and Design Musculoskeletal Reconstructions of the Lower Limb. PhD thesis, Stanford University, 1990.]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[William A. Fetter. A progression of human figures simulated by computer graphics. IEEE Computer Graphics and Applications, pages 9-13, November 1982.]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[H.S. Gasser and A.V. Hill. The dynamics of muculax contraction. Royal Society of London Proceedings, 96:398-437, 1924.]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_obj_id>74335</ref_obj_id>
				<ref_obj_pid>74334</ref_obj_pid>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Jean-Paul Gourret, Nadia Magnenat-Thalman, and Daniel Thalman. Simulation of object and human skin deformations in a grasping task. ACM Computer Graphics, 24(3):21-30, 1989.]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[Andrew P. Grieve and Cecil G. Armstrong. Compressive properties of soft tissues. Biomechanics XI-A, International Series on Biomechanics, Amsterdam, 1988. Free Unversity Press.]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
			<ref>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[A.F Huxley and R. Niedergerke. Structural changes in muscle during contraction. Nature, 173:971-973, 1954.]]></ref_text>
				<ref_id>11</ref_id>
			</ref>
			<ref>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[H. Huxley and J. Hanson. Changes in the crossstriations of muscle during contraction and stretch and their structural interpretation. Nature, 173:973-976, 1954.]]></ref_text>
				<ref_id>12</ref_id>
			</ref>
			<ref>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[David L. Kelley. Kinesiology: Fundamentals of Motion Description. Prentice Hall, Inc., 1971.]]></ref_text>
				<ref_id>13</ref_id>
			</ref>
			<ref>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[Koji Komatsu. Human skin model capable of natural shape variation. Laboratories Note 329, NHK, Tokyo, March 1986.]]></ref_text>
				<ref_id>14</ref_id>
			</ref>
			<ref>
				<ref_obj_id>37422</ref_obj_id>
				<ref_obj_pid>37402</ref_obj_pid>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[W.E. Lorensen and H.E. Cline. Marching cubes: A high resolution 3d surface construction algorithm. A CM Computer Graphics, 21(4):163-169, 1987.]]></ref_text>
				<ref_id>15</ref_id>
			</ref>
			<ref>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[Delle Rae Maxwell. Graphical marionette: a modernday Pinocchio. Master's thesis, MIT, 1983.]]></ref_text>
				<ref_id>16</ref_id>
			</ref>
			<ref>
				<ref_seq_no>17</ref_seq_no>
				<ref_text><![CDATA[S. McKenna, Y. Harvill, A. Louie, and D. Huffman. Swivel 3D Professional User's Guide. Paxacomp, Inc., 1987-1990.]]></ref_text>
				<ref_id>17</ref_id>
			</ref>
			<ref>
				<ref_seq_no>18</ref_seq_no>
				<ref_text><![CDATA[Thomas A. McMahon. Muscles, Reflexes, and Locomotion. Princeton University Press, 1984.]]></ref_text>
				<ref_id>18</ref_id>
			</ref>
			<ref>
				<ref_obj_id>147180</ref_obj_id>
				<ref_obj_pid>147156</ref_obj_pid>
				<ref_seq_no>19</ref_seq_no>
				<ref_text><![CDATA[Steve Pieper, Joseph Rosen, and David Zeltzer. Interactive computer graphics for plastic surgery: A task-level analysis and implementation. Proceedings of the A CM 199~ Symposium on Interactive SD Graphics, pages 127-134, 1992.]]></ref_text>
				<ref_id>19</ref_id>
			</ref>
			<ref>
				<ref_seq_no>20</ref_seq_no>
				<ref_text><![CDATA[Steven Donald Pieper. CAPS: Computer-Aided Plastic Surgery. PhD thesis, MIT, 1992.]]></ref_text>
				<ref_id>20</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378524</ref_obj_id>
				<ref_obj_pid>378456</ref_obj_pid>
				<ref_seq_no>21</ref_seq_no>
				<ref_text><![CDATA[John C. Platt and Alan H. Barr. Constraint methods for physical models. A CM Computer Graphics, 22(4):279-288, 1988.]]></ref_text>
				<ref_id>21</ref_id>
			</ref>
			<ref>
				<ref_seq_no>22</ref_seq_no>
				<ref_text><![CDATA[D. Terzopoulos and K. Waters. Physically-based facial modelling, analysis, and animation. The Journal of Visualization and Computer Animation, 1(2):73-80, 1990.]]></ref_text>
				<ref_id>22</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378522</ref_obj_id>
				<ref_obj_pid>378456</ref_obj_pid>
				<ref_seq_no>23</ref_seq_no>
				<ref_text><![CDATA[Demetri Terzopoulos and Kurt Fleischer. Modeling inelastic deformation: Viscoelasticity, plasticity, fracture. ACM Computer Graphics, 22(4):269-278, 1988.]]></ref_text>
				<ref_id>23</ref_id>
			</ref>
			<ref>
				<ref_seq_no>24</ref_seq_no>
				<ref_text><![CDATA[F. E. Zajac. Muscle and tendon: Properties, models, scaling, and application to biomechanics and motor control. Critical Reviews in Biomedical Engineering, 17:359-411, 1989.]]></ref_text>
				<ref_id>24</ref_id>
			</ref>
			<ref>
				<ref_seq_no>25</ref_seq_no>
				<ref_text><![CDATA[F. E. Zajac, E.L. Topp, and P.J. Stevenson. A dimensionless musculotendon model. Proceedings IEEE Engineering in Medicine and Biology, 1986.]]></ref_text>
				<ref_id>25</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 Computer Graphics, 26,2, July 1992 Pump It Up: Computer Animation of a Biomechanically Model of Muscle 
Using the Finite Element Based Method David T. Chen and David Zeltzer Computer Graphics and Animation 
Group The Media Laboratory Massachusetts Institute of Technology Cambridge, MA 02139 ABSTRACT Muscle 
is the fundamental motor that drives all animal motion. We propose that changes in shape of moving hu­man 
and animal figures will be accurately reproduced by simulating the muscle action and resulting forces 
that propel these figures. To test this hypothesis, we developed a novel computational model of skeletal 
muscle. The geometry and underlying material properties of muscle are captured using the finite element 
method (FEM). A biomechanical model of muscle action is used to apply non-linear forces to the finite 
element mesh nodes. We have tried to validate the FEM model by simulating well known muscle experiments 
and plotting out key quantities. Our results indicate that the twin goals of realistic computer animation 
and valid biome­chanical simulation of muscle can be met using these meth­ods, providing a principled 
foundation both for animators wishing to create anatomically based characters and biome­chanical engineers 
interested in studying muscle function. CR Categories: 1.3.7 [Computer Graphics]: Three-Dimensional Graphics 
and Realism Animation. Additional Keywords: finite element method, non­linear dynamics, character animation. 
 INTRODUCTION Modeling and animation of the human form has long been a research goal in computer graphics. 
The human figure is an imrrortsmt and ubiquitous exr)ressive tool that we would like t: use in compu~er 
anima~ions: our bodies transmit information about ourselves, and we take cues, both narra­tive and physical, 
from what is seen of others. The human body, however, is a collection of complex rigid and non-rigid 
components that are difficult to model. Moreover, skeletal motions of the bodv. are well coordinated 
and subtlv. com­plex. Muscles change shape due to the dynamic interactions of contraction and contact. 
The muscles, in turn, are cov­ered by overlapping layers of living tissue, and modeling the ways in which 
this tissue interfaces to the outside world is also daunting. Typically in character animation, only 
the surface geom­etry is modeled. Here we take a detailed look at modeling Perrmssiunto copy withou! 
fee all or part of this material is granted provided that the copies are not made or distributed for 
direct commercial advantage. the ACM copyright notice and the title of the publication and its date appear. 
and notice is gvventhat copying is by permissimr of the Assoeiatiorr for Computing Machinery. Tn COPY 
otherwise. or 10 republish. requires a fee and/nr specific permission. the important underlying structures, 
i.e., muscles and bone. Our immediate research goal is to accurately model indi­vidual three-dimensional 
muscles. This is a bottom up approach, but because a physically-based model is created, the results can 
be applied both to produce realistic-looking animations of human characters as well as to help create 
new bioengineering applications in which computer graph­ics display is vital. As computer workstations 
become more powerful, and rendering and computation times drop, it will be possible to extend the research 
results in a considered and straightforward way. The eventual goal then is not only character animation 
but to take a step towards the creation of an artificial person that can repond convincingly as its simulated 
muscles are activated. 1.1 Previous Work The approaches taken to modeling the shape of the human figure 
include: 1. geometric rigid links, like bones, in which only the static geometry is specified 2. kinematic 
the geometry of a whole limb changes due to the kinematics of the underlying skeleton 3. elastic-modeling 
parts of the body as non-linear visco­elastic-plastic composite materials that change shape due to the 
action of forces  For the geometric case, the three methods most commonly used are polygonal meshes, 
volume primitives and surface patches. Fetter [7] used contours derived from biostereo­metric data to 
generate the polygons in his Fourth Man and Woman . Human forms from standard volume primi­tives include 
Badler s Bubbleman [1], made from spheres, or Ginsberg and Maxwell s cloud figure [16], based on ellip­soids. 
In these examples, the shape of the limbs does not change as the character moves. Examples of kinematic 
models include that of Komatsu, who parameterized spline patch control points to simulate a contracting 
biceps as the elbow is bent [14]. Komatsu used four major spline patch surfaces to cover the head, chest, 
abdomen and legs of a skeleton. Chadwick et.al. in [4], gen­eralized this approach by using a layered 
technique based on free-form de~ormaiions (FFDs) to apply muscle effects onto a skeleton. Their model 
derives the shape of a whole limb from the kinematic skeletal state. Abstract muscles are parameterized 
as two sets of FFDs. These FFDs are con­trolled by the skeleton position to simulate the gross effects 
of muscle contraction at the body s surface. A simple elastic model based on discretized mass points 
joined by Hookean springs can be added on top of this to allow for automatic squash and stretch of the 
face or whole limbs. [o]992 ACM-O-R9791-479-l/92 /W7/00fi9 $01.50 SIGGRAPH 92 Chwgo, JUly 26-31, 1992 
Elasticl models [23] comprise one form or another of dis­placement analysis of an elastic continuum. 
This analysis can be characterized as static or dynamic, linear or non­linear, isotropic or anisotropic, 
and so on. The particular shape of a deformation is a function of both the internal stresses and strains 
within the elastic object and the exter­nal forces applied to it. Examples include Gourret [9], who described 
a system for modeling the human hand with a fi­nit e element volume meshed around bone. He formulates 
and solves a set of statics equations for skin deformation based on bone kinematic and hand/object contact 
points in a grasping task. While bending and flexing of the hand flesh is nicely simulated, no muscle 
ethxts or changes in the underlying shape are calculated. Pieper et al. [19] [20], has developed a su~icai 
simulation system that can be used both to create animation of the face and to simulate surgical reconstructions 
of the face. He performs a finite element analysis of the skin arranged as three different layers of 
material. Force generating muscles that control facial expression have also been implemented. Terzopoulos 
and Waters [22] have constmcted a dynamic model of the face for computer rmimation based on a lattice 
of springs and masses. They too have implemented force generating muscles to provide realistic expressions. 
This pa­per concerns skeletal muscle, the anatomy for which is dif­ferent than muscles of the face. Skeletal 
muscle makes up from 40 to 45 percent of the total human body weight, so we expect that our emphasis 
on modeling this muscle type will eventually allow us to simulate shape throughout much of the body. 
2 MUSCLE ANATOMY Muscle connects to bone through tendons, which are bun­dles of connective tissue. These 
connective tissues are com­posed largely of collagen, a fibrous protein found throughout the body. The 
center part of the muscle can be called the belly , which is surrounded by a connective tissue sheath 
called the epimysiurn. The tendons are actually continua­tions of these connective tissue sheaths that 
hold the muscle together. The angle made by the muscle fibers relative to the tendon is the pennatiora 
angle. The whole muscle is held in place within the body by extensive connective tissue layers called 
jascia [13]. The connective tissue also penetrates the muscle and di­vides it longitudinally into groups 
of muscle fibers known as fasciculi. It is at this level of differentiation that the muscle is supported 
by capillaries, veins and nerve fibers. Mus­cle fibers come in many lengths sometimes stretching the 
whole length of a muscle-and are usually 10 to 100 microns in dkuneter. The muscle fibers are composed 
of still smaller elements called myofibrds that run the whole length of the fiber. Each myofibril is 
about 1 to 2 microns thick. A single muscle fiber contains on the order of hundreds to thousands of myofibrils. 
It is at the level of myofibril that a discussion of the con­ tractile mechanism for a muscle usually 
begins. The myofib­ ril is made up of sarcomervs arranged in a repeating pattern along its length. This 
repeating pattern is responsible for the striations or banding pattern often observed on skele­ tal muscles. 
The sarcomere is the actual functional unit of contraction for the muscle. Sarcomeres are short sections 
only about 1 to 2 microns long that contract upon suitable excitation, developing tension along their 
longitudinal axis. The shortening of a single muscle fiber then is due to the effect of many sarcomeres 
shortening in series. A bundle of *i.e., visco-elastic-plastic models  IDd!2x Lu@h (c) Figure 1: 
Tension-length curves. The dotted line shows the le;gth-tension curve ;f the resting muscle. The total 
force recorded on fully activating the muscle is shown by the solid line. The extra force developed on 
stimulation is shown by the dashed line. The progression from (a) to (c) results from muscles with progressively 
less connective tissue [31. muscle fibers can be thought to be many of these force gen­erators arranged 
in parallel. Finally, the combined tension produced by bundles of muscle fibers is transmitted to the 
bones through the network of connective tissue and muscle tendons. 2.1 Sliding Filament Theory of Contraction 
The discussion above has concerned the more or less macro­scopic properties of muscle force generation. 
Here we will briefly touch upon the contractile mechanism within a sin­gle sarcomere. Muscles have been 
differentiated into at least eight separate protein structures, of which four play a role in contraction. 
The two most important of these are actin and myosin. These two contractile proteins form filaments within 
the sarcomere, and, when viewed in cross section, can be seen to be packed hexagonally, with six thin 
filaments surrounding each thick filament. The thick myofilaments are made of myosin, the thin myofilaments 
are made of actin. The idea behind the sliding filament theory of muscle con­traction is that as a muscle 
fiber shortens, the thin and thick myofilaments do not themselves get shorter, rather they slide across 
each other [11] [12]. 2.2 Hill s Force Model One of the simplest kinds of experiments that can be done 
to a prepared, isolated whole muscle is to measure the force output as the muscle is stretched through 
a number of con­stant lengths, see Fig. 1. If this is done with no stimula­tion, then the resulting plot 
of force or tension to length is said to represent the passive elastic properties of the mus­cle. This 
passive tension-length curve has an exponential shape in which the curve gets steeper and steeper the 
more the muscle is elongated. This behavior is very similar to a rubber band in which the material can 
be pulled very easily until it is all stretched out , and then the rubber band can feel very stiff. Computer 
Graphics, 26,2, July 1992 If the same kind of tension-length plot is then made with the muscle fully 
stimulated, then a different curve is pro­duced that has components from both active and passive force 
components. This curve, of course, should always be greater than the passive force-length plot by itself 
and is called the total tension-length curve. Finally, the tension­length curve that represents only 
the active muscle force is found by subtracting the passive curve from the total curve. The length dependence 
of the developed force is altogether consistent with the sliding filament theory of muscle con­traction 
[11]. Furthermore, from measurements on human subjects, A. V. Hill proposed that there is also a velocity 
dependent force component that counteracts the contraction force. That is, the force ezertesf by the 
muscle decreases as the speed of shortening increases [8]. It was supposed at first that this phenomenon 
depended on an automatic regulatory mecha­nism within the central nervous system, but Gaaser and Hill 
showed through quick-release experiments on isolated frog muscle that this damping effect was part of 
the fundamen­tal character of the muscle itself. A muscle held isometri­cally was suddenly allowed to 
shorten to a new length against no applied load. The force that was recorded fell below the amount that 
corresponded to the isometric equilibrium point of the new length and only slowly developed tension back 
up to that point. The observation that the measured muscle force did not instantaneously reach the level 
predicted by the new length indicated a damping effect within the contractile machinery. See Fig. 2. 
Figure 2: Quick-release curves, plotting tension versus time [8] A simple mechanical model of muscle 
that takes into ac­count the effects described above is shown in Fig. 3. This model is commonly attributed 
to A. V. Hill. The active state force TO is found, as discussed above, by subtracting the total force 
measured at different lengths for a stimulated muscle from that found to be due to passive effects alone. 
The notation TO(Z1, t) indicates that this force is a func­tion of the muscle length and time-varying 
activation. The passive parallel stiffness ~P.E has contributions due to the penetration of connective 
tissue through the muscle body resulting in the fasciculus divisions and also interfiber elas­ticity. 
The parallel damping component B is most likely due to the rate of the biochemical reactions that are 
responsible for contraction at the myofilament level. The series stiffness Ks.E is primarily from the 
effect of tendon at the muscle attachment points, but is also probably partially due to the details of 
myofilament attachment within a sarcomere. The series element is verv imDortant in its abilitv to buffer 
the .. . rapid change from inactive to active state and also provides a mechanical energy storage mechanism 
for the body in mo­ tion. The Hill model, while very simple, has proven enormously C#Wactile cornn:l 
T T Figure 3: Hill s muscle model [18] useful in practice in making calculations of the force gener­ation 
of muscles working against different kinds of loads.  2.3 Zsjec s Force Model Zajac [25] [24] has developed 
a dimensionless lumped model of a complete musculotendon actuator that can be eas­ily scaled to model 
particular whole muscles. Zajac s model is a refinement of the Hill model, and the normalized force curves 
that are presented directly refIect the non-linearities that result from the action of sliding filaments. 
The curves for the active and passive muscle force components are taken from measurements of single muscle 
fibers to ensure that ten­don effects are not superimposed. Furthermore, pennation effects are directly 
included, while the series elastic element not associated with tendon is removed. The isometric force 
generated in a particular actuator de­pends on one set of parameters that is considered constant over 
all actuators and another set that is musculotendon specific. The four specific parameters are, a pennation 
angle FO maximum isometric force of active muscle Iy optimal muscle length at which FO is developed 1=* 
tendon rest length  E4iz­ 4 F ,, _,:g Figure 4: Musculotendon architecture [25] The active muscle is 
represented in Fig. 4 by the contrac­tile element Cl?. Force developed by passive muscle is from SIGGRAPH 
92 Chicago, July 26-31, 1992 ~pE and is summed with the force from CE. The effect of the series elastic 
element ks E is lumped with the ten­ . don model k=. The dimensional units of interest are force and 
length. and 10Mare the normalizing factors for these FO units. A tilde above a symbol denotes that it 
is a normalized quantity, for example, l%g normalized muscle fiber length Other quantities and relationships 
used are, ,MT musculotendon length IT tendon length lMT = IT + IMCosa Zajac gives the non-specific, dimensionless 
functions to model a musculotendon actuator in [25]. We implemented the active muscle function ~~~= (jM 
) as an interpolating cu­bic spline through twelve control points from [6]. For the -PE [M), we USe the 
quadratic func­passive parallel force F ( tion, ~pE(jM) = 4(fM -1)2 if iM ~ 1, else O Plots of these 
two functions are presented in Fig. 5. The isometric muscle force functions can then be written, P;. 
O(iM, t) = ~fi~(i~)a(t) fiM(~~,t,a) = (FisO(~~,t) + fipE(~~))COS~ where a(t) is the time-varying normalized 
muscle activation function. This activation function results from a neural con­troller u(t) and excitation-contraction 
dynamics-the pro­cess of calcium releaae and associated sarcomere shortening due to neural excitation. 
This effect can be safely ignored for our application as will be shown. For tendon, the normalized force 
is ~T(CT) where .cT is the tendon strain defined by, CT _ /T-~T(l~T-@fcOs O) /: (1~=-i~ly CO. a)-lr = 
 -q+= 1: 1: This we also implemented as a polynomial function, see Fig, 6. To characterize the dynamic 
properties of a musculoten­don actuator, it is necessary to consider the velocity de­pendent nature of 
the muscle forces, This damping force is represented by the dashpot element B in Hill s model and is 
typically formulated as a ~orce-vefocity relationship in which the force is scaled depending on the contraction 
velocity. Zajac presents such a curve in terms of the dimensionless form of velocity fi~E, which we implement 
with an arctan function, Fig. 7. The function is designed such that the nor­malized force will be 1 when 
the velocity is O and the force will be O when the velocity is -1. Finally, the total active force from 
the contractile ele­ment is a function of the activation a(t), the force function &#38;~aE(j~ ), and 
the normalized muscle velocity &#38;E, F CEs f(fi~E)Fi.o(iM, t) = f(tisE)a(t)Pfl(iM) and the force in 
the whole muscle is &#38; = (~cE + FpE(iM))c06a 3 MUSCLE SHAPE In our research we have tried to test 
the hypothesis that to make a good simulation of the changes in shape that a con­tracting muscle experiences, 
it is sufficient to characterize # ,,, i / ,,. 1 i /  ,,,. / 1 ,,,. . !. , ,,. ,, Figure 5: Plots 
of force vs. normalized m~scle fiber length i~. Solid line is active force function ~~E(lM ). Daahed 
line PE(fM). is passive force F ,, ., ,, ,, ,,. Figure 6: Normalized tendon force ~T(~T) vs. tendon strain 
ET ,%~ ,2 ., Figure 7: Amount of normalized force relative to isometric force vs. dimensionless velocity 
fi~E. Negative velocity is for muscle contraction, while lengthening muscle will have positive velocity. 
both the resting material and the changes in force known to be important to the contractile process. 
The primary benefit of this approach is that if the forces are calculated properly, then not only will 
it be possible to visualize a mus­cle in action, but a valid biomechanical model will also be developed 
that can be used in further experimentation. For the purposes of visualization, however, it is important 
to ob­tain accurate geometric representations of the rest shapes of muscle messes upon which dynamic 
simulations will be run. We have constructed muscle rest shapes using the Swivel 3DTM Professional [17] 
modeling program on the Macintosh and from contour stacks derived from magnetic resonance imaging (MRI) 
systems. 3.1 Manual Shape Input Since much of the experimental work reported in the mus­cle biomechanics 
literature is done using frog muscles, the gastrocnemius muscle from a prepared frog was digitized for 
use in the computer simulated biomechanical experiments discussed in Section 5. Some time was spent observing 
Dr. Simon Gitzer at MIT in the frog lab making force-length measurements from the gastrocnemius of an 
actual animal. After these were done, the muscle was fully dissected and the top and side dimensions 
measured. Swivel was then used to lathe a polyhedral model. See Fig. 10.  3.2 Contour Data Imaging from 
CAT and MRI scanning systems is a rela­tively new but very important source of clinical data. These systems 
acquire three-dimensional objects as a series of 2D slices arranged along an axis in space. The skinning 
facil­ity in Swivel can be used to operate on data sets of this kind, where anatomical forms are defined 
by varying the shape of the cross section along the length of the body. More sophis­ticated techniques 
such as the marching cubes algorithm [15] can automatically create polygonal models of constant den­sity 
surfaces from 3D data arrays of this type, but it remains problematic to identify meaningful structures. 
A polygonal data set from an entire human left calf was made available to us through Dr. Alan Garfinkel 
at UCLA. The source for the calf model was a long sequence of MRI scans that were carefully hand segmented 
into the individ­ual, anatomical muscle masses and then skinned into tri­angles. Ten muscles, including 
the medial-gastrocnemius, the lateral-gastrocnemius, and the soleus, and one muscle group make up the 
data. The tibia and fibula bones are also included. Because the leg data was received as files of triangle 
meshes, no further processing had to be done to ready them for simulation or display. Fig. 8 shows three 
different views of the reconstructed leg. The entire data set is shown in the middle view. In the left 
view, the overlying gastrocnemius muscles and the soleus are removed to show the underlying structures, 
and the tibia and fibula are shown on the right. 4 METHODS We have presented Hill s muscle model and 
discussed Za­jac s refinement. Our data sources have included Cyberware scans, MRI slices and direct 
geometric output from Swivel. All these are turned into a standard polyhedral representa­tion for display. 
To simulate the action of muscle for our computer graph­ics application, the biomechanical model and 
input data must be synthesized, and for this the finite element method [2] is used, Fig. 9. Thus the 
FEM serves as a vehicle for our muscle model. The polyhedral data is used to define Computer Graphics, 
26,2, July 1992 meshes of twenty-node isoparametric brick elements. Dy­namic equilibrium equations are 
derived from the mesh. Za­jac s model is used to apply non-linear forces to the mesh node points. The 
FEM model is then dynamically simulated forwards and the mesh automatically deforms in response. A free-form 
deformation defined by the mesh helps us visu­alize the resulting changes in shape due to the contraction. 
Unfortunately, a full discussion of our finite element system is beyond the scope of this paper; details 
can be found in [5], The muscle model was constructed by dissecting the gas­trocnemius from an anesthetized 
frog, measuring the top and side dimensions, then Swivel was used to make a polyhe­dral model as discussed. 
A user-assisted finite element mesh generator was then used to interactively construct the mesh shown 
in Fig. 10. Four t went y-node isopararnet ric bricks are used to approximate the gastrocnemius. The 
exact number of elements used represents a tradeoff of the quality of the simulation versus simulation 
time. The model then has 56 nodes or 168 total degrees of freedom. From the mesh of twenty-node brick 
elements, equilibrium equations are derived that have the form Mii + CU+ J{u = R(t) For a body having 
n nodal points, u is an 3n vector of nodal displacements, M, C and A are 3n x 3n matrices describing 
the mass, damping and stiffness between points within the body, and R is a 3n vector of forces applied 
to each node. The finite element matrices are specified in terms of Young s modulus E, Poisson s ratio, 
v, and mass density, p. The FEM equilibrium equations can be characterized as a coupled set of second-order 
differential equations. To solve for the displacements u(t), first reduce to the equivalent first­order 
system, u= v(t) i! = M- (R(t) h-u Cv) A standard ordinary differential equation solver like LSODE from 
NetLib, can then be used to compute the dynamic time­course of the nodal displacements. This is done 
in terms of a derivs function that first calculates R(t) so that ii and L can be found. To simulate a 
muscle contraction, non-linear force gen­erators are added to the node points of the finite element mesh 
that act along the longitudinal direction of the mus­cle. Wired in this way, there are eight generators 
per twenty­node brick, for a total of 32 for the whole muscle. Tendons are constructed in a similar fashion, 
see Fig. 11. To allow the derivs function to calculate the world-space nodal force R(t) due to the action 
of these fibers, the finite element data structures are augmented with information for the muscle state. 
For the muscle fibers, we add 1. fibers, a vector of integers, of length (nofibers*2): en­codes nodal 
attachment of each fiber 2. fiber.lenO, a vector of doubles, of length (nofibers): fiber rest length 
 3. fiber-len, a vector of doubles, of length (nofibers): current fiber length 4. fiber-time, a scalar: 
simulation time for which fiber-len was calculated  In addition, three scalar parameters define the 
muscle, as per Zajac s dimensionless model. The maximum iso­ metric active force is fiber-FOa, the passive 
force scalar is fiber_FOp and the maximum normalized fiber velocity 93    SIGGRAPH 92 Chicago, July 
26-31, 1992 -. Figure 13: Simulation results for tension-length experiment. Isometric muscle force vs. 
normalized length. Dotted line is total isometric force, dashed line is the force from passive muscle 
and the solid line is the developed force. is repeated for the muscle set to different initial lengths. 
The resulting tension-length curves are presented in Fig. 13. An examination of this plot shows a good 
correspondence to the published biological observations (see Fig. 1), with a local maximum for the muscle 
at its rest length. The other result taken from this simulation, interesting from the point of view of 
computer graphics, is that very little changes in shape are produced by a muscle undergoing purely isometric 
contraction. Another of the simplifying assumptions made in the muscle model is that all the fibers are 
homogeneous both in terms of the amount of force they can develop, and in their response to stimulus 
from the neural controller u(t). The small observed shape change is then expected since the actions of 
all the series and parallel fibers should produce a net zero resultant force at the internal mesh faces, 
while producing a large force at the origin and insertion ends which is then canceled by the tendon forces. 
Hence, to produce larger shape changes for the purposes of computer animation requires either the muscle 
to lengthen or shorten, or for the contraction to work against shape changes due to external forces such 
as gravity. 5.2 Quick Release Experiment The second experiment simulated is the quick release proce­dure 
carried out by Gaaser and Hill to examine the velocity dependent effects within the muscle. The muscle 
is stim­ulated and made to work isometrically. Then the muscle is suddenly released and hits a knot or 
new position con­straint after a certain amount of time. A plot of force versus time for this experiment 
is presented in Fig. 14. The muscle begins at the rest length, 6 cm or jM = 1. The amount of shortening 
that takes place is 1.3 cm so that the final normalized muscle length is jM = 0.7833. Fig. 14 shows a 
good correspondence with Gasser and Hill s plots of Section 2.2. In that section, the conclusion drawn 
from the shape of the curves is that the slow rise in the force both when the muscle is activated, and 
after the quick release, indicate that it is caused by a biochemical damping effect, rather than a central 
nervous system control mecha­nism. llwtherrnore, we feel the shape of this force function justifies another 
of the simplifying assumptions made in the model, namely that the effects of excitation-contraction dy­namics 
are negligible for this application because they occur    4fzTi *W 150 .2 .4 1 Figure 14: Simulation 
results for Gaaser-Hill quick release experiment. Force vs. time. Force is scaled to match plot of Fig. 
2. on a much shorter time sczde than what is being simulated. As discussed above, a change of shape in 
the simulated muscle is only predicted for a situation in which the con­traction works against shape 
changes produced by external forces. Such a case is presented in Fig. 15, in which the relaxed frog muscle 
bows downwards due to gravity. Upon contraction, the muscle pulls taut between its attachment points. 
If however, velocity dependent effects are not in­cluded, or the maximum velocity, fi$E, is set too high, 
the muscle will oscillate back and forth, much aa a plucked string, in an amusing, albeit unrealistic 
manner. The ar­rows in the figure show the direction, but not the scale, of the world space forces acting 
at the finite element mesh node points. 5.3 Human Gastrocnemius Simulation The FEM baaed muscle model 
is used in a similar way to sim­ulate contraction of the medhl gastrocnemius from a human subject. This 
muscle was chosen both because of its large size, and because it is on the outside, closest to the skin. 
Thus it should play a large part in determining the shape of the whole leg. The gastrocnemius is approximated 
with a four element mesh made of twenty-node bricks aa in the frog simulations. The medial gastrocnemius 
model is 24 cm long. The maximum isometric force used is 1113 N from [6]. Each of the 32 fibers generates 
34.78 N or 3.48 x 106 dynes. The passive mechanical parameters for the FEM mesh are set as before, with 
gravity equal to 980 cm/s2. To model fascia attachments to the rest of the leg, tendons are defined for 
nodes on the backside of the muscle. These are set so that the muscle can move freely, but not by a large 
amount, Furthermore, a reaction constraint [21] is defined so that the muscle will not penetrate the 
soleus. For the animation, the leg is rotated 45 degrees to horizontal and the relaxed muscle deforms 
due to gravity. Fig. 16 shows that muscle contraction causes the gastrocnemius to pull taut as expected. 
Again, the arrows only show the direction in which the world space forces are acting. 5.4 Human Biceps 
Simulation The example above demonstrates muscle acting isometri­cally against external forces. In an 
effort to apply the re­search results to making computer animation of muscled characters, it is necessary 
that we be able to simulate non­isometric muscle action as well. Geometry for a human biceps was digitized 
from an anatomically accurate plastic model. A FEM mesh was constructed and contraction forces applied 
to the nodes as before. For thk simulation, the bi­ceps is attached at the shoulder, but the forearm 
end is left free. Activation causes the biceps to shorten; the forearm flexes inverse cinematically to 
track the end of the muscle, see Fig. 17.  CONCLUSIONS For computer animation, the next step beyond 
kinematic simulations of skeleton movement must include realistic modeling and rendering of the muscle 
and skin. We have developed a novel finite element model of muscle that can be used both to simulate 
muscle forces and to visualize the dynamics of muscle contraction. Biomechanically, we have taken an 
existing model of muscle function, added complex­ity by making it 3D, and shown that under certain circum­stances 
it still behaves like a muscle. We have tried to val­idate the model by doing biomechanical experiments 
and plotting out key quantities. It is much harder to validate the shape changes produced by the force-based 
FEM muscle model. Videos of live frog and human subjects have been made to serve as checkpoints for the 
simulations, but these can do so only qualitatively. The clearest way to verify the shape changes produced 
by the muscle model would be to make a whole series of MRI reconstructions, with the limb held in different 
states of iso­metric tension while measuring the muscle force wherever possible. A series of reconstructions 
made in this way would be appropriate data against which to compare simulation results. This would be 
a big project, and just barely doable with the current MRI technology. However, by emphasizing the taken 
a step beyond the original making a virtual actor, up to the person. By studying the anatomy, through 
the function, ACKNOWLEDGMENTS physical model, we have computer graphics goal of goal of making an artificial 
the form will be revealed This work was supported in part by NHK (Japan Broadcast­ing Corp. ) and an 
equipment grant from Hewlett-Packard. Thanks to Dr. Joe Rosen, Betsy, Darcy and the SnakePit guys for 
help and support. Special thanks go to Dr. Simon Gitzer of the MIT Brain and Cognitive Science Department 
for sharing his experience and understanding of muscle func­tion, and to Dr. Alan Gartinkel of UCLA for 
providing the human leg data. References [1] N.I. Badler, J. O Rourke, and H. Toltzis. A spherical representation 
of a human body for visualizing move­ment. Proceedings IEEE, 67( 10): 1397 1402, 1979. [2] Klaus-Jurgen 
Bathe. Finite Element Procedures in En­gineering Analysis. Prentice-Hall, 1982. [3] F. D. Carlson and 
D. R. Wilkie. A4uscie Physiology. Prentice-Hall, Inc., 1974. [4] John E. Chadwick, David R. Parent. Layered 
construction characters. ACM Computer 1989. [5] David T. Chen. Pump It of a Biomechanically Based Haumann, 
and Richard E. for deformable animated Graphics, 23(3):243-252, Up: Computer Animation Model of Muscle 
using the Finite Element Method. PhD thesis, MIT, 1992. [6] Scott L. Delp. Surgery Simulation: A Computer 
Graph­ics System to Analyze and Design Musculoskeletal Re­constructions of the Lower Limb. PhD thesis, 
Stanford University, 1990. Computer Graphics, 26, 2, July 1992 [7] William A. Fetter. A progression of 
human figures sim­ulated by computer graphics. IEEE Computer Gmphics and Applications, pages 9 13, November 
1982. [8] H.S. Gasser and A.V. Hill. The dynamics of mucu­lar contraction. Royal Society of London Proceedings, 
96:398-437, 1924. [9] Jean-Paul Gourret, Nadia Magnenat-Thalman, and Daniel Thalman. Simulation of object 
and human skin deformations in a grasping task, ACM Computer Graphics, 24(3):21-30, 1989. 10] Andrew 
P. Grieve and Cecil G. Armstrong. Compres­sive properties of soft tissues. l?iomechanics XI-A, In­ternational 
Series on Biomechanics, Amsterdam, 1988. Free Unversity Press. 11] A.F Huxley and R. Niedergerke. Structural 
changes in muscle during contraction. Nature, 173:971 973, 1954. [12] H. Huxley and J. Hanson. Changes 
in the cross­striations of muscle during contraction and stretch and their structural interpretation. 
Nature, 173:973 976, 1954. [13] David L. Kelley. Kinesiology: Fundamentals oj Motion Description. Prentice 
Hall, Inc., 1971. [14] Koji Komatsu. Human skin model capable of natural shape variation. Laboratories 
Note 329, NHK, Tokyo, March 1986. [15] W.E. Lorensen and H.E. Cline. Marching cubes: A high resolution 
3d surface construction algorithm. ACM Computer Gmphics, 21(4):163-169, 1987. [16] Delle Rae Maxwell. 
Graphical marionette: a modern­day Pinocchio. Master s thesis, MIT, 1983. [17] S. McKenna, Y. Harvill, 
A. Louie, and D. Huffman. Swivel 3D Professional User s Guide. Paracomp, Inc., 1987-1990. 18] Thomas 
A. McMahon. Mugcles, Re~ezes, and Locomo­tion. Princeton University Press, 1984. 19] Steve Pieper, Joseph 
Rosen, and David Zeltzer. Interac­tive computer graphics for plastic surgery: A task-level analysis and 
implementation. Proceedings of the ACM 1992 Symposium on Interactive .?D Graphical pages 127-134, 1992. 
 [20] Steven Donald Pieper. CAPS: Computer-Aided Plastic Surgery. PhD thesis, MIT, 1992. [21] John C. 
Platt and Alan H. Barr. Constraint meth­ods for physical models. ACM Computer Graphics, 22(4):279-288, 
1988. [22] D. Terzopoulos and K. Waters. Physically-based fa­cial modelling, analysis, and animation. 
The Jouma/ of Visualization and Computer Animation, 1(2):73 80, 1990. [23] Demetri Terzopoulos and Kurt 
Fleischer. Modeling in­elastic deformation: Viscoelasticity, plasticity, fracture. ACM Computer Graphics, 
22(4):269-278, 1988. [24] F. E. Zajac. Muscle and tendon: Properties, mod­els, scaling, and application 
to biomechanics and motor control. Critical Reviews in Biomedical Engineering, 17:359-411, 1989. [25] 
F. E. Zajac, E.L. Topp, and P.J. Stevenson. A dimen­sionless musculotendon model. Proceedings IEEE En­gineering 
in Medicine and Biology, 1986. SIGGRAPH 92 Chicaclo, Julv 26-31, 1992 Figure 15: Relaxed muscle deforms 
due to gravity. Active muscle pulled taut. Figure 16: Human gastrocnemius deforn Figure 17: Biceps shortens 
upon activation, forearm motion is specified inverse kinematically. 
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134017</article_id>
		<sort_key>99</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>11</seq_no>
		<title><![CDATA[Dressing animated synthetic actors with complex deformable clothes]]></title>
		<page_from>99</page_from>
		<page_to>104</page_to>
		<doi_number>10.1145/133994.134017</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134017</url>
		<keywords>
			<kw><![CDATA[cloth animation]]></kw>
			<kw><![CDATA[collision responses]]></kw>
			<kw><![CDATA[deformable surface model]]></kw>
			<kw><![CDATA[discretization]]></kw>
			<kw><![CDATA[dynamic constraints]]></kw>
			<kw><![CDATA[garment design]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Animation</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Curve, surface, solid, and object representations</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>H.1.2</cat_node>
				<descriptor></descriptor>
				<type></type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010399</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Parametric curve and surface models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003120.10003121</concept_id>
				<concept_desc>CCS->Human-centered computing->Human computer interaction (HCI)</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010401</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Volumetric models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010352</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Animation</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
			<gt>Human Factors</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>P199541</person_id>
				<author_profile_id><![CDATA[81100297547]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Michel]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Carignan]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[MIRALab, HEC. University of Montreal, Canada]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>PP14128320</person_id>
				<author_profile_id><![CDATA[81100358571]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[Ying]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Yang]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[MIRALab, University of Geneva]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>PP35046642</person_id>
				<author_profile_id><![CDATA[81332531807]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>3</seq_no>
				<first_name><![CDATA[Nadia]]></first_name>
				<middle_name><![CDATA[Magnenat]]></middle_name>
				<last_name><![CDATA[Thalmann]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Computer Graphics Lab. Swiss Federal Institute of Technology]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>PP40028323</person_id>
				<author_profile_id><![CDATA[81100534488]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>4</seq_no>
				<first_name><![CDATA[Daniel]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Thalmann]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_obj_id>90974</ref_obj_id>
				<ref_obj_pid>90967</ref_obj_pid>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Aono Masaki. A Wrinkle Propagation Model for Cloth. In Proc. Computer Graphics International '90, Springer, Tokyo, 1990, pp.96-115.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378509</ref_obj_id>
				<ref_obj_pid>378456</ref_obj_pid>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Barzel R, Barz Alan H. A Modeling System Based on Dynamic Constraints. In Proc. SIGGRAPH "88, Computer Graphics, Vol. 22, No4, 1988, pp.179-188.]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Bezault Lament, Boulic Ronan, Magnenat Thalmann N. Thalmann D. An Interactive Tool for the Design of Human Free-Walking Trajectories. In Proc. Computer Animation '92, Springer, Tokyo, 1992.]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[Eringen AC, Suhubi, ES. Elastodynamics, Vol.1, Academic Press, NY.,1974.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[Hinds BK, McCartney J. Interactive garment design, In The Visual Computer, 1990, Vol. 6, pp.53-61.]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_obj_id>90703</ref_obj_id>
				<ref_obj_pid>90692</ref_obj_pid>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[Kunii Tosiyasu L, Gotoda Hironobu. Modeling and Animation of Garment Wrinkle Formation Processes. In Pro~. Computer Animation'90, Springer, Tokyo, 1990, pp.131-147.]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Lafleur Benoit, Magnenat Thalmann Nadia, Thalmann Daniel. Cloth Animation with Self-Collision Detection. In Proc. IFIP Conference on Modeling in Computer Graphics, Springer, Tokyo, 1991, pp.179-187.]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[Magnenat Thalmann Nadia, Thalmann Daniel. Flashback. {videotape} SIGGRAPH Video Review, ACM SIGGRAPH, New York, 1990.]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_obj_id>617690</ref_obj_id>
				<ref_obj_pid>616019</ref_obj_pid>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Magnenat Thalmann Nadia, Thalmann Daniel. Complex Models for Visualizing Synthetic Actors. In IEEE Computer Graphics and Applications, Vol.1 1, No5, 1991, pp.32-44.]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_obj_id>119604</ref_obj_id>
				<ref_obj_pid>119587</ref_obj_pid>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[Magnenat Thalmann Nadia, Yang Ying. Techniques for Cloth Animation. In New Trends in Animation and Visualization, edited by N. Magnenat Thalmann and D. Thalmann, John Wiley &amp; Sons Ltd.,1991, pp.243-256.]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
			<ref>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[Mangen Alain, Lasudry Nadine. Search for the Intersection Polygon of any Two Polygons: Application to the Garment Industry. In Computer Graphics Forum, 1991, Vol.10, pp.19-208.]]></ref_text>
				<ref_id>11</ref_id>
			</ref>
			<ref>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[Marion, J.B. Classical Dynamics of Particles and Systems. Academic Press, 1970.]]></ref_text>
				<ref_id>12</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378528</ref_obj_id>
				<ref_obj_pid>378456</ref_obj_pid>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[Moore Matthew, Wilhelms Jane. Collision Detection and Response for Computer Animation. In Proc. SIGGRAPH'88, Computer Graphics, Vol.22, No.4, 1988, pp.289-298.]]></ref_text>
				<ref_id>13</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378524</ref_obj_id>
				<ref_obj_pid>54852</ref_obj_pid>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[Platt Jone C, Barr Alan H. Constraints Methods for Flexible Models. In Proc. SIGGRAPH'88 , Computer Graphics, Vol.23, No.3, 1988, pp.21-30.]]></ref_text>
				<ref_id>14</ref_id>
			</ref>
			<ref>
				<ref_obj_id>37427</ref_obj_id>
				<ref_obj_pid>37402</ref_obj_pid>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[Terzopoulos Demetri, Platt John, Barr Alan, Fleischer Kurt. Elastically Deformation Models. In Proc. SIGGRAPH'87, Computer Graphics, 1987, Vol. 21, No.4, pp.205-214.]]></ref_text>
				<ref_id>15</ref_id>
			</ref>
			<ref>
				<ref_obj_id>97883</ref_obj_id>
				<ref_obj_pid>97880</ref_obj_pid>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[Von Herzen Brian, Barr Alan H, Zatz Harold R. Geometric Collisions for Time-Dependent Parametric Surface. In Proc. SIGGRAPH'90, Computer Graphics, Vol.24,No.4, 1990, pp.39-46.]]></ref_text>
				<ref_id>16</ref_id>
			</ref>
			<ref>
				<ref_obj_id>15891</ref_obj_id>
				<ref_obj_pid>15886</ref_obj_pid>
				<ref_seq_no>17</ref_seq_no>
				<ref_text><![CDATA[Weil Jerry. The Synthesis of Cloth Objects. In Proc. SIGGRAPH'86, Computer Graphics, Vol.20, No.4, 1986, pp.49-54.]]></ref_text>
				<ref_id>17</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 SIGGRAPH 92 Chicago, July 26-31, 1992 In this paper, Section 2 explains the physics-based model used 
for the simulation of cloth motion. Section 3 describes the collision response algorithm. Section 4 discusses 
the algorithm of joining and attaching elements of the deformable panels. Finally in Section 5, we discuss 
how to reduce the number of parameters and how to choose values which provide realism and mathematical 
stability, thus improving the interface between the animator and the physics-based model. 2. The dynamic 
model Our work is based on the fundamental equation of motion as described by Terzopoulos et al. [15] 
with the damping term replaced by a more accurate one proposed by Platt et al. [14]: . +: jf ll~-%lliu, 
da2 = Z ~x (1) !2 Because this equation is quite similar to Eq.1 of [ 15], we dscuss only the modified 
third term and refer the reader to [15] for notation and explanations. In the second term of Eq.1, E 
= G -G is called the Lagrangian strain tensor. In the third one, E is the time rate of E and is defined 
as [14]: This term works like a dissipative function. We choose to replace it because the one used in 
[15] is scalar. So, no matter where energy comes from, it will be dissipated. For example, gravitational 
energy is dissipated, resulting in a surface which achieves a limiting speed and is not continually accelerated. 
In our case, we use Raleighs dissipative function [4] generalized for a continuum surface [14]. As E 
is the strain (a measure of the amount of deformation), dE/dt is the spee&#38; at which the deformation 
occurs. This means that the surface integral may be considered a rate of energy dissipation due to internal 
friction. This implies that the variational derivative with respect to velocity of the surface integral 
will minimize the speed of the deformation. With this approach, no dissipation occurs when the surface 
undergoes rigid body displacement like when falling in an air-free gravity field. This improves the realism 
of motion. Taking the variational derivative in Eq.1 and keeping only terms of the fiist order, expression 
Eq. 15 of [ 15] becomes, with the new dissipative function, 22 .fj~ ti~l-$ {((aj+tij#f_} +&#38; (~ja) 
(3) This expression gives the internal forces due to stretching, dissipation and bending that act on 
an infinitesimal part of the surface located at r. In this expression, we define: a (4a) vti(Gij-G:) 
ij (4b) ? ij =Vij (~ij ) /)ij = lj~ (Iij -B; ) (4C) which are constitutive functions of the elastic properties 
of the material. In Eq.4, Gti md Bij csn be computed with the help of their definitions given in Eq.3 
and Eq.4 of [15] respectively. J!3ijcan be computed as in Eq.2 above. And q~ p~ and {~ are physical constants 
which can be computed as shown later. On the right side of Eq.1, we put all external forces. Contact 
forces coming from collisions with the cloth itself or any rigid object like an actor s body are described 
in the next section. In reality, complex clothes or garments usually consist of many fabric panels. To 
apply the elastic deformable surface model, the polygonal panel should be discretized using the finite 
difference approximation method. The discretization of the cloth boundary follows the teduique in [15]. 
3. Collision response This problem is handled in two steps. The f~st one is collision detection, This 
means that we have to find any object s triangle (including those belonging to the cloth itself) within 
a threshold distance from cloth s vertices. Several algorithms have already been proposed [7, 16, 13]. 
When a collision is detected, we pass through the second step where we act on the vertices to actually 
avoid the collision. This may be done using a potential field method as suggested by Terzopoulos et al. 
[15]. A detailed algorithm is described by Lafleur et al. [7] for Marilyn s skirt in the film Flashback 
[8]. Although the method works, the use of this type of force is somewhat artificial and cannot provide 
realistic simulation with complex clothes. In fact, the effect degrades when the potential becomes very 
strong, looking like a kick given to the cloth. To improve realism, we propose the use of the law of 
conservation of momentum for perfect] y inelastic bodies. This means that kinetic energy is dissipated, 
avoiding the bouncing effect. Case 1: Self collision We use a dyn~ic inverse procedure to simulate a 
perfectly inelastic collision. Such collisions between two particles are characterized by the fact that 
their speed after they collide equaIs the speed of their centers of mass before they coIlide. Let p. 
be a point from one part of the cloth that collides with a triangle on another part. Let p 1 be the point 
where the collision occurs on that triangle. AU physical quantities at pf are obtained by linear interpolation 
from values at the triangle% vertices. Let us call ui and vi the speed before and after the collision 
where i stands for O and 1. Fi will be the resultant of external and internal forces at i and fui is 
an unknown force whick when added to Fi makes vi C@ Vc, the speed of the centers of mass of particles 
O and 1 before they collide. Assuming that forces are constant in the time interval, speed after the 
encounter will be (FO + fuo) At V. =Uo+ (5) mo motto+ ml ut With v. = (6) mo +ml and the soft collision 
criteria Vo -V==(I (7) IGO  SIGGRAPH 92 Chicaao, Julv 26-31, 1992 To put together sides of panels (or 
a side of a panel to a rigid object), we put constraints on pointa belonging to sides according to the 
seam information recorded at the creation stage of the garment. In the process, as long as Irol -ro21 
> d the constraint of the fiist type applied  fi = -r), (15) k~f?lJrj making the distance decrease over 
time. Aa soon as Irol -rml <d, according to the momentum law: tn~vol + mz.voz = (ml + mz) vm (16) we 
put the second type of constraint. Vm = (mlvo~ + mz.vm) / (ml + mj) (17) rm = rol + (rOz-r01).m2/ (ml 
+ nq) (18) Thereafter points on a seam stay together. In formulas above, rti, VW,mi (i .l~), are the 
position vector, velocity, and mass of element i (i =1,2) before the constraint is applied to them, rm, 
Vm are the position vector and velocity of both points 1 and 2 after the constraint applied to them. 
d is the threshold combining distance, k is a constant, and depending if point i belongs to a vertical 
or ~i l lill (orqi22 horizontal side) is the metric factor of the material of the panel. In the case 
where point 2 belongs to a rigid objecg we make the assumption that mass is infinite and no constraints 
are applied. In this case Eq.17 and Eq.18 comes = V02 (19) m rm = rm (20) 5. Automatically computed 
parameter Physics-based animation models are very powerful because they allow the production of realistic 
results. Unfortunately, models are generally too complex to be used by an animator with no background 
in physics. For exampl% in the physics­baaed cloth model from Eq. 1, quite a few parameters should be 
specified by the animator. Each parameter haa a physical meaning and controls a physical property. To 
model clothes made horn different kind of fabrics, we should fmd parameter values which make clothes 
move realistically. In addition, these parameters control the mathematical stability of the mode~ so 
it is not a trivial task to put them all together. To overcome these difflctdties, we propose a way of 
computing all the parameters from just two which have more intuitive meaning to people with no background 
in physics. our goal is to introduce a few user parameters intuitive in meaning and insensitive to diacretization. 
This technique allows testing with very few points deftig a cloth, and we can look for the physical properties 
to be modeUed with little CPU time. Them when satisfi~ we may diacretize as much as we want without searching 
for a new set of parameters. The fmt parameter to calculate is the mass for each node. BUG we consider 
density a more fundamental quantity than mass, because it is independent of how clothing panels are diacretized. 
The animator should selec~ for exam le a value Y ranging from 0.005 gr/cm2 for silk to 1.000 gr/cm for 
heavy leather. Maas at a node is them calculated as follows: m(a) = p(u)da@tq (21) The second parameter 
controls the resistance to stretching. To compute it, we use an artificial criterion: the percentage 
a clothing panel will stretch when suspended under gravity. If the norm of gravity is g and if A is the 
percentage of stretch tolerance, we have q,, = mghv12121100 (22a) q22 = mghh12/~100 (22b) q~~ = 7121= 
(Vll + n22)lf2 (22C) In this expression q~ is a force multiplied by a aquared length. For rI,2 and r121. 
we take the mean value from ql, and q22 as it is shown in Eq.22c. The third parameter to be calculated 
is At, used to control the step size in the numerical integration of Eq. 1. Furthermore, At should be 
correlated with real-time or a video time unit. This means that in a simulation from tl to t2 with a 
step size of At, we can record a video frame each NAt = 1/25 sec. resulting in a cloth animation sequence 
that is neither too fast nor too slow. We should not forget that the time parameter also controls the 
mathematical stability of the numerical integration of Eq. 1. The lower the At, the greater the accuracy 
and stability, but the larger the processing time. The best values are then a matter of compromise. As 
a clothing panel in our model may be considered a suitable medium in which waves can travel, we can fmd 
[12] that phase speed of lower node waves can be calculated as: VV = (rl,,lm)ln (23a) (23b) vh = (V22Jm)1n 
 where VVand vh are wave speeds in the vertical and horizontal directions, respectively. A good At could 
reasonably be chosen to make a wave travel only a fhwtion 1 of the inter-vertex space in one time step: 
At= d n (hv/vv, hhh h) / i (24) where a good value for I is 2 or 3. The fourth parameter is ~ij, which 
appears in Eq.1. This parameter controls the resistance to bending. A zero value corresponds to no resistance 
at all, which means a cloth moves very freely like satin. For greater values cloth appears like rigid 
cotton or even leather or plastic. Ag@ we are looking for values independent of discretization but in 
this case, we introduce a user parameter c that has no physical meaning for the user parameter, like 
qy This value is given by (11 = cmgh~ (25a) $2= cmg~ (25b) (25c) C12= $, = (t,, + $z)ln  
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134019</article_id>
		<sort_key>105</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>12</seq_no>
		<title><![CDATA[Three dimensional apparel CAD system]]></title>
		<page_from>105</page_from>
		<page_to>110</page_to>
		<doi_number>10.1145/133994.134019</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134019</url>
		<categories>
			<primary_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Curve, surface, solid, and object representations</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>J.6</cat_node>
				<descriptor>Computer-aided design (CAD)</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.7</cat_node>
				<descriptor></descriptor>
				<type></type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010405.10010432.10010439.10010440</concept_id>
				<concept_desc>CCS->Applied computing->Physical sciences and engineering->Engineering->Computer-aided design</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010352</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Animation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010405.10010469.10010472.10010440</concept_id>
				<concept_desc>CCS->Applied computing->Arts and humanities->Architecture (buildings)->Computer-aided design</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010178.10010224.10010226.10010239</concept_id>
				<concept_desc>CCS->Computing methodologies->Artificial intelligence->Computer vision->Image and video acquisition->3D imaging</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010401</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Volumetric models</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010399</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Parametric curve and surface models</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
			<gt>Design</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>P110310</person_id>
				<author_profile_id><![CDATA[81332519094]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Hidehiko]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Okabe]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Research Institute for Polymers and Textiles, 1-14, Higashi, Tsukuba, 305 Japan]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>PP31080785</person_id>
				<author_profile_id><![CDATA[81100062874]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[Haruki]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Imaoka]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Nara Women's University, Kits-uoya-nisirnachi, Nara, 630 Japan]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P277646</person_id>
				<author_profile_id><![CDATA[81332531929]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>3</seq_no>
				<first_name><![CDATA[Takako]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Tomiha]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Toray Industries, Inc., Engineering Research Labs., 3-3-1, Sonoyama, Otsu, 520 Japan]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P108157</person_id>
				<author_profile_id><![CDATA[81100312473]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>4</seq_no>
				<first_name><![CDATA[Haruo]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Niwaya]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Research Institute for Polymers and Textiles, 1-14, Higashi, Tsukuba, 305 Japan]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Amirbayat and J. W. S. Hearle, "The Complex Buckling of Flexible Sheet Materials - Part I. Theoretical Approach", International Journal of Mechanical Sciences 28 (1986), 339.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_obj_id>90974</ref_obj_id>
				<ref_obj_pid>90967</ref_obj_pid>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[M. Aono, "A Wrinkle Propagation Model for Cloth", Proceedings of CG INTERNATIONAL,90 (1990), 95.]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[J. -L. Delaporte and R. Soenen, (personal communication).]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_obj_id>97883</ref_obj_id>
				<ref_obj_pid>97880</ref_obj_pid>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[B. V. Herzen, A. H. Barr and H. R. Zatz, "Geometric Collision for Time-Dependent Parametric Surfaces", Proceedings of SIGGRAPH '90 (August 1990). in Computer Graphics 24, 4 (August 1990), 39.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[H. Imaoka, H. Okabe, H. Akami, et al., "Analysis of Deformations in Textile Fabrics", Sen-i Gakkaishi 44 (1988)t, 217.]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[H. Imaoka, H. Okabe, R. Matsuda, et al., "Estimation Method of Textile Deformation - In the C~e of Two-Dimensional Problem", Sen-i Gakkaishi 44 (1988)v, 229.]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[H. lmaoka, H. Okabe, T. Tomiha, et aL, "Prediction of Three- Dimensional Shapes of Garments from Two-Dimensional Paper Patterns", Sen-i Gakkaishi 45 (1989)t. 420.]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[H. Imaoka, A. Shibuya, N. Aisaka, "Automatic Paper Pattern Making Using Mechanical Development Method of a Curved Surface on a Plane Surface", Sen-i Gak.ka/shi 45 (1989)t, 427.]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[B. Lafleur, N. Magnenat-Thalmann and D. Thalmann, "Cloth Animation with Self-Collision Detection", Proceedings of IFIP WGS.I 0 - Modeling in Cong~uter Graphics (1991 ), 179.]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[H. Niwaya, H. Imaoka, A. Shibuya and N. Aisaka, "Predicting Method of Contact Pressure of Fabrics", Sen-i Gakkaishi 45 (1989)t, 427.]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
			<ref>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[H. Okabe, H. Imaoka, T. Tomiha, et al., "Transformation from Paper Pattern to Spatial Structure of Dress by Computer - Simulation of Sewing and Dressing", Sen-i Gakkaishi 44 (1988)t, 129.]]></ref_text>
				<ref_id>11</ref_id>
			</ref>
			<ref>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[H. Okabe and T. Ikawa, "Point Matching for Stereoscopy by Bayesian Inference", Computer Vision Graphics and Image Processing (submitted).]]></ref_text>
				<ref_id>12</ref_id>
			</ref>
			<ref>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[T. Sengan, (personal communication)t.]]></ref_text>
				<ref_id>13</ref_id>
			</ref>
			<ref>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[W. J. Shanahan, D. W. Lloyd and J. W. S. Hearle, "Characterizing the Elastic Behavior of Textile Fabrics in Complex Deformations", Textile Research Journal 48 (1978), 495.]]></ref_text>
				<ref_id>14</ref_id>
			</ref>
			<ref>
				<ref_obj_id>37427</ref_obj_id>
				<ref_obj_pid>37402</ref_obj_pid>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[D. Terzopoulos, J. Platt, A. Barr and K. Fleischer, "Elastically Deformable Models", Proceedings of SIGGRAPH "87 (July 1987). In Computer Graphics 21, 4 (July 1987), 49.]]></ref_text>
				<ref_id>15</ref_id>
			</ref>
			<ref>
				<ref_obj_id>15891</ref_obj_id>
				<ref_obj_pid>15886</ref_obj_pid>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[J. Weil, "The Synthesis of Cloth Objects", Proceedings of SIGGRAPH "86 (August 1986). In Computer Graphics 20, 4 (July 1986), 49.]]></ref_text>
				<ref_id>16</ref_id>
			</ref>
			<ref>
				<ref_seq_no>17</ref_seq_no>
				<ref_text><![CDATA[T. Yasuda and S. Yokoi, "Shading Model to express the texture of cloth", Nikkei Computer Graphics 1990, 2 (February 1990)t, 150.]]></ref_text>
				<ref_id>17</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 z Computer Graphics, 26,2, July 1992 Three Dimensional Apparel CAD System Hidehiko Okabel, Haruki Imaoka2, 
Takako Tomih;and Haruo Niway~ 1: Research Institute for Polymers and Textiles, 1-14, Higashi, Tsukuba, 
305 Japan 2: Nara Women s University, Kits-uoya-nisirnachi, Nara, 630 Japan 3: Toray Industries, Inc., 
Engineering Research Labs., 3-3-1, Sonoyama, Otsu, 520 Japan Abstract We aredeveloping a three dimensional 
( denoted 3D, hereafter) CAD system for garments to help the process of pattern making. This is a process 
to create a 3D form of a garment by designing a two dimensional ( 2D, hereafter ) paper pattern that 
realizes the 3D form The core of the system is a simulator that estimates the 3D form of a garment put 
on a body from its paper pattern ( 2D~3D process ) and a developing program to obtain the 2D pattern 
that minimizes the energy required to deform it to the given 3D shape ( 3D ~2D process ). In both processes, 
the specific snisotropy of the mechanical properties of cloths is ecmsidered. In the 2D +3D process, 
the contact problem with body and geometrical nonlinearity are also taken into account. The preprocessor 
for the 2D+3D simulator is quite unique in that it converts an arbitrmy 2D paper pattern into a 3D surface, 
ecmaidering the topological operatiom sewing . Both the 2D~ 3D process and the 3D +2D process are formulated 
as nonlinear energy-minimum problems, and they are solved by our original method in about 10 minutes 
with our workstations. Once the 3D form is obtain~ the color pattern of a given cloth is mapped and displayed. 
As a consequence of the mechanical calculation, the distributions of the distortion and stress of the 
cloth are also visualized. Such information may contribute to the design of garments with consideration 
of physical attributes as well as visual beauty. 1. Introduction The apparel industry is one of the 
fields where utilization of CAD systems dates back to the early age of computer graphics. However, still 
now, apparel CAD systems remain only for the treatment of 2D objects -paper patterns and color patterns 
of textiles, while CAD systems for other products can check the fti results of&#38;signs by way of 3D 
views. This is mainly because of 1: Tel, 81(Japan) 298-54-6323,6277 Fax. 298-54-6232 Email S5603@jpnaist 
(BITNE f) 2: Tel. 81(Japan) 742-20-3465 Fax. 742-26-5897 3: Tel. 81(Japan) 775-33-8465 Fax. 775-33-8466 
 Permission I() copy wilhout fee all or part nf this material is granted provided that the copies arc 
not made or distributed for direct commercial odwsntagc.the ACM copyright nmice and the title of the 
publication and its date appear. and notice is given that copying is by permission of the Asmiation for 
Computing Machinery. To copy ntherwlsc. or to republish. requires a fce wrd/or specific p+wrnission. 
the gap between the 2D paper patterns and dte 3D form of the garments. In fact, the mechanical analysis 
of a &#38;ess draprng rdong a human body bears most of the difficult problems found in structure analysis, 
such as contact and friction with the body, large deformation non-linearity, and extreme anisotropy of 
materials. Although there has been some research conducted to analyze or simulate the formation of a 
3D form of garments on the basis of material mechanics[l,2,14], these studies did not take the fomt of 
applicative general ptrpose systems. On the otJter hand, there are some apparel oriented graphic editors 
that allow local distortions of the picture imitating the 3D view. Once such distortions are defined 
by hand, then any pattern of cloth can be substituted into these places. In some cases, the 3D coordinates 
of an actual garment corresponding to the lattice points of a 2D cloth are measured, and pattern mapping 
onto a true 3D surface is retdized[13]. Though such systems are effective for designing color patterns 
of clothes, they lend no aid for the design of the 3D form itself. Also we cannot forget to mention about 
the attractive studies which have presented the motions of cloth in wirtd[9,15]. Though, the ultimate 
goal must be the same ( i.e. true dynamical sirnufation of the dress, body and the sir), the present 
direction of these studies seems to be different from ours. Therefore, the system introduced here may 
be considered to be the first 3D apparel CAD system because it supports the sneehanicrtl analysis of 
draping from a 2D paper pattern to a 3D form, the development of a 3D surface to a 2D pattern, and the 
preprocessing which accepts arbitrary paper patterns for input. Although there is still a gap between 
our present system and eomrnercial systems of the future, we are developing this system with the intention 
that it will be used by a wide variety of people. This is reflected in the fully automated preprocessor, 
where one need only to indicate the lines to be sewn together and the lines consisting of the waist or 
neck line, and our seleetion of robust methods all over the system, where no delicate regulation is required. 
But this does not mean that the true mechanics is sacrificed in this system. We rather believe that the 
fidelity to the natural process is a key for the clarity and easiness of such a system . Due to the limitation 
of space, it is impossible to discuss the techniques used for the implementation of this system in detail. 
Several parts of the system including the formal mathematical expressions, have been published already[5,7,8,11 
]. However, we think that the concepts and struetttre of this system are more important than the implementation 
technique, and we believe that $0150 105 ACM-()-89791 -479-I/92/tW7/f)lfM SIGGRAPH 92 Chlcago, July 
26-31, 1992  The shaded parts are unfinished or in planning. Mechanical measurement Body data Figure 
1 An outline of the 3D apparel CAD system our system shows a basic fismework for 3D apparel CAD. This 
mearts two things: Firs&#38; this will provide a common ground or starting point for fitrther discussions 
in this field. Second, the results of such discussions witl be easily implemented and tested by refining 
or replacing some components of this system. 2. Overview of the system An overview of the system including 
our future plan is shown in Fig.1, Though the textile editor and 2D pattern editor are expressed as different 
processes in the figure, it is only an expedient for explanation. A is observed in some programs for 
drawing, these two editors can be superimposed as two layers of a 2D graphic editor. Actually, our most 
important and urgent subject is to prepare an elegant and integrated interface between a user ( designer) 
and our system. As a primitive form of such an interface, we have already developed a command procedure 
which provides the control of the execution of programs, file assignment and file management. BUL with 
the ability of cumnt graphic workstations, we can expect a much more comfortable and efficient work environment 
for designers. Especially, three graphic programs, textile color pattern editor, 2D paper pattern editor, 
and the 3D image viewer should be incorporated so as to reflect instantaneously the changes given in 
one view to others. That is, the cursors in the 2D view and 3D view should always point at the corresponding 
position of the clo~ and if one alters the color of a pixel of the cloth in the 2D view, it should be 
me m the 3D su~sce at the same momen~ and vice vema. The visualization of various m=hartical properties 
of garments such as the distribution of normal stress ( which is equal to the body contact pressure ) 
must be especially useful for the design of underclothes and sportswear. In the futurq provided with 
a more precise mechanical model for human bodies and a 3D measurement system, this ability of our system 
may contribute to furttkh all clothing with a perf~t fit of custom-tailoring. In Fig.2, we show the position 
of our system in the whole process of the design and production of garments. It should be 3D measurement 
Body data I   E!Y!w!9 Computer Graphics, 26, 2, July 1992 noted that both textile design and apparel 
&#38;sign can be parallelly or synchronously processed by our sy-thou~ traditionally, they are thought 
to be in serial relation. There is a special implication in the comection between our system and the 
manufacturing process of clothes. Our data structure for paper patterns contains the description of how 
the parts of a dress are sewn together and how the &#38;ess is to be ptt on the body. The fact that our 
CAD system can simulate the formation of the fti shape of a dress, assures that the information given 
by this data structure is sufficient to indicate how the parts should be assembled and sewn in apparel 
CAM or an automated sewing system. The old vezsion of our system was written by FORTRAN and we utilized 
CORE for 3D views and PLOtUO for 2D views. The present version utilizes PHIGS or IDEAS for both 3D and 
2D views. Now we are rewriting the whole program m C or C++ for the explicit treatment of the data structures, 
easy interface with advanced graphic libraries, and convenience for use at workstations. The requirement 
for our system for the memory is very humble. The most &#38;manding step is the mechanical analysis, 
but it requires no more than 3M bytes for the stntctur% rnchtding up to 4000 triangles ( 6000 variables 
). The most time commming step ( fiat is, of course, the mechanical analysis) is finished within 10 minutes 
for typical structures containing 1500 triangles by floating point calculation oriented workstations. 
We suppose that this is not an unbearable time for designers because the wr­respondmg conventional process 
to sew up a prototype dress needs one day or more. 3. Preprocessor -conversion from 2D to 3D Making a 
system that accepts various inputs is completely dfiferent from writing down a program that calculates 
a speciat problem. This preprocessor for mechanical analysis is the main source of the difference from 
other studies simulating cloths. In addition to the usual mesh gexwratiom our preprocessor has a +: hd 
Weaving o Textile pattern Dyeing I o  Paper Pattern I ~* Flow of products Figure 2 The position of 
the 3D CAD system in apparel industry in the future. SIGGRAPH 92 Chicago, July 26-31, 1992 remarkable 
timction to convert a 2D paper pattern into a 3D structure, which may be characteristic to 3D apparel 
CAD systems. Fm~ we input the 2D shape of each piece of a paper pattern as a collection of curved lines, 
assign the lines to be sewn together, and mark the lines which are to be put at some characteristic position 
of the human body ( e.g., waist line). Precisely, thii is a task of the 2D paper pattern edhor. Then 
the computer generates a triangular mesh on each piece, considering that the lines to be sewn together 
should be divided with the same proportion along each arc length, even though they have mutually different 
shapes and lengtha. We call this mesh in the 2D plane the P-mesh. NexL the topological structure of the 
3D garment ( S-mesh ) is obtained by unifying the edges and vertices of the P-mesh indicated to be sewn 
together. The cor­respondence between the triangles of the S-mesh and those of the P-mesh is one to one, 
while an edge or a vertex of the S-mesh may correspond to two or more elements of the P-mesh. At this 
poin~ the 3D coordinates of the vertices of the S-mesh are left open. The data structures for the P-mesh 
and S-mesh are de­signed to satisfy the defiition of the two dimensional sim-plicial complex, and thii 
facilitates the utilization of the concepts and results of elemental topology. The last step is to fiU 
in the 3D coordiites of the vertices of the S-mesh with appropriate values, providing a good initial 
state for the mechanical analysis. Let us take an example as in the case of a skin. Fus~ the vertices 
on the lines that are designated to be put at the waist line ( we denote these vertices as the Oth layer 
vertices ) are given the 3D coordinates along the waist line of the human body model. Then, each vertex 
adjacent to the (i-l)th layer vertices in the S-mesh is classified to be the ith layer, and they receive 
3D coordinate (k i x, ki y, Z-ai), where x, y and z are the average of the coordinates of adjacent vertices 
in the (i-l)th layer, ~d ki da i are &#38;terrnined by the standard mesh size and the numbers of vertices 
in the ( i-1 )th and ith layers. We regard this step as an analog of the process to put a dress on a 
human body. Aa the standard characteristic portions of the human body for this step, we selected the 
neck line, arm holes, waist line ( for skirts ) and crotch-waist lines ( for panta ). 4. Mechanical analysis 
The mechanical elements considered in the present version of our system are expressed by the following 
energy terms: E= Eau+Eau +Esh+Ebu +Ebv+Etw +Eg+EP, where Eau and Eau are elongation energiez, Esh is 
the shearing energy, i!?bu and Ebu are bending energies, E tw is the twisting energy, Eg is the gravitational 
energy and EP is the energy of a potential function of which the value is O at the outside of the body 
and Zfd2 inside the body, where d is the distance from the surface of the body and ~ is an appropriate 
large value. Note that the deformation energy terms Eau, Eau, Eak l%bu, Ebv and Etw should be calculated 
by referring to the original position of each triangle in the P-mesh, because the directions of the warp 
( u-axis ) and weft ( u-axis ) in the 2D pattern determine the anisotropic properties of each triangular 
element in the S-mesh. The term EP is known as the pedty function for the violation of the boundary condition. 
From the viewpoint of treating the human body as a deformable objec~ the penalty function method is not 
an expedience, but is the first order approximation, while a completely hard surface corresponds ordy 
to the Oth order approx­imation. We do not take into account the mutual interference of each prut of 
cloth, because it requires a large amount of calculation[4]. So, it sometimes happens that two different 
parts of cloth penetrate each other, causing a destructive effect for the 3D view. Presently, the appearance 
is covered by shifting one pstt upward, but we recognize that this ia not the true resolution and we 
are determined to take up this problem in the near future. Our method for fiiding the minimum point of 
the energy function highly contributed to the development of this system, with its robusmess, efficiency 
and compactness by means of both the program size and data memory area. It can be claasitled as a mutant 
of the steepest descent metho~ bu~ since we control the size of the step in each variable independently, 
the total vector of one step is no more directed to the gradiqnt of the energy function. The spirit of 
the step control is very simple. One step ia tried to the decreasing direction of the energy. If the 
value of the partial derivative of energy by that variable does not widely change, one can proceed more 
boldly, i.e. with a larger step. If the value of the partial derivative widely changes ( for example, 
the sign changes ), then one should reduce the scale of the step the next time. Though it is not mathematically 
proven for general cases, many experiments showed that this method never loses control and it ends in 
a certain minimum solution. Moreover, we tested this method with many classical sample functions known 
to be difficult to attain the minimum, and its robustness and efficiency were well confkrted. 5. Development 
from 3D to 2D It is natural to think that it would be quicker and more straightforward to make a 2D pattern 
diredy from a 3D form by developing or flattening it. However, with more considerati~ it is noticed that 
the process to flatten a curved surface to a plane is different from the process to force a pattern on 
a pkme to take tie form of the given curved surface, and the real process to make a dress from an undeformed 
cloth is equivalent to the latter. So, we solved a sort of inverse problem to obtain a 2D pattern that 
will take the given 3D form after its spontaneous deformation, as follows. Although there are some trials[3], 
it is not easy to define and edit a curved 3D surface of a human body or a garment with standard I/O 
devices of present graphic workstations. Therefore, we project the domain of the 3D surface with a preliminary 
mapping 0, in order to obtain an initial shape of the 2D pattern. Here, we use a very simple 0 that maps 
a point on the body expressed as (r,@, z) by the cylindrical coordinate system to a point (r08, z) by 
the two dimensional Cartesian coordinate system, where rO = 10cm. Then we define some dmta in the initial 
2D pattern and generate a P-mesh on iL Nex4 we operate the inverse map of @ to the vertices of the P-mesh 
to obtain the S-mesh. This time, we consider the energy E required to &#38;form the P­mesh to the S-mesh 
as a function of the 2D coordinates of the vertices of the P-mesh, and the minimization problem of E 
is solved by the same method for the 2D +3D simulation. Since EP is independent from the w coordinates 
of vertices, it is omitted in the minimization. We also neglect Ebu, Ebv, Ebv, Etw and Eg since the changes 
of these terms are higher order functions of the infinitesimal deformation of the S-mesh. Aa a resul~ 
the final shape of the 2D pattern and the distribution of the Computer Graphics, 26, 2, July 1992 Figure 
3 Examples of simulated garments and their paper patterns SIGGRAPH 92 Chicaao, Julv 26-31, 1992 residual 
strain that could not removed by the darts are dmplayed. There is no guarantee that the developed 2D 
pattern will take the very indicated 3D form because the cloth is no more constrained on the indicated 
surface in the natural draping process. In other words, there are 3D forms that can never be realized 
by draping. Therefore, the developed pattern should be checked by the 2D~3D simulator, and it should 
be modiikxl until a satisfactory 3D drape form is obtained. 6. Further results and future problems Some 
experiments were made to check the agreement between the real material and the results of the calculations[6]. 
The differences of the draped shapes were no more than 3% of the length of the cloth in the standard 
experiments using rectangular specimens and less in the experiments using actual skirts. Considering 
that displacement of specimens by deformation is very large and that some percentages of variance in 
the me­chanical properties of a given cloth are usual, the agreement is satisfying. The results of the 
measurement of the contact pressure were more striking. We observed that even the smallest sensor embedded 
in the contacting object caused a concentration of pressure, and the total stress always exceeded the 
weight of the specimen. On the other hand, the total stress and the weight weed precisely in our simulation[lO]. 
The mechanical parameters of fabrics used in our system were measured by KES, a fabric measuring system 
developed by S. Kawabata. But when compared with hard materials like metals, our knowledge about the 
mechanical properties of cloths is still very incomplete and there are many problems in deducing mechanical 
parameters for our simulation from the results of measurements. Although they are not considered much 
in our Pr=ent system, the optical surface character and mati&#38;re of cloths are very diverse, and they 
are important factors in the appearance of garments. There are some trials to model and visualize the 
touch of cloths[l 6, 17], but recognizing the variety from velvet to gossamer and from silk to leather, 
we realize that this is still a vast area to be explored. Precise and quick measurement of a 3D form 
of an object is very important in obtaining human body shapes and compuirtg the forms of actual garments 
with computed ones. At present, our model for the human body is based on a dress dummy measured by a 
contact type 3D digitizer. But in the future, the measurement of a customer s body in various postures 
or even in motion may be required. In response to such a request, we are now engaged in the research 
of a 3D measurement system based on color pattern recognition and muhi-TV camera stereo­ scopy[20]. Our 
system may have more applications. Paper is snother highly deformable 2D material widely used to produce 
3D forms and we have a special concern in simulating paper crafts or orig~ a highly geometrical traditional 
art of Japan. Our system may be interesting from the viewpoint of computational topology. As sewing and 
draping acunnpany large deformations, the mesh structures and their operations defiied in our system 
should be firrrdy based on topology. In turn, our system can help the visualization of topological operations 
since it can simulate the widely used rubber film model in topology. References ~ in Japanese 1. J. 
Amiibayat and J. W. S. Hesrle, The Complex Buckhmg of Flexible Sheet Materials -Part I. Theoretical Approach 
, International Journal of Mechanical Sciences 28 (1986), 339. 2. M. Aono, A Wrinkle Propagation Model 
for Cloth ,  Proceedings of CG INTERNATIONAL90 (1990), 95. 3. J. -L. Delaporte and R. !bm~ (personal 
communication). 4. B. V. Herzen, A. H. Barr and H. R. Zatz, Geometric Collision for Time-Dependent Parametric 
Surfaces , Proceedings of SIGGRAPH 90 (August 1990). lrt Ccmputer Graphics 24,4 (August 1990), 39. 5. 
H. Itnaok4 H. Okabe, H. Akami, et al., Analysis of Defor­mations in Textile Fabrics , Sen-i Gakkzishi 
44 (1988)+, 217. 6. H. Imaok&#38; H. Okabe, R. Matau&#38; et al., Estimation Method  of Textile Deformation 
-In the C e of Two-Dimensional ? Problem , Sen-i GaMuishi 44 (1988) ,229. 7. H. Imaok&#38; H. Okabe, 
T. Tomih% et al., Prediction of Three-Dimensional Shapes of Garments from Two-Dimensional Paper Patterns 
, Sen-i Gakkaislti 45 (1989)t, 420. 8. H. Imaok&#38; A. Shibuy&#38; N. Aistdm Automatic Paper Pattern 
Making Using Mechanical Development Method of a CurVed Surface on a Plane Surface , Sen-i GakkaMti45 
(1989)+, 427. 9. B. Lafleur, N. Magnenst-Thalmann and D. Thabrtanru Cloth Animation with Self-Collision 
Detection , Proceedings of IFIP WG5.1O -Modeling in Computer Graphics (1991), 179. 10. H. Niway~ H. 
Imaok% A. Shibuya and N. A&#38;@ Predicting Method of Contact Pressure of Fabrics , Sen-i Gakkzaishi 
~ (1989)+, 427.  H. Okabe, H. hnaok~ T. Tomih~ et al., Transformation hn Paper Pattern to Spatial Structure 
of Dress by Computer -Simulation of Sewing and Dressing , Sen-i Gakkuishi 44 (1988)t, 129. 12. H. Okabe 
and T. Ikawa Point Matching for Stereoscope by Bayesisn Inference , Computer Vision Graphics and Image 
Processing (submitted). 13. T. Sengsn, (peIzonal cxmummication)+. 14. W. J. Shanahan, D. W. Lloyd and 
J. W. S. Hesrle, Charsc­terizirtg the Elastic Behavior of Textile Fabrics in Complex Defonnations , Textile 
Research Journal 48 (1978), 495.  15. D. Terzopotdos, J. Platt, A. Barr and K. Fleischer, Elastically 
Deformable Models , Proceedings of SIGGRAPH 87 (July 1987). In Computer Grqhics 21,4 (July 1987),49. 
 16. J. Weil, The Synthesis of Cloth Objects , Proceedings of SIGGRAPH 86 (August 1986). In Conywter 
Gr@ics 20,4 (holy 1986), 49. 17. T. Yasuda and S. Yokoi, Shading Model to express the texture of cloth 
, Nikkzi Computer Graphics 1990, 2 (February 1990)t, 150.   
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134021</article_id>
		<sort_key>111</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>13</seq_no>
		<title><![CDATA[A simple method for extracting the natural beauty of hair]]></title>
		<page_from>111</page_from>
		<page_to>120</page_to>
		<doi_number>10.1145/133994.134021</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134021</url>
		<keywords>
			<kw><![CDATA[anisotropic reflection]]></kw>
			<kw><![CDATA[collision detection]]></kw>
			<kw><![CDATA[differential equation]]></kw>
			<kw><![CDATA[hair]]></kw>
			<kw><![CDATA[human modeling]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Color, shading, shadowing, and texture</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Curve, surface, solid, and object representations</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>G.1.7</cat_node>
				<descriptor></descriptor>
				<type></type>
			</other_category>
			<other_category>
				<cat_node>H.1.2</cat_node>
				<descriptor></descriptor>
				<type></type>
			</other_category>
			<other_category>
				<cat_node>I.3.3</cat_node>
				<descriptor></descriptor>
				<type></type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010401</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Volumetric models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003120.10003121</concept_id>
				<concept_desc>CCS->Human-centered computing->Human computer interaction (HCI)</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010399</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Parametric curve and surface models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002950.10003714.10003727.10003728</concept_id>
				<concept_desc>CCS->Mathematics of computing->Mathematical analysis->Differential equations->Ordinary differential equations</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010382</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Image manipulation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010372</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Rendering</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010382</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Image manipulation</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010382.10010384</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Image manipulation->Texturing</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
			<gt>Human Factors</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>P159675</person_id>
				<author_profile_id><![CDATA[81100085512]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Ken-ichi]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Anjyo]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Hitachi Research Lntmratory, 4026 Kuji, Hitachi, Ibaraki 319-12, Systems Engineering Division, IIitachi, Ltd., 4-6, Kanda-Surugadai, Chiyoda Tokyo 101]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>PP31098034</person_id>
				<author_profile_id><![CDATA[81332532943]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[Yoshiaki]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Usami]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Hitachi Research Lntmratory, 4026 Kuji, Hitachi, Ibaraki 319-12]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>PP31030512</person_id>
				<author_profile_id><![CDATA[81100170761]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>3</seq_no>
				<first_name><![CDATA[Tsuneya]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Kurihara]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Hitachi Central Resenrch LAmratory, 1-280 Higashi-Koigakubo, Kokubunji, Tokyo 185]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Arnold V. I. Mathematical Methods of Classical Mechanics (2nd ed.) Springer Verlag New York, 1989]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_obj_id>563893</ref_obj_id>
				<ref_obj_pid>965141</ref_obj_pid>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Blinn J. Models of Light Reflection for Computer Synthesized Pictures Computer Graphics 11, 3 (July 1977) 192 -198,]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_obj_id>83821</ref_obj_id>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Foley J., van Dam A., Feiner S. and Hughes J. Computer Graphics: Principles and Practice, Addison-Wesley, 1990.]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_obj_id>74361</ref_obj_id>
				<ref_obj_pid>74334</ref_obj_pid>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[Kajiya J. T. and Kay T. L. Rendering Fur with Three Dimensional Textures Computer Graphics 23, 3 (July 1989) 271 -280.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[LeBlanc A. M., Turner R., and Thalmann D. Rendering Hair using Pixel Blending and Shadow Buffers The Journal of Visualization and Computer Animation 2, 3 (1991) 92-97.]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_obj_id>617690</ref_obj_id>
				<ref_obj_pid>616019</ref_obj_pid>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[Magnenat-Thalmann N. and Thalmann D. Complex Models for Animating Synthetic Actors IEEE Computer Graphics and Applications 1 I, 5 (September 1991) 32-44.]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_obj_id>102332</ref_obj_id>
				<ref_obj_pid>102313</ref_obj_pid>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Miller, Gavin. S. P. From Wire-Frame to Furry Animals Proceedings of Graphics Interface "88 (October 1988) 138- 146.]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[Rosenblum, R. E., Carlson, W. E. and Tripp, III, E. Simulating the Structure and Dynamics of Human Hair: Modelling, Rendering and Animation. The Journal of Visualization and Computer Animation 2, 4 (October- December 1991 ), 141-148.]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Terzopoulos D. and Fleischer K. Deformable Models The Visual Computer 4, 6 (December 1988) : 306 -331.]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[Timonshenko S. Strength of Materials : Part 1 Elementary Theory and Problems D. Van Nostrand Company, Princeton, New Jersey, 1955]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
			<ref>
				<ref_obj_id>617720</ref_obj_id>
				<ref_obj_pid>616021</ref_obj_pid>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[Watanabe, Y. and Suenaga, Y. A Trigonal Prism-Based Method for Hair Image Generation IEEE Computer Graphics and Applications 12, 1 (January 1992), 47-53.]]></ref_text>
				<ref_id>11</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 z Computer Graphics, 26,2, July 1992 A Simple Method for Extracting the Natural Beauty of Hair Ken-ichi 
Anjyo*~ Yoshiaki Usami* Tsuneya Kurihara~ Hitachi, Ltd. ABSTRACT A simple differential equation method 
is proposed for modeling the aesthetic features of human hair. In the method, a simplified cantilever 
beam simulation is employed for hairstyle modeling, which allows hairdressing variations with volumetric 
and realistic appearance. In order to describe the dynamical behavior of hair in an animation, one-dimensional 
projective differential equations of angular momenta for linked rigid sticks are also derived. For the 
problem of collision detection between hair and a human head, the rough approximate solution is provided, 
which gives visually satisfactory results by solving the projective equations under a ps~udo-force field. 
The hair s pliability can be controlled by using a set of stiffness parameters in the method. In addition, 
a fast rendering technique for anisotropic reflection is introduced, which is derived from Blirm s specular 
model. The efficiency of the proposed method is illustrated by the still images and short animations 
obtained. CR Categories and Subject Descriptors: 1.3.3 [Computer Graphics]: Picture/image Generation; 
1.3.7 [Computer Graphics]: Three-dimensional Graphics and Realism. General Terms: Algorithms, Graphics 
Additional Keywords and Phrases: human modeling, hair, differential equation, simulation, collision detection, 
anisotropic reflection . Hitachi Research Lntmratory, 4026 Kuji, Hitachi, Ibaraki 319-12 t Hitachi Central 
Resenrch LAmratory, 1-280 Higashi-Koigakubo, Kokubunji, Tokyo 185 $ Current address: Systems Engineering 
Division, IIitachi, Ltd., 4-6 Kanda-Surugadai, Chiyoda Tokyo 101 Permis\mn to cxlpy without fcc all m 
pa-t O( this ma(erml is granted provided tha( [he copits we not made or distrihuted for direct commercml 
xfvantagc. the ACM copyrigh(notice and the titk nf [he publication and its date appew, mrd mmce IS gwen 
that copying is by permission ot the Awmwr!xm fnr Compu!mg Machinery To copy othcrwtsc. or 10 republish. 
requires a fec imd/or specific perrmssimr. 1. Introduction Modeling human characters is one of today 
s most challenging issues in computer graphics [6]. In particular realistic representation of human hair 
presents many problems to overcome, which appear in all aspscts of computer graphics technologies, i.e. 
rendering, shape modeling and animation. In the late 1980 s several new techniques appeared relating 
to synthe[ic hair representation, but most of them were oniy for rendering furry objects, such as a teddy 
bear [4] or spider [7], rather than human hair. More recent works [5, 8] have shown that naturalistic 
human hair rendering can also be performed as variations of previous research, including the above techniques. 
These successful results for rendering have ied us to achieve more realistic syntheses of human characters, 
aiong with the development of modeling and animation techniques. However research for hairstyle modeling 
or for describing dynamical behavior of hair is not compieted yet. In an actuai hairstyling process, 
many artificial techniques are provided by a hairdresser, such as shearing, perming, and combing. These 
may be very important factors in selecting a desirable hairstyle. Other essential factors lie in the 
natural and physicai properties of hair, which include hair color, width, pliability and volumetric appearance. 
Therefore a hairstyle modeling method for our purpose should be computationaily tractable, while considering 
these two aspects of achtal hairstyling: artificial and intrinsic factors. A previous work [11 ] proposed 
models for describing some artificial factors. The intrinsic factors may be achieved partiy by the rendering 
techniques mentioned above. However, for shape modeling of hair, a novel technique dealing with the intrinsic 
factors as weli as the artificialities is desired. In order to modei the dynamical behavior of hair in 
art animation, a physically based modeiing approach [9] may not be applicable. In a physically meaningful 
simulation, the number of unknown functions appearing in the derived differential equations must be too 
large to obtain satisfactory rcsuits at reasonable computational cost. In particular it is impossible 
to numerically treat seif-interaction or collision detection of a large amount of hair, typicaily tens 
of thousands of hairs. On the other hand, supposing several simpiiflcations, such as disregard for inter-hair 
coilision, a variation on the philosophies of physically based modeling haa been recently proposed [8]. 
In any case physically faithful dynamics of hair ,, 199? Ill ACM-()-X9791 -479 -l!92/(N)7/()1 1I $01.50 
SIGGRAPH 92 Chicago, July 26-31, 1992 can be considered to reflect an aspect of the hair s beauty, so 
that a differential equation approach would not be avoided. Consequently the differential equation approach 
for our purpose should employ easy-to-solve equations which still hold some aesthetics of hair as the 
physically faithful realities. This paper is therefore intended to provide a step forward in modeling 
the aesthetic features of human hair, focusing on hairstyling and dynamics. However, we do not emphasize 
the rigorous physics necessary for modeling. The heart of the proposed method lies in deriving simple 
differential equations as the visuii[ analogies, while abandoning a physically rigorous formulation or 
its simplification [9, 8]. This allows the method to employ several simple and intuitive ideas fol fast 
processing while preserving a visually satisfactory reality. The organization of the paper is as follows: 
In section 2 we describe the hairstyle modeling technique, which employs a simple ordinary differential 
equation governing cantilever beam deformation. The obtained hairstyle variations illustrate the efficiency 
of the proposed technique. In section 3, we introduce simple differential equations of one-dimensional 
angular momenta for describing dynamical behavior of hair. Collision detection or avoidance of hair strands 
is then discussed. The animation examples are also shown. In section 4 the rasterization process in our 
method is briefly presented. The computational costs are also discussed along with the examples obtained. 
In addition a fast rendering method for representing anisotropic reflection of hair is derived. Concluding 
remarks are made and further work is discussed in section 5. 2. Hairstyle modeling In our case a geometrical 
model of a human head with texture is obtained from the three-dimensional digitized data of an actual 
mannequin, whereas the textures of such items as eyes, mouth, and teeth are made by a designer using 
interactive operations. The hairstyle modeling then consists of the following steps: [~] Define an ellipsoidal 
hull of the head model, which can bc considered as a rough approximation to the head. Then also specify 
the region of hair pores on the ellipsoid. [~] Calculate hair bending, based on a simplified simulation 
of a cantilever beam. This process also includes collision detection between each hair and the ellipsoid. 
[y] Cut hair and modify with slight adjustment, in order to get the desired shape in the final stage, 
In step [a], the ellipsoid is employed simply for convenience in the design and calculation of hairstyle. 
For example, the pore positions are easily specified on the ellipsoidal hull, rather than on the original 
(polygonal) head model. This is because a polar coordinate system for the ellipsoid is available, which 
provides global guidance for explicit positioning. In addition, collision detection between the ellipsoid 
and hair is readily done at a low computational cost, compared to checking between the polygonal head 
model and hair. Though, of course the ellipsoidal approximation is not accurate for general purposes, 
we believe that it is still valid and efficient for extracting the beauty of hair which is described 
in this paper. The central idea of the modeling method is the use of a cantilever beam simulation for 
the hair bending calculation, which allows variations in hairdressing with volumetric and realistic appearance. 
The following sections are mainly devoted to describing the hair bending method. 2.1 The cantilever beam 
simulation for hair bending In the field of material strengths [10], the cantilever beam is originally 
defiied as a straight beam with a one-sided and fixed support, as shown in Fig. 1 (a). Let us employ 
the cantilever beam as our hair model, which is also shown iater [o give an efficient analogy for volumetric 
representation of hair. The hairstyle modeling method then involves the process of hair bending, which 
is actually interpreted as the numerical simulation of the cantilever beam deformation. In order to describe 
the simulation technique, a two-dimensional case is first treated for simplicity. Suppose that the cantilever 
bmrn of two-dimensions in an initiai state is set as shown in Fig. 1 (a), where one end of the beam is 
fixed. (This actually corresponds to the pore of a hair). Let us consider a typical case in which the 
beam is loaded by the external force g uniformly distributed on the whole beam, such as gravity. Then 
two types of model deformation may occur: one is caused by bending moment and the other is by shearing 
force. The former deformation is principally activated, whereas the latter does not affect our purpose. 
Thus we just consider the bending momentum deformation. Let the x-axis be along the initial beam direction, 
and the y-axis be vertical to the direction. The y-axis indicates the reflectional direction, with the 
variable y representing deflection of the beam. Assuming that the model is elastically deformed, the 
following equation governs the pO :pore 91=92=9 ;!3 Distribution loads of the cantilever beam (a) for 
hair model bending moment d! 2d! 3d I o x -gd ..----. ---.--l-..---..--.*@+ M3 , ...... ... ...H -3gd 
****I .*.9~ Ml1 *--* ! .egd .* * iI (b) Bending moment diagram Fig. 1 Bending moment of the cantilever 
beam   SIGGRAPH 92 Chicago, July 26-31, 1992 iyaxis node pi node R., zaxis / Fig. 7 The polar coordinate 
system for a hair segment Y L ~ PI applied force F /- y V8 FO=(F,V jV * ,8 plane&#38; i / x Fig. 8 Definitions 
of 0 plane and FFJ v x Fig. 9 Definitions of @plane and F~ which are defined as shown in Figs. 8 and 
9. The e plane is the plane sp~ed by the y-axis and the segment si. If Si is almost puallel to the y-axis, 
Lhen the 0 plane is defined using the y­axis and an applied force F instead of Si. The @plane is defined 
as the zx plane. Then, on these planes, the variables Bi(t) and $ i(t) with the time parameter t may 
be governed by the ordinary differential equations: d%i/dt2 = ci ui Fe. (4) d2~/dt2 G ci vi F@ (5) where 
ci corresponds to the reciprocal number of the inertia moment of si; Uj is (1/2) llSillj . vi is the 
half length of the segment that is the projection of Si onto the 1$plane; and Fe , F@ are the 9,@-components 
of the applied force F respectively, as shown in Figs. 8 and 9. The above e component Fe of the applied 
force field F is the scalar vaiue defined by Fe = llFell =(F, Ve), where VB is tie unit vector (i.e. 
the magnitude is equal to one) on the t3 plane that is perpendicular to the segment si. Similarly the 
$ component F@ is defined by F~ = IIFQII=(F, Vt$. where v~ is the unit vector on the @plane which is 
perpendicular to the projection segment of si onto the @plane. Our idea is that we employ one-dimensional 
projective equations (4) and (5) for describing hair dynamics, though originally these govern projective 
behaviors of our hair model. In the numerical simulation, these equations mean simple recurrence formulae 
of second order. Using the known values e n-1 and Oin, ~hc new value 8in+1 at the time (n+l)A t is 1 
obtained by ej +1-2ein +ejn-l=(At)2ciui F8 (4) n-1 n+l . Similarly, from @iand Qin , the new value @i 
M given by @i +1 -2@in + @in-l s (At)2civi F@ . (5) The calculation starts with the segment S1, and 
the new position of si is successively determined, using (4) and (5) . It should be noted that, in the 
calculation of (4) and (5) , the discrete time loop concerning the parameter n can be set as the inner 
loop while the outer loop is the segment number i. This would bc useful for saving time in calculating 
many frames of a huge amount of hair. An example of the initial condition is the hair is still at the 
beginning. Other conditions for the parameters or input information about (4) and (5) are described next, 
which also involves rough treatment of collision    SIGGRAPH 92 Chicago, July 26-31, 1992 segments, 
along with polygon data. It should also be noted that the technique can be extended to the case where 
the hair width in the obtained image is less than the pixel size. This is easily achieved by a oversampling 
technique. In Fig. 14, about 50,000 hair strands are described whose width is 1/4 pixel size and the 
image resolution is 1024x783. The presented method for modeling, rendering and animating of hair is implemented 
on a Silicon Graphics Iris Power Series workstation w ids a VGX graphics board. The provided hardware 
supports involves the z-buffer algorithm, anti-aliasing and linear color interpolation. Typically the 
generated model has about 20,000 hairs, each of which is at most 20 linear segments. The wall clock time 
for the hairstyle modeling (mainly for the hair bending calculation) was about 50 seconds, whereas it 
averaged around 40 seconds per frame in the animation calculation. As for a rendering time, it was usually 
several seconds. In particular, the image with a different camera angle was obtained in ahnost real time. 
Even in adding the anti-aliasing process, it took less than 15 seconds on average at 1024 x 1024 pixels 
resolution. Finally we note that the fast processing facilities of the method allow quick feedback in 
previewing. In particular, an animation preview is easily done under the condition that the number of 
hairs is less than a few hundred. Then hair segment data generation by the method for makhg an animation 
takes less than 2 seconds per frame. Consequently, after stacking the hair data for hundreds of frames, 
the near real time animation preview is performed by the fast rendering method. The projective equations 
allow numerically stable simulations, so that longer animations can be produced than those illustrated 
in this paper. However, interactive facilities would be desired for explicit specification of the external 
forces in pursuing more complex hair dynamics. 5. Concluding remarks This paper has presented a simple 
method for describing human hair, which is essentially a combination of simple ordinary differential 
equations and some intuitive heuristics. The obtained images have demonstrated well the efficiency of 
the method. It should then be noted that these differential equations are directly combined with the 
aesthetic observations, sacrificing rigorous formulation of physics. Moreover this allows to easily introduce 
fast processing and several efficient heuristics to the method, which is evident in particular for hair 
dynamics. The one-dimensional projective equations are solved under a pseudo-force field. Consequently 
the method provides a big advantage over existing approaches, in fast processing and descriptive power 
of hair s natural beauty. We are currently working on extending the method, giving rough approximate 
solutions of the problems in collision detection between hair and a human body or other objects, in order 
to deal with the long hair in a more general situation. The available range of the proposed method may 
still be small, compared to the diversity and variety of actual human hair. It is also understood that 
several assumptions used for the method do not hold in general. Nevertheless we feel the melhod is valuable 
as a first trial for extracting some aesthetic features of hairstyle modeling and animation of hair dynamics. 
  Acknowledgements The authors would like to thank Ryozo Takeuchi, George Nishiyama, Akio Yajima and 
Masao Yanaka for their continuous encouragement and support. Thanks to Munetoshi Unuma, Kiyoshi Arai 
and Hiroaki Takatsuki for helpful discussions. The first author thanks Takeshi Sato for his programming 
support. The authors also wish to thank Dr. Carol Kiktrchi for proofreading and suggestions. Reference 
[1] Arnold V. 1. Mathematical Methods of Classical Mechanics (2nd cd.) Springer Verlag New York, 1989 
[2] Blinn J. Models of Light Reflection for Computer Synthesized Pictures Computer Graphics 11, 3 (July 
1977) 192-198. [3] Foley J., van Dam A., Feiner S. and Hughes J. Compuler Graphics: Principles and Practice, 
Addison-Wesley, 1990. [4] Kajiya J. T. and Kay T. L. Rendering Fur with Three Dimensional Textures Computer 
Graphics 23, 3 (July 1989) 271 -280. [5] LeBlanc A. M., Turner R., and flalmann D. Rendering Hair using 
Pixel Blending and Shadow Buffers The Journal of Visualization and Computer Animation 2, 3 (1991) 92-97. 
[6] Magnenat-Thalmam N. and Thalmann D. Complex Models for Animating Synthetic Actors IEEE Compu/er Graphics 
and Applications 11, 5 (September 1991) 32-44. [7] Miller, Gavin. S. P. From Wire-Frame to Furry Animals 
Proceedings of Graphics Interface 88 (October 1988) 138­ 146. [8] Rosenblum, R. E., Carlson, W. E. and 
Tripp, HI, E. Simulating the Structure and Dynamics of Human Hair: Modelling, Rendering and Animation. 
The Journal of Visualization and Computer Animation 2, 4 (October-December 1991), 141-148. [9] Terzopoulos 
D. and Fleischer K. Deformable Models The Visual Computer 4, 6 (December 1988) :306-331. [10] Timonshenko 
S. Streng/h of Materials : Part 1 Elementary Theory and Problems D. Van Nostrand Company, Princeton, 
New Jersey, 1955 [11] Watanabe, Y. and Suenaga, Y. A Trigonal Prism-Based Method for Hair Image Generation 
IEEE Computer Graphics and Applications 12, 1 (January 1992), 47-53.   
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134024</article_id>
		<sort_key>121</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>14</seq_no>
		<title><![CDATA[Interval analysis for computer graphics]]></title>
		<page_from>121</page_from>
		<page_to>130</page_to>
		<doi_number>10.1145/133994.134024</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134024</url>
		<keywords>
			<kw><![CDATA[approximation]]></kw>
			<kw><![CDATA[constrained minimization]]></kw>
			<kw><![CDATA[constraint solution]]></kw>
			<kw><![CDATA[implicit curve]]></kw>
			<kw><![CDATA[inclusion function]]></kw>
			<kw><![CDATA[interval analysis]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Curve, surface, solid, and object representations</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>G.4</cat_node>
				<descriptor>Reliability and robustness</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Geometric algorithms, languages, and systems</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Raytracing</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>G.1.7</cat_node>
				<descriptor></descriptor>
				<type></type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010147.10010371.10010372.10010374</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Rendering->Ray tracing</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002950.10003705</concept_id>
				<concept_desc>CCS->Mathematics of computing->Mathematical software</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003752.10010061</concept_id>
				<concept_desc>CCS->Theory of computation->Randomness, geometry and discrete structures</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002950.10003714.10003727.10003728</concept_id>
				<concept_desc>CCS->Mathematics of computing->Mathematical analysis->Differential equations->Ordinary differential equations</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010401</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Volumetric models</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010399</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Parametric curve and surface models</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
			<gt>Reliability</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>PP39079343</person_id>
				<author_profile_id><![CDATA[81100167784]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[John]]></first_name>
				<middle_name><![CDATA[M.]]></middle_name>
				<last_name><![CDATA[Snyder]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[California Institute of TechnologyPasadena, CA]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Alefeld, G., and J. Hcrzberger, Introduction to Interval Computations, Academic Press, New York, 1983.]]></ref_text>
				<ref_id>ALEF83</ref_id>
			</ref>
			<ref>
				<ref_obj_id>55282</ref_obj_id>
				<ref_obj_pid>55279</ref_obj_pid>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Bajaj, C., C. Hoffman, J. Hopcrofl, and R. Lynch, "Tracing Surface intersections," Cm~uterAided Geometric Design, 5, 1988, pp. 285-307.]]></ref_text>
				<ref_id>BAJA88</ref_id>
			</ref>
			<ref>
				<ref_obj_id>74364</ref_obj_id>
				<ref_obj_pid>74334</ref_obj_pid>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Kalr~ Devendra, and Alan H. Ban-, "Guaranteed Ray Intersections with Implicit Surfaces," Computer Graphics, 23(3), July 1989, pp. 297-304.]]></ref_text>
				<ref_id>KALR89</ref_id>
			</ref>
			<ref>
				<ref_obj_id>93276</ref_obj_id>
				<ref_obj_pid>93267</ref_obj_pid>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[Mitchell, Don, "Robust Ray Intersections with Interval Arithn~tic," Proceedings Graphics Interface '90, May 1990, pp. 68-74.]]></ref_text>
				<ref_id>MITC90</ref_id>
			</ref>
			<ref>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[Mitchell, Don, ".Throe Applications of Interval Analysis in Computer Graphics," Course Notes for Frontiers in Rendenng, Siggraph '91.]]></ref_text>
				<ref_id>MITC91</ref_id>
			</ref>
			<ref>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[Moore, R.E., Interval Analysis, Prentice Hail, Englewood Cliffs, New Jersey, 1966.]]></ref_text>
				<ref_id>MOOR66</ref_id>
			</ref>
			<ref>
				<ref_obj_id>1098639</ref_obj_id>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Moore, R.E., Methods and Applications of Interval Analysis, SIAM, Philadelphia.]]></ref_text>
				<ref_id>MOOR79</ref_id>
			</ref>
			<ref>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[Moore, R.E. "New Results on Nonlinear Systems," in Interval Mathematics 1980, Karl Nickel, ed., Academic Press, New York, 1980, pp. 165-180.]]></ref_text>
				<ref_id>MOOR80</ref_id>
			</ref>
			<ref>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Mudur, S.P.0 and P.A. Koparkar, "'Interval Methods fog Processing Geometric Objects," IEEE Computer Graphics and Applications, 4(2), Feb, 1984, pp. 7-17.]]></ref_text>
				<ref_id>MUDU84</ref_id>
			</ref>
			<ref>
				<ref_obj_id>52091</ref_obj_id>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[Ratschek" H. and i. Rokne, New Computer Methods for Global Optimization, Ellis H~ Limited, Chichestet, England, 1988.]]></ref_text>
				<ref_id>RATS88</ref_id>
			</ref>
			<ref>
				<ref_obj_id>97891</ref_obj_id>
				<ref_obj_pid>97880</ref_obj_pid>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[Segal, Mark, "Using Tolerances to Guarantee Valid Polyhedral Modeling Results," Computer Graphics, 24(4), August 1990, pp. 105-114.]]></ref_text>
				<ref_id>SEGA90</ref_id>
			</ref>
			<ref>
				<ref_obj_id>145840</ref_obj_id>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[Snyder, John, Generative Modeling: An Approach W High Level Shape Design for Computer Graphics and CAD, Ph.D. Thesis, California Institute of Technology, 1991.]]></ref_text>
				<ref_id>SNYD91</ref_id>
			</ref>
			<ref>
				<ref_obj_id>134094</ref_obj_id>
				<ref_obj_pid>133994</ref_obj_pid>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[Snyder, John, "Generative Modeling: A Symbolic System for Geometric Modeling," to he published in Siggraph "92.]]></ref_text>
				<ref_id>SNYD92a</ref_id>
			</ref>
			<ref>
				<ref_obj_id>130368</ref_obj_id>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[Snydex, John, Generative Modeling for Computer Graphics and CAD: Symbolic Shape Design Using Interval Analysis, to be published by Academic Press, summer 1992.]]></ref_text>
				<ref_id>SNYD92b</ref_id>
			</ref>
			<ref>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[Suffem, Kevin G., and Edward Facket~ll, "'Interval Methods in Computer Graphics," Proceedingsof Ausgraph '90. Melbourne, Australia, 1990, pp. 35-44]]></ref_text>
				<ref_id>SUFF90</ref_id>
			</ref>
			<ref>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[Timmer, H.G., Analytic Backgroundfor Computation of Surface intersections, Douglas Aircraft Company Technical Memorandum CI-250-CAT- 77-036~ April 1977.]]></ref_text>
				<ref_id>TIMM77</ref_id>
			</ref>
			<ref>
				<ref_obj_id>325233</ref_obj_id>
				<ref_obj_pid>325165</ref_obj_pid>
				<ref_seq_no>17</ref_seq_no>
				<ref_text><![CDATA[Toth, Daniel L., "'On Ray Tracing Parametric Surfaces," Computer Graphics, 19(3), July 1985, pp. 171-179.]]></ref_text>
				<ref_id>TOTH85</ref_id>
			</ref>
			<ref>
				<ref_obj_id>37415</ref_obj_id>
				<ref_obj_pid>37402</ref_obj_pid>
				<ref_seq_no>18</ref_seq_no>
				<ref_text><![CDATA[VonHetzen, Brian P. and Alan H. Barr,"Accentc Sampling of Deformed, Intersecting Surfaces with Quadtroes," Computer Graphics, 21(4), July 1987, pp. 103- i 10.]]></ref_text>
				<ref_id>VONH87</ref_id>
			</ref>
			<ref>
				<ref_obj_id>76222</ref_obj_id>
				<ref_seq_no>19</ref_seq_no>
				<ref_text><![CDATA[Vee Hetzen, Brian P., Applications of Surface Networ~ to Sampling Problems in Computer Graphics, Ph.D. Thesis, California In#titut~ of Technology, 1989.]]></ref_text>
				<ref_id>VONH89</ref_id>
			</ref>
			<ref>
				<ref_obj_id>97883</ref_obj_id>
				<ref_obj_pid>97880</ref_obj_pid>
				<ref_seq_no>20</ref_seq_no>
				<ref_text><![CDATA[Von Herzen, B. A.H. Bart, and HR. Zatz, "Geometric Collisions for Time-~nt P~c Surfaces," Computer Graphics, 24(4), August 1990, pp. 39-48.]]></ref_text>
				<ref_id>VONH90</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 z Computer Graphics, 26,2, July 1992 Interval Analysis For Computer Graphics John M. Snyder CaliforniaInstituteof 
Technology Pasadena, CA 91125 Abstract This paper discusses how interval analysis can be used to solve 
a wide vari­ety of problems in computer graphics. These problcrna include ray tracing, interference detection, 
polygonal decomposition of parametric surfaces, and CSO on solids kmnderf by parametric surfaw?s. Ordy 
two basic afgorhfuna MErequired SOLVE,which computes solutions to a system of constraints, and MINIMIZE,which 
computes the global minimum of a function, subject to a system of constraints. Wepresent algorithms for 
SOLVEmd MINIMIZEusing intervaf analysis as the conce~uat framework. Crtrciafto the tedtnique is the creation 
of inclu­sion functions for each eoastraint and function to be minimised. Inclusion functions compute 
abound on the range of a function, given a similar bound on its domain, aflowing a branch and bound approach 
to constraint solution and constrained rnirrimir.ation.Inchrsion functions also allow the MINIMIZE algorithm 
to compute global rather than local minima, urdike many ofher numerical algorithms. Someveryrecenttheoretical 
results arepresentedregardingexistenceand uniquenessof roots of nonlinear equations, and global parameterizsrbllity 
of implicitly described manifolds. To illustrate the pwer of the approach, the hadc algorithms are further 
developedinto a new afgotithm for the approx­imation of implicit curves, CR Categork: 1.3.5 [Computer 
Graphics]: Computations Geometry and object Modeling; G.4 [Mathematical Software]: Reliability and Robustness 
Additional Key Words: constraint solution, constrsinczt minimization, in­terval analysis, inclusion function, 
approximation, implicit curve 1 Introduction Intervaf anatysis is a new and promising branch of applied 
mathematics. A general treatment can bs found in [MOOR66] and [MOOR79], by R.E. Moore, the originator 
of this field. The main benefit of intervst analysis is that it can solve problems an that the results 
are guaranted to be correct, even when computed with finitely precise floating point operations. flris 
is accomplished by using inclusion functions that compute bounds on functions relevant to the problem, 
thus controlling approximation errors. Although the application of interval methods to computer graphics 
is nor new, it haa been applied only to a limited class of computer gra~tcs prob lents. Mudur and Kopswkar 
[MUDU84] have presented m sdgorithm for raaterizing parametric surfaces using interval arithmetic. They 
also suggest the utility of such methcda for other operations in geometric modeling. T@h [TOTH85] has 
demonstrated the usefulness of interval baaed methods for the direct ray tracing of general parametric 
surf=. Most recently, inter­val methods have been used for error bounding in computing topological properties 
of tolerance polyhedra [SEGA90], for contouring 2D functions Pcmuwmn to copy wlthtwt fee All or parl 
c>fthis materialis granted provided(htitthe copici we notmadeor distributedfordmect commercialwfvmhrgc.the 
ACM cnpyright notice and the titIe nf the publication and i[i &#38;ItCoppcm.and notice is given that 
copyingis by pcrmiwion{>fthe Associationfnr Computing Mach! nery. Tn copy otherwise, (w In republish, 
requires a fee and/nr yxcific permission and rendering implicit surfaces [SUFF90], and for ray tracing 
implicit sur­faces [MITC90]. Several researchers have also used Lipaehitz bounds, a S*SI CMeof M interval 
method, in their algorithrrtx to approximate fWS­ntetric surfaces [VONH87], to compute collisions between 
time-dependent parametric surfaces [VONH89,VONH90], and to ray trace implicit surfaces [KALR89]. This 
paper extenda the work of these researchers by showing how a gen­erat set of problems in computer graphics 
can be solved using only two algorithms that employ interval analysis: constraint solution (SOLVE) and 
constrained rrdrsirtdzation(MINIMIZE). Many of the ideas presented here are krrowed from recent work 
in the area of interval amatysis ([IUTS88, ALEF83]), but are new to computer graphics. flrese ideaa inchr&#38; 
the X­trsalafgorithrna for SOLVE(Section 3.1)and MINIMIZE(Section 3.3), anda robust test for the solution 
of nonlinear systems of equations (Swtion 3.2). Section 2 presenta bsckgrod information neccsaary for 
the understanding of these ideaa. Using the techniques described, Section 4 presents a new, robust algorithm 
for the approximation of implicit curves, an important af­gorithm in shape mcxieling operations such 
as CSG. 1.1 Problem Deflnitlon for SOLVE and MINIMIZE SOLVE computes solutions to a consfraintprobkm, 
which seeks points from a domain, 1 D C R , that satisfy a logicat combination of equalities and inqualities. 
That is, it seeks the set given by where F: R + {O, 1} represents the constraint to be solved. For example, 
F(x) may be given by the simultaneous satisfaction of the r +s constraints gj(x) = o i=l,. ... r /lj(X) 
< 0 j=l, ....s The scalar functions gi(.r) and hj(~) are called the consfrainlfwrcrionals, and are assumed 
to be continuous. Related to the constraint problem is what we call the cons;rainedpar?i­tioning problem, 
which seeks to partition a domain D into a collection of hyper-redangles, {Ri}, such that each partition 
/?i satisfies a given set con­straint. A se; constraint is a mapping from a hyper-reciarrgle to {0, 1}. 
For example, let S R* + R he a parametric surface, and let R C R 2. Define the dkmrrce function of the 
surface, d(ft), as themaximum distance between two surface points, mapped from R 2 d(R) E SUp{ll~(pI) 
 ~@)ll I PI, P2 E ~} A useful set constraint for the surface approximation problem, G@), is G(R) ~ (d(R) 
< t) (1) which rquires that no two pints on S from R be farther apart than t. A con­strained partitioning 
problem can afso be combined with a constraint prob lem, in order to partition the constraint problem 
s solution set. We will later show how SOLVE can be applied to the constrained partitioning problem. 
1WewitlUWMCh tin ofd pmbknuisahy~mtqk, alsoatkd . vector.valued intervalinSdm 2.t 2supdcmoussupmmum,u~ 
bud O(IM. rk W  !, 199~ ACM-()-89791 -479-l/92/(~7/0i21 $01.50 MINIMIZEcomputes aolutiom to a corwmined 
mininu don problem, which seeks the global minima of a scalar timetiortJ(x), called the objective funcrwn, 
over the pointa in a given domain that satisfy a system of non­ objective funetiorr 3 MINIMUMf ~ infv(x) 
Ix E ~, F(x) = 1} XGD,F(X)=I or its set of global minimizers Note that the MINIMUMoperators well-defined 
only if the feasible set of the constraint system is nonempty. We assume the eontinuiry of the objective 
function as well as the constraint fimctionsla involved in the definition of F(x). This, together with 
the eompactneas of D, guarantees that the Mini­mizers operator ia wetl-defined when the feasible set 
is nonempty. We will w the term g/ohlproblem for a constraint problem, eortatrained Partilionirrgpmblem 
or constrained miniiurtion problem. L2 SOLVE and MINIMIZE InComputsrGraphics SOLVE and MINIMIZEcan be 
applied to a wide variety of problems in ren­dering and geometric modeling. We shall deaeribe an important, 
but by no means exhaustive, set of examples in the following paragraphs. Further a~ piicatiom of the 
algorithms to computer graphics include scan conversion of parametric surfaces, pararnetridlmplicit representationconversion, 
aelee­tion of feaaible@timal parameters for parsmeteriz.ed shapes, and computa­tion of tolerance geometric 
queries such as point enclosure. Ray Tracing Rsy tracing a parametric surface, S(u, V} R 2 + R , in­volves 
a minimisation problem over (u, v) space. LA o and d be the origin and dkeetion, respectively, of a given 
ray. Aa in m85], to find the first intersection of this ray with S, we may solve MINIMUM1(U, V) (U,v)eq 
 F(.,v)=l where the objeetive function, r(u, v), is given by 4 S.(U, v) -ox SY(u, v) -OY w? v) % r(u,v)~min{ 
d , d , d } x Yz and the constraint function F(u, v) is given by (s(u, v) -o)xd=Osndr(u, v)~O Ray 
tracing of implicit surfaces cartbe aceomptiahed with a similar, lD mirt­irnizntion problem [MITC90]. 
Polygonal Decompnaltloss Approximating shape, aueb as a curve or sur­face, as a mllection of simple pieees 
is a fundarnentrdoperation in computer grapMcs. For example, we may wish to pr-odueca collection of trisngks 
that ap~~~t~ a ~c SUrf=t ~U, V), tO 50t0e erKOStokranee. SuekrWI approxnnatmn carsbe accomplished using 
constrained partitioning with the set mnstraint, G@), from Formula (1). For eaeh remrltarrt(u, v) partition, 
a set of triangles can be formed joining the partition s four corner vertiees, as well as any vertiees 
from more highly aubdNided neighbor partitions (Fig­ ure 1). The whole collection of triangles approximates 
the surface without &#38;viating from it more than a distsneeof c. Set constrsintacan be ASObe &#38;­ 
fined that bound each partition s surfaa w maximum variation of surfti normrd, or any other function 
over the surf-. F@re 10 compares polygo­ nal decomposition using set umatrsinta with simple uniform sampling. 
 InterferenceDetedon LetS(u,v)andT(r,s)betwopmmetric surfaces, with DS and DT theiudomains. sur­ respective 
To rmmpute whether these faces intersect, the following 4D constraint problem is appropriate: SOLVE 
(S(u, v) = T(r, s)) (M,V)EQ (r,.)@f 3hf km Mmum,rhcSI=restb~ ~ fa*   41(myrayCrlnqmmtsuls.m =lmdwq-imttitiomkm, 
d dirdonarerquatroo, soisign.x cdinlhemin. * , I L 1 Figure 1: Approximating a surface as a triartgulartoed 
-The surfsee s pa­rameter spaec is first broken into rectangles each of whkh satisfies a set ematraint, 
controlling the appmxirrtdon quahty. A collection of triangles is then generated connecting points at 
the comers of the rectangle or its neigb­bora. In this case, evaluation of the points of intemeclion 
is umeceq we ned only eomputc whether or not the feaaibie set is empty. Siiar eonatmm t problems ean 
be solved to determine whether two moving srrrfatxa inter­sect, by solving a SD constraint problem given 
the thtte-depertdent surfsrxa S(U, V, t) and T(r, S, 1) [VONH90]. A related problem is to determine the 
minimum distance between two pametric arrrfaees, which maybe expressed as the urreonstrairredmini­mization 
problem WIIMIM IIS(U,v) -T(r, s)[I (2) (,,.)6% F@re 11 shows the results of the unconstrained rninimbtiorr 
problem 10 comp@e the minimum dkisnce between two parametric surfaces. CSG Computing CSG operations on 
aolii represented by tkii ~ nc surface boundaries involves computing the curve of intersection between 
pairs of parametric surfaces. The resulting curve ean be projected into the respective parameter spaces 
of the two srrrfams, and used to perform trimm­ing operationa. The curve of interaeclion ia an implicit 
curve solving a system of three equations in four variables, of the form SOLVE (s(u, v) = T(r, J)) (u,v)eD~ 
(,,.)E% where Sand Tare the two intersecting parametric surfaeea. This probkm is similar to the one 
presented for interference detection, execpttbat an approx­imation of the solution is desired rather 
than a mere indhtioo of solution existence. Such an approximation em be computed using the algorithm 
in Seetion 4, which is buiit on the SOLVE algorithm Figure 8 shows ttreresults of CSG operations computed 
in thk way. 2 Inclusion Functions Theinterval analysis approach to solving global problems works by 
recur­sively subdividing so initial hyper-rectatrgk of the parameter space of tbe global problem. Inclusion 
funetiorta are used to teat wbetbex a patticrdar region satisfies the ematraints (corratraintand minimization 
probkrna), wrr­tains points with a small enough value of the objective function (rnitdrrdxa­ tiorrproblem), 
or satisfies the set constraint (partitioning problem), by com­puting a bound on the function over the 
region. For example, to teat whether a region X inelu&#38;s a solution to the equation~(x) = O,an inelrrsion 
function forj is evaluated over the region X. If the resulting tmmd on~ does not contain O, t13enX may 
be rejected. The following section defines inclusion functions more precisely, diaeuases some of their 
properties, and explains how they may he implemented.  2.1 Terminology and Definitions An interval, 
A = [a, b],is a subset of R defined as [a, b]s{xla ~x~b, x,a, bCR} The numbers a and b are called the 
bounds of the interval; a is called the lower bound, written Ib[u, b], and b, the upper baurrd,written 
ub [a, b]. The symbol 1 denotes the set of all intervals. A vec~or-vsahudinrervalo~dirnerrsion n, A = 
(A t, Az, ..., An), is a stdmet of R defined as A~{.rl~i EAi~d AiEIfori =1,2,. ... n} For example, a 
vector-valued interval of dimension 2 represents a rectan­gle in the plane, while a vector-vafued interval 
of dknension 3 represents a %ick in 3D space. An intend A J that is a component of a vector-vafued interval 
is called a coordinate in~erval ofA. The symbol Imdenotes the set of all vector-valued intervals of dimension 
m. Hereafter, we will use the term interval to refer to twth intervals and vector-valued intervsfs; the 
distinction will be clear from the context. The width of an interval, written w([a, b]), is definedby 
w([a,b]) E b a Similarly, the width of a vector-valued interval, A E I , is defined as w(A) ~ ~~~ tiAi) 
Given a subset D of Rm, let I(D) be defined as the set of ail intervals that are sut3sets of D I(D) S{ 
YIYEf and Y~D} Let f: D + R be a function. An inclusionfunction for f, written Of, is a function .f:I(D)+ 
1 such that xE Y* f(x) E .f(y) W EW) In orher words, Of isa vector-valued interval hound on the range 
of f over a vector-valued interval bound on its domain. Many possible inehsaion fimc­tions maybe defined 
for a given functionf, each having different properties. For example, an inclusion function .f is cafkd 
convergent if w(x)+ o* W(Df(x)) + o Note thatf must be continuous for its inclusion function to be convergent. 
 2.2 Incluslon Functions for Arithmetic Operators To see how inehrsion functions can be evshsated on 
a computer, let us fit consider functions defined using arithmetic operations. Let g and h be func­tions 
from Rm to R, and let X 6 Im. Let inclusion functions for g and h be given and evaluated on the interval 
X Og(X) = [a, b] Oh(x) = [c, dl Given these interval hounds on g and h, we can bound an arithmetic com­bination, 
g * h, where * represents addition, subtraction, multiplication or division. f his bound maybe computed 
by bounding the set Q . , deftned as Qaa{~*v[~E[a,bl,yE[c,4} Q* CM hC bourtdd within an intervaf using 
the we]l-known tedtrti ae of interval an lhmetic, which defines the operators + IJ, o, *O, and 7 o ac­ 
 [a+c, b+dl [a-d, b-c] [min(ac, ad, bc, bd), msx(oc, d, bc, M)] [dn(:, j,:> $),m($!~! :,$,] providedO 
f [c, dl Com~uter Graphics, 26, 2, JUIV1992 The inchraion functions defined above rely on an infinitely 
precise rep rcsentation for real numbers and arithmedc operations. To perform interval analysis on a 
computer, m intervaf A = [a, b] must be WNrnated by a machine irrterwdAM = [aM,bM] containing A, so that 
aM and b~ aremem­bersof the machine s set of tkating point numbers. we earstrotassume that an inclusion 
function for g + h can be comtmcted by producing the intend [a +Mc, b+~~, where +M&#38;rtotes the hardwareaddition 
operator. Because of ddition rOUS2dinge-, a+n Cmy not &#38; a Iowa W for a+c. This problem can be salved 
on maebinea that usnfarm to the lEfiE floating point standard using using round-to- m mcxte for computation 
of interval lower hounda, sod round-to-+co mode for intervaf upper bosmda.  2.3 Natural Interval Extensions 
It is clear that the interval bounds of the previous section ean be mxmsively appliedto yield an inelosion 
frsnctiorrfor an arti~, tied ~ onof arithmetic operatora on a ad of functiom with known inehtsion functions. 
For example, an inehssionfursetionforf + (g + h) is given by n(f+(g + h)) s Of+IZ (Og +a Oh) (3) Fwthermore, 
this n~ion can be extended to non-arithmetic operators. For -h operator,P(fI ,fz, . . . ,.h), that producesa 
function given n simpIer functions, we must define a method, Pa, that evahsates an inclusion func­ tion 
for P, dependktg only on the interval results of the inclusion functions ofi. Let -h of tk functiomfi 
be defined on a domain D andletX E I(D). Given Po. assinclusion function for P(fI,. . . .f ) is then 
given by WV, ,fz , ,.. ,fn)(xl ~ POCYtKh afi(xl,. ~., f.(x)) In a generalization of Equation 3, given 
a set of qeratora, PI, Pz,.... PN, an inclusion function can bc evstuated for any function formrd by 
tbek com­position (e.g., PI (Pz(fi,fz), PJ(fg))). Inclusion functions corratructedin this way are called 
natural extensions. interval Construction of an operator s inclusion function method may not be dif­ficult 
if the operator s monotonicity intervafs are known. For example, an inclusion function evaluation methcd 
east be &#38;fined for the eoairw operator, baaed on the observation that the eoaine function is monotonically 
decreas­ing in the interval [~2rr, @n + 1)], and monotonically increasing in the in­tervaf [T(2JI+ 1), 
T(2n + 2)], forintegerrr. Letf be a function from R to R, and let X c I . f-et an inclusion functiom 
forf be given and evaluated on the intenml X, yielding the interval [a, b]. Assinehsaionfunction for 
coa (f) can be evaluated on X sccording to the following rules: WSn([a, b]) S  ( [-1;1], [-l, max(cos(tr), 
coa(b))], if ~~1 <$ and [:1 mod2= [min(eos(a), cua(b)), 1], if (~l<$and [~lmod2=0 { ( [min(ecm(o), cm(b)), 
tiw tWX(COS(@,em(b))], tI-wnumericsd cosine evakations implied by rain (coa(a), coa(b)), for ex­ ample. 
must be eomprsted so that they area lower bound for the Mid result. Similar inclusion functions cart 
be constructed for operators such ss sine, square root, exponential, and logarithm. Inclusion functions 
for vector and matrix operatiom are also easy to con­struct. For example, m inchrsion function method 
for the dot product oper­ator can be defined via .(f. g)s (ofl .0 .gl)+0(of2*Oag2)+0...+0(of. .0 ctg.) 
Similarly, interval arithmetic can he used to define inehsaion funetian meth­ ods for the matrix multiply, 
inverse, and &#38;terminant operators, and for vec­ tor operatora like addition, subtraction, length, 
acalhsg, and emaa product. 2.4 Inclusion Functions for Relational and Lq#cal Op­erato~ Inclusion functions 
cart also be defined for relational and logical qeratora, allowing natural interval extensions for functions 
used as wnatrsdnts. A relational operator produces a result in the set{ 0,1 }, O for fafse and 1 for 
he . l%e operators eqrsaf to, not aqtsalto, less tbast, andgreater thanorequaltoamallbmafyfelafiotudopemtors.An 
inclusion hrnctions forarelational operator,such asIeu than,caneasilybe&#38;6sted.Letf andg be functions 
fmm R to R, with given iochtsiott functions, .j and Rg. Let X E I , and .f(x) = [a,b] .g(x) = [c, dl 
 Then we have [0,o], ifd~a a(f.cg)(~~ [1,1], ifb<c [0, 1], otherwise{ Logicat operators, such as and, 
or, and n@ combine reardts of the refs­tiomd operators in Boolean expressions. Their inclusion functions 
am also easily tfefittod. For example, if rl and r2 are two relational functions front R to {O, 1}, and 
OrI and .r2 are their corresponding inclusion functions, then an inclusion function for the logicsd and 
of the relations, r I A r2, is given by [0,0] , if Or, = [0,0] or .r2 = [0,0] .(rl A~)S [1,1], ifOrl 
=[1,1] andO~ =[1,1] [0, 1], otherwise {  2.5 Mean Value Forma Glvena diffcrentiahlefurtctionfi Rm ~ 
R , with pararnetera.q, x2,.. ., .%, an inclusion fitnctiott, calfed the rneun vahu~orm, cartbe constructed 
for-f as follows: .$(y) S f(c) +a .~ (Y) .0 (1 -O c) (4) wherec E Y,YE Imand .t~ is art inclusion function 
for the Jacobian matrix off, i.e., That the at-me forrntttarepresents a vahd inclusion function for~ 
is an imme­diate consequertceof Taylor s theorem. The mean vatue form has the rrsefut property that, 
under certain amditioos, the resutting bound 00 ~ quadrat­ically converges to the ideally tight bound 
as tbe width of Y shrinks to O (Krawczyk-Nickel1982 fora formal statentent andpmof, see [SNYD92b]). Note 
thatthe addition, subtraction and -x-vector mrdtiplication opera­tions implied by this definition are 
computed using interval arithmetic. 5 The ensuingtrcatmettt of interval analysis will drop the . subscripts 
for interval arithmetic operstiou, it should bc clear by the context whether the standard opwatiotts 
or fheii intend analogs are meant. The idea of a mean value form can be gerteralimd to produce inclu­ 
sion functions that incorporate more terms of a fmctioo sTaylor expansiom called T~lorfomu. A related 
inclusion function, called the monolorricify­ test inchrsionfunction,is alsodefitted using inclusion 
fisnctiottaon the partial derivatives off [MOOR79]). By testing whether these derivatives exclude O, 
(i.e., the function is monotonic with respect to a given parameter), very tight bounds cart bc produced. 
Mcart vahse forms cart ah be detincd for functions which are only pieccwise differentiable (see ~TS88]). 
3 Solving Global Problems 3.1 Constraint Solution Algortthm A system of constraints can be represented 
as a function, E R ~ R, that re­turns a 1ifthecorrstrairttsaresatisfiedandaOiftheyarenot. Suchafunction 
can incorporate both eqtrality and ineqtrahty cxmstrainta,and can he repre­sented with the relational 
and logical operators whose irtchrsicmfunctions were examined in Section 2.4. Aa dtscuaaed in Section 
2.4, an inclusion function for F, .F, over a region X C 1 can take on three possible vsfuex .~(x). [t), 
1] * X is an indeterminate m@tr OF(X) = [1, 1] ~ X is a feasible region An iqfeosibk rsgion is a region 
in which no point solves the constraint sys­tem. Afeasible regwn is a region in which every point solves 
the cortsfrairtt system. An ina%lerrninaferegion is a region in which the constraint sys­tem may of may 
not have solutions. We now present aft algorithm to find solutions to this constraint system. Algorltbm 
3.1 (SOLVE) We are given a constraint irtchssionfunction .F, an itdtiaf region,6 X, in which to find 
solutions to the corrstrrdntpvblem F(x) = 1, and tbe solution acceptance set coftatraint, m, specifying 
when an indeterminate region should be accepted as a solution. place X on list L while L is nonempty 
remove next region Y fmm L evahsate ~ onY if OF(V = [1,1] add Y to solution else if OF(Y) = [0,O]dkcard 
Y ckeifO A(Y) = [1,1] add Ytoaolutiors else subdhide Y into regions Yj and Y.2, and insert into L endwhile 
Subdivision in Afgorifhm 3.1 can he achieved by dividing each candi­date interval in hatf afong the midpoint 
of a singte dhneosion. By storing the irt&#38;x of tfte last suMivided dimension with each region, the 
afgonthrrt carscyclicstly sttlxMi&#38; all dhnenaions of the isitiat region, ensuring that the width 
of cattdklate regions tenda to O as the number of iterations in­creases. Grt the other hand, by knowing 
properties of the constraint sys­tem whose solutions are sought, we cast offen deduoe smafler regions 
that bound the solutions, especially through the use of internal Newton methods [TCYTH85,RATS88, SNYD92b], 
The Hartaen-Greenbergalgorithm is an ef­ficientmethod for finding zeroes of a function ~TS88] and uses 
exhaustive suMlvisiou interval Newton mcthcds, and local Newton methods. 3.1.1 The Problem of Indeterminacy 
Algorithm 3.1 finds a set of intervals bounding the solutions to the wmstram t system. Jnparticular, 
by the pmpefty of inclusion functions, if this algorithm finds no solutions, then the constraint system 
has no solutions, because a region Y is rejected onfy when .F(Y) shows that it is infeasible. It can 
afso he proved that the consffaiftt solution algorithm converges to the acftraf solution set, when the 
inclusion functions used in the cquahty znd inequatky conatrairrtaare convergent (see, for example, [SNYD92b]). 
Unfortunately, a computer implementation of the constraint soiution sl­gofithm cats not iterate fofeve~ 
it must terminate at some iteration n and sc­cept the rermdrtingfegions as solutions. Espeziatly wftenequalky 
coostmints are used, the afgorithm may accept some indeterminate regions, which may contain zero, one, 
of more solutions, when these regions satisfy the solution acceptance set constraint. This problem is 
mitigated by several factors. Fret, it maybe enough to distinguish between the case that the cortatmint 
problem possibly has solutions (to some tolerance), and the case that it has no solutions. For example, 
to compute interfermm &#38;text ion between two parametric surfaces, SI, S2:R2A R3,a constraint system 
of three equations in four variables can be solved of the form S](UI, VI)= S2(U2, V2) If we instead 
solve tbe relaxed constraint problem IIs](rq, VI) -S2(M2,V2)II< c the algorithm can hope to produw feasible 
solution regions, for which the wmatrsinfs are sslisfied for every point in the region. 7 Such relaxed 
con­ %biOilidresiOOXcmbein6ni*iftb31dmiqucOfiw&#38;ilcimlcdadhnw&#38;-isud(W [IrA fass]). 7NOteMtbe SOhniCntOrhCacurwof 
maaeaimhelvmenlblwa Umf-e4fmkmisrypidy ~M-hym~dspd mtimd&#38;-prnufffkhti fwOIUrracr.s60nxinrmec1mdhmadOOOtIotvelhesysremr# 
 eqUAms.TherdUatpmbkm.rm becshuhmat,tu, sotu60mforwhichofmdtenoushsiz 1mci@bothondeisccnqktdyccmuimdWirhinlb 
IOhuiOn *. stmirrt problems are called c-collisions in [VONH89]. If arty feasible re­gions are found, 
the surfacca interfere, within the tolerance. If all regions are evetiuatly found to be infeasible, the 
surfaces do rsrAinterfere within the tokstrtee, and in fact come no closer than c. h is also possible 
that ordy indeterminate regiona are accepted as solutiona. In this case, we may con­sider the two surfacca 
to interfere to the extent that our limited floating pint precision is able to ascertain. second, we 
may know a priori that the system has a single solution. Let the solution ace.eptance set corrstrrtirrthave 
the simple form M(Y) a (s@ <t) If the inclusion functions bounding the constraint equality and inequrdity 
functions are convergent. then the solution approximation produced by Af­gorirhm 3.1 achieves any degree 
of accuracy as c goes to O. Third, we msy be able to compute information about sohrtions to the con­straint 
system as the afgoritbstr progresses. Section 3.2 presents a theorem specifying conditions computable 
with interval techniques under which a region contains exactly one xern of a system of equations. Finally, 
we carsrelax the constraints of a constraint system and/or accept indeterminate resultsof the algoritbrn. 
In practice, although we carsnot guar­antee the validity of such results, they are nevertheless useful. 
 3.1.2 Termination and AcceptssneeCriteria for Constraint solution SOLVE can be applied to five specific 
problems: t. find a bound on the set of solutions 2. determine whether a solution exism 3. find one 
solution 4. find all solutions 5. solve a constrained partitioning problem  The foliowing discussion 
analyzes the application of Algorithm 3.1 to these spific problems, making the distinction between heun 
sfic approaches, in which the results are not guaranteed to be correct, and robu.r/ approaches, in which 
the results are guaranteed to be correct. Algorithm 3. I never rejects a region unless it contains no 
solutions to the constraint prcblem. Therefore, an unmcr&#38;fied Algorithm 3.1 can be used to robustly 
find a set of regions bounding the solutions to the constraint system. Such a solution superaet is often 
useful in hlgber-level algorithms, such as the implicit curve approximation atgoritbm of Section 4. The 
solution super­ set can also be visualized to obtain a rough idea of the nature of the solutions, even 
if the solutions form a multidimensiorrsd manifold rather than a finite set of points. To determine whether 
a solution exists, if the algorithm terminates with so empt y list of solutions, then the afgontbm should 
return the answer no . If at any point the algorithm finds a feasible region, then the algorithm can 
immediate y terminate with the answer yes . If the algorithm finds only in­determinate regions, then 
nothing can be conciuded with certainty. A heuris­tic solution is to return yes anyway. This heuristic 
approach carsbe made more robust through the choice of an appropriate solution acceptance set constraint. 
For example, in solving the system ~(x) = O for a continuous functionj, it is reasonable that a region, 
Y, before being accepted m a soiu­tion, should satisfy w(llf(Y)) < L5 for some small 6. The algorithm 
should report an error when none of the in­determinate regions satisfy the acceptance criteria, before 
the machine pre­cision limit is reached during subdivision. A robust solution to the problem can be achieved 
by testing indeterminate regions for the existence of solu­tions, using the test of Section 3.2. Totind 
any single solution to a constraint system, Afgontbm 3.1 may con­clude that the entire starting region 
is infeasible, or find a feasible region. In Orelatter case, any point in the feasible region is chosen 
as a representative solution and the atgorithm is hafted. Indeterminate regiona are beuristicatly accepr~ 
whentheysatisfy the solution acceptance set constraint. ney may also be tested for the existence of solutions, 
again using the test of Sec­tion 3.2. Algorithm 3. I can also be applied [o the problem of finding all 
solutions to a constraint system, when a finite set of solutions is expected. Again, if Computer Graphics, 
26, 2, July 1992 B m   !33? El Figure 2: Solution aggregation -The soiution by Algo regions returnedrhhm 
3.1 are the collection of nondaabed squares. The actual solutions are marked by dots. An dequate level 
of suMivision has beersachieved so that sets of contiguous regions encompass each of the four solutiona, 
and each contiguous region may be bounded in an intervat (dashed boxes) that is dis­joint from other 
such regions. the aigorithrrrterminates with an empty solution list, there are no solutions. If a feasible 
region is found, an infinite number of solutions exist. If ordy indeterminate regions are found, then 
a useful heuristic approach is to union all contiguous solution regions into a set of mutually disjoint 
aggregate re­gions, as shown in Figure 2. A point inside each aggregate region is picked as a solution. 
If the number of solutions is known beforehand, then the algo­rithm cart be terminated with an error 
condkion if the miwhlne precision is reached in suMivision with a number of aggregated regions uoequat 
to the number of solutions. Of course, we note that although this approach almost always works correctly, 
it is still heuristic, since, for example, one region may contain no solutions while another czmtairrstwo. 
A robust approach is to test for solution existence in each aggregated region. In this case, reachb-tg 
the machhw precision limit during subdivision withnut being abie to verify solution existence should 
result in an error termination. Finally, to solve a constrained partitioning problem, Algorithm 3.1 must 
be sIightly modified so that it adda a region to the solution only when 0,4 is true, regardless of the 
value of .F. Alternatively, the constraint inclusion can be set so that it returns tme (i.e., tbe constant 
[1, 1]) for all regions. The solutionacceptanceset corrstraintthen becomesthe set constraint of the constrained 
partitioning problem. 3.2 Interval Tests for Solutlon Existence and Unlque­neas An interesting sod useful 
remdt can be proved that guarantees the existence of a unique zero of the furrction~. RM+ RRin an interval 
domain X. Theorem 3.1 (Ba*Rokne 1987) LetF R + R be continuously differ­entiable in art interval domain 
X, sod let c E X. f-et OJ be the interval Jacobian matrix off over X, i.e., Let Q k the solution set 
of the linear interval equation in x f(c) +Cu(. c)= o That is, Q= {Xl 3JE .Jsuchtkar\(c)+J(x c)=O} IfQ#0andQ 
~ X,tbenf hasauniquezeroinX. A proof of this theorem can be found in [SNYD9 2b]. The hyptbeak of the 
theorem cars kc verified using practicsd computations in several way~. First, if the interval determinant 
of IW is not O, then Q C c a~-lj(C) where .J -1 is tie interval matrix inverse of OJ. We CSSStherefore 
compute I15 the interval inverse of the Jacotkn matrix Ct.1,mmpute Q* ~ C-~-if(C) and verify that X 
C Q*, in order to show the existenee of a unique solution in X. Gther methods involve Gauss-Si&#38;l 
iteration on the linear equation [RATS88], or usc of linear optimisation [SNYD92b]. We note that the 
theorem is not useful in every ease, sirsee if there is a sero ofj in X at p, and the determinant of 
the Jaeobhrr off at p is O,then we can never verify solution uniqueness using thk theorem. We stso note 
that an interval test for solution existenee (but not necessarily uniqueness) can he found in [MGGR80]. 
The appendix discusses a test that indkites when a region has atmost one zero. 3.3 Minlmlzatlon Algorlthm 
Theconstrained minimizntiorr problem involvesfinding the global minimum (or global minimisers) of a fuoctionfi 
R + R for afl points that satisfy a constraint function 1? R -+ {O, 1}. This umstraint function is defined 
exactly as in Section 3.1. Algorithm 3.2 (MINIMIZE)We are given a constraint inclusion timction .F, a 
solution aeeeprarsce set constraint, OA, an inelusion function for the objective function, Of, and an 
initial region, X. The variable u is a pro­gressively refined least upper bound for the vatoe of the 
objective function~ evaluated at a feasible pint. Regions are inserted into the priority queue L so that 
regions with a smaller lower hound on the objective functia~ have kc X on priority queue L nitialir.e 
upper bound u to +co uhlle L is nonempty get next region Y from L if .A(Y) = [1, 1] add Yto solution 
eke subdivide Y into regions Y1 and Y2 evaluate .F on Y1and Y2 if .F(Yi) = [0, O]discard Yi evaluate 
Of on YI and Y2 if lb .~(Yi) > u dl~~d Yi insert Yi into L aczording to lb .~(Yi) if Yi contains an identified 
feasible point q u = min(u,f(q)) else if Yi contains an unidentified feasible point u= min(u, ub .~(Yi)) 
ersdif endif ndwhile Let the region U~ be thei-th region on the priority queue L after n while loopiterations 
of the algorithm. I-et u be the value of u at iteration n, and let 1. be given by 1 s lb Oj(fJ;) The 
interval U: is called the leading condi&#38;a/e intervol, and has the smallest lower bound for the value 
off. Letf be the minimum value of the objec­tive function subject to the constraints. We note that if 
a region X contains feasible points for the constraint function F, therr~ . exists. Given existenee of 
a feasible point, an important property of Algorithm 3.2 is In <f < u. Vn Algorithm 3.2 suffers the 
same problems that Afgorithm 3.1 does, in that an indeterminate region (i.e., a region Y for which .F(Y) 
= [0, l]), mayor may not include feasible points of the system of constraints. This implies that the 
rdgorithm may accept indeterminate regions as solutions that are, in feet, infeasible. Moreover, if the 
constraints cart never be satisfied exactly, (e.g., they are represented using equafity mrrstraints), 
then all candidate regions are indeterminate, so that u is never updated. In this ease, the algorithm 
is unable to reject any of the candidate regions on the bask of the objective function bound and accepts 
all indeterminate regions as solutions. A robust solution to this problem is to use assexisterree test, 
such as the one presented in Section 3.2, to verify that a region contains at least one feasibk point. 
A heuristic approach is to eortaider inde@mbte regions of strtall enough width as if they contained a 
feasible point. lheae Metermi­rtateregions may&#38;subjected to an appqxhe -p-t that provides more umfi&#38;nck 
that the region contains a feasible point. Afgorithm 3.2 cart be enhanced with techniques that find feasible 
points, feasible points with a smalkr value of the objective function, or feasibk regions in which the 
objective timction is monotonic with respect to any input variable ~TS88]. 33.1 Termination and AeceptarseeCriteria 
for Minimization A constrained rninimiration poblem can be solved in three ways 1. find the minimum value 
of the objdve function 2. find one feasible point that minimi-the objective function 3. find all feasible 
points that rrtinimize the objective functiw  Slight mcsrMicationsto Algorithm 3.2 regarding when the 
algorithmic halted and when indeterminate regions are accepted as solutions CM make it appli­ cable to 
each of these spedic subproblems. To find the minimum value of the objective function, ~ ., Afgorithm 
3.2 should he terminated when a kadiig tildate intervaf, U ~, is eneotrntered with w(O~( iY~)) sufficient 
y small, given that U: contains at leastfeasi­ one  ble points In this case, the vafuef(q) should be 
returned for some q E U ~. This approach is justified because if U~ contains a feasible point then lb 
.f(U;) ~f ~ ub ~(@) This apprnaeh presumes that we can verify the preaenee of a feasible point in an 
indeterminate region before h machine precision is reached in sub­ division. Lack of this verification 
should result in some form of error ter­ mination. A heuristic approach is to accep indeterminate regions 
of smafl enough width (and, possibly, satisfying other criteria) as though they con­ tained a feasible 
point. Findhsg one or all minimizers of the objective function is a difficult prob Iem that is currently 
not amenable to completely robust solution. Under certain condkions9, Algorithm 3.2 emsverges, in a theoretical 
sense, to the set of global minimisers of the minimisation problem. In praetiec however, weoMain abound 
onthesetofglohal minimisers after atinitemmtberof iterations. Afthmrgh techniques exist to verify whether 
a given interval in this bound contains a kaf minitttkr of the minimization problem we wifl not know, 
in generaf, if thae local minimisers are afso global minimizers. If we know, a priori, that a singk gksbal 
rnirdrnizerexists, then the tech­nique of solution aggregation (Seetion 3.1 .2) can be used to eolkct 
candidate solutions into a single inkrval. We can then verify that the width of this in­terval tends 
to zero as the algorithm iterates. If we expect a finite ~t of glebsl mirrimizrs, then a reasonable heuristic 
approach is to aggregate solutions, and pick a point in eaeh aggregated region as a global minimizer. 
Such an aggregated mgiOISshould be small enough in width and satisfy other SC­tance criteria that increase 
eonfi&#38;noe that it rmntains a global minimizer.  4 Example: Approximating Implicit Curves An implicit 
curve is the solution to a constraint system F(x) = 1,.x . XC R , such that the solution forms a ID manifold. 
Implicit cmwes are ex­tremely useful in geometric modeling, especially for CSG and trimming w erations 
on parametrically described shapes. They ean represent, for exam­ple, the intersection of two pametric 
surfaces in R3, or the silhouette edges of a pametric surface in R3 with respect to a given view. The 
robustness of the algorithm presented here is superior to k.realmeth­ods soeh as ~M77,BAJA88]. Timmer 
s method, for example, sepamea implicit curve approximation into a hunting phase, wherr intersections 
of the implicit curve with a preselected grid are computed, and a trwing phase, where the curve inside 
esch grid eel] is traced to determine how to connect the intersections. The new afgorithm computes #nts 
on the impficit cmve using Algo­rithm 3.1, guaranteeing a bound 00 the resrsft. Ttds method is superior 
to 8W&#38;~ ilrervmbsJemjsemd,ltlmrlOfeaaibteirlrkoligiDd  pc&#38;be.aist*soy domeotc!xist 9A~t~~&#38; 
. sxuraueefasequmccotpoimsinrbeinuriordti fAbtedom,io rhueonvq m1gtobdMinializcr[RA1-sss]. Fk.ure 3: 
Implicit curve approximation -The figureon the left shows an im-plicit curv; satisfying ~; algorithm 
s assump;ons. It consists of three segments two closed segments, and one segment intersecting the boundary 
of the interval ofconsideration.The figureonthe rightshowsanapproxima­tion of the implicit curve. In 
this case, the algorithm produces thres linked lists of points as output, one for each segment of the 
implicit curve. local methods, such as Newton iteration, which are not guaranteed to con­verge. Ttmmer 
s rnethcd also fails to find a disjoint segment of the curve if it lies completely witbin one grid cell, 
while the proposed algorithm uses a globai pstrameterizahility criterion that subdivides parameter space 
until no curve segment can be lmt. The algorithm is similar to the one described in [SUFF90], but differs 
in three respexw it uses this global parametenrabil­ity criterion, it handles multivariate implicit curves, 
md it incorporates an approximation quality metric. 4.1 An Implicit Curve Approxlmatlon Algorithm The 
following arc inputs to the approximation algorithm 1. artinterval X E 1 , called the irrfervafof consideration, 
in whtch to approximatetheimplicitcurve. 2. aninclusionfunction.F(Y), Y E 1(X) for the constraint system 
defin­ing the implicit curve. 3. an inclusion function m(y), Y E I(X), called the approximation ac­ceptance 
inclusion function. This inclusion function tells when an in­terval Y is small enough that each segment 
of the implicit curve it con­tains can he approximated by a single interpolation segment between a pair 
of solution points.  algorithm works by subdividing the region X into subregions, called pro.rimareinlervals, 
that contain the implicit curve, satisfy the approximat­ion accqmutce inclusion function, and allow simple 
computation of the lo­cal topology of the curve. The algorithm makes the following assumptiotw 1. The 
solution to the constraint system F(x) = I is a continuous, 1D manifold. This implies that the solution 
contains no self-intersections, isolated singularities, or solution regions of dimensionaiit y greater 
than 1. It further implies that each disjoint curve segment of the solution is either closed or has 
endpints at the boundary of the region X. 2. The intersection of the solution curve with a proximate 
interval s boundaries is either empty or a finite collection-of points, nor a 1D manifold. Ilk assumption 
is unimportant for implicit curves with no segments entirely along the parametric axes. When the implicit 
curve does have such segments, the constraint system most be reposed (of­[en simply by a linear transformation 
of the parametric coordinates) as discussed in [SNYD92b].  Under these assumptions, each point on the 
implicit curve is linked to two neighbors, or possibly a single neighbor if the point is on the boundary 
of X. The output of the approximation algorithm is a list of cmes , where each curve is a linked list 
of points on a single, disjoint segment of the implicit curve, as shownin Figure3. Algorithm 4.1 (Implicit 
Curve Approximation) 1. Subdivide X into a collection of proxirmste intervnis bounding the impiicit 
curve and satisfying the approximation acceptance inciu­siorsfunction. This cars be accompiiahed using 
Algorithm 3.1. Fig­ ure 4 shows an exampie of a collection of proximate intervals. Computer Graphics, 
26,2, July 1992 2. Check each proximate interval for giobai puameteriaabiiity. The implicit curve contained 
in a proximate interval Y is called glo&#38;Uy paronreterizabk in a paransereri if thereis at moat one 
point in Y on the curve for my value of the i-th parameter (see Figure 5). ff the impiicit curve is not 
globally parameterizabie in Y for any pammetm, then Y is recursively suhshvided and teated again. 3. 
Find use intersedosu of the impikitcurvewithtbebnund8riaof each proximate interval, using Algorithm 3.1. 
Assumption2 impiies that this intersection will be empty or a finite collection of points. 4. Ensure 
that the boundary interudmu are disjoint in the giobai  pnrsrmeteriaabiiitypmmteter. Let i be the giobai 
parameterizabiiity parameter for a proximate interval Y, computed from Step 2. Tbis step checks that 
intersections of the implicit curve with rs boundary are non-overlapping in smorshate i, as shown in 
F@e 6, so that they can be utrambigtsotsalysorted in increaaing order of coordinate i. If Y sboundaryintersectionsarenotdisjointinparameter 
i, Y is recur­sively subdhided and retested. 5. Compute the connection of boundary intersedons in each 
proxi­mate interval. If an interval Y contains no boundary intersections, it can be dkarrded, because 
the global parsmeterizabiiity condition im­piies that the solution cannot he a closed curve entirely 
contained in Y. NW can the soiution be a cume segment that does not intemect ~s boundary, by Assumption 
1. M Y contains a single boundaryintemec­tion, then the solution is either tangent to a boundary of Y 
or pawes through a corner of Y, but does not intersect the interior of Y, If Ycontains more than one 
boundary intersection, tireboundary inter­sections are sorted in order of the global paramcterir.abiiity 
parameter i. For each pair of boundary intersections adjacent in parameter i, Aigm ritbm 3.1 is used 
to see if the solution curve intersects the i-th pmmeter hypcrplane midway between the two boundary intetiions, 
as shown in Figure 7. If so, the boundary intersections are connected in the Iocsi curve tcqmlogy iinired 
iist. 6. Find the set of disJoint curve segments comprising the implkit curve. After the impiicit curve 
has been traced ~nside of each proxi­mate interval, the iist of connected boundary intersections is traversed, 
using the foiiowing algorithm iet S be the set of boundary intersections while.$ is nonempty remove an 
intersection point P from S find and remove ail pointa Q in S that are (indirectly) connected to P *soci*e 
P andthe set Q with a new curve endwhile We note that in accumulating the act of points on a particular 
curve using this algorithm, if a point P EQis eventually found such that P=P then the curve is closed. 
Otherwise, the curve has two endpoints on the boundary of X by Assumption 1. Step 1 of the algorithm 
combines the constraint inciusion with the q proxiriMion accept-a= inclusion to create an initial collection 
of Proxiti intervals bounding the impiicit curve (subproblem 1 in section 3. 1.2). Step 2 ensures that 
each proximate interval satisfy a global pararmxerizabiiity cri­terion. Tire appendix presents a theorem 
i&#38;ntifying condhiorrs for global paratneterizstility, computssbie with intenwi tcctilqtses already 
discussed. This theorem pertains to the special case of a system of n -I continuously differentiable 
equality constraints inn parameters. We have also deveioped a more general but heuristic test for giobsi 
Prsrameterizalilily, dkcusaed in [SNYD92b]. Step 3 of the algorithm computes the intersections of the 
impiicit me with the boundary of each proximate interval. Algorithm 3. i is used with the original constraint 
inciusion, OF, md an initial region formed by one of the 2n (n-1)-sfimensionai hyperpianes kunding the 
proximate interval. For each boundary hyperpiane, Algorithm 3. i searches for ail the constraint sys­tem 
s solutions, producing a set of intervals bounding the solutions, caiied boundary intersection infervai.r. 
Boundary intersection intervals that are shared along edges or corners of contiguous proximate intervals 
sbouid be merged, as discussed in [SNYD92b]. Figure 4 Collection of proximate intervals bounding an 
implicit curve-In these examples, the constraint system is given by the equation A?+yz + cos(2mx)+ sin(27rv) 
+ sin(2ff~)cos(2~y2) = 1 Theintervaf ofconsiderationis [-1.1, 1.1] x [ 1.1, 1.1]. Theappmxirmr­tion acceptance 
inclusion function for the let? example simply requires that the width of the parameter space interval 
should he leas than 0.2, while that on the right guarantees the global parameterizaMlity of the solution 
in each intervaf. I. Examples Globally Parameterizable in x II. Examples Not Globally Parameterizable 
in x III. Examples Not Allowed by Assumptions TIEIPHZI  F@ue 5: Global Pararneteritilfity -The figure 
illustrates some of the pos­sible behaviors of an implicit curve in an intend. Steps 4 and 5 link boundary 
intersection intervals that are connected by the same segment of the implicit curve. Boundary intersection 
intervals are sorted in the global parameterikabilit y parameter, md each pair of adjacent intersections 
is tested. The test uses Algorithm 3.1 to discover whether the implicit curve intersects a hyperplarte 
midway between the pair of inter­sections. This application of the constraint afgoritbm need only ascertain 
whether a solution existq the location of the intersection point is not re­ quired. On the other hand, 
the intersection point earrbe used to better ap at little extra computationalcost. Fhlly, after all proximate 
intervafs have been examined, Step 6 asso­ciates each of the boundary intersection intervals with a disjoint 
segment of the implicit curve. A point insi&#38; each of the boundary intersection intervals should be 
chosen to represent the acturd point of intersection of the proxi­mate intm%d s boundary with the implicit 
curve. Tlds point can be chosen arbitrarily (e.g., midpoint of the interval) or computed using a lcal 
iterative. technique such as Newton s method. We note that an algorithm similar to Algorithm 4.1 can 
be used to generate approximationsof impficit surfaces [SNYD92S]. This algorithm dso U= the global parameterizaMlity 
criterion describedin the ap~ndix, for the case a q A B Figure 6 Boundary intersection sortabWy -Figure 
A illustrates a 2D inter­val containing four hourtdmy interned ions that are dmjoint in the x prrrame­ter 
(horizontal axis). fhey can therefore be sorted in x, yielding the ordering p, q, r,s. In figureB, boundaryintersections 
q and rare not disjoint in x (the dashed line shows a common x coordinate). 1. Boundary Intersections 
of an Implicit Curve II. Eight Cases of Implicit Curve Behavior III. Not Allowed by Global Parameterizabllity 
rzltswa  Figure 7: Global Par-ameterizatdity md the linking of boundary interjec­tions -In thii figure, 
we assume an implicit curve defined in R 2 ia globally parameterizatde in x in artinterval. The implicit 
curve has four intersections with the interval s Lmrmdary,as shown in I. Because of global parameteriz­ability 
and the curve approximation afgorithm s assumptions, there are ordy eight possible ways the implicit 
curve ean connect the Lmmdary intersec­tions, as shown in II. The Possibilities shown in III are not 
globafly param­eterizable in x, and are therefore excluded To disamblguate between these eight cases, 
we rrc%donly see if the implicit curve intersects the x hyperplarre (dashed vertical line in I) between 
each pair of adjacent boundary intersec­tions. of a 2D manifold rather than a 1D manifold. 5 Results 
Figures 8 though 11illustrate the results of the interval analysis algorithms. Running times for the 
examples ranged from about 5 seconds for the canpu­tation of the minimum distance between two parametric 
surfaces (F@e 11) to several minutes for the CSG example (Figure 8) on a HP9000 Series 835 Workstation. 
6 Conclusions We have shown how a variety of important problems in computer graph­ics can be solved using 
the technique of interval analysis. These problems include ray tracing, computation of tolerance polygonal 
decompositions, detection of eollisiorta, computation of CSG operations, approximation of silhouette 
curves, and many others. We have described two general kdgo­rifhms, eonstrairtf solution and cortstrairted 
minimization, which ean solve these problems either directly, or when used in a higher level aJgorifhm 
such as the implicit curve approximation afgotifhm of Seetion 4. The advantage of the approach advocated 
here is twofold. Robust so­lution of computer grapfdcs problems is achieved because interval analysis 
controls numerical error. A simple implementation is achieved because ordy two trade algorithms are necessary, 
which require inclusion functions for functions relevant 10 the problem. Definition of inclusion functions 
ia not difficul~ nafuraf interval extensions, a pimicukzr type of inclusion function, can be defined 
by implementing an inclusion function metbcd for each op erator used in the relevmt functions (e.g., 
the tithmetic opsratora and the cosine operator of Section 2.3). Mean value forma, another type of inclusion 
function, can be defined using natural interval extensions and a derivative operator. An entire, very 
powerful geometric modeling system can be built upon a act of operators exh having an inclusion method, 
such as the system described in [SNYD92a,SNYD92b]. Acknowledgments 1would like to thartk At Barr for 
his support and encouragement of the pub­lication of this research. Al Barr and Ronen Bat-d have provided 
many helpful comments md suggestions. This work was funded, in part, by IBM, Hewlett-Packard, and the 
National Science Foundation. References [ALEFW] Alcfcld, G., snd J. Hcrzberger,Intmductiun to Interval 
Computations, Academic Press, New York. 1983. [BAJA88] Bsjsj, C., C. Hoffman, J. Hopcmft, and R. Lynch, 
Tracing Suzface In­tersections, CorrrputerAidedGsmncfric Oe$igrz,5, 1988, pp. 285-307. [KALR89] Kalra. 
Dsvendw and Alm H. Barr, Gusrsntcxd Rsy Intersections with Implicit Surfaces, Computer Gmphics, 23(3), 
July 19S9, pp. 297-304. [mm] Mitchell, Dun, Robust Ray Intersecticmswith Interval Azidmrctic, Pzc­ceedings 
Clm@ics Interface 90, Msy 1990, pp. 68-74. [MJTc91] Mhchcll, Don, Thee Applications of Mend Anstysis 
in computer Graphics; Course Notes for Frontiers in Rendering, Siggmph 91. [MGGR66] Moare, R.E., Interval 
Ana/ysis, Prmticc Hskl, Englewood Ckiffs, New Jersey, 1966. [MOGR79] Murme, R.E., Methcxlsand Applica:iom 
of Interval Anafysis, StAM, Phhdelphia. [M~R80] Mourc, R.E.. f4ew Results on Nonlinear Systcrns; in Inttwal 
Math­ematics /980, Karl Nickel, cd., Academic Press, New York, 19S0, W. 165-180. [MUDU84] Mudur, S.P,. 
and P,A. Koparkar,Methods fc+ processing Gec­ kntezvatnretricObjects. /EEE CoenpulerGmphics and Applications, 
4(2), Feb, 1964, pp. 7-17. [RATS88] Ratschek. H. and J. RokzK,New CornputerMeMcdsforGI0601Optimiza­tion, 
EUisHorwoud Limited, Chichesta, Engkmd, 1988, [SEGA90] Segat, Msrk, UsingTolerances to Guarantee Valid 
Polyhedral Modeling Results, Computer Graphics, 24(4), August 1990, pp. 105-t 14. [SNYD91] Snyder, John, 
Gewmtiw Modeling: An .4pprtxmhto High Lmel Shape Oesignfor ComputerGraphicsandCAD, Ph.D. Thssis, Cafifomia 
Insti­[Uk of Technology, 1991. [SNYD92S] Snyder, John, GenerativeModeling: A Symbolic System for (kmnekic 
Modslingu to be published in Siggmph 92. [SNYD92b] %ydu, John, Genemtiw hfodeling for Computer Gmphics 
and CAD: SYm60fic ShapeDesignUsingIntcrvalAnaIysis, m be published by Aca­demic P2CSS,SU22U22C2 1992, 
 [SUFF9Q] SutTem, Kevin G., and Edwatd Fsckaell. fnteJwJ Methods in Computer GrapMcsV Proceedingsof Ausgrsph 
90, M.lboums, Australia, 1990, pp. 35-44. [ITMM77] Tii, H.G,, Ana/ytic&#38;ckgmwrd for Computationof 
Swface lntersec­fions,Oo@s ANZ4 CompanyTechnicalMmnorsndunrCI-250-CAT­77-0.36, April 1977, [TOTHR5] Toth, 
Daniel L., On Rsy Tracing Parametric Surfxes, Computer Graphics, 19(3), July 1985, pp. 171-179. Computer 
Graphics, 26,2, July 1992 [VONH87] Von Hct-zen,Brian P. and AJan H. Bazr;Accuratc .%nzplingof Defamsd, 
Jmusecting Surfaces with Quadtrus, Computer Gmp6ic$, 21(4), July 1987, pp. 103-I10. [VONH89] Vozt Hsrzen, 
Brian P., Applications of Surface Networks to .%npfing Pmkdems in Computer Graphics, Ph.D. Thesis. Cafifomia 
hzstitutc of Tecturdagy, 1989, [VONH90] Von Herzen, B.. AH. Barr. and HR. Zatz, Geometric Collisiau for 
T*Depen&#38;nt Pwamerxic Surfaces, Computer Gmphics, 24(4), Au­ gusl 1990,pp. 39-48. Appendix -A Robust 
Test for Global Parameteriz­ability Consider an rdimcnsicmsl manifold defined as he solution [o a systim 
of n -r cqux­tiOnsin npamnWem(r E{ O,l,.. ,,n-l)): fl(~l!~2,..., %) = o Jkr(xl, q,...,%) = o ~lvenamtofrpmt=iAka,A= 
{kl, k2, . ..lk,), andmintavat XE 1 , we detioss subimewufof X overA ass set dependiion rpammelm fY17Y2). 
..?Yrk yj E Xk,. ~fi~ by Thus, a subint~sl is m intervat subset of X, r of whose com-diitez area specikt 
C02kSW2t.and the rest of whose CO02dinStCSu= tbc karrx3as in X. The sokution to a system of n -r equations 
in n pamwrem is Cstkedgk2k47lfypa­mmstsn oz61e inrherparametas indexsdby A overanintavat Xifrhemisatrnmt 
one soJution to he system in my subintenak of X overA. Put -sizqrly, the system of equations is globally 
parameteriz.skdeif r parameters can be fuund -h that dzsre is at most ane sotution to the systcm for 
my paAculsr vahze of ths r pmametm in ths inrez vd. We &#38;fiZZSlJJ{kl ,k2,,,, ,k,, (X), cakledthe inwwzl 
Jacobianwbmalrix, w m (n ­r) x (n -r) intervalmatrix given by Forannx nintemat matrix O.M, we write det 
D.U+Oif tbcreexists nommtrix ME . IMsuch tbst &#38;t M = O. The following tbeaomz guarantees the gfobat 
px­rameterbxbfity of the solution in m inLe4wJX (for a Prcmf,-[SNY092bl). TbcuremA.1(IntcrvatImpfkdtFuncdonlbeoran) 
Let the camtmint hmedom fi(x), i = 1,2,. ..,.-rbscontinuoudy diff-ntiable. Letaregicm X E I es­ ist such 
hat &#38;10J(kl,k2,.,,, k,)(~#0 Then the Zulution 10the system OfCq2ationsf i(x) .0 is gJObOtlyparameWhMe 
in therpxrxmetsrs indexed by{kl, k2, . . ..k.)overX. Inrbc caseof appximatianof a ID zcdutiunmanifold, 
r = 1;i.e.. as~temofn -I quariom in n varixtdm is to bs solved. Tbc rheomm guarantees that if, in xn 
herd X,wecsnfindn-1 Pwsrncters such thsl then ths solution manifold is gkobakly paramcterizabtc in X 
over tbs paruneterx ~. MCI thus satisfies the constraint of Step 2. We can verify that dctaJ(q (X)# o 
by forming m inclusion function f-the d+xerminantof any of then intervxkJEobian submatrices using tbs 
intervsk arithmetic IWSsentcdin section 2.2.    
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134027</article_id>
		<sort_key>131</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>15</seq_no>
		<title><![CDATA[Interval arithmetic recursive subdivision for implicit functions and constructive solid geometry]]></title>
		<page_from>131</page_from>
		<page_to>138</page_to>
		<doi_number>10.1145/133994.134027</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134027</url>
		<keywords>
			<kw><![CDATA[anti-aliasing]]></kw>
			<kw><![CDATA[collision detection]]></kw>
			<kw><![CDATA[compositing]]></kw>
			<kw><![CDATA[computer-aided animation]]></kw>
			<kw><![CDATA[dynamic simulation]]></kw>
			<kw><![CDATA[image synthesis]]></kw>
			<kw><![CDATA[recursive subdivision]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Geometric algorithms, languages, and systems</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>G.1.0</cat_node>
				<descriptor>Numerical algorithms</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.3</cat_node>
				<descriptor>Display algorithms</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.3</cat_node>
				<descriptor>Viewing algorithms</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Curve, surface, solid, and object representations</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Hierarchy and geometric transformations</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Animation</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Visible line/surface algorithms</descriptor>
				<type>S</type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010399</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Parametric curve and surface models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002950.10003714.10003715.10003724</concept_id>
				<concept_desc>CCS->Mathematics of computing->Mathematical analysis->Numerical analysis->Numerical differentiation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010382</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Image manipulation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010372.10010377</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Rendering->Visibility</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010352</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Animation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010178.10010224.10010240.10010244</concept_id>
				<concept_desc>CCS->Computing methodologies->Artificial intelligence->Computer vision->Computer vision representations->Hierarchical representations</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003752.10003809</concept_id>
				<concept_desc>CCS->Theory of computation->Design and analysis of algorithms</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010401</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Volumetric models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010382</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Image manipulation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010372</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Rendering</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010382</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Image manipulation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010372</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Rendering</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002950.10003714.10003715</concept_id>
				<concept_desc>CCS->Mathematics of computing->Mathematical analysis->Numerical analysis</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003752.10010061</concept_id>
				<concept_desc>CCS->Theory of computation->Randomness, geometry and discrete structures</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>PP31074780</person_id>
				<author_profile_id><![CDATA[81100337249]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Tom]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Duff]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[AT&T Bell Laboratories, 600 Mountuin Avenue, Murray Hill, New Jersey]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_obj_id>93320</ref_obj_id>
				<ref_obj_pid>93267</ref_obj_pid>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[John Amanatides and Don P. Mitchell, "Some Regularization Problems in Ray Tracing," Proc. Graphics Intepfu&lt;e '90, ! 990]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378509</ref_obj_id>
				<ref_obj_pid>378456</ref_obj_pid>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Roncn Barzcl and Alan H. Bart, "A Modeling System Bascd on Dynamic Constraints," Computer Graphics 22(3 ). July 1988. 179-188]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_obj_id>74356</ref_obj_id>
				<ref_obj_pid>74334</ref_obj_pid>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[David Baraff, "'Analytical Methods for Dynamic Simulation of Non-penetrating Rigid Bodies," Computer Gr~q~hi~s 23(3). July 1989, 223-231]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_obj_id>808573</ref_obj_id>
				<ref_obj_pid>964965</ref_obj_pid>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[Alan H. Burr. "'Global and Local Deformalions of Solid Primitives," Computer Gr~q~hics ! 8(3), July 1984, 21-30]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_obj_id>808585</ref_obj_id>
				<ref_obj_pid>964965</ref_obj_pid>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[Lorcn Carpenter, "'The A-Buffer, An Anti-Aliased Hidden Surface Melhod." Computer Graphi~'s 18(3), July 1984, 1()3-1()8]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_obj_id>74343</ref_obj_id>
				<ref_obj_pid>74334</ref_obj_pid>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[Norman Chin and Steven Feiner. "Near Real-Time Shadow Generation Using BSP Trees," Computer Graphics 23(3), July 1989, 99-106]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_obj_id>808600</ref_obj_id>
				<ref_obj_pid>964965</ref_obj_pid>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Franklin C. Crow, "'Summed Area Tables for Texture Mapping," Computer Graphics 18(3), July 1984, 207-212]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_obj_id>325174</ref_obj_id>
				<ref_obj_pid>325165</ref_obj_pid>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[Tom Duff, "Compositing 3-D Rendered Images," Computer Graphics I9(3), July 1985, 270-275]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Tom Duff, "Polygon Scan Conversion by Exact Convolution," Raster imaging and Digital Typography '89, Cambridge University Press, London, 1989]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[Gerd Fischer, Mathematische Modelle/Mathematical Models, Friedr. Vieweg &amp; Sohn, Braunschweig/Wiesbaden, 1986]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
			<ref>
				<ref_obj_id>807481</ref_obj_id>
				<ref_obj_pid>965105</ref_obj_pid>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[H. Fuchs, Z. M. Kedem and B. F. Naylor, "On Visible Surface Generation by A Priori Tree Structures," Computer Graphics 14(3), July 1980, 124-133]]></ref_text>
				<ref_id>11</ref_id>
			</ref>
			<ref>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[IEEE Standard for Binary Floating-Point Arithmetic, ANSI/IEEE Std 754-1985, Institute of Electrical and Electronics Engineers, New York, 1985]]></ref_text>
				<ref_id>12</ref_id>
			</ref>
			<ref>
				<ref_obj_id>74364</ref_obj_id>
				<ref_obj_pid>74334</ref_obj_pid>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[Devandra Kalra and Alan H. Ban', "'Guaranteed Ray Intersections with Implicit Surfaces," Computer Graphics 23(3), July 1989, 297-306]]></ref_text>
				<ref_id>13</ref_id>
			</ref>
			<ref>
				<ref_obj_id>93276</ref_obj_id>
				<ref_obj_pid>93267</ref_obj_pid>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[Don P. Mitchell, "Robust Ray Intersection with Interval Arithmetic," Proc. Graphics Interface '90, 1990]]></ref_text>
				<ref_id>14</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122736</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[Don P. Mitchell, "Spectrally Optimal Sampling for Distribution Ray Tracing," Computer Graphics 25(3), July 1991, 157-164]]></ref_text>
				<ref_id>15</ref_id>
			</ref>
			<ref>
				<ref_obj_id>1098639</ref_obj_id>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[Ramon E. Moore, Methods and Applications of Interval Analysis, Society for Industrial and Applied Mathematics (SIAM), Philadelphia, 1979]]></ref_text>
				<ref_id>16</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122743</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>17</ref_seq_no>
				<ref_text><![CDATA[Shugeru Muraki, "Volumetric Shape Description of Range Data using "Blobby Model"," Computer Graphics 25(4), July 1991,227-235]]></ref_text>
				<ref_id>17</ref_id>
			</ref>
			<ref>
				<ref_obj_id>74355</ref_obj_id>
				<ref_obj_pid>74334</ref_obj_pid>
				<ref_seq_no>18</ref_seq_no>
				<ref_text><![CDATA[Alex Pentland and John Williams, "Good Vibrations: Model Dynamics for Graphics and Animation," Computer Graphics 23(3), July 1989, 215-222]]></ref_text>
				<ref_id>18</ref_id>
			</ref>
			<ref>
				<ref_obj_id>808606</ref_obj_id>
				<ref_obj_pid>964965</ref_obj_pid>
				<ref_seq_no>19</ref_seq_no>
				<ref_text><![CDATA[Thomas Porter and Tom Duff, "'Compositing Digital Images," Computer Graphics 18(3), July 1984, 253-259]]></ref_text>
				<ref_id>19</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122745</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>20</ref_seq_no>
				<ref_text><![CDATA[Sclaroff and Alex Pentland, "'Generalized Implicit Functions for Computer Graphics," Computer Graphics 25(4), July 1991,247-250]]></ref_text>
				<ref_id>20</ref_id>
			</ref>
			<ref>
				<ref_obj_id>74348</ref_obj_id>
				<ref_obj_pid>74334</ref_obj_pid>
				<ref_seq_no>21</ref_seq_no>
				<ref_text><![CDATA[Thomas W. Sederberg and Alan K. Zundel, "Scan Line Display of Algebraic Surfaces," Computer Graphics 23(3), July 1989. 147-156]]></ref_text>
				<ref_id>21</ref_id>
			</ref>
			<ref>
				<ref_obj_id>145840</ref_obj_id>
				<ref_seq_no>22</ref_seq_no>
				<ref_text><![CDATA[John Snyder, Generative Modeling: An Approach to High Level Shape Design for Computer Graphics and CAD, Ph.D. Thesis, California Institute of Technology, 1991]]></ref_text>
				<ref_id>22</ref_id>
			</ref>
			<ref>
				<ref_obj_id>37421</ref_obj_id>
				<ref_obj_pid>37402</ref_obj_pid>
				<ref_seq_no>23</ref_seq_no>
				<ref_text><![CDATA[W. Thibault and B. F. Naylor, "Set Operations on Polyhedra Using Binary Space Partitioning Trees," Computer Graphics 21(4), July 1987, 153-162]]></ref_text>
				<ref_id>23</ref_id>
			</ref>
			<ref>
				<ref_obj_id>97883</ref_obj_id>
				<ref_obj_pid>97880</ref_obj_pid>
				<ref_seq_no>24</ref_seq_no>
				<ref_text><![CDATA[Brian von Herzen, Alan H. Barr and Harold R. Zatz, "Geometric Collisions for Time-Dependent Parametric Surfaces," Computer Graphics 24(4), August 1990, 39-48]]></ref_text>
				<ref_id>24</ref_id>
			</ref>
			<ref>
				<ref_seq_no>25</ref_seq_no>
				<ref_text><![CDATA[J.R. Woodwark and K. M. Quinlan, "Reducing the effect of complexity on volume model evaluation." Computer- Aided Design 14(2t, March 1982, 89-95]]></ref_text>
				<ref_id>25</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 Computer Graphics, 26,2, July 1992 Interval Arithmetic and Recursive Subdivision for Implicit Functions 
and Constructive Solid Geometry Tom Duff+ AT&#38; T Bell Luboru!orie.s 600 Mountuin A l,enue Murray 
Hill, Ne~ .lersey 07974 Abstract Recursive subdivision using interval arithmetic allows us to render 
CSG combinations of implicit function surfaces with or without anti -aliasing, Related algorithms will 
solve the collision detection problem for dynamic simulation, and allow us to compute mass. center of 
gravity, angular moments and other integral properties required for Newtonian dynamics. Our hidden surface 
algorithms run in constant time. Their running times are nearly independent of the number of primitives 
in a scene, for scenes in which the visible details are not much smaller than the pixels. The collision 
detection and integration algorithms are utterly robust collisions are never missed due 10 numerical 
error and we can provide guaranteed bounds on the values of integrals. CR Categories and Subject Descriptors: 
G. 1.0 [Numerical Analysis ] Numerical Algorithms 1.3.3 [Picture and Image Generation ] Display algorithms, 
Viewing algorithms, 1.3.5 [Computational Geometry and Object Modeling] Curve, surface, solid and object 
representations, 1.3,5 [Computational Geometry and Object Modeling] Hierarchy and geometric transformations. 
1.3.7 [Three-Dimensional Graphics and Realism] Visible line/surface algorithms, Animation General Terms: 
Algorithms Additional Keywords and Phrases: anti-aliasing, compositing, computer-aided animation, recursive 
subdivision, image synthesis, dynamic simulation, collision detection 1. Introduction The most commonly-used 
geometric representations in computer graphics are local. Polygonal models, for example, specify which 
points are on an object s surface, and tell us nothing substantial about the rest of tbe space in which 
the object is embedded. except by omission. It requires substantial mental effort to formulate answers 
tp questions like Do these objects intersect ? , or What parts of this object are visible? or even 
something as simple as +What is the volume of this object? . More elaborate surface representations. 
like Bezier patches or NURBS don t make these questions any easier since they only describe tbe objects 
locally, they make it difficult to answer global questions about them. Likewise, the computational methods 
we normally use are mostly local. The ray-tracing algorithm, for example. tries to *Phone (908 ) 582-6485, 
email td@research. att .com Permission to copy wllhout fee fill or pwt of this materml n gmmeci provded 
thw the coptes me not made nr distributed for direc( commercial advantage. the ACM copyright notice and 
the title of the publication and It. date appear. and notice is given that copying IS by ~rmiwion nf 
the Association for Computing Machinery. To copy ntherwise. or to republisb, requmesa fee and/or specific 
Permission. compute an image one pixel at a time by testing every primitive in the scene for intersection 
with a ray from the eye-point through the pixel s center. Of course any decent ray-tracer goes to a lot 
of trouble to avoid most of this work. But an algorithm that had decent access to global information 
about the scene wouldn t need go to the trouble it would know immediately what parts of the scene were 
relevant to what parts of the screen, A good example of a global representation is the BSP tree [11]. 
Each node of a BSP tree gives useful information about the object s relationship to the whole of the 
space it s embedded in. The nodes effectively say about their subtrees, in this half of space, you need 
only think about this half of the model. BSP trees naturally engender simple algorithms for all sorts 
of geometric tasks, from hidden surface removal to object intersection [231 to shadow generation [6], 
Ihat make natural, effective use of the global information stored in the model. This paper will examine 
in detail another global object representation and its algorithms, based on implicit functions, Constructive 
Solid Geometry and interval arithmetic. Briefly, implicit functions are test functions for classifying 
points in space as inside, on or outside an object. Interval arithmetic allows us to extend those tests 
to whole chunks of space at once. Constructive Solid Geometry allows us to combine simpler objects, keep 
unwieldy primitives (like infinite cylinders) under control and model many important industrial and natural 
processes that go into creating geometric forms. 2. Implicit Functions Implicit functions are an indirect 
representation of solid objects. Given a function of three variables F( .x,y,: ), we can use the equation 
F(.t, y,T) =0 to specify the points on a surface. The representable surfaces range from the mundane to 
the exotic: from planes (at +by +t: +d =()) and quadrics the spheres, cones cylinders and paraboloids 
of elementary geomett -to more exotic polynomial surfaces like those of Kummer and Dupin [ 1()] to Barr 
s downright weird twisted, bent and tapered super­ellipsoids 141. If F is continuous, we can classify 
points as inside, on or outside the object depending on whether F <O, F = O or F > (). This is the global 
property we are after: F classifies every point in space in its relationship to the surface. In regions 
of space not crossed by the surface, the fact that F s sign does not change is a source of coherence 
useful in hidden-surface and other geometric algorithms that can be exploited by using interval arithmetic 
m quickly obtain bounds on F( i ,Y,U) for whole ranges of t, y and :. 3. Interval Arithmetic Interval 
arithmetic [ 16) generalizes ordinary arithmetic to closed, bounded ranges of real numbm. If X and ~ 
arc real numbers with XS~, then X is an interval x=[~,x]= {.[rl~<.r<i} ACM-O-89791-479-tW2KM)7K)l31 
$0150 SIGGRAPH 92 Chicago, July 26-31, 1992 The natural interval extensions of the elementary operations 
of arithmetic are x+ Y=[g+~,x+i] x Y=[~-i,I-~] -(1)XxY = [min(XY,~7,i~,I~) ,max(XY,X7,1~,XF)] . X/Y=[ 
11~,11~], but undefined if ~SO<~ These definitions give tight bounds on the range of the corresponding 
real functions with arguments chosen in the given intervals. In particular, for degenerate intervals 
like [a,a], interval arithmetic reproduces ordinary arithmetic. We can use these rules to compute bounds 
on the value of a rational expression F(.r,y,z) inside any box (X, Y,Z). Unfortunately, the achievable 
bounds on general arithmetic expressions are not as tight as on the arithmetic operators. For example, 
.r~~ [0,1] when .r= [ 1,1], but, by (l), XXX=[-1,1]. Generally, for intervals X, Y, Z, [F(., ,y,:)l.rG 
x, J GY,zEztcF(x,Y,z) but we cannot replace ~ by = except in special circumstances. A second source 
of looseness is that when using finite precision floating-point arithmetic, we must be sure to round 
the upper and lower bounds in the appropriate directions. Doing this is not the practical problem that 
it used to be machines claiming to do IEEE arithmetic [12] are required to provide control of the rounding 
direction of floating-point calculations. If instead you use improperly-rounded interval arithmetic, 
the errors introduced will not often be noticeable. Of course, such an implementation voids the warranty 
of robustness. Any F(X, Y,Z) composed using the rules ( 1) above is an inren al e.rterrsiorr of the corresponding 
real function. That is, ~([.r,-~1 ,[.Y,.vI ,[u, T])= [F(.~,.v, =) ,F(.\-,y, z)]. Furthermore, F is inclusion 
monotonic, That is, if X =X, Y GY and Z ~Z, then F(X , Y ,Z )GF(X, Y,Z). Moore [16] is a good general 
introduction to interval methods, and discusses these properties and their implications in detail. For 
purposes of this paper, it is sufficient that if .r~ X, y= Y and c= Z that F(x,y, z) E F (X, Y,Z). This 
is true for every inclusion monotonic interval extension of F(.r,y,:). We can easily construct interval 
extensions of most standard transcendental functions. For monotonic functions like e , In x, L, we have 
F(X)= [F(~), F (~)], or if F(x) is monotone decreasing, F(X) = [F(i) ,F(X) ]. Continuous func­tions that 
have maxima and minima in krr~wn places, like sin and COS, can be handled by taking the union of their 
values over monotonic pieces. For example [~ , i ] n odd or X>O  x = [x , ~ ] n even and ~SO [O,max(-~,~) 
] n even and ~<0<~ 1 These interval extensions all give tight bounds on the underlying transcendental 
functions, and expressions involving them yield inclusion monotonic interval extensions of the underlying 
real expressions. If ~(X, Y,Z) <0, we know that all points (.v,Y,z) with X= X, -vE Y and ze Z are located 
inside the implicit function surface F , and if F(X, Y,Z) >0 they are all outside. If F(X, Y,Z) sOS~(X, 
Y,~), we can guess that the surface might ~ntersect the cell (we cannot be sure unless we know that the 
bounds we ve computed are tight) and that it deserves closer examination. 4. Constructive Solid Geometry 
A powerful and natural tool for taming implicit functions and building useful geometric models from them 
is Constructive Solid Geometry (CSG). Since implicit functions describe volumes as point-sets, we can 
use them as primitives and build more complicated models using set-theoretic union, intersection, complement 
and difference operators. The union and set­difference operators can model the most important ways that 
people build real objects. Milling machines, saws, drills, routers and chisels are all (restricted) set-difference 
engines. Glue, nails, soldering irons and Velcro are set-union agents in the world of real solids, all 
unions are of disjoint sets. Set intersection allows us to focus attention on interesting or useful local 
features of implicit functions that may extend to infinity or otherwise behave wildly at a distance. 
In general, we will represent an object or scene as a tree with implicit functions at its leaves and 
CSG operators at its interior nodes. We will assume that the only oper?tors in the tree are union (SUT) 
and intersection (.Sn T). Set difference (.$ T) and complement (-S) operators can be eliminated by repeatedly 
applying the rules S T~Sn~T ~(SUT)+-ISn-T -fsn~)+=su=~ -F+ F, where F is a leaf function  The first 
rule converts set differences into intersections. The second two (deMorgan s laws) push complement operators 
toward the leaves. The third absorbs complement operators into the leaf functions. 5. Rendering Suppose 
we wish to make shaded images of a scene described as a CSG combination of implicit-function primitives. 
For simplicity, we will make an image by parallel projection in the z direction into the A-Yplane. (Perspective 
is a simple extension we can either incorporate the viewing transfomnation directly into the CSG tree 
s leaf functions or decorate the CSG tree with transformation matrices and transform coordinates as we 
walk the tree.) We are given a CSG tree and a rectangular viewing volume described by three intervals 
(X, Y,Z). For each leaf of the tree, we can do an interval computation to bound the value of the leaf 
s function in the viewing cell. If the upper bound is negative or the lower bound is positive, we can 
replace the leaf by the empty set @ or its complement U and simplify the tree by repeatedly applying 
the rules Ons+O, uns+s Ous+s, iws+u Now we can divide the viewing cell into 8 pieces by dividing X, 
Y and Z at their midpoints and repeat this procedure recursively. At each level of subdivision, replacement 
of primitives by constants will further reduce the CSG tree if we are lucky, the whole tree will reduce 
to a constant, in which case we need consider the cell no further, since it contains no surface. (We 
should always keep in mind that the reduced CSG trees are valid only within the corresponding cells.) 
Subdivision terminates when the bases of the cells are pixel-sized, at which point the reduced CSG tree 
should be very small t ypically only the one or two primitives contributing to the image at the pixel. 
At each level of subdivision we should first examine the sub-cells closest to the viewpoint and use a 
quad-tree or some equivalent data structure to keep track of which pixels are computer Gratshics, 26, 
2, JUIV1992 completely covered, allowing us easily to avoid examining more distant cells that will contribute 
nothing to the image. (This algorithm follows directly from the ~vde algorithm, described by Woodwark 
and Quinlan [25]. They use a similar subdivision scheme, but for CSG models whose only primitives are 
planar half-spaces. for which they need not resort to interval arithmetic to classify cells. ) The total 
expenditure required to sample the surface is nearly independent of the number of primitives in the model. 
This obviously cannot be true in the limit. Let us call a model realistic if by-and-large no more than 
a few primitive surfaces cross each pixel. (On a 1000x 1000 screen, a modeI can have several million 
(small) primitives and still satisfy this requirement. ) For realistic models, small cells will by-and-large 
contain reduced CSG trees with only a few nodes. Large cells, containing more complex trees, are much 
fewer in number depending on how many cells are culled by the coverage quad­tree, there are between 
three and seven times as many pixel-sized cells as there are cells of all other sizes combined. The great 
majority of the computation occurs in small cells, in which the size of the reduced CSG trees does not 
strongly depend on the complexity of the original model, When we have subdivided to the pixel level, 
we can sample the image using ordinary ray-casting methods, We substitute the ray s parametric equation 
(.r,y,:) = A +a(B A), where A and B are appropriate points on the near and far planes of the subdivided 
cell. into each primitive of the reduced CSG tree and find all values of a where the primitives go to 
zero. We discard values of ct for which the corresponding point is outside the object. as determined 
by substituting point coordinates into the leaves and evaluating the CSG operators. The smallest remaining 
a, if any, denotes the visible point on the surface, Papers by Amanatides and Mitchell ([ 14], [ 15], 
[ I]) answer in much more detail questions that may arise in implementing this sort of ray-casting procedure. 
 6. Anti-aliasing If point-sampling dissatisfies you (as it ought to!) then interval arithmetic can 
help do better. If we ignore for now the problems of highlight and texture aliasing (see [7], among numerous 
others, for apposite approaches to these aspects of the problem), then the anti-aliasing question hinges 
on identifying silhouette edges of primitives and intersection edges of CSG combinations, Ideally, we 
would compute in their entirety the visible portions of all significant edges and use an exact convolution 
method like that of [9] to compute an anti-aliased image. As this appears to be too much to hope for, 
we must satisfy ourselves with a careful treatment of the simple cases that affect most pixels, approximating 
the rest as well as we can afford. (For simplicity, we will assume that we are using a box filter to 
sample the image although that is by no means a limitation of the method-see [9] for more relevant discussion. 
That is, we compute pixel values by integrating the scene s intensity across pixel-sized squares. ) As 
above, we will subdivide the viewing volume, reducing CSG trees as we go. When we reach pixel resolution, 
we will concentrate our best attention on cells that are completely covered by one primitive (figure 
1a) or are crossed by a single visible edge. This edge will be either the silhouette edge of a tree with 
a single leaf (figure Ib) or an intersection edge in a two-leaf tree (figure It). We will treat more 
complicated situations (figure ld) by subdividing the pixel, hoping to find a simpler situation in the 
subpixels and giving up when their contribution to the image is tiny. Suppose that each implicit function 
F at the leaves of our CSG tree has continuous partial derivatives. The silhouette of the surface F = 
O is precisely those points at which dF/dz = O. So, let us use interval arithmetic 10 evaluate dF/dz 
in our pixel-sized cell, calling the result S. If 0< S, the surface has no edge inside the cell. It may, 
however, protrude through the cell s front or back surface (figure Ie), giving a spurious edge crossing 
the pixel where the surface is clipped. An interval computation can alert us to this possibility, If 
O= F(X, Y,[~,~] ) then F may pass through the far surface of the cell (X, Y,Z). Whenever we come to process 
a cell that contains such a surface, we save the CSG tree and the cell coordinates and defer processing 
the cell. When later we return to the cell behind it, we can merge the two cells and their trees before 
processing them, (Of course, if the CSG tree in [he cell behind has been reduced to 0 or U, we will not 
return to it. When later we return to the pixel for farther cells, we should first dispose of the saved 
tree by treating it as one of the more complicated cases mentioned above, You might, as 1 did initially, 
naively believe that this circumstance cannot occur after all, if there is nothing in the cell behind, 
how could a surface cross the cell boundary? However, if one surface of an intersection passes through 
the back of a cell and the other does not. the cell behind may easily reduce to 0.) Now we are ready 
to handle the simple cases: If the reduced CSG tree has only one leaf and 0< S, the primitive has no 
edges inside the cell (figure 1a) and may trivially be rendered by casting a ray through the pixel s 
center. If the CSG tree has two leaves and 04 S for each, then we have two possibly intersecting primitives 
F and G, neither with an edge in the cell (figure 1c). We will approximate their intersection curve by 
a straight line that runs from edge to edge of the pixel, We can cast four rays to find the Z coordinates 
at which the surfaces pass through the pixel comers. Then, following [8], we compare the : values at 
each comer. Along each pixel edge where the z s compare differently we linearly interpolate the z s to 
find a point at which they are equal. In any cell there will be zero, two or four such points. We join 
them up as in figure 2 (taken from [8]) and compute the quantity ~, the total fraction of the pixel in 
which F is in front of G, according to our approximation. Now we need only determine which surface, if 
any, is visible in each part of the cell and compute their contributions, weighted by ~, to the color 
of the cell. We can determine visibility by considering the CSG operator connecting the two surfaces, 
and whether the two surfaces face the viewer. For example, if F faces the viewer and G faces away, and 
the CSG operator is n, then we can see F inside the part of the pixel where it is in front, and nothing 
in the other part, The following table summarizes the contributions in all cases: F toward F toward F 
away F away G toward G away G toward G away u 13F+(I-p)G (1-@)G pG+(I-~)F n ~G+(I-~)F f3F (l~~)G ~F+(l-~)G 
 If the reduced CSG tree has only one leaf and Oc S, then there may be a silhouette edge in the cell, 
as in figure 1b. As before, we wish to approximate the edge by a segment running from edge to edge of 
the pixel. Again, we can cast rays through the pixel comers, but now we are interested only in identifying 
cell faces through which the edge must pass because the surface intersects one edge of the face but not 
the other. Having identified these faces (again there must be zero, two or four of them), we can find 
the silhouette s endpints by solving systems SIGGRAPH 92 Chica!ao, JUIY26-31, 1992 /./,0,0/ -,0, Z. 
.,,XX,   /--vb / , ,/ /0, / ,. /,/ /, .. . <., /0 Z . Figure i Simple and non-simple cells Figure 
la illustrates a cell completely covered by a single surface. lb has a cell containing a single surface 
with a silhouette edge. 1c has a cell covered by a pair of intersecting surfaces. 1d is too complicated 
to be handled without subdivision. le illustrates a cell with a surface passing through its back face. 
Its processing will be deferred for merging with the cell behind it. of three simultaneous equations: 
F(,r,y, z) = O, i)~/&#38; = O and t~e the surface. Note that this computation is not particularly robust 
plane equation of the cell face, one of x =3, x =X, y = Y or y = Y. it is entirely possible for an edge 
to protrude a pixel without A useful optimization is to eliminate the cell face e@ation by the surface 
passing through any vertex. Indeed, the whole surface substituting into the other two. Moore ([16] pp 
62-68) outlines may be contained within a single cell. But, we stated up front that robust interval methods 
for producing these solutions. we intended to approximate the silhouette by a sequence of line segments 
passing from pixel edge to pixel edge, and neither of As in the previous case, we can join these points 
by line these situations admits a reasonable approximation in those terms. segments (see figure 3) to 
find the fraction of the pixel covered by A more robust computation that could identify these situations 
;I:lzl:;l++a+ ­:!;lxl::i- m ;EI:EE;:5!3%!I ;B;:ljzl zl   Figure 2-Joining endpoints of edges Figure 
3 silhouette edge approximation Each square represents a pixel. The comers are marked The squares are 
pixels. The closed curve is the a silhou­with the sign of F G. The label in each pixel fragment ette 
edge of a surface that intersects each pixel as in figure indicates which surface is in front in it. 
~ is the total area 1a. The dashed lines are our piecewise linear approxima­of the fragments labeled 
F. tion to the silhouette. and allow us to subdivide would be stmightforward, if tedious, to implement. 
Any situation not handled above we manage by further subpixel subdivision. We subdivide only in .[ and 
y, not z, further reducing the CSG tree as we go, stopping when we find a subpixel satisfying one of 
the above cases or in any case at some fixed depth. The contributions of the subpixel cells, weighted 
by subpixel area, are added to determine the color of their pixel-sized ancestor. Since cells that partly 
cover pixels must allow the color of cells behind them to show through the uncovered parts, we store 
colors in the rgba representation of Porter and Duff [ 19], using et-blending to composite each cell 
s color with the accumulated color of the cells in front of it. This can make mistakes in pixels that 
contain multiple visible edges, If this worries you, you can use a more elaborate compositing scheme, 
saving a list of previously-encountered edges against which to clip tbe newly­computed regions or keeping 
at each pixel a sub-pixel bit-mask (as in Carpenter s A-buffer [S], but simpler because we know depth 
order u priori) against which to clip the newly-computed regions. 7. Collision detection Let us now turn 
our attention to motion computations for animation purposes. Suppose we have a scene composed of a number 
of CSG objects, and that we wish to compute their motion, At any point in time, we need to decide whether 
objects in the scene have collided, in order to prevent interpenetration and to compute the forces resulting 
from any collision, Let the objects in the scene (considered as point-sets) be 0,, ()< i <11. Then to 
compute an image we would run one of the above algorithms on the CSG tree for ,, 1 Uo, (2) ,=() To decide 
whether there has been a collision, we must decide whether there are points occupied by more than one 
object. To do this, we first build a CSG tree in which each of the top-level union operators (see equation 
2) is specially marked. Now, we recursively subdivide a cell surrounding the entire scene, reducing the 
CSG tree at each subcell as before, except that for specially­marked top-level union opemtors we rewrite 
the tree using only the rule au.$+s We do not reduce top-level instances of U using the rule UUS-) U 
because we wisfl to count tfrern.If at any level of subdivision the reduced CSG tree contains two or 
more top-level U s, we have detected a collision, Likewise, if the tree has no marked top-level union 
operator, there can be no collision in this cell and we need subdivide no further, If we subdivide down 
to cells smaller than some tolerance without reaching a decision, we can declare the question unanswerable 
to within the given tolerance. This may strike you as unsatisfactory. and in fact we can make a much 
stronger statement. For all functions computed by sequences of arithmetic operations and transcendental 
functions, their natural interval extensions satisfy an in(erl,al Lipschirc cmrdirion (under certain 
mild assumptions. ) That is, there is an easy-to-compute constant c, depending only on F and the domain 
of interest (say a viewing volume (X(), Y(,,Z,) )), such that if (X, Y,Z) G(X,,, Y{,,Z()) then ~(X, y, 
Z)-~(X, Y,Z)<cmax(~-X, ~-~,~-~). (Again, we refer you to [ 16] pp 33-35 for further details, including 
a proof. ) Informally, the size of the intervals F( X, Y,Z) decreases at worst Computer Graphics, 26,2, 
July 1992 \ Figure 4 collision F and G are two colliding surfaces. VF is the normal to F at the point 
of collision. VI and V(J are their velocities at the point of collision. Since the angle between VF and 
V(; Vf is larger than 90 degrees, surfaces are separating and the collision will be rejected. linearly 
with the size of (X, Y,Z). Thus, when we abandon subdivision at a tolerance E, we know that the surfaces 
touch to within some easily-computable tolerance c~.  8. Dynamic Collision Detection If we can describe 
tbe motion of O, as a function of time, we can extend the abrrve algorithm to find the earliest time 
in an animation at which a collision occurs. We need only subdivide in s, y, : and I, looking at subcells 
earlier in time before later cells and stopping when we first find a cell smaller than a collision tolerance 
&#38;that still contains parts of two intersecting objects. At this point we will presumably do a momentum-transfer 
calculation and restart the colllslon detector with ~ = (<,,11,,,,,,,But . this will just re-detect the 
previous collision. We must reject collisions at which the objects are not approaching one another. Let 
the two objects be F and G, and let their velocities at tbe point of collision by l ~ and P {, see figure 
4. G is moving towards F if the angle between its velocity (relative to F) and F s normal at the point 
of collision is larger than 90 degrees, that is if VF. ( \ cJ -t ~ ) <0, [n an edge-to-edge or other 
complicated collision. F s gradient may be undefined. In that case, we must use the normal to the collision 
tangent plane as described by Baraff [3]. The sorts of motion that this scheme can accommodate are fairly 
general. Any time-varying coordinate mapping will do, as long as its inverse can be expressed in a closed 
form that admits an inclusion monotonic interval extension. For example, points on a rigid body tumbling 
and moving under gravity are transformed by II o P=rot(co/,A )R(P -C)+C+P(, +Vot+ -112gIz (3) o where 
P = (x.y,z)r is the transformed point, rot ( (), uxis ) is a rotation matrix, w is the object s rate 
of rotation, A is the axis about which it rotates, I35 SIGGRAPH 92 Chicago, July 26-31, 1992 R is a 
rotation matrix describing its orientation at t = O, P is a coordinate in model-definition space, C is 
the object s center of mass, PO is its position at time r = O, VO is its velocity at time f = O, and 
g is the acceleration due to gravity. The inverse of (3) is just o P =R~rot( cOt,u)(P-C-PO-Vol --1/2gt2 
)+C [1 o So, the implicit function F(P ) is just F as transformed by its motion. More complex motions. 
like the modal deformations of Pentland and Williams [18] can be handled similarly. Constrained motions 
like those described by Barzel and Barr [2] and Baraff [3] for which the associated ODES are generally 
insoluble in closed form are beyond the scope of the work reported here. Interval methods for ODES are 
an interesting research problem and would be extremely helpful here. In their absence, we must use conventional 
ODE methods and accept the loss of robustness that they entail. Pentland and Williams [18] claim to do 
collision detection of implicit functions (but not their CSG combinations) by converting one of a pair 
of objects to be tested into polygons. The objects intersect if any of the vertices gives a negative 
value when substituted into the other function. Sclaroff and Pentland [20] repeat this claim. But, their 
scheme does not work it is easy for an object to pass through a polygonal face without meeting any of 
its edges. Even testing the polygonal representation of each object against the other will not work, 
as they can easily meet edge-to-edge with no vertex of either polygonization penetrating the other object. 
The methods presented here are utterly robust interval arithmetic always provides guaranteed bounds on 
the functions we compute. When we discover that two objects meet, we need to calculate the collision 
forces and their effects on the bodies motions. To do this, we need to know in what direction the force 
is applied and some physical properties of the colliding bodies particularly their masses and moments 
of inertia. The information needed to calculate the direction of applied force is readily available when 
the collision is detected. Inside the cell in which the collision occurs the reduced CSG trees will include 
one or more surfaces from each of the colliding objects. If a single surface from one object or the other 
is involved, we need only compute its normal direction. If each object has two surfaces active, we have 
an edge-to-edge collision. We can find the edge directions by looking at intersections of tangent planes, 
and transmit the force as in [3]. More complicated situations represent indeterminate cases that can 
also be linearized by working with the tangent planes and handled as in [3]. 9. Integral Properties 
Mass and moments of inertia are infegral properdes of solid objects. Computing them involves evaluating 
simple definite integrals inside the objects volumes. For example, to compute the mass of a body B, we 
need to evaluate jjjP(.w,z)dx dy dz B where p is the density of the material. If p is easy to integrate 
over rectangular prisms (often it will be constant), we can recursively subdivide a cell surrounding 
B, reducing B s CSG tree as we go, and accumulate the integral s value over those cells in which the 
reduced CSG tree is U. Cells whose reduced CSG trees are 0 contribute nothing, and partially occupied 
cells will contain a vanishingly small fraction of B s volume as the subdivision limit decreases. (The 
fraction may not decrease as quickly as you d like if the Hausdorff dimension of B s surface is larger 
than 2, but then you have worse problems since, for example, B s partial derivatives will be undefined.) 
Other integral properties can be computed similarly. For example, B s moment of inertia about a particular 
axis is just  ~jjr2P(. ,Y, )d dy d. B where r is the distance from (.r,y, z) to the axis in question. 
10. Examples Figures 5-9 show a variety of objects as rendered by our algorithms. Figure 5 is Kummer 
s surface with 16 real double­points (4 are at infinity) with malachite texture. This beautiful surface 
extends to infinity in 8 directions and would be useless for real applications without some sort of trimming. 
Figure 6 is the intersection of Kummer s surface and a sphere. Figure 7 is the intersection of a Parabolic 
Spindle Cyclide and a sphere with hideous orange marble texture. (Fischer [ 10] gives good detailed descriptions 
of these surfaces.) Figure 8 is an image of a face made using a 48x48 raster of intersecting marbles 
of varying sizes, just to show that we can handle scenes with a larger number of primitives. Figures 
5-8 were all computed at 1024x 1024 resolution using the point-sampling renderer described in section 
5. Figure 9 is an anti-aliased rendering of a compound of 3 spheres, done at 256x256 resolution using 
the algorithm of section 6. The videotape accompanying this paper shows two simple animations made using 
our dynamic collision detection and rendering algorithms. The first scene shows 9 balls falling onto 
a sphere with a dish carved out of its top. You can see the balls collide with the dish and, in one case, 
with each other. The second scene is similar, but with 25 balls. There are 80 collisions in this shot, 
mostly between pairs of balls. 11. Conclusion We have presented a wide range of algorithms that use 
intewal arithmetic and recursive subdivision of object space to process geometric objects described as 
CSG combinations of implicit function primitives. The algorithms are all suited to manipulating extremely 
complex objects because they discard parts of the objects that are irrelevant to the subdivided cells. 
Their running times are only mildly influenced by the size of their inputs because small cells typically 
contain at most one or two surfaces. Presumably when the number of primitives in the original model is 
a large fraction of the number of pixels on the screen we will start to see greater dependence, as this 
assumption will begin to break down. The algorithms of sections 7, 8 and 9 are quite robust it is impossible 
to lose track of parts of objects due to rounding error when using interval arithmetic. The bounds it 
provides are absolutely guaranteed to enclose the exact function values. We can only run into trouble 
when we terminate subdivision at some a priori level, and even then the existence of interval Lipschitz 
conditions can help us set that level to bound the unavoidable error in our computations however we wish. 
In retrospect, the work most closely related to ours is work by Al Barr and his colleagues on rendering 
and collision detection of functions with Lipschitz conditions [13], [24]. A Lipschitz condition (not 
to be confused with an interval Lipschitz condition) is a bound on a function s variation. Given an appropriate 
Lipschitz constant, one can easily bound a function s value on an interval, a sort of interval arithmetic 
without the intervals. In fact, Lipschitz constants can be computed by interval evaluation of a function 
s derivatives, and those bounds converted into bounds on the original function using the mean value theorem. 
In this Iigh[ it is perplexing that Kalra and Barr [13] put the question of identifying ... useful implicit 
functions and computing Lipshitz constants for them first on their list of important problems to attack. 
Recursive subdivision using interval arithmetic is a natural and versatile scheme to use for implicit 
function CSG models. We have only begun to scratch the surface of its potential applications. Our anti-aliased 
rendering method should l-weasily convertible into a polygonization algorithm. (Indeed, Snyder [22] gives 
an interval polygonization algorithm, along with many other applications of interval arithmetic. ) Interval 
function minimization methods can provide global optima for many problems and should be applicable to 
some of the control problems in animation. and. as Don Mitchell has pointed out in conversation, to a 
range of global illumination problems as well. Another problem that must be better addressed before we 
can consider wider use of implicit function surfaces is the problem of using them to model sculpted surfaces. 
a realm in which Bezier surfaces and NURBS reign. There is some hope that this situation will improve. 
[ 17] and [21] are two recent papers describing ideas that show a great deal of promise.  12. Acknowledgements 
Don Mitchell is always a good friend and source of ideas and criticism. His paper on interval root-finding 
[ 14] put this bee in my bonnet. and his interval arithmetic routines made it possible to get the first 
version of this stuff going in a couple of days. Andy Witkin suggested looking at collision detection. 
A detailed and insightful referee s report cmrtri buted greatly to the paper s clarity and correctness, 
13. References John Amanatides and Don P. Mitchell. Some Regularization Problems in Ray Tracing, Proc, 
Graphics  90, I990 interfit( 1 Romm Barzcl and Alan H. Barr, A Modeling System Basmi on Dynamic Constraints, 
 Computer Graphics ~~(~) July l%++. 179-188 David Baraff, Analytical Methods for Dynamic Sirnultition 
of Non-penetrating Rigid Bodies, Computer Gr[lp/li[.! 23(3). July 1989.223-23 I Alan H. Barr, Global 
and Local Deformations of Solid Prim itives, ( {m~pu/cr Graphi~s 18(3). July 1984, 21-30 Lortm Cwpcntcr, 
The A-Buffer, An Anti-Aliased Hidden sUIf:lL CMethod. ~onywrcj G) a/Jhics 18(3), July ] 984, 103-Iox 
Computer Graphics, 26, 2, July 1992 [6] Norman Shadow Gruphics Chin and Steven Feiner, Generation Using 
BSP 23(3), July 1989,99-106 Near Trees, Real-Time Cornpufer [7] Franklin C. Crow, Summed Mapping, Computer 
Graphics Area Tables for Texture 18(3), July 1984,207-212 [8] Tom Duff, Compositing 3-D Rendered Computer 
Graphics 19(3), July 1985,270-275 Images, [9] Tom Duff, Convolution, 89, Cambridge Polygon Scan Conversion 
by Exact Raster Imaging and Digital Typography University Press, London, 1989 [10] Gerd Fischer, Mathematische 
Modelle/Mathematical Models, Friedr. Vieweg &#38; Sohn, Braunschweig/Wiesbaden, 1986 [11] H. Fuchs, Z, 
M. Kedem and B. F. Naylor, On Visible Surface Generation by A Priori Tree Structures. Compurer Graphics 
14(3), July 1980, 124-133 [12] IEEE Standard for Binary Floaring-Point Arithmetic. ANSI/lEEE Std 754-1985, 
Institute of Electrical and Electronics Engineers, New York, 1985 13] Devandra Kahd and Alan H. Barr, 
Guaranteed Ray Intersections with Implicit Surfaces, Computer Graphics 23(3), July 1989,297-306 141 
Don P. Mitchell, Robust Ray Intersection with Arithmetic, Proc. Gruphics Interface 90, 1990 Interval 
[15] Don P. Mitchell, Spectrally Optimal Sampling for Distribution Ray Tracing, Compu/er Graphics 25(3), 
July 1991, 157-164 [i6] Ramon E. Moore, Methods and Application.r af lruervul Ana/ysis, Society for Industrial 
and Applied Mathematics (SIAM), Philadelphia, 1979 [17] Shugeru Muraki, Volumetric Shape Description 
of Range Data using Blobby Model , Computer Graphics 25(4), July 1991,227-235 [18] Alex Pentland and 
John Williams, Good Model Dynamics for Graphics and Animation, Graphics 23(3). July 1989, 215-222 Vibrations: 
Computer [191 Thomas Images, Porter and Tom Duff, Compositing Digital Compurer Graphics 18(3), July 
1984, 253-259 [201 Sclaroff Functions 25(4), Juiy and Alex Pentland, Generalized for Computer Graph ics, 
Cornpuler 1991,247-250 Implicit Graphics [21] Thomas W. Sederberg and Alan Display of Algebraic Surfaces, 
23(3), July [989. 147-156 K. Zundel, Scan Line Computer Graphics [22] John Snyder. Level Shape Ph.D. 
Thesis. Generurise Modeling: An Approach to Hi~h Design for Computer Graphi~.s and CAD. California Institute 
of Technology, 1991 [23] W, Thibault and Polyhedra Using Computer Graphits B. F. Naylor, Set Operations 
on Binary Space Partitioning Trees, 2 1(4), July 1987, 153-162 [241 Brian von Herzen, Alan H. Barr and 
Harold R. Zatz, Geometric Collisions for Time-Dependent Parametric Surfaces, Compu/er Graphics 24(4). 
August 1990, 39-48 [25 J. R. Woodwark and K. M. Quinlan, Reducing tbe effect of complexity on volume 
model evaluation. Compuler-Aided Design 14(2), March 1982, 89-9S  SIGGRAPH 92 Chicago, July 26-31, 
1992 F~,qure 5 -Kummer wrface L- F&#38;WY 9 - Combination of 3 spheres, anti-aliased  
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134029</article_id>
		<sort_key>139</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>16</seq_no>
		<title><![CDATA[Computing the antipenumbra of an area light source]]></title>
		<page_from>139</page_from>
		<page_to>148</page_to>
		<doi_number>10.1145/133994.134029</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134029</url>
		<keywords>
			<kw><![CDATA[Plu&uml;cker coordinates]]></kw>
			<kw><![CDATA[aspect graph]]></kw>
			<kw><![CDATA[discontinuity meshing]]></kw>
			<kw><![CDATA[radiosity]]></kw>
			<kw><![CDATA[stabbing lines]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Geometric algorithms, languages, and systems</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Color, shading, shadowing, and texture</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Radiosity</descriptor>
				<type>S</type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010147.10010371.10010372.10010376</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Rendering->Reflectance modeling</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010382.10010384</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Image manipulation->Texturing</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010382</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Image manipulation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003752.10010061</concept_id>
				<concept_desc>CCS->Theory of computation->Randomness, geometry and discrete structures</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>PP39080034</person_id>
				<author_profile_id><![CDATA[81100244355]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Seth]]></first_name>
				<middle_name><![CDATA[J.]]></middle_name>
				<last_name><![CDATA[Teller]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Computer Science Department, Berkeley, CA 94720]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_obj_id>807403</ref_obj_id>
				<ref_obj_pid>800248</ref_obj_pid>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[E Atherton, K. Weiler, and D. Greenberg. Polygon shadow generation. Computer Graphics (Proc. SIGGRAPH '78), 12:275-281, 1978.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[B. Griinbaum. Convex Polytopes. Wiley-lnterscience, New York, 1967.]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122724</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Daniel R. Baum, Stephen Mann, Kevin P. Smith, and James M. Winget. Making radiosity usable: Automatic preprocessing and meshing techniques for the generation of accurate radiosity solutions. Computer Graphics (Proc. SIGGRAPH '91), 25(4):51-60, 1991.]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_obj_id>97896</ref_obj_id>
				<ref_obj_pid>97880</ref_obj_pid>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[A.T. Campbell Ill and Donald S. Fussell. Adaptive mesh generation for global diffuse illumination. ComputerGraphics (Proc. SIGGRAPH '91), 24(4):155-164, 1990.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_obj_id>147159</ref_obj_id>
				<ref_obj_pid>147156</ref_obj_pid>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[Norman Chin and Steven Feiner. Fast object-precision shadow generation for area light sources using BSP trees. In Proc. 1992 Symposium on Interactive 3D Graphics, pages 21-30, 1992.]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_obj_id>82363</ref_obj_id>
				<ref_obj_pid>82362</ref_obj_pid>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[Kenneth L. Clarkson and Peter W. Shot. Applications of random sampling in computational geometry {I. Discrete Computational Geometry,, pages 387-421, 1989.]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_obj_id>563901</ref_obj_id>
				<ref_obj_pid>563858</ref_obj_pid>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Frank C. Crow. Shadow algorithms for computer graphics. Computer Graphics (Proc. SIGGRAPH '77), 11(2):242-248, 1977.]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_obj_id>807481</ref_obj_id>
				<ref_obj_pid>800250</ref_obj_pid>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[H. Fuchs, Z. Kedem, and B. Naylor. On visible surface generation by a priori tree structures. Computer Graphics (Proc. SIG- GRAPH '80), 14(3): 124-133, 1980.]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_obj_id>147158</ref_obj_id>
				<ref_obj_pid>147156</ref_obj_pid>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Thomas A. Funkhouser, Carlo H. S~quin, and Seth J. Teller. Management of large amounts of data in interactive building walkthroughs. In Proc. 1992 Workshop on Interactive 3D Graphics, pages 11-20, 1992.]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_obj_id>116704</ref_obj_id>
				<ref_obj_pid>116700</ref_obj_pid>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[Ziv Gigus, John Canny, and Raimund Seidel. Efficiently computing and representing aspect graphs of polyhedral objects. IEEE Transactions on Pattern Analysis and Machine Intelligence, 13(6):542-551, 1991.]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
			<ref>
				<ref_obj_id>80992</ref_obj_id>
				<ref_obj_pid>80983</ref_obj_pid>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[Ziv Gigus and Jitendra Malik. Computing the aspect graph for line drawings of polyhedral objects. IEEE Transactions on Pattern Analysis and Machine Intelligence, 12(2):113-122, 1990.]]></ref_text>
				<ref_id>11</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122740</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[Pat Hanrahan and David Salzman. A rapid hierarchical radiosity algorithm. Computer Graphics (Proc. SIGGRAPH '91), 25(4): 197-206, 199 i.]]></ref_text>
				<ref_id>12</ref_id>
			</ref>
			<ref>
				<ref_obj_id>144727</ref_obj_id>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[Paul S. Heckbert. Simulating Global Illumination Using Adaptive Meshing. PhD thesis, Computer Sciences Department, University of California, Berkeley, June 1991.]]></ref_text>
				<ref_id>13</ref_id>
			</ref>
			<ref>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[J.J. Koenderink and A.J. van Doom. The internal representation of solid shape with respect to vision. Biol. Cybern., 32:211-216, 1979.]]></ref_text>
				<ref_id>14</ref_id>
			</ref>
			<ref>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[Tomoyuki Nishita and Eihachiro Nakamae. Half-tone representation of 3-D objects illuminated by area sources or polyhedron sources. In Proc. IEEE COMPSAC, 1983, pages 237-242, 1983.]]></ref_text>
				<ref_id>15</ref_id>
			</ref>
			<ref>
				<ref_obj_id>325169</ref_obj_id>
				<ref_obj_pid>325165</ref_obj_pid>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[Tomoyuki Nishita and Eihachiro Nakamae. Continuous-tone representation of three-dimensional objects taking account of shadows and interreflection. Computer Graphics (Proc. SIG- GRAPH '85), 19(3):23-30, 1985.]]></ref_text>
				<ref_id>16</ref_id>
			</ref>
			<ref>
				<ref_obj_id>40599</ref_obj_id>
				<ref_seq_no>17</ref_seq_no>
				<ref_text><![CDATA[Joseph O'Rourke. Art Gallery. Theorems and Algorithms. Oxford University Press, 1987.]]></ref_text>
				<ref_id>17</ref_id>
			</ref>
			<ref>
				<ref_obj_id>98563</ref_obj_id>
				<ref_obj_pid>98524</ref_obj_pid>
				<ref_seq_no>18</ref_seq_no>
				<ref_text><![CDATA[Marco Pellegrini. Stabbing and ray-shooting in 3-dimensional space. In Proc. 6th ACM Symposium on Computational Geometry, pages 177-186, 1990.]]></ref_text>
				<ref_id>18</ref_id>
			</ref>
			<ref>
				<ref_seq_no>19</ref_seq_no>
				<ref_text><![CDATA[Ken Perlin and Xue-Dong Wang. An efficient approximation for penumbra shadow. Technical Report 346~ New York University Courant Institute of Mathematical Sciences, Computer Science Division, 1988.]]></ref_text>
				<ref_id>19</ref_id>
			</ref>
			<ref>
				<ref_obj_id>111137</ref_obj_id>
				<ref_obj_pid>111135</ref_obj_pid>
				<ref_seq_no>20</ref_seq_no>
				<ref_text><![CDATA[W.H Plantinga and C.R. Dyer. Visibility, occlusion, and the aspect graph. Int. J. Computer Vision, 5(2):137-160, 1990.]]></ref_text>
				<ref_id>20</ref_id>
			</ref>
			<ref>
				<ref_seq_no>21</ref_seq_no>
				<ref_text><![CDATA[David Salesin, Dani Lischinski, and Tony DeRose. Reconstructing illumination functions with selected discontinuities. In Proc. 3rd Eurographics Workshop on Rendering, 1992.]]></ref_text>
				<ref_id>21</ref_id>
			</ref>
			<ref>
				<ref_obj_id>98570</ref_obj_id>
				<ref_obj_pid>98524</ref_obj_pid>
				<ref_seq_no>22</ref_seq_no>
				<ref_text><![CDATA[Raimund Seidel. Linear programming and convex hulls made easy. In Proc. 6th ACM Symposium on Computational Geometry, pages 211-215, 1990.]]></ref_text>
				<ref_id>22</ref_id>
			</ref>
			<ref>
				<ref_seq_no>23</ref_seq_no>
				<ref_text><![CDATA[D.M.Y. Sommerville. Analytical Geometry of Three Dimensions. Cambridge University Press, 1959.]]></ref_text>
				<ref_id>23</ref_id>
			</ref>
			<ref>
				<ref_obj_id>894547</ref_obj_id>
				<ref_seq_no>24</ref_seq_no>
				<ref_text><![CDATA[Seth J. Teller and Michael E. Hohmeyer. Computing the lines piercing four lines. Technical Report UCB/CSD 91/665, Computer Science Department, U.C. Berkeley, 1991.]]></ref_text>
				<ref_id>24</ref_id>
			</ref>
			<ref>
				<ref_obj_id>894553</ref_obj_id>
				<ref_seq_no>25</ref_seq_no>
				<ref_text><![CDATA[Seth J, Teller and Michael E. Hohmeyer. Stabbing oriented convex polygons in randomized O(n2) time. Technical Report UCB/CSD 91/669, Computer Science Department, U.C. Berkeley, 1992.]]></ref_text>
				<ref_id>25</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122725</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>26</ref_seq_no>
				<ref_text><![CDATA[Seth J, Teller and Carlo H. S~quin. Visibility preprocessing for interactive walkthroughs. Computer Graphics (Proc. SIG- GRAPH '91), 25(4):61-69, 1991.]]></ref_text>
				<ref_id>26</ref_id>
			</ref>
			<ref>
				<ref_obj_id>894565</ref_obj_id>
				<ref_seq_no>27</ref_seq_no>
				<ref_text><![CDATA[Seth J, Teller and Carlo H. S6quin. Visibility computations in polyhedral three-dimensional environments. Technical Report UCB/CSD 92/680, Computer Science Department, U.C. Berkeley, 1992.]]></ref_text>
				<ref_id>27</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 Computer Graphics, 26, 2, July 1992 Computing the Antipenumbra of an Area Light Source Seth J. Teller 
University of California at Berkeley~ Abstract We define the antiumbra and the antipenumbra of a convex 
area light source shining through a sequence of convex area] holes in three dimensions. The antiumbra 
is the volume from which all points on the light source can be seen. The antipenumbra is the volume from 
which some, but not all, of the light source can be seen. We show that the antipenumbra is, in general, 
a disconnected set bounded by portions of quadric surfaces, and describe an implemented 0(n2) time algorithm 
that computes this boundary, where n is the total number of edges comprising the light source and holes. 
The antipenumbra computation is motivated by a visibility scheme in which we wish to determine the volume 
visible to an observer looking through a sequence of transparent convex holes, or portals, connecting 
adjacent cells in a spatial subdivision. Knowl­edge of the antipenumbra should also prove useful for 
rendering shadowed objects. Finally, we have extended the algorithm to com­pute the planar and quadratic 
surfaces along which the rate of areal variation in the visible portion of the light source changes discon­tinuously 
due to occlusion. These surfaces are relevant in polygon meshing schemes for global illumination and 
shadow computations. CR Categories and Subject Descriptors: [Computer Graph­ics]: 1.3.5 Computational 
Geometry and Object Modeling geomet­ric algorithms, /anguuges, and sysfems; 1,3.7 Three-Dimensional 
Graphics and Realism -color shading, shadowing, and texture. Additional Key Words and Phrases: Radiosity, 
aspect graph, discontinuity meshing, stabbing lines, Plucker coordinates. 1 Introduction 1.1 Penumbrae 
and Antipenumbrae Suppose an area light source shines past a collection of convex oechrders. The oecluders 
cast shadows, and in general attenuate 1COmPLItCrScience Deptiment, Berkeley, CA 94720 (seth @cs.berkeley.edu) 
Permission m copy wnhout fee all or part of this material IS granted provided that the copies are not 
made or distributed for direct commercial advantage, tbe ACM copyright notice and the title of the publication 
and its date appear. and notice is given that copying M by ~rmission of the Association for Computing 
Machinery. To copy otherwise. or 10 republ)sh, requires a fee and/or specific permission. or eliminate 
the light reaching various regions of space. There is a natural characterization of any point in space 
in this situation, depending on how much of the light source can be seen by the point. Figure 1 depicts 
a two-dimensional example. If the point sees none of the light source (that is, if all lines joining 
the point and any part of the light source intersect an Wcluder), the point is said to be in umbra. If 
the point sees some, but not all, of the light source, it is said to be in penumbra. Otherwise, the point 
may see all of the light source. panumlxa ~y.  ..___ 7. , /./ ./ / I,ght -,> / 00md9r smrce ~ . -.-/ 
 -4~--    Mllfik Figure I: Umbra and penumbra of an occluder in 2D. Imagine that the oecluders are 
replaced by convex holes, or transparent areas, in otherwise opaque planes. In a sense comple­mentary 
to that above, every point in space can again be naturally characterized. We define the anriumbra cast 
by the 1ight source as that volume from which the entire light source can be seen, and the arrfipenumbra 
as that volume from which some, but not all, of the light source can be seen (Figure 2). For a given 
light source and set of holes or occluders, the umbra is the spatial complement of the union of antiumbra 
and antipenumbra; similarly, the antiumbra is the spatial complement of the union of umbra and penumbra. 
Both the antiumbra and antipenumbra may be vacuous beyond the plane of the final hole, i.e.. they may 
contain no points. I,ghl Figure 2: Antiumbra and antipenumbra of a series of holes in 2D. For a point 
light source and a set of polygonal occluders in three  1.3 Overview It can easily be shown that, in 
three-space, tbe antiumbra is convex, polyhedral, has complexity 0(n), and can be computed in 0( n Ig 
n ) time, where t) is the total polygon edge complexity of a convex light source and some number of convex 
area] holes. Here, we show that the three-space antipenumbra is, in general, non-convex and disconnected, 
but has at most quadratic complexity in 71. We present an implemented 0( n~) time algorithm that computes 
the piecewise-quadratic boundary of the antipenumbra. We also describe an extension of the algorithm 
that computes lin­ear and quadratic et ent surjaces [10]. These are the loci at which the rate of area] 
variation in the visible portion of the light source, and therefore the derivative of illumination intensity, 
changes discon­tinuously doe to occlusion, Such surfaces are useful, for example, in polygon meshing 
schemes for global illumination and shadow contputations. The algorithm uses Pliicker coordinates, a 
five-dimensional line representation, to transform the edges of the light source and holes into hyperplanes 
bounding a five-dimensional polytope. The face structure of this polytope is then intersected with a 
four-dimensional quadric surface, the Plucker quadric, The resulting intersections or traces are remapped 
to 3D objects such as stabbing lines and portions of planar and quadric surfaces, some of which are shown 
to bound the antipenumbra. The remaining traces corres~nd to surfaces of illumination rate discontinuity 
lying within the antipenumbra. 2 Plucker Coordinates Weusethe Plucker coordinatization [23] ofdirected 
lines in three space. Any ordered pair of distinct points p = (p,, pu, p,) and q = (q~. ~~Y.~]~)defines 
adirected line fin~D. Thislinecomesponds to a projective six-tuple ~~ = (T?tl. nrI, Trl, TIJ, r~~, T!5), 
each component of which is the determinant of a 2 x 2 minor of the matrix Prpyp: I (1) ( ~.r quq2 I ) 
We use the following convention dictating the correspondence between theminors of Equation 1 andtherrfj: 
Z(O = PIf7.Y qrPy ~fl = P.qz qrpz ~P2= p, qr ~P3 = Pvrlz flyP2 ~t-1 = pz qz irqs= % Py (this order 
was adopted in [18] toproduce positive signsin some useful identities involving Plucker coordinates), 
If o and b are two directed lines, and Ii,,, IIh their corresponding Pliicker dual.r, a relation .~ide(c, 
b) can be defined as the permuted inner product n,, ~111,= ~<,,,~h, + 7r,,lT1 \+ i r ??rkl+ T,,4T,A, 
+ ?T,,,TI,, +I?tl, nh?. (2) This sidedness relation can be interpreted geometrically with the right-hand 
rule (Figure 5): if the thumb of one s right hand is directed along a, then side(a, b) is positive (negative) 
if b goes by a with (against) one s fingers. If lines n and b are coplanar (i.e., intersect orareparallel 
),side(a. b) is zero. Computer Graphica, 26, 2, July 1992 / a aa ?ide (a. b)<O ride (a. b) = O .stde 
(a, b) >0 Figure5: Theright-hand role applied toside(fl. b). The six-tuple ~~ can be treated either as 
a homogeneous point in 5D, or (after suitable permutation via Equation 2) as the coefficients of a five-dimensional 
hyperplane. The advantage of transforming lines to Plucker coordinates is that detecting incidence of 
lines in 3D becomes equivalent to computing the inner product of a homo­geneous point (the dual of one 
line) with a hyperplane (the dual of the other). Plucker coordinates simplify computations on lines by 
mapping them topoints andhyperplanes, which are familiar objects. How­ever, although every directed line 
in 3D maps to a point in Plucker coordinates, not every point in Pliicker coordinates corresponds to 
area[ line. Only those pointsn satisfy ingthe quadratic relation n.rl=o (3) correspond toreal linesin 
3D. Another points correspond toirnag­ inary lines, The six Pliicke rcoordinatesof a real line are not 
independent, First, since they describe a projective space, they are distinct only to within a scale 
factor. Second, they must satisfy Equation 3. Thus, Plucker coordinates describe a four-parameter space. 
This confirms basic intuition: onecould describe alllines inthree-space in terms of, for example, their 
intercepts on two standard planes / /\J/ / I 3D Figure6: Directed lines maptopoints on, orhyperplanes 
tangent to. the Plucker surface. The set of points in SD satisfying Equation 3 is a quadnc surface called 
the P[iickersu@ace [231. One might visualize this set as a four-dimensional ruled surface embedded in 
five dimensions, analo­gous to a quadric hyperboloid of one sheet embedded in three-space (Figure 6). 
 edge constraints determining the line (Figure 10). The surface, or swafh, swept out by the sliding line 
must either be planar (if the line remains tight on a vertex) or a regulus, whose three generator lines 
embed three polygon edges, In the terminology of [ 10], swaths are VE or EEE evenr surjaces important 
in the construction of aspect graphs, since they are loci at which qualitative changes in occlusion occur. 
(1) (It) Figure 10: Sliding a stabbing line away from various extremal lines in 3D generates a VE plane 
(i) or a EEE quadratic surface (ii). Figure 10-i depicts an extremal VV stabbing line tight on four edges 
A,B,C and D. Relaxing constraint C yields a VE (pIanar) swath tight on A, B, and D. Eventually, the sliding 
line encounters an obstacle (in this case, edge E), and terminates at a VV line tight on A,B,D, and E. 
Figure 10-ii depicts an extremal 4E stabbing line tight on the mutually skew edges A,B,C, and D; relaxing 
constraint A produces a EEE (regulus) swath tight on B, C, and D. The sliding line eventually encounters 
edge E and induces an extremal VEE line, terminating the swath. Consider the same situations in the 5D 
space generated by the Plucker mapping (Figure I I). Extremal lines map to particular points in Plucker 
coordinates; namely, the intersections of the edges, or ID-faces, of the polytope nk hi with the Plucker 
surface. Since swaths are one-parameter line families, they correspond to curves in Plucker coordinates. 
These curves are the traces or intersections of the 2D-faces of n~ h; with the Plucker surface, and are 
therefore conies (in 5D, a polytope s 2D-faces are planar, and determined by the intersection of some 
three h~). We call the 3D swaths corresponding to these 5D conic traces extrerrrd swaths, All swaths 
have three generator lines, and consequently three generator edges, arising from the input polygons. 
 5 Internal and Penumbral Swaths An object can be extremal (that is, lie on the bounda~ of the convex 
hull) in 5D. yet lie wholly inside the antipenumbra in three-space. Just as there are extremal stabbing 
lines that lie in the interior of the antipenumbra, so there are extremal swaths in the interior as well. 
We define a ptmumbra/ swath as an extremal swath that lies on the boundary of the antipenumbra (these 
are the red and green surfaces in Figure 4). All other extremal swaths are interns/. Examining the 2D-faces 
of the polytope nk hi yields all extremal swaths; how­ever, we must distinguish between penumbral and 
internal swaths, This distinction can be made purely locally; that is, by examining only the swath s 
three generator edges and, in turn, their generator polygons. From only these (constant number of) objects, 
we show how to determine whether stabbing lines can exist on both sides Computer Graphics, 26,2, July 
1992 dual of extremal stabbing line other edges (1 D-faces) (dual of 3D swath) ....... a Figure 11: 
Traces (intersections) of extremal lines and swaths on the Plucker surface in SD (higher-dimensional 
faces are not shown). of the swath in question. If so, the swath cannot be penumbral, and is classified 
as internal. 5.1 Edge-Edge-Edge Swaths Internal and penumbral EEE swaths can be distinguished as follows. 
Suppose three mutually skew generator edges A, B, and C give rise to an extremal EEE swath. Choose some 
line L incident on the generators respectively at points a, b, and c (Figure 12-i). At these points, 
erect three vectors N,,, N~, and NC, perpendicular both to L and to the relevant generator edge, with 
their signed directions chosen so as to have a pasitive dot product with a vector pointing into the interior 
of tbe edge s generator polygon. (We refer to these vectors collectively as the N,. ) ci Nb B N= -. k 
... .. -.. $4wlg %. Ma \ PL91w (11) cs generatof Pam .~ a b C L- ~­ (1) ( Ill ) Figure 12: An internal 
EEE swath (i), viewed along L (ii) and transverse to L (iii). The N, can be contained. We say that three 
coplanar vectors can be contained if there exists a vector whose dot product with all three vectors is 
strictly positive. We claim that a swath is internal if and only if its corresponding N, can be contained. 
Suppose that the N, can be contained (as in Figure 12). Consider any vector having a positive dot product 
with the N, (such as one pointing into the gray region of Figure 12-ii). Next, slice the SIGGRAPH 92 
Chicago, July 26-31, 1992 configuration with a plane containing both L and this vector, and view the 
swath in this plane (Figure 12-iii). The trace (intersection) of the swath on this plane is simply the 
stabbing line L, which partitions the slicing plane into two regions L+ and L-beyond the plane of C s 
generator polygon (Figure 12-iii). We can move L infinitesimally by keeping it tight on, say, point a. 
The interiors of the other two holes allow L to pivot in only one direction, thus generating stabbing 
lines into L+ (dotted). Analogously, pivoting about point c generates stabbing lines into L-(dashed). 
Since, by construction, the swath admits stabbing lines on both sides, it cannot be penumbral. ,.. .C 
Nb B -­ ?:A Nc -- :. -. ,,..,. dcing + % plane Figure 13: A penumbral EEE swath (i), viewed along L 
(ii) and transverse to L (iii), The Nj cannot be contained. In contrast, the Ni of Figure 13-i cannot 
be contained. Thus, any vector (including one chosen from the gray region of Figure 13-ii) will have 
a negative dot product with at least one, and at most two, of the Ni. Suppose it has a negative dot product 
with NC. Slice the configuration with a plane containing both L and one such vector (Figure 13-iii). 
Pivoting on point b generates stabbing lines into L­(dotted), as does pivoting on point c (dashed). The 
configuration does not admit any stabbing lines into L+. Since this is true for any choice of slicing 
plane and (as we will show) for any choice of L, we conclude that the swath is penumbral; ie., it separates 
a region of zero illumination from a region of partial illumination. 5.2 Vertex-Edge Swaths Suppose 
the swath in question has type VE. Label the two generator edges defining the swath vertex v as A and 
B, the remaining edge C (not in the plane of A and B), the two relevant generator polygons P and Q, and 
the plane through C and v as S (Figure 14). Orient S so that Q (C s generator polygon) is above it (i.e., 
in S+); this is always possible, since Q is convex. Plane S divides the space beyond the plane of Q into 
two regions S+ and S-. If stabbing lines can exist in only one of these regions, the swath is penumbral. 
This occurs if andonly ifSisa separating plane of P and Q; that is, if and only if polygon P is entirely 
below S. Suppose S separates polygons P and Q. Imagine choosing some stabbing line from the swath, and 
moving it so that it comes free from the swath vertex v, but remains tight on edge C (and remains a valid, 
though non-extremal, stabbing line). If S separates P and Q, the moving line s intersection with P can 
only lie below S (Figure 14-i); thus, beyond the plane of Q, all such stabbing lines must intersect S+. 
Similarly, should the stabbing line move off of C and into Q s interior, while remaining tight on v, 
it can only intersect S+. The swath admits only stabbing lines in S+, and is therefore penumbral. (i) 
(11) Figure 14: Penumbral (i) and internal (ii) VE swaths. Suppose, in contrast, that the plane S does 
not separate P and Q, i e., that one or both of the edges A and B lie in S+ (Figure 14-ii). Again move 
a swath line so that it comes free from the swath vertex v, but stays tight on edge C. If the line (dashed) 
moves along A above (say) plane S, it will intersect the region S beyond the plane of Q. Similarly, motion 
along edge B below S produces stabbing lines (dotted) in S+. The swath admits stabbing lines into both 
S­and S+, and therefore cannot be penumbral. Note that the three-vector construction for EEE swaths is 
appli­cable in this (degenerate) setting as well, since S is a separating plane if and only if the normals 
erected along A,B, and C cannot be contained. 5.3 The Containment Function The containment function 
is a criterion for distinguishing between penumbral and internal swaths. However, it applies only along 
a single stabbing line, not over an entire swath. Fortunately, evaluat­ing the containment function anywhere 
along a swath produces the same result. To see why this is so, consider any configuration of three coplanar 
vectors N., N~, and N,. Suppose that the config­uration changes continuously from containable to non-containable 
(e.g., by rotation of vector NC), as in Figure 15. At either moment of transition (marked with dotted 
lines in the figure), NC and one of N. or N~ must be antiparallel. ofNc ; Nb ,.. Nc ,.. ,.. ,.. ~) ,.. 
,.. containment ,.. Na., of Nc ... Figure 15: Directions of containment and non-containment for N,, 
for fixed N. and N~. Transition directions are marked. For this to occur in the EEE swath construction 
(Figure 13) two of the three generator edges must be coplanar. Similarly, in the VE swath construction 
(Figure 14), edge C and one of the edges A      8 Illumination Discontinuities Internal VE and EEE 
swaths, which were merely categorized and discarded by the antipenumbra algorithm, are generally surfaces 
along which discontinuities occur in the first or second spatial derivatives of illumination intensity. 
Imagine an observer inside an antipenumbral volume, looking back through the generating hole se­quence 
to the light source. Since each intervening hole edge clips a halfplane away from the light source, the 
observer must see a con­vex polygonal region of the light (Figure 18-i). The region edges arise directly 
from hole edges. The region vertices arise either from hole vertices, or from apparent intersections 
among non-adjacent hole edges as seen by the observer. As the observer moves, the apparent area of the 
light source (and therefore the illumination intensity at the observer location) changes smoothly, except 
when a swath (i.e., event surface) is encountered. Generically, this happens in one of two fundamental 
ways for poly­hedral objects [11 ]. Either a hole vertex appears (disappears) from the region boundary 
(Figure 18-ii), or the observer s line of sight simultaneously intersects three edges, causing the appearance 
(dis­appea~nce) of an apparent boundary vertex (Figure 18-iii). In either case a qualitative change occurs 
in the effect of infinitesimal observer motion on the apparent area of the light source. Imagine the 
observer s motion as sweeping an occluding half­plane, determined by a hole edge and the observer position, 
over the light source. In general, each sweep surface occludes or re­veals an area that changes quadratically 
with the observer position (parallel edges, as in Figure 18-iv, can cause linear variation in ap­parent 
area). Along extremal swaths, the set of contributing edges changes, adding or removing linear or quadratic 
terms from the function relating the amount of visible light area to observer bca­tion. Consequently, 
extremal swaths are in general loci of first-or second-derivative discontinuities in illumination intensity. 
(In the terminology of [13], planar traces of extremal swaths are curves of D or D* discontinuity.) Zeroth-derivative 
discontinuities (i.e., abrupt changes in illumi­nation value) can occur only in the presence of a point 
light source, or if the observer crosses the plane of an area light source. Neither of these circumstances 
occurs in the antipenumbra computation, since (1) all light sources and holes are areal, and (2) no portal 
plane can be traversed twice during any valid portal sequence through the spatial subdivision. The internal 
swaths induced by the polygon configuration of Fig­ure 16, intersected with a plane beyond the final 
hole to produce segments of lines and conies, are shown in Figure 19. The segments comprise a planarcume 
arrangement of complexity 0(n2), each cell of which contains points having the same aspect, or qualitative 
view, of the light source. Of course, penumbral swaths also demarcate qualitative changes in occlusion, 
since by stepping across one, an observer would see the light source appear or disappear from view. Finally, 
we show how an area light source and as few as three holes can produce a disconnected antipenumbra. First, 
a light source and two holes, all thin rectangular slits, are arranged so as to admit a fattened regulus 
of antipenumbral light (Figure 20-i). A third slit then partitions the fattened reguhts into two disconnected 
compo­nents (Figure 20-ii).  Conclusion We presented an 0( n~) time algorithm that computes the antipenum­bra 
cast by a convex light source through a sequence of convex holes Computer Graphics, 26, 2, July 1992 
in three dimensions, with total edge complexity n. We described the antipenumbra as a disconnected volume 
bounded by regions of quadric and planar surfaces, and showed that each swath, or portion of the antipenumbral 
boundaty in three-space, arises from a conic segment on the intersection of a five-dimensional convex 
hull with a four-dimensional quadric surface, the Pliicker quadric. The algo­rithm is related to the 
aspect graph computation, in that it generates surfaces that separate regions with qualitatively distinct 
views of the light source or the intervening holes. We identified both penumbral and internal swaths 
as surfaces along which the first derivative of illumination intensity changes discontinuously due to 
csccl[iskm. We demonstrated an implementation of the antipenumbracompu­tation on several polygon sequences. 
The algorithm was motivated by a visibility scheme involving static, volume-based culling in three dimensions. 
Knowledge of the antipenumbra may also prove useful, however, in shadowing algorithms and meshing schemes 
that model illumination discontinuities. Acknowledgments Jim Winget, my mentor at Silicon Graphics, 
was an extraordinary motivator and facilitator of this work. My advisor Carlo Wquin has been a constant 
source of inspiration, encouragement, and valuable observations. The late Professor Ren6 de Vogelaere 
taught me about reguli and classical geometry. Ziv Gigus, John Airey, Jim Ruppert, and Efi Fogel made 
thoughtful comments on an early draft of this paper. Raimund Seidel and Michael Hohmeyer also contributed 
helpful insight and comments. Paul Haeberli provided aesthetic advice, and helped prepare the color figures 
for submission and publication. Finally, Silicon Graphics afforded me access to their considerable physical 
resources. References [1] P. Atherton, K. Weiler, and D. Greenberg. Polygon shadow generation. Computer 
Graphics (Pro<. SIGGRAPH 78), 12:275 281 , 1978. [2] B. Griinbaum. Corr} ex Polytope,s. Wiley -lnterscience, 
New York, 1967. [3] Daniel R. Baum, Stephen Mann, Kevin P. Smith, and James M. Winget, Making radiosity 
usable: Automatic preprocessing and meshing techniques for the generation of accurate radios­ity solutions. 
Computer Graphics (Proc. SIGGRAPH 91), 25(4):51-60, 1991. [4] A.T. Campbell 111and Donald S. Fussell. 
Adaptive mesh generation for global diffuse illumination. Comparer Graphics (Proc. SIGGRAPH 91 ), 24(4): 
155-164, 1990. [5] Norman Chin and Steven Feiner. Fast object-precision shadow generation for area light 
sources using BSP trees. In Proc. ! 992 Symposium on Interactive 3D Graphics, pages 2 I-30, 1992. [6] 
Kenneth L. Clarkson and Peter W. Shor. Applications of ran­dom sampling in computational geometry Il. 
Di.wrete Cmr­putational Geometry, pages 387421, 1989. [7] Frank C. Crow. Shadow algorithms for computer 
graphics. Computer Graphics (Proc. SIGGRAPH 77), I I (2):242-248, 1977. SIGGRAPH 92 Chicago, July 26-31, 
1992 [8] H. Fuchs, Z. Kedem, and B. Naylor. On visible surface genera­tion by a priori tree structures. 
Computer Graphics (Proc. SIG-GRAPH 80), 14(3): 124-133, 1980. [9] Thomas A. Funkhouser, Carlo H. S6quin, 
and Seth J. Teller. Management of large amounts of data in interactive building walkthroughs. In Proc. 
1992 Workshop on Interactive 3D Graphics, pages 11-20, 1992. [lo] Ziv Gigus, John Canny, and Raimund 
Seidel. Efficiently com­puting and representing aspect graphs of polyhedral objects. IEEE Transactions 
on Pattern Analysis and Machine Intelli­gence, 13(6):542 55 1, 1991. [11] Ziv Gigus and Jitendra Malik. 
Computing the aspect graph for line drawings of polyhedral objects. IEEE Transactions on Pattern Analysis 
and Machine Intelligence, 12(2): 113-122, I990. [12] Pat Hanrahan and David Salzman. A rapid hierarchical 
radlos­ity algorithm. Computer Graphics (Proc. SIGGRAPH 91), 25(4): 197-206, 1991. [13] Paul S. Heckbert. 
Simulating Global Illumination Using Adap­tive Meshing. PhD thesis, Computer Sciences Department, University 
of California, Berkeley, June 1991. [14] J.J. Koenderink and A,J. van Doom. The internal represen­tation 
of solid shape with respect to vision. Biol, Cybem., 32:211-216, 1979. [15] Tomoyuki Nishita and Eihachiro 
Nakamae. Half-tone repre­sentation of 3-D objects ilhsminated by area sources or poly­hedron sources. 
In Proc. IEEE COMPSAC, 1983, pages 237-242, 1983. [16] Tomoyuki Nishita and Eihachiro Nakamae. Continuous-tone 
representation of three-dimensional objects taking account of shadows and interreflection. Computer Graphics 
(Prac. SIG-GRAPH 85), 19(3):23-30, 1985. [17] Joseph O Rourke. Art Gallery Theorems and Algorithms. Ox­ford 
University Press, 1987. [18] Marco Pellegrirri. Stabbing and ray-shooting in 3-dimensional space. In 
Pmt. 6th ACM Symposium on Computational Ge­omehy, pages 177 186, I990. [19] Ken Perlin and Xue-Dong Wang. 
An efficient approximation for penumbra shadow. Technical Report 346, New York Uni­versity Courant Institute 
of Mathematical Sciences, Computer Science Division, 1988. [20] W.H Plantinga and C.R. Dyer. Vkibility, 
occlusion, and the aspect graph. lnt. J. Computer Wsion, 5(2): 137 160, 1990. [21] David Salesin, Dani 
Lischinski, and Tony DeRose. Recon­stmcting illumination functions with selected dlscontinuities. In 
Proc. 3rd Eurographics Workshop on Rendering, 1992. [22] Raimund Seidel. Linear programming and convex 
hulls made easy. In Proc. 6th ACM Symposium on Computational Ge­ometry, pages 2 I I 215, 1990. [23] D.M.Y. 
Somerville. Analytical Geomet~ of Three Dimen­sions. Cambridge University Press, 1959. [24] Seth J. 
Teller and Michael E. Hohrneyer. Computing the lines piercing four lines. Technical Report UCB/CSD91 
/665, Com­puter Science Department, U.C. Berkeley, 1991. [25] Seth J. Teller and Michael E. Hohmeyer. 
Stabbing oriented convex polygons in randomized 0(rt2) time. Technical Re­port UCB/CSD 91/669, Computer 
Science Department, U.C. Berkeley, 1992. [26] Seth J, Teller and Carlo H. %quin. Vkibility preprocessing 
for interactive walkthroughs. Computer Graphics (Proc. SIG-GRAPH 91), 25(4):61-9, 1991. [27] Seth J, 
Tejler and Carlo H. !ik$quin. Visibility computations in polyhedral three-dimensional environments. Technical 
Re­port UCB/CSD 92/680, Computer Science Department, U.C. Berkeley, 1992. i48 
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134031</article_id>
		<sort_key>149</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>17</seq_no>
		<title><![CDATA[Topological design of sculptured surfaces]]></title>
		<page_from>149</page_from>
		<page_to>156</page_to>
		<doi_number>10.1145/133994.134031</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134031</url>
		<keywords>
			<kw><![CDATA[automorphic functions]]></kw>
			<kw><![CDATA[boundary value problems]]></kw>
			<kw><![CDATA[computer-aided design]]></kw>
			<kw><![CDATA[marked polygon]]></kw>
			<kw><![CDATA[multiply periodic functions]]></kw>
			<kw><![CDATA[sculptured surfaces]]></kw>
			<kw><![CDATA[topology]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Geometric algorithms, languages, and systems</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>G.1.7</cat_node>
				<descriptor>Boundary value problems</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Curve, surface, solid, and object representations</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.6</cat_node>
				<descriptor>Interaction techniques</descriptor>
				<type>S</type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010147.10010371.10010387</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Graphics systems and interfaces</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010401</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Volumetric models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003120.10003121.10003125.10010391</concept_id>
				<concept_desc>CCS->Human-centered computing->Human computer interaction (HCI)->Interaction devices->Graphics input devices</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002950.10003714.10003727.10003728</concept_id>
				<concept_desc>CCS->Mathematics of computing->Mathematical analysis->Differential equations->Ordinary differential equations</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010399</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Parametric curve and surface models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003752.10010061</concept_id>
				<concept_desc>CCS->Theory of computation->Randomness, geometry and discrete structures</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
			<gt>Design</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>PP31075864</person_id>
				<author_profile_id><![CDATA[81100399802]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Helaman]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Ferguson]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Supercomputing Research Center, Bowie, MD]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P15780</person_id>
				<author_profile_id><![CDATA[81100334998]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[Alyn]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Rockwood]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Computer Science Dept., Arizona State University, Tempe, AZ]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P147808</person_id>
				<author_profile_id><![CDATA[81100290986]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>3</seq_no>
				<first_name><![CDATA[Jordan]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Cox]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Dept. of Mech. Eng., Purdue University, West Lafayette, IN]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_obj_id>91781</ref_obj_id>
				<ref_obj_pid>91778</ref_obj_pid>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Bloor, M. I. G., Wilson, M. J., "Using Partial Differential Equations To Generate Free-Form Surfaces", Computer-Aided Design, vo| 22, number 1, May 1990.]]></ref_text>
				<ref_id>Blo90</ref_id>
			</ref>
			<ref>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Bloor, M. I. G., Wilson, M. J., "Generating N- sided Patches with Partial Differential Equations~, Computer Graphics International, Wyvil, B. (Editor), Springer-Verlag 1989.]]></ref_text>
				<ref_id>Blo89</ref_id>
			</ref>
			<ref>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Cannon, L, "The Combinatorial Structure of Cocompact Discrete Hyperbolic Groups,~ Geometn'ae Dedicata, vol 16, 1984, 123-148.]]></ref_text>
				<ref_id>Can84</ref_id>
			</ref>
			<ref>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[Cannon, J., Wagreich, P., "Growth Functions of Surface Groups", to appear in Math. Annalen, 1992.]]></ref_text>
				<ref_id>Can92</ref_id>
			</ref>
			<ref>
				<ref_obj_id>144412</ref_obj_id>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[Cox, 3., "Domain Composition Methods For Combining Geometric And Continuum Field Models", PhD Thesis, Purdue University, West Lafayette, IN, Ikcember 1991.]]></ref_text>
				<ref_id>Cox91a</ref_id>
			</ref>
			<ref>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[Cox, J., Anderson, D., C., "Single Model Formulations That Link Engineering Analysis With Geometric Modeling", Product Modeling for Computer-Aided Design and Manufacturing, J. Turner, J. Pegna and M. Wozny (F.zlitors), Elsiver Science Publishers B. V., North-Holland, New York, 1991.]]></ref_text>
				<ref_id>Cox91b</ref_id>
			</ref>
			<ref>
				<ref_obj_id>112579</ref_obj_id>
				<ref_obj_pid>112515</ref_obj_pid>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Cox, J., Charlesworth, W., W., Anderson, D. C., "Domain Composition Methods For Associating Geometric Modeling With Finite Element Modeling", Proceedings of the ACM/SIGGRAPH Symposium on Solid Modeing Foundations and CAD/CAM Applications, Austin, TX, June 5-7, 1991.]]></ref_text>
				<ref_id>Cox91c</ref_id>
			</ref>
			<ref>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[Cox, J., Ferguson, H. R. P., Kohkonen, K., "Single Domain Methods For Modeling Objects In The Round For Engineering And Manufacturing Applications", Advances in Design Automation, ASME Design Automation Conference, Orlando, FL, Sept. 25-28, 1988.]]></ref_text>
				<ref_id>Cox88</ref_id>
			</ref>
			<ref>
				<ref_obj_id>573874</ref_obj_id>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Epstein, D.B.A., J.W.Cannon, D.F.Holt, F.V.F. Levi, M.S.Paterson, W.P.Thurston, Word Processing in Groups, jones and Bartlett, Boston, 1992.]]></ref_text>
				<ref_id>Eps92</ref_id>
			</ref>
			<ref>
				<ref_obj_id>61954</ref_obj_id>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[Farin, G. E., Curves and surfaces for Computer Aided Geometric Design, Academic Press Inc., Boston, 1988.]]></ref_text>
				<ref_id>Far88</ref_id>
			</ref>
			<ref>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[Ferguson, H., "Umbilic Torus NC," SIGGRAPH'89 Art Show, Boston, Mass., Leonardo, Journal of the International Society for the Arts, Sciences and Technology, Supplemental Issue, August 1989, page 117, 122.]]></ref_text>
				<ref_id>Fer89</ref_id>
			</ref>
			<ref>
				<ref_obj_id>91011</ref_obj_id>
				<ref_obj_pid>91008</ref_obj_pid>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[Ferguson, H., Two Theorems, Two Sculptures, Two Posters, American Mathematical Monthly, Volume 97, Number 7, August-September 1990, pages 589 - 610.]]></ref_text>
				<ref_id>Fer90</ref_id>
			</ref>
			<ref>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[Ferguson, H., "Algorithms for Scientific Visualization," Supercomputing Research Center Tech. report SRC-92-xxx, 1992.]]></ref_text>
				<ref_id>Fer92</ref_id>
			</ref>
			<ref>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[Firby, P. and C. Gardiner, Surface Topology, John Wylie &amp; Sons, New York, 1982.]]></ref_text>
				<ref_id>Fir82</ref_id>
			</ref>
			<ref>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[Ford, L R., Automorptffc Functions, Chelsea, Hew York 1951.]]></ref_text>
				<ref_id>For51</ref_id>
			</ref>
			<ref>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[Hoffmann, C., Geometric Modeling, Morgen Kaufman, New York, 1990.]]></ref_text>
				<ref_id>Hof90</ref_id>
			</ref>
			<ref>
				<ref_seq_no>17</ref_seq_no>
				<ref_text><![CDATA[Lapidus, L., Pinder, G. F., Numerical Solutions of Partial Differential Equations in Science and Engineering, John Wiley &amp; Sons, New York, 1982.]]></ref_text>
				<ref_id>Lap82</ref_id>
			</ref>
			<ref>
				<ref_seq_no>18</ref_seq_no>
				<ref_text><![CDATA[Martin, G. E., The Foundations of Geometry and the Non-Euclidean Plane, Springer-Verlag, New York, Second Printing, 1986.]]></ref_text>
				<ref_id>Mar86</ref_id>
			</ref>
			<ref>
				<ref_seq_no>19</ref_seq_no>
				<ref_text><![CDATA[Rockwood, Alyn, "The (5,3) Toroidal Knot," SIGGRAPH86 Art Show Catalog,August,1986.]]></ref_text>
				<ref_id>Roc86</ref_id>
			</ref>
			<ref>
				<ref_seq_no>20</ref_seq_no>
				<ref_text><![CDATA[Siegel, C.L., Topics in Complex Function Theory, vol.l: "Elliptic Functions and Uniformization Theory'; vol.2, "Automorphic Functions and Abelian Integrals", Wylie Interscience, New York, 1988]]></ref_text>
				<ref_id>Sie88</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
   Computer Graphics, 26,2, July 1992 Move clockwise around the polygon and give the letter a -1 superscript 
if its edge runs counter to the movement, otherwise the letter gets no superscript. The word that describes 
the toms in Figure 2.1 is ABA-lB-l. ThewordABAB-l, forwhichthedirectionof thethirdedge differs from the 
torus, represents the Klein bottle and is always an immersion. Immersions and embedding are both possible 
for tori. A surface is orientable if an inside and an outside can be distinguished, i.e. bounds a natural 
object. The sphere and torus are orientable; the Klein bottle is not. The following theorem classifies 
all orientable surfaces: A closed, orientable surface has a marked polygon word either of the form AA-l 
or AI BIA1-l B1-l ... AgBgAg-l Bg-l (g> 0). The fmt case is a sphere. The second can be thought of as 
gluing g tori together. The number g is the genus of the object. It counts the number of donut holes. 
These are called handles. All objects of the same genus are topologically equivalen~ they can be continuously 
deformed from one to another. A corollary to the above theorem is A closed, orientable suflace (g>O) 
has a marked polygon with 4g sides. Many cutting schemes are possible for objects of genus g>l. The textbook 
cuts [Fu82, Sre88] usually emanate from a central point and emphasize symmetries as in Figure 6. We have 
devised non-standard cuts that are better for some purposes. Consider the double torus ( Borus )shown 
in Figure 2.2. All cuts begin at point A inside on the bottom of the lower handle. The fnt cut divides 
the bottom loop into two sleeves. The next one slits the sleeve orthogonally to the fust along C. The 
next pair of cuts run from one sleeve comer totheotherthroughalong B andthenD. The example is easily 
generalized to a genus g objecq g>2. The object is first deformed into an extended figure 8. All cuts 
are made from the same point. The even cuts traverse through each handle and return to the point. The 
odd set of cuts start from the point and pass through the antipodal point in the handle without intersecting 
any other cuts. The next step in the marked polygon design process determines vector valued functions 
that define the surface. Consider the function fl P+S, for P a polygon in R2, surface S in R 3 and f: 
(u, v) +(x, y, z). Notice that pairwise related edges of the marked polygon must map so theirdirectionscoincide 
on the surface. The function ~ is vector-valued with coordinate functions fj: R2+ R, j=l,2,3, where x 
= ~l(u,v), y = \2(u,v) and z = ~3(u,v). These coordinate functions have the polygon as a single common 
domain. B B-l Figure2.2. Illustrationofthesystemofvirtualcutsona doubletorusasitk openeduptoastopsignshapedmarked 
polygon with formal word ACBDA-lC-lB-lD-l.  4. Defining the Embedding with Multiply Periodic Functions. 
 Natural sculptured objects are always bounded by a surface, are closed, and have genus. For a surface 
to have genus amounts to having multiple periods. A simple closed curve in space is periodic and has 
periodic coordimte functions. Closed surfaces in space can be defined by coordinate functions that are 
multiply periodic. A rich class of multiply periodic functions are available in the classical literature 
[For51, Sie88]. In this literature multiply periodic functions are usually called automo~hic functions 
because these functions are invarient under a group of automorphisms. A problem with the classical literature 
is that it tends to be preoccupied with complex analytic functions that do not give bounded embedding. 
We circumvent this obstruction by constructing enough real analytic functions which are bounded. These 
real analytic (smooth) functions are the analogs of the classical doubly periodic real analytic functions 
of variables u and v, the finite Fourier series in Sin(u), Sin(v), Cos(u), Cos(v) encountered for the 
torus in Section 3.2. Another feature is that the multiple periods of interest for surfaces of genus 
greater than one are not additive. The periods are elements of a multiplicative and non-commutative group 
of transformationsof the variables u and v. Multiply periodic functions can h of any arbitrary differentiability 
class. In what follows, we solve the problem of defining a smooth embedding from the marked polygon to 
the surface of an object. It allows the embedding to be defined smoothly across the boundary marks of 
the domain, and thus the virtual cuts of the object. We realize this markedpolygon in the hyperbolic 
disc with sides which are geodesics in the hyperbolic geometry. The multiple periods will be hyperbolic 
translations. All these hyperbolic translations form a multiplicative group, The hyperbolic translationstessellate 
the hyperbolic disc with copies of the markedpolygon. Traversingthe polygon from one tesselant to a neighbor 
is equivalent to recentering the original polygon at another point of the tmundary. A periodizing transformation 
is defined on the tessellated disc that takes functions, say polynomials, over the fundamental domain 
and blends them at the marks, making them seamless, i.e. infinitely smooth across the virtual cuts. This 
was done for taking the tear drop to the smooth circle in Section 3.1. This multiple periodizing transformation 
involves a sum over all of the elements of the group of hyperbolic translations. A different group will 
be defined for each genus. 4.1. The Hyperbolic Disc. The natural geometry for the surfaces with handles 
which are of interest to us is a hyperbolic geometry. A surface with g handles can be cut with 2g cuts. 
The comesponding polygon has 4g sides and can be laid down in a hyperbolic geometry, mar83]. One model 
for this geometry, the Poincan5model, is given by imposing some geometric structureon the unit disc (z 
I ZZ*<1,zE C} where C is the usual complex number field and z* is the complex conjugate. The points of 
this hyperbolic geometry are the points of the unit disc. The lines or geodesics of this hyperbolic geometry 
are given Computer Graphics, 26, 2, July 1992 by arcs in the unit disc of circles peqwmdicularto the 
disc boundary at their endpoints. Lengths of arc segments, angles between intersecting arcs, and area 
of polygons bounded by arcs are all &#38;fincd, [Sie66]. One-to-one, onto, analytic mappings of the disc 
to itself that pr-e lengths and angles are given by linear fractional transformationsof the form z -> 
(az+b)/(b*z+a*) where a, b are complex numbers such that aa*-bb*=l. Among these are the hyperbolic rzanslationswe 
define for the periods of a sphere with finitely many handles. 4.2. The Single Marked Polygon Patch. 
As described in Section 2, it is possible to mark a surface with exactly g handles in such a way that 
when the surface can be sewn up from the interior of a polygon of exactly 4g sides, where opposite sides 
are identified and the sewing is done without twisting. We specify a particular such polygon with 4g 
circular arc sides in the hyperbolic disc. This special set of 4g circular arcs comprises the boundary 
of the what we will call the canonical 4g -gon. It is symmetric about the origin. Ad@ining arcs are constrained 
to meet a vertex with interior angles of exactly n/2g radians. Hence, the sum of these 4g angles is exactly 
2x. This ensures, by a theorem of Poincar6 ~ir82], that a group of h~rbolic translations, rg which we 
define Mow, of the 4g-gon exactly covem the hyperbolic disc. Each boundary circular arc is given by the 
inside arc of a chcle of radius sin(7t/4g) r= e centered at integer multiples of x/2g and radius cg=rg 
cot(n/4g). For genus two, Q=J% dc2=J% The mdhs of the excribed circle containing the eight vertices of 
the poly on is 2-1/4 and the radius of the inscribed circle is (21b -1)12. 4.3. The Group rg of Multiple 
Periods. Define lg and mg by $tan;(l-:) and  21* m= . g 1+~ Define the hyperbolic translation z-m Tg:z+ 
,  1-m~z of intinite order,and the single rotation L -1 Rg:z+e2g z, I 53   SIGGRAPH 92 Chicago, 
July 26-31, 1992 The surface of the double torus of Figure 7 has anomalous bumps and ridges. Changes 
in the partial differential operator affect bumpiness. For example, the stiffness of the surface could 
be increased, the order or form of the differential operatorcan be modi.tkl, or a body force applied 
to smooth the resulting object. Further investigation into these methods is ongoing. Another problem 
is the distortion of the grid on the octagonal domain to the image grid on the double torus. More research 
on partial differential operators and more &#38;velopment of methodsof selecting internalconstraintsis 
invitedtoconmol the modeling of coordinate functions. It is significant to note that the genus of the 
object is preserved throughout while them is great flexibility in the shape and locations of the handles. 
This gives a spatial richness needed for geometric design. 6. Conclusion Our approach is unique in its 
incorporation of topology as well as geometry into the design process. This leads to more comprehensive 
models for scientific visualization and manufacturingneeds and is well-suited to a variety of representations 
of complex objects which arise naturally from tie abstrtwtionprocess in scientitlc research. A basic 
outstanding problem is to provide a good set of sufficient conditions (on the coordinate functions) to 
give an embedding of a sphere with handles. The techniques introducedhereworkinprincipleforanydimension. 
Future directions includes applying these ideas for volume domains and volume images with attached functions. 
Acknowledgements We appreciate Sareddy Madhukar of Spatial Technologies, Boulder, CO for help on Figure 
3.3 and Dave Smittley of the Super computing Research Center Bowie, MD for help with Figure 4.5. References 
llW90] Bloor, M. I. G., Wilson, M. J., Using Partial Differential Equations To Generate Free-Form Surfaces 
, Computer-Ai&#38;d Design, vol 22, number 1, May 1990. @lW89] Bkmr, M. I. G., Wilson, M. J., Generating 
N­sided Patches with Partial Differential Equations , Computer Graphics International, Wyvil, B. (Editor), 
Springer-Verlag 1989. [can84] Cannon, J., The Combinatorial Structure of Cocompact Discrete Hyperbolic 
Groups,n Geometrt aeDedicata, VOI16,1984,123-148. [Can92] Cannon, J,, Wagmich, P., GrowthFunctions of 
Surface Groups , to appear in Math. Annalen, 1992. [Cox91a] Cox, J., Domain Composition Methods For Combining 
Geometric And Continuum Field Models , PhD Thesis, Purdue University, West Lafayette, IN, December 1991. 
[Cox91b] Cox, J., Anderson, D., C., Single Model Formulations That Link Engineering Analysis With Geometric 
Modeling , Product Modeling for Computer-Ai&#38;d Design and Man#actura ng, J, Turner, J. Pegna and M. 
Wozny (Editors), Elsiver Science Publishers B. V., North-Holland, New York 1991. [COX91C]Cox, J., Charlesworth, 
W., W., Anderson, D. c., Domain Composition Methods For Associating Geometric Modeling With Finite Element 
Modeling , Proceedings of the ACMISIGGRAPH Symposium on Solid Modeing Foundations and CADICAM Applications, 
Austin, TX, June 5-7,1991. [COX88] Cox, J., Ferguson, H. R. P., Kohkonen, K., Single Domain Methods For 
Modeling Objects In The Round For Engineering And Manufacturing Applications , Advances in Design Automation, 
ASME Design Automation Conference, Orlando, FL, Sept. 25-28, 1988. rEPs921 Epstein, D.B.A., J.W.Cannon, 
D.F.Holt, F.V.F. Levi, M.S.Paterson, W.P.Thurston, Word Processing in Groups, Jones and Bartlett, Boston, 
1992. rFar88] Farin, G. E., Curves and sur$acesfor Computer Aided Geometric Design, Academic Press Inc., 
Boston, 1988. l-Fe&#38;9] Ferguson, H., Umbilic Torus NC, SIGGRAPH89 Art Show, Boston, Mass., Leonardo, 
Journalof the Intematiomd Society for the Arts, Sciences and Technology, Supplemental Issue, August 1989, 
page 117, 122. l-Fer90] Ferguson, H., Two Theorems, Two Sculptures, Two Posters, American Mathematical 
Monthly, Volume 97, Number 7, August-September 1990, pages 589-610. rFer92] Ferguson, H., Algorithms 
for Scientific Visualization, Supmmmputing Research Center Tech. qort SRC-92-XXX,1992. Fir82] Firby, 
P. and C. Gardiner, Surface Topology, John Wylie &#38; Sons, New York, 1982. FO151] Ford, L R,, Automorphic 
Functions, Chelsea, New York 1951. rHof90] Hoffmann, C., Geometric Modeling, Morgen Kaufman, New York, 
1990. [~2] Lapidus,L., Finder,G. F., Munericai Solutions of Partial Differential Equatwns in Science 
and Engineering, John Wiley &#38; Sons, New York, 1982. Martin, G. E., The Foundations of Geometry and 
the Non-Euclidean Plane, Springer-Verlag, New York, Second Rinting, 1986.  B-1 Rockwood, Alyn, The (5,3) 
Toroidal Knot, SIGGRAPH86 Art Show Catalog~ugust,1986. [Sie88] Siegel, C.L., Topics in Complex Function 
Theory, vol.1: Elliptic Functions and Uniformization Theory ; VO1.2, Automorphic Functions and Abelian 
Integrals , Wylie Interscience,New York 1988 
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134033</article_id>
		<sort_key>157</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>18</seq_no>
		<title><![CDATA[Variational surface modeling]]></title>
		<page_from>157</page_from>
		<page_to>166</page_to>
		<doi_number>10.1145/133994.134033</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134033</url>
		<keywords>
			<kw><![CDATA[constrained optimization]]></kw>
			<kw><![CDATA[interaction techniques]]></kw>
			<kw><![CDATA[surface design]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Curve, surface, solid, and object representations</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>G.1.2</cat_node>
				<descriptor>Spline and piecewise polynomial approximation</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>G.1.6</cat_node>
				<descriptor>Constrained optimization</descriptor>
				<type>S</type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10003752.10003809.10003716</concept_id>
				<concept_desc>CCS->Theory of computation->Design and analysis of algorithms->Mathematical optimization</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002950.10003714.10003736.10003737</concept_id>
				<concept_desc>CCS->Mathematics of computing->Mathematical analysis->Functional analysis->Approximation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002950.10003714.10003716</concept_id>
				<concept_desc>CCS->Mathematics of computing->Mathematical analysis->Mathematical optimization</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002950.10003714.10003715.10003720</concept_id>
				<concept_desc>CCS->Mathematics of computing->Mathematical analysis->Numerical analysis->Computations on polynomials</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010401</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Volumetric models</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010399</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Parametric curve and surface models</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>PP31024562</person_id>
				<author_profile_id><![CDATA[81100043538]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[William]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Welch]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[School of Computer Science, Carnegie Mellon University, Pittsburgh, PA]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P18516</person_id>
				<author_profile_id><![CDATA[81100295587]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[Andrew]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Witkin]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[School of Computer Science, Carnegie Mellon University, Pittsburgh, PA]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[I. Babuska and W. C. Rheinboldt. Error estimates for adaptive finite element computations. SlAM J. Numer. Anal., 15(4), 1978.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Richard H. Bartels and John C. Beatty. A technique for the direct manipulation of spline curves. In Proceedings, Graphics Interface, 1989.]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_obj_id>362974</ref_obj_id>
				<ref_obj_pid>362946</ref_obj_pid>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Richard. H. Barrels and Gene Golub. The simplex method of linear programming using lu decomposition. CACM, 12(5), May 1969.]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[~ ke Bjtirck. A general updating algorithm for constrained linear least squares problems. SlAM J. Sci. and Stat. Comp., 5(2), 1984.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122746</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[George Celniker and Dave Gossard. Deformable curve and surface finite-elements for free-form shape design. Computer Graphics, 25(4), July 1991. Proceedings SIGGRAPH '91.]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_obj_id>147191</ref_obj_id>
				<ref_obj_pid>147156</ref_obj_pid>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[George Celniker and William Welch. Linear constraints for nonuniform b-spline surfaces. In Proceedings, Symposium on Interactive 3D Graphics, 1992.]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[J. E De. S. R. Gago, D. W. Kelly, and O. C. Zienkiewicz. A posteriori error analysis and adaptive processes in the finite element method: Part ii - adaptive mesh refinement. Int. J. Numet. Methods Eng., 19:1621-1656, 1983.]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_obj_id>83600</ref_obj_id>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[Gerald Farin. Curves and Surfaces for Computer Aided Geometric Design. Academic Press, Inc., 1990.]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_obj_id>137847</ref_obj_id>
				<ref_obj_pid>137844</ref_obj_pid>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Philip Fong and Hans-Peter Seidel. Control points for multivariate b-spline surfaces over arbitrary triangulations. Computer Graphics Forum, 10:309-3 17, 1991.]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378512</ref_obj_id>
				<ref_obj_pid>378456</ref_obj_pid>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[D.R. Forsey and R.H. Barrels. Hierarchical b-spline refinement. Computer Graphics, 22(4), August 1988. Proceedings SIGGRAPH '88.]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
			<ref>
				<ref_obj_id>147172</ref_obj_id>
				<ref_obj_pid>147156</ref_obj_pid>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[Barry Fowler. Geometric manipulation of tensorproduct surfaces. In Proceedings, Symposium on Interactive 3D Graphics, 1992. (to appear).]]></ref_text>
				<ref_id>11</ref_id>
			</ref>
			<ref>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[Barry Fowler and Richard Bartels. Constraint-based curve manipulation. In ACM Siggraph Course Notes, Topics in the Construction, Manipulation, and Assessment of Spline Surfaces, 1991.]]></ref_text>
				<ref_id>12</ref_id>
			</ref>
			<ref>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[Gene Golub and Charles Van Loan. Matrix Computations. Johns Hopkins University Press, 1989.]]></ref_text>
				<ref_id>13</ref_id>
			</ref>
			<ref>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[W.E.L. Grimson. An implementation of a computational theory of surface orientation. Computer Vision, Graphics, and Image Processing, 22( I ):39-69, 1983.]]></ref_text>
				<ref_id>14</ref_id>
			</ref>
			<ref>
				<ref_obj_id>19623</ref_obj_id>
				<ref_obj_pid>19619</ref_obj_pid>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[B.K.P. Horn and M.J. Brooks. The variational approach to shape from shading. Computer Vision, Graphics, and Image Processing, 33:174-208, 1986.]]></ref_text>
				<ref_id>15</ref_id>
			</ref>
			<ref>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[D. W. Kelly. The self-equilibration of residuals and upper bound eror estimates in the finite element method. In I. Babuska, editor, Accuracy Estimates and Adaptive Refinements in Finite Element Computations, pages 129-146. Wiley, 1986.]]></ref_text>
				<ref_id>16</ref_id>
			</ref>
			<ref>
				<ref_seq_no>17</ref_seq_no>
				<ref_text><![CDATA[D. W. Kelly, J. P. De. S. R. Gago, and O. C. Zienkiewicz. A posteriori error analysis and adaptive processes in the finite element method: Part i - error analysis, lnt.J. Numer. Methods Eng., 19:1593- 1619, 1983.]]></ref_text>
				<ref_id>17</ref_id>
			</ref>
			<ref>
				<ref_obj_id>63739</ref_obj_id>
				<ref_obj_pid>63735</ref_obj_pid>
				<ref_seq_no>18</ref_seq_no>
				<ref_text><![CDATA[N.J. Lott and D. I. Pullin, Method for fairing b-spline surfaces. Computer-Aided Design, 20(10), 1988.]]></ref_text>
				<ref_id>18</ref_id>
			</ref>
			<ref>
				<ref_obj_id>134035</ref_obj_id>
				<ref_obj_pid>133994</ref_obj_pid>
				<ref_seq_no>19</ref_seq_no>
				<ref_text><![CDATA[Henry Moreton and Carlo S6quin. Functional minimization for fair surface design, in these proceedings.]]></ref_text>
				<ref_id>19</ref_id>
			</ref>
			<ref>
				<ref_obj_id>15906</ref_obj_id>
				<ref_obj_pid>15886</ref_obj_pid>
				<ref_seq_no>20</ref_seq_no>
				<ref_text><![CDATA[Francis J. M. Schrnitt, Brian A. Barsky, and Wen-Hui Du. An adaptive subdivision method for surfacefitting from sampled data. Computer Graphics, 20(4), 1986. Proceedings SIGGRAPH '86.]]></ref_text>
				<ref_id>20</ref_id>
			</ref>
			<ref>
				<ref_seq_no>21</ref_seq_no>
				<ref_text><![CDATA[D.G. Schweikert. An interpolation curve using a spline in tension. Journal ofMath andPhys., 45:312- 317, 1966.]]></ref_text>
				<ref_id>21</ref_id>
			</ref>
			<ref>
				<ref_seq_no>22</ref_seq_no>
				<ref_text><![CDATA[Gilbert Strang. Introduction to Applied Mathematics. Wellesley-Cambridge Press, 1986.]]></ref_text>
				<ref_id>22</ref_id>
			</ref>
			<ref>
				<ref_obj_id>37427</ref_obj_id>
				<ref_obj_pid>37402</ref_obj_pid>
				<ref_seq_no>23</ref_seq_no>
				<ref_text><![CDATA[Demetri Terzopoulis, John Platt, Alan Barr, and Kurt Fleischer. Elastically deformable models. Computer Graphics, 21(4), July 1987. Proceedings of SIG- GRAPH '87.]]></ref_text>
				<ref_id>23</ref_id>
			</ref>
			<ref>
				<ref_obj_id>889269</ref_obj_id>
				<ref_seq_no>24</ref_seq_no>
				<ref_text><![CDATA[D. Terzopoulos. Multi-level reconstruction of visual surfaces. MIT Artificial Intelligence Memo Number 671, April 1981.]]></ref_text>
				<ref_id>24</ref_id>
			</ref>
			<ref>
				<ref_obj_id>5994</ref_obj_id>
				<ref_obj_pid>5979</ref_obj_pid>
				<ref_seq_no>25</ref_seq_no>
				<ref_text><![CDATA[D. Terzopoulos. Regularization of inverse visual problems involving discontinuities. IEEE Trans. Pattern Analysis and Machine Intelligence, PAMI- 8:413-424, 1986.]]></ref_text>
				<ref_id>25</ref_id>
			</ref>
			<ref>
				<ref_seq_no>26</ref_seq_no>
				<ref_text><![CDATA[Charles Van Loan. On the method of weighting for equality-constrained least-squares problems. SlAM J. Numer. Anal., 22(5), 1985.]]></ref_text>
				<ref_id>26</ref_id>
			</ref>
			<ref>
				<ref_seq_no>27</ref_seq_no>
				<ref_text><![CDATA[O.C. Zienkiewicz and K. Morgan. Finite Elements and Approximation. John Wiley and Sons, 1983.]]></ref_text>
				<ref_id>27</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 Computer Graphics, 26, 2, July 1992 Variational Surface Modeling WilliamWelchand AndrewWhkin Schoolof 
ComputerScience CarnegieMellon University Pittsburgh, PA 15213 {welchl witkln}@cs. emu. edu  Abstract 
 We present a new approach to interactive modeling of free­form surfaces. Instead of a fixed mesh of 
control points, the model presented to the user is that of an infinitely mal­leable surface, with no 
fixed controls. The user is free to apply control points and curves which are then avail­able as handles 
for direct manipulation. The complexity of the surface s shape may be increased by adding more control 
points and curves, without apparent limit. Within the constraints imposed by the controls, the shape 
of the surface is fully determined by one or more simple criteria, such as smoothness. Our method for 
solving the resulting constrained variational optimization problems rests on a surface representation 
scheme allowing nonuniform sub­division of B-spline surfaces. Automatic subdivision is used to ensure 
that constraints are met, and to enforce er­ror bounds. Efficient numerical solutions are obtained by 
exploiting linearities in the problem formulation and the representation. Keywords: surface design, constrained 
optimization, interaction techniques Introduction The most basic goal for interactive free-form surface 
de­sign is to make it easy for the user to control the shape of the surface. Traditionally, the pursuit 
of this goal has taken the form of a search for the right surface representation, one whose degrees of 
freedom suffice as controls for di­rect manipulation by the user. The dominant approach to surface modeling, 
using a control mesh to manipulate a Permission to copy without fee all m part of this material is granted 
prnvideci that the cnpies are not made or distributed for direct commercial advantage, the ACM copyright 
notice and the title of the publication and its date appear, and notice is given [hat copying is by permission 
of lhe Associa[imr for Ccrmputmg Machinery. Tn copy otherwise, or to republish, requires a fee and/or 
specific permission. B-spline or other tensor product surface, clearly reflects this outlook, The control 
mesh approach is appealing in large mea­sure because the surface s response to control point dis­placements 
is intuitive: pulling or pushing a control point makes a local bump or dent whose shape is quite easily 
controlled by fine interactive positioning. Unfortunately, local bumps and dents are not the only features 
one wants to create. For example, almost anyone who has used a control mesh interface has had the frustrating 
experience of trying to make a conceptually simple change, but be­ing forced in the end to precisely 
reposition many--even all the control points to achieve the desired effect. This sort of problem is bound 
to arise whenever the con­trols provided to the user are closely tied to the represen­tation s degrees 
of freedom, since no fixed set of controls can be expected to anticipate all of the users needs. The 
work we will describe in this paper represents an effort to escape this kind of inflexibility by severing 
the tie between the controls and the representation. The model we envision presenting to the user is 
that of an infinitely malleable piecewise smooth surface, with no fixed controls or structure of its 
own, and with no prior limit on its complexity or abi lity to resolve detail. To this surface, the user 
may freely attach a variety of features, such as points and flexible curves, which then serve as handles 
for direct interactive manipulation of the surface. Within the constraints imposed by these controls, 
sur­face behavior is governed not by the vagaries of the repre­sentation, but by one or more simply expressed 
criteria that the surface should be as smooth as possible, should conform as closely as possible to a 
prototype shape, etc. Our choice of this formulation is motivated by the desire to present a simple representation-independent 
facade to the user; however, maintaining the facade is anything but simple. Formally, our approach entails 
the specification of surfaces as solutions to constrained variational opti­mization problems, i.e. surfaces 
that extremize integrals subject to constraints. To realize our goal of forming and solving these problems 
quickly enough to achieve inter­activity, yet accurately enough to provide useful surface models, we 
must address these key issues: ACM-f-89791 -479-l/92/007/0157 $01.50 SIGGRAPH 92 Chicago, July 26-31, 
1992 . Surface Representation. We require a surface rep­resentation that is concise, yet capable of resolving 
varying degrees of detail with no inherent limit to sur­face complexity; that is capable of representing 
Cn surfaces (in practice we are usually content with C2 continuity) and that supports efficient solution 
of the constrained optimization problems we wish to solve. On the other hand, since the representation 
is to be hidden from the user, we do not require the surface to respond in an intuitive or natural way 
to direct control-point manipulation. . Constrained Optimization We must be able to ac­curately and 
efficiently impose and maintain a va­riety of constraints on the surface, including those requiring the 
surface to contain a curve, or requir­ing two surfaces to join along a specified trim curve. Such constraints 
raise special problems because the constraint equation involves an integral which must be extremized. 
Subject to the constraints, we must be able to extremize any of a variety of surface integrals to create 
fair surfaces, minimize deviation from a specified rest shape, etc. . Automatic Refinement To create 
surfaces that reflect the variational solution, without letting the limitations of the representation 
show through, the resolution of the surface representation must be automatically con­trolled. Ideally, 
subdivision should be driven by a measure of the error due to the surface approxima­tion. As constraints 
are added, additional degrees of freedom must be provided to allow all constraints to be satisfied simultaneously 
without ill conditioning. Unlike point constraints, which can be met exactly, integral constraints require 
subdivision to bring their approximation error within a specified tolerance. Ad­ditional subdivision 
should be driven by estimates of the error with which the constrained variational min­imum is approximated. 
 In this paper we report on our progress to date in pur­suing the substantial research agenda that these 
require­ments define. Following a discussion of background and related work, we will address each of 
the issues outlined above. First, the need to compactly represent arbitrarily detailed surfaces leads 
us to consider schemes for locally refinable representations. Although many have been de­veloped, none 
meets all of our requirements. We describe a surface representation based on sums of tensor-product B-splines 
at varying levels of detail. Next we consider the constrained optimization problem itself. We give for­mulations 
for several quadratic objective functions, and discuss linear constraints for controlling arbitrary points 
and curves on the surface. We then turn to the problem of automatic surface refinement based on two kinds 
of ap­proximation erroc objective function error, and constraint error. Finally, we describe a preliminary 
implementation and present results. 2 Background 2.1 Direct control of curve and surface points The limitations 
of control meshes as interactive handles have been noted before. To address them, Fowler and Bartels[l 
1, 12] present techniques that allow the user to directly manipulate arbitrary points on linear blend 
curves and surfaces: the curve/surface is constrained to interpo­late the grabbed point. As the point 
is moved interactively, the change to the control points is minimized subject to the interpolation constraint. 
Parametric derivatives are also presented to the user for direct manipulation, to control surface orientation 
and curvature at a point. Moving be­yond point constraints, Celniker and Welch[6] presented a technique 
for freezing the shape of the surface along an em­bedded curve, although the issues involved in having 
the surface track a moving control-curve were not addressed. 2.2 Nonuniform surface refinement One of 
our key requirements is the ability to represent smooth surfaces with no a priori limit on the detail 
that can be resolved. Although a number of nonuniform refine­ment schemes have been developed, no existing 
one meets all of our needs. Most of these fail to provide C2 continu­ity we require. In computer graphics, 
Bezier patches [8] have been most widely used for nonuniform refinement. In general, however, higher-order 
continuity between Bezier patches is not preserved if they are manipulated after sub­division, though 
[20] formulates adaptive Bezier patch refinement with G 1 continuity. Triangular patches, which support 
topologically irregular meshes, are widely used in finite element analysis, but have been restricted 
to first­order continuity. Recent developments[9] point to trian­gular B-spline patches as a way of constructing 
a surface with higher-order continuity across a triangular mesh, al­though a computationally efficient 
refinement scheme for such a representation has not yet been presented. Forsey [10] presents a refinement 
scheme that uses a hierarchy of rectangular B-spline overlays to produce C * surfaces. Overlays can be 
added manually to add detail to the surface, and large-or small-scale changes to the sur­face shape can 
be made by manipulating control points at different levels. The hierarchic offset scheme may be well­-suited 
to direct user manipulation of the control points, but it does not meet our need for a refinable substrate 
for con­strained variational optimization. One of the fundamental advantages of conventional tensor product 
surfaces is lin­earity: surface points and derivatives are linear functions of the control points. Under 
Forsey s formulation Iinearit y is lost because unit normals are used to compute offsets. We depend heavily 
on linearity in later sections; use of the hierarchic offset representation would have a devastating 
impact on performance. 2.3 Constrained optimization Variational constrained optimization plays a central 
role in the formulation of so-called natural splines, piecewise cubic C* plane curves that interpolate 
their control points. The proof that natural splines minimize the integral of second derivative squared 
subject to the interpolation con­straints frequently appears as a demonstration problem in the calculus 
of variations[22]. Surface models based on variational principals have been widely used in computer vision 
to solve surface re­construction problems, in which a surface is fit to stereo measurements, noisy position 
data, surface orientations, shading information etc. [14, 15, 24], Similar formula­tions have been employed 
in computer graphics for phys­ically based modeling of deformable surfaces [23], All of these are based 
on regular finite difference grids of fixed resolution. Constrained optimization based on second-derivative 
norms has been used in fairing B-spline surfaces[l 8]. Moreton[ 19] minimizes variation of curvature 
to gener­ate surfaces which skin networks of curves while seeking circular or straight-line cross-sections. 
Such schemes can give rise to very fair surfaces, but the nonlinearity of their fairness metrics prevents 
them from being used for inter­active surface design. Cehriker [5] proposed a physically-based model 
for in­teractive free-form surface design, in which the surface is modeled using a C mesh of triangular 
patches, and posi­tions and normals may be controlled along patch bound­aries. Interactivity is possible 
because the surface fairing problem is formulated as a minimization of a quadratic functional subject 
to linear constraints. Our approach is closely related in this respect, although we consider more general 
formulations for both surface functional and shape control constraints.  3 Surface Representation We 
require a representation for smoothly deformable sur­faces, which has no a prior-i limit on the detail 
that can be resolved. Further, we require that points on such a surface be linear functions of its shape 
control parameters, yielding a more tractable control problem. Tensor-product B-splines[8] conveniently 
represent C piecewise polynomial surfaces as control-point weighted sums of nonlinear shape functions, 
and they form the basis of our representation scheme. Unfortunately, the standard tensor-product construction 
does not allow detail to be Computer Graphics, 26,2, July 1992 nonuniformly added to the surface through 
local refine­ment. We instead represent such a lccally refined region as a sum of the original surface 
and smaller, more finely parametenzed surfaces. Surface patches at various lev­els are evaluated and 
summed to compute the nonuniform surface s value. This is related to Forsey s overlay scheme for B-spline 
surface refinement [10], but the formulation is much simpler because there is no notion of hierarchic 
offsets for overlays. The nonuniform surface is a simple sum of sparse, uniform surface layers, which 
may overlap in arbitrary ways. Further, the resulting surface shape re­mains a linear function of the 
control-points, leading to a tractable surface control problem. A degree r tensor-product B-spline surface 
span is for­mulated as r+l r+l W( fl,t) = ~~N*(U)Nj(ZJ)P~j, (1) 1 1 where N(t) is the vector of r + 1 
uniform B-spline basis functions evaluated at t, and P isan(r-+ 1)x (r+ I) array of control-points. A 
mesh of such spans will form a C -1composite surface if neighboring spans sharer rows of control-points 
along their common boundary. A [Jx V array of control-points thus yields a (U r) x ( V r)-span composite 
surface. It is easy to get lost in the sea of summations and in­dices when working with composite surfaces 
and fom-mlas involving (1). To simplify notation in this and following sections, we take advantage of 
the fact that the X, Y, and Z dimensions of the surface in this representation scheme may be treated 
independently, and state our formulas in one dimension only. Further, we will represent the nth uniform 
surface layer u! in terms of a I x (U,, V. ) control vector p, which is related to the U. x Vn control-point 
matrix P by the structure-flattening constant S: p,, =~ S,,kpk. k where Sij~ = 1 if P,j corresponds to 
pk, and is O other­wise (S converts between a matrix and eg. its row-major representation). Then 1 J 
is a vector of basis functions, and its dot-product with the control vector yields the value of the surface 
at that point. A nonuniform surface w represented as the sum of n uniform surfaces at varying levels 
of refinement is then n W(u. 21) p bi(u, v) x = p=b(u, v) (2) where b and p are concatenations of the 
individual layers basis and control vectors into respective global vectors. Note that although each level 
s parametenzation spans the (u, v) domain of the base surface, its control-vector I59 SIGGRAPH 92 Chicago, 
July 26-31, 1992 will in general be sparse, with nonzero entries correspond­ing to local refinements 
of the surface. In our implemen­tation, we represent a particular layer of refinement as a sparse plugboard 
of control-points which exist indepen­dently of any spans which reference them. Whenever a new span is 
created within a particular level, it is con­nected to the appropriate subset of the control-points for 
that level. This implements the necessary control-point sharing between adjacent spans. New control-points 
are created within a layer the first time they are referenced by a span belonging to that layer. Thus, 
only the regions where refinement has actually taken place within a level are explicitly represented 
and evaluated. It remains to ensure that the resulting sum of surfaces has the proper degree of parametric 
continuity. Although the summed surface is not formulated as a hierarchic offset surface as in [10], 
Forsey s technique for enforcing con­tinuity over a composite offset surface is still applicable. For 
any patch belonging to a particular level of refinement, we constrain an r-wide band of control-points 
associated with the patch s boundary to be O. This forces each patch s position and r 1 derivatives 
to O at the patch boundaries, which is sufficient to guarantee that the summed surface is CT-l regardless 
of the way in which patches in various layers overlap. When disjoint patches within a particular layer 
have grown to the extent that they meet at a com­mon boundary, the constraints along that boundary may 
be discarded and the patches merged into one.  Constrained Optimization We would like to control a surface 
by attaching points and curves to it, letting the surface interpolate between the controls in an appropriate 
way, so that the user need not completely specify the surface at every point. Exactly what characterizes 
desirable surface behavior depends on the application, though there is often the requirement that the 
surface prefer fair, graceful shapes. Regardless of their particulars, many such behaviors can be cast 
as minimum principles over the surface. One formulates a measure of goodness at each surface point, and 
then integrates this measure over the entire surface to get a single number which characterizes the desirability 
of the surface shape under that metric. We then search for surface shapes which optimize this quantity 
while still satisfying the geometric constraints specified by the user. More formally, we seek shapes 
which extremize the integral of a surface metric subject to geometric con­straints. Such shapes are not 
intrinsically linked to any particular surface representation scheme, but exist instead as the solutions 
to constrained variational optimization problems[22]. Our modeler must construct acceptable ap­proximations 
to such infinite-dimensional variational sur­faces using a finite number of control parameters. The approach 
taken is to approximate the ideal surface as a piecewise polynomial surface using the nonuniform B­spline 
representation of the previous section. In this section we describe techniques for computing the B-spline 
control-points which optimize surface shape while satisfying user-supplied geometric constraints. We 
first discuss a number of possible surface metrics (objective functions, in optimization parlance). We 
then formulate point and curve constraints for controlling the surface. Finally, we discuss techniques 
for solving the resulting constrained optimization problems at interactive speeds. 4.1 Surface Objective 
Functions One might choose to extremize any number of functions over a surface to achieve fair shapes. 
One such func­tion measures how much the surface is stretched and bent by looklng at the differential 
area and curvature at each point[23]: (3) where G and B represent the first and second fundamen­tal 
surface forms, and a and /3 weight the matrix norms. The a and ~ terms determine resistance to stretching 
and resistance to bending, respectively. The vector and matrix norms in this function make it highly 
nonlinear, leading to a difficult nonlinear optimiza­tion problem. It is therefore common[23, 5, 24] 
to simplify this objective function by linearizing the matrix norms and B (this is the thin plate under 
tension model [21, 25]): where Diw represents the partial derivative of the surface w with respect to 
the ith parameter. The approximation is only accurate near the actual minimum (where higher order terms 
tend to O) but it is still well-behaved away from the minimum, and the computational benefits are enormous: 
for a linear surface representation such as a tensor product B-spline, this simplified objective function 
is quadratic in the underlying surface degrees of freedom, and we can cast the optimization problem as 
a constrained least-squares minimization. First, we formulate (4) in terms of the composite B­spline 
surface of equation(2): 2 ~ijp~Dib p~Djb Q(w = /x(w ~j=, Pij(pT~i~jb)2 ) Comm.der GraDhics, 26, 2. Julv 
1992 Since the surface is linear in the control vector p it may be brought outside and the integration 
in (u. u) completed to yield a dim(p) x dim(p) matrix H: ~ ~ljDib @ Dlb ­Q(w) =PT + P  /-x( ) .W 
I.j=l /jlJDIDjb @ DiDjb = pTHp. (5) (the symbol @ signifies an outer product) Minimizing (5) yields a 
value for the control vector p comesponding to the optimal approximation to the varia­tional surface 
defined by (4), for the given surface refine­ment. This is the Rayleigh-Ritz method of approximating 
a continuum solution with a finite set of continuous lin­ear functions[22]. Clearly a minimal solution 
to equation (5) is O we must add constraints to keep the surface from collapsing to a point if things 
are to be at all inter­esting, As we will see in the next subsection, a variety of geometric constraints 
can be expressed as linear relations over the control vector. Then the optimization becomes a linearly 
constrained quadratic minimization, which can be efficiently solved using techniques described in Sec­tion 
4.3. But first, consider another possibility for the objective function. Suppose we measure the amount 
the surface has deformed from some prototype shape. In the absence of constraints, minimizing this deformation 
metric causes the surface to assume the prototype shape. When constraint handles are attached to such 
a surface and manipulated, the surface should gracefully deform from this shape. One way of formulating 
such a shape attractor is to modify (4) to measure the change in stretch and bending from that of a rest 
shape W [23, 18]. This yields ~ m,JD, (w W)DJ(W +/) Q(w) = /x( 1,]=1 w bij(D~~J~w -w))* ) leading 
to Q(w) =(p-p)=H(p -~) (6) where p is the control vector comesponding to the proto­type shape. We must 
then minimize (6) subject to con­straints. The curve manipulation techniques of [2, 11] can also be cast 
as a shape-attracting quadratic optimization. They minimize absolute control-point displacement subject 
to point constraints. That is, their deformation metric is sim­ply (p p)T(p p), where p is the control 
vector for the cument shape. This is not a satisfactory objective function from the standpoint of representation-independent 
control because, as the authors noted, the local properties of the basis show through. Components of 
p which are not di­rectly affected by constraints will always keep their origi­nal values, as this produces 
the minimum deformation . Thus, the size of the bump raised by pulling on such a sur­face depends on 
the level of refinement in the underlying representation,  4.2 Geometric Constraints l%euser must be 
able to attach points and curves to the surface and use them to control the surface shape during sculpting. 
We implement these handles as geometric con­straints which the surface must satisfy while optimizing 
its objective function. In this section, we discuss two broad classes of geometric constraints: finite-dimensional 
con­straints, which control the surface shape at discrete points, and transfinite constraints, which 
control the surface shape along embedded curves or sub-regions of the surface. Whhin each of these classes, 
we focus on constraint formulations which are linear in the surface control vec­tor, as they lead to 
a constrained optimization problem which can be solved at interactive speeds, In general, such constraints 
involve surface features whose surface u, t) coordinates remain fixed, so that the B-spline basis functions 
may be evaluated once to yield linear relation­ships among the components of the control vector. Thus, 
constraints involving sliding surface points of attachment are excluded in such formulations. Within 
the class of linear constraints, we further restrict our focus to constraint formulations which do not 
couple the (independent) control vectors for each of the surface s spatial dimensions. Computing an independently 
con­strained solution in each spatial dimension is significantly cheaper than computing a single coupled 
solution for all dimensions because the system matrices involved grow as the square of the size of the 
control vector, though for some applications the additional cost may be justified. 4.2.1 Finite-Dimensional 
Constraints In sculpting a surface one might specify shape require­ments which must hold at a set of 
discrete points on the surface. Surface point positions, point normal directions, and offset relationships 
between points are all examples of useful point constraints for controlling the surface. Each generates 
some fixed number of constraints, depending on the way in which the relationship is formulated. For example, 
the constraint that a surface point W(W, vo ) remain fixed at a world-space point x can be written as 
x= W(uo. t]()) = pTb(uO. vo). This actually represents three independent constraints, one in each spatial 
dimension, and b( Uo. ZIO) maybe evaluated to yield linear constraints in their respective p s. Con­straints 
to control various parametric derivatives of the surface, such as tangent vectors at a point, are similarly 
formulated [11 ]. . SIGGRAPH 92 Chicago, July 26-31, 1992 4.2.2 lkansfinite Constraints A constraint 
which involves a one-or two-dimensional sur­face entity, such as an embedded curve or surface patch, 
must be formulated as an integral over the entity. For ex­ample, given a parametric (u, v) curvec(t) 
= (u(t), W(t)), the constraint that the surface curve C(t) = (w o c)(t) align itself with the space curve 
D(t) would lx written: / ~(C-D)2=0. (7) Such a constraint statement is dimensionally infinite, and because 
our surface representation has only a finite number of control points the surface will in general not 
be able to exactly satisfy the constraint. We will instead constrain the discretized surface to optimally 
approximate the constraint in a least-squares sense. Analogous to the objective functions of the previous 
section, we formulate a transfinite constraint as a quadratic function which achieves a global minimum 
when the con­straint is satisfied[6]. Thus, equation (7) is at a minimum when its gradient with respect 
to the control vector is O, and yields the dis­cretized gradient constraints:  = c(C-D)~ J  ((w o 
c) -D)a(;; c)Jc For our B-spline surface this becomes o=pT (bo c)(f)@ (bo c)(t) ­/c D(b O C)(t), / c 
 The integration is completed independently of p (analyt­ically, or numerically by point sampling), leading 
to a system of linear constraints in the control vector p. The constraints clamp the surface in a shape 
which minimizes its least-square deviation from the control curve c. Unac­ceptably large deviations can 
be eliminated by refining the parts of the surface through which the curve passes. The constraints generated 
by thk gradient-clamping op­eration are not necessarily independent. The shape of the embedded curve 
in u, v determines number of independent constraint rows generated an iso-paramteric line only produces 
r+ 1 independent constraint rows per span, while a zigzag stitch across a span might produce fully (r 
+ 1)2 independent rows, so that the space curve would com­pletely control the shape of the underlying 
surface span. Thus, the presence of dependent constraint rows, while numerically inconvenient, is desirable 
because it means the surface can interpolate the constraint curve with some of its control points remaining 
undetermined. The surface is then free to change so as to minimize its objective func­tion or to respond 
to other sculpting operators while still preserving the constraint. As with any technique in which the 
question of lin­ear independence arises, there are delicate numeric issues which must be considered. 
In particular, a u, w curve with very slight high-degree oscillations will give rise to nearly ­dependent 
constraint rows for an interpolation constraint, and thus will lock down all degrees of freedom in the 
spans it passes through. When such a curve is attached to a space curve, the surface shape is completely 
determined by the space curve, and thus the surface can behave arbi­trarily badly with respect to the 
objective function. Such constraint leverage can be reduced by adaptively refining the surface representation. 
Another technique, reduced quadrature [27], involves numerically evaluating the con­straint integral 
by sampling as if the surface representation was of a lower order. Such undersampling leads to a de­pendent 
set of constraints, thereby eliminating some of the locking behavior associated with a higher-order integra­tion. 
 4.3 Linearly Constrained Quadratic Opti­mization Having formulated the surface approximation problem 
with a quadratic objective function and linear constraints, a vast body of optimization literature can 
be brought to bear. In particular, very efficient techniques exist for en­forcing linear constraints 
in this context, and we discuss two we have used: one method using Lagrange multipliers to enforce a 
least-squares fit to the constraint matrix, the other using a penalty-based approach. We seek solution 
methods for the linearly constrained quadratic optimization problem min ll~pTHp pTfll (8) p subject 
to Ap = b where H is the Hessian of the quadratic metric to be min­imized, f is the gradient optimization 
term, and Ap = b is the system of linear constraints to be satisfied (each row of A represents a single 
linear constraint, and the corre­sponding component of b is its value). Solution methods generally transform 
this to an unconstrained system whose solutions E, when transfomned back to p s, are guaranteed to satisfy 
the constraints. The unconstrained system is at a minimum when its derivatives are O, thus we are led 
to solve the system to find the minimizing @, then transform it back to p to recover the constrained 
minimum solution. Computer Graphics, 26,2, July 1992 We may make either of two transfosmations of the 
prob­lem to an unconstrained optimization. For the first, we reformulate equation (8) by adding a single 
degree of free­dom y, (a Lagrange multiplier[22]) for each constraint row Ai and we then minimize the 
unconstrained min ;pTHp pTf + (Ap b)Ty . P Differentiating with respect to p then y leads to the aug­mented 
system H AT p_f (9)  AOy b which, though no longer positive-definite, does determine the unique minimum 
which satisfies the constraints pro­vided the constraint matrix contains no dependent rows. This method 
has the advantage that it enforces the con­straints exactly, in contrast with the penalty method below. 
This is at the expense of adding an additional variable yi for each constraint to be enforced. Also, 
an initial reduc­tion of the constraint matrix to a set of independent rows must be performed. Note that 
if a least-squares fit to the constraints is to be enforced, we must actually form the normal matrix 
AT A, and take its independent rows as our constraints. A second solution method associates a penalty 
term with each constraint, so that the minimization becomes ; I (ia -( :) - 0) where ~f is a large positive 
weight and the solution to the resulting unconstrained minimization approaches the true constrained minimum 
as p + x. In computing a least-squares solution to ( 10), we can avoid the numerical conditioning problems 
associated with forming the con­straint normal matrix ATA by instead performing a QR factonzation[ 13] 
of the matrix in ( 10). Since p must be chosen small enough to leave a well-conditioned problem, the 
solution to the penalty system can leave an unaccept­ably large constraint residual. This can be reduced 
by performing additional minimization steps on the residual using the same factored matnx[26]. An advantage 
to formulating the constrained minimiza­tion in this way is that no new variables are added to the system. 
This is offset, however, by the need to per­form additional solver steps in refining the residual, A 
more important advantage to the formulation is that de­pendent constraint rows need not be eliminated 
prior to building and factoring the augmented matrix. This makes it straightforward to use factorization 
update techniques [3, 4] to incrementally update the factorization of the sys­tem matrix as surface constraints 
are added or deleted. 4.4 Automatic Refinement We are using a piecewise polynomial surface with a fi­nite 
number of control parameters to approximate an infinite-dimensional variational surface. To maintain 
a representation-independent facade, we must be able to control the emor introduced by this approximation. 
We must be concerned with two kinds of approximation er­ror. First, the discretized surface may be unable 
to satisfy all constraints simultaneous y (constraint error. ) Second, even if all constraints are met, 
the discretized surface may fail to achieve the variational minimum (objectivefurrctirm error. ) Of the 
two, objective function error is more difficult to handle because it cannot be measured directly . How 
10 estimate this kind of error apriori is an open research prob­lem [27, 16]. More widely used are apos(eriori 
methods in which an estimate is obtained by comparing higher-order solutions to lower-order ones. [1, 
17, 7] In contrast, constraint emor can generally be measured directly, by calculating point-to-point 
or curve-to-curve distances. A straightforward refinement scheme is to com­pute the constraint error 
per surface span, refining those spans whose error exceeds a specified tolerance. 5 Results An interactive 
free-form surface modeler implementing the techniques described in this paper has been developed at CMU. 
The modeler, which runs on Silicon Graphics Ins workstations, allows the user to interactively manipulate 
variational curves and surfaces, controlling and combin­ing them through a variety of constraints and 
objective functions. By default, surfaces minimize the fairness integral given in equation (4) subject 
to the constraints acting on them. At any time, the user may install a surface s current shape as its 
rest shape, or melt a previously remembered rest shape. We have found that additional objective function 
terms can be useful as interactive sculpting tools for in­stance, terms which inflate or deflate the 
surface. Basic surface control is provided by point constraints, which take the place of conventional 
control points. Ephemeral position constraints allow the user to grab and drag arbitrary points on the 
surface, while persistent con­straints help define surface shape. Additional control is afforded by surface 
normal constraints. Curve constraints have proven to be a far more pow­erful modeling tool. To create 
a surface or space curve, the user defines a sequence of surface or space points, from which an interpolating 
curve is constructed. Once created, curves become first-class variational objects that can be controlled 
by constraints. To use curves as sur­face controls, a surface curve is attached to a space curve, which 
may be manipulated by the user. This attachment can be established in either of two ways. First, a surface 
curve may be snapped to an independently created free­ 1unless the error-free answer is available for 
comparison! I 63     SIGGRAPH 92 Chicago, July 26-31, 1992 erroranalysis. ht. J. Numez Methods Eng., 
19:1593­1619,1983. [18] N. J. Lott and D. I. Pullin, Methodfor fairingb-spline surfaces. Computer-Aided 
Design, 20(10), 1988. [19] Henry Moreton and Carlo S6quin. Functional min­imization for fair surface 
design. In these proceed­ings. [20] Francis J. M. Schmitt, Brian A. Barsky, and Wen-Hui Du. An adaptive 
sulxhision method for surface­fitting from sampled data. Computer Graphics, 20(4), 1986. Proceedings 
SIOGRAPH 86. [21] D.G. Schweikert. An interpolation curve using a spline in tension. Journal ofMath and 
fhys., 45:3 12 317, 1966. [22] Gilbert Strang. Introduction to Applied Mathematics. Wellesley-Cambridge 
Press, 1986. [23] Demetri Terzopoulis, John Plan, Alan Barr, and Kurt Fleischer. Elastically deformable 
models. Computer Graphics, 21(4), July 1987. Proceedings of SIG-GRAPH 87. [24] D. Terzopoulos. Multi-level 
reconstruction of visual surfaces. MIT Artificial Intelligence Memo Number 671, April 1981. [25] D. Temopoulos. 
Regularization of inverse visual problems involving discontinuities. IEEE Trans. Pattern Analysis and 
Machine Intelligence, PAMI­8:413424,1986. [26] Charles Van Loan. On the method of weighting for equality-constrained 
least-squares problems. SL4M J. Numer Anal., 22(5), 1985. [27] O.C. Zlenkiewicz and K. Morgan. Finite 
Elements and Approximation. John Wiley and Sons, 1983.  
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134035</article_id>
		<sort_key>167</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>19</seq_no>
		<title><![CDATA[Functional optimization for fair surface design]]></title>
		<page_from>167</page_from>
		<page_to>176</page_to>
		<doi_number>10.1145/133994.134035</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134035</url>
		<categories>
			<primary_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Curve, surface, solid, and object representations</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>G.1.8</cat_node>
				<descriptor>Finite element methods</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>G.1.6</cat_node>
				<descriptor></descriptor>
				<type></type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10003752.10003809.10003716</concept_id>
				<concept_desc>CCS->Theory of computation->Design and analysis of algorithms->Mathematical optimization</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002950.10003714.10003715.10003718</concept_id>
				<concept_desc>CCS->Mathematics of computing->Mathematical analysis->Numerical analysis->Computations in finite fields</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002950.10003714.10003716</concept_id>
				<concept_desc>CCS->Mathematics of computing->Mathematical analysis->Mathematical optimization</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010399</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Parametric curve and surface models</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010401</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Volumetric models</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
			<gt>Design</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>PP31089594</person_id>
				<author_profile_id><![CDATA[81100412948]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Henry]]></first_name>
				<middle_name><![CDATA[P.]]></middle_name>
				<last_name><![CDATA[Moreton]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Computer Science Division, University of California, Berkeley]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P41115</person_id>
				<author_profile_id><![CDATA[81100058395]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[Carlo]]></first_name>
				<middle_name><![CDATA[H.]]></middle_name>
				<last_name><![CDATA[S&#233;quin]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Computer Science Division, University of California, Berkeley]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_obj_id>1098650</ref_obj_id>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Abramowitz, M. and Stegun, I.A. (editors), Handbook of Mathematical Functions with Formulas, Graphs, and Mathematical Tables, Dover, Inc., New York, N.Y. 1972.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Birkhoff, G.D., Aesthetic Measure, Harvard University, Cambridge, Mass., 1933.]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_obj_id>360353</ref_obj_id>
				<ref_obj_pid>360349</ref_obj_pid>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Blinn, J.E, Newell, M.E., Texture and Reflection in Computer Generated Images, Communications of the ACM 19, 10 (Oct. 1976), 542-547.]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_obj_id>87562</ref_obj_id>
				<ref_obj_pid>87526</ref_obj_pid>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[BOhm, W., On Cyclides in Geometric Modeling, Computer Aided Geometric Design 7 (1990), 243-255.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[Calladine, C.R., Gaussian Curvature and Shell Structures. In The Mathematics of Surfaces, Clarendon, Oxford, England, 1986, pp. 179-196.]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122746</ref_obj_id>
				<ref_obj_pid>122718</ref_obj_pid>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[Celniker, G. and Gossard, D., Deformable Curve and Surface Finite-Elements for Free-Form Shape Design, Proceedings of SIGGRAPH '91 (Las Vegas, Nevada, July 29-August 2, 1991t. In Computer Graphics 25, 4 (July 1991 ), 257-266.]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_obj_id>578374</ref_obj_id>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Conte, S.D. and de Boor, C. Elementary Numerical Analysis, An Algorithmic Approach, McGraw-Hill, New York, N.Y., 1980.]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[Courant, R. and Hilbert, D., Methods of Mathematical Physics, Volume I, Wiley-lnterScience, New York, N.Y., 1953.]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[DeRose, T.D. and Mann, S., An Approximately G I Cubic Surface Interpolation. To appear in the Proceedings of the 1991 Biri Conference.]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_obj_id>87553</ref_obj_id>
				<ref_obj_pid>87526</ref_obj_pid>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[DeRose, T.D., Necessary and Sufficient Conditions for Tangent Plane Continuity of B~zier Surfaces, Computer Aided Geometric Design 7 (1990), 165-179.]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
			<ref>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[Do Carmo, M.P., Differential Geometry of Curves and Surfaces, Prentice-Hall, Englewood Cliffs, New Jersey, 1976.]]></ref_text>
				<ref_id>11</ref_id>
			</ref>
			<ref>
				<ref_obj_id>13023</ref_obj_id>
				<ref_obj_pid>13021</ref_obj_pid>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[Greene, N., Environment Mapping and Other Applications of World Projections, IEEE Computer Graphics and Applications 6, 11 (Nov. 1986), 21-29.]]></ref_text>
				<ref_id>12</ref_id>
			</ref>
			<ref>
				<ref_obj_id>43652</ref_obj_id>
				<ref_obj_pid>43647</ref_obj_pid>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[Hagen, H. and Schulze, G., Automatic Smoothing with Geometric Surface Patches, Computer Aided Geometric Design 4, (1987), 231-236.]]></ref_text>
				<ref_id>13</ref_id>
			</ref>
			<ref>
				<ref_obj_id>48487</ref_obj_id>
				<ref_obj_pid>48483</ref_obj_pid>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[Jones, A.K., Nonrectangular Surface Patches with Curvature Continuity, Computer Aided Design 20, 6 (Jul./Aug. 1988), 325-335.]]></ref_text>
				<ref_id>14</ref_id>
			</ref>
			<ref>
				<ref_obj_id>96529</ref_obj_id>
				<ref_obj_pid>96526</ref_obj_pid>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[Kallay, M. and Ravani, B., Optimal Twist Vectors as a Tool for Interpolating a Network of Curves with a Minimum Energy Surface, Computer Aided Geometric Design 7, 6 (1990), 465-473.]]></ref_text>
				<ref_id>15</ref_id>
			</ref>
			<ref>
				<ref_obj_id>63739</ref_obj_id>
				<ref_obj_pid>63735</ref_obj_pid>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[Lott, N.J. and Pullin, D.L., Method for Fairing B-spline Surfaces, Computer Aided Design 20, 10 (Dec. 1988), 597- 604.]]></ref_text>
				<ref_id>16</ref_id>
			</ref>
			<ref>
				<ref_seq_no>17</ref_seq_no>
				<ref_text><![CDATA[Mann, S., Loop, C., Lounsbery, M., Meyers, D., Painter, J., DeRose, T., and Sloan, K., A Survey of Parametric Scattered Data Fitting Using Triangular Interpolants. In Curve and Surface Modeling, Hagen, H. (editor), SIAM.]]></ref_text>
				<ref_id>17</ref_id>
			</ref>
			<ref>
				<ref_seq_no>18</ref_seq_no>
				<ref_text><![CDATA[Mehlum, E., Nonlinear Splines. In Computer Aided Geometric Design, R.E. Bamhill and R.E Riesenfeld (editors), Academic, Orlando, Florida, 1974, pp. 173-207.]]></ref_text>
				<ref_id>18</ref_id>
			</ref>
			<ref>
				<ref_obj_id>112553</ref_obj_id>
				<ref_obj_pid>112515</ref_obj_pid>
				<ref_seq_no>19</ref_seq_no>
				<ref_text><![CDATA[Moreton, H.P. and S~quin, C.H., Surface Design with Minimum Energy Networks. In Proceeding of the Symposium on Solid Modeling Foundations and CAD~CAM Applications (Austin, Tex., June 5-7). ACM, New York, N.Y., 1991, pp. 291-301.]]></ref_text>
				<ref_id>19</ref_id>
			</ref>
			<ref>
				<ref_seq_no>20</ref_seq_no>
				<ref_text><![CDATA[Nielson, G.M., A Method for Interpolating Scattered Data Based Upon a Minimum Norm Network, Mathematics of Computation 40, 161 (1983), 253-271.]]></ref_text>
				<ref_id>20</ref_id>
			</ref>
			<ref>
				<ref_seq_no>21</ref_seq_no>
				<ref_text><![CDATA[Nowacki, H. and Reese, D., Design and Fairing of Ship Surfaces. In Surfaces in Computer Aided Geometric Design, Barnhill, R,E. and Boehm, W. (editors), North-Holland, Amsterdam, The Netherlands 1983, pp. 121-134.]]></ref_text>
				<ref_id>21</ref_id>
			</ref>
			<ref>
				<ref_obj_id>87556</ref_obj_id>
				<ref_obj_pid>87526</ref_obj_pid>
				<ref_seq_no>22</ref_seq_no>
				<ref_text><![CDATA[Peters, J., Local Smooth Surface Interpolation: A Classification, Computer Aided Geometric Design 7 (1990), 191-195.]]></ref_text>
				<ref_id>22</ref_id>
			</ref>
			<ref>
				<ref_seq_no>23</ref_seq_no>
				<ref_text><![CDATA[Peters, J., Smooth Interpolation of a Mesh of Curves, Constructive Approximation 7 (1991 ), 221-247.]]></ref_text>
				<ref_id>23</ref_id>
			</ref>
			<ref>
				<ref_seq_no>24</ref_seq_no>
				<ref_text><![CDATA[Poeschl, T., Detecting Surface Irregularities Using Isophotes, Computer Aided Geometric Design, 1 (1984), 163-168.]]></ref_text>
				<ref_id>24</ref_id>
			</ref>
			<ref>
				<ref_seq_no>25</ref_seq_no>
				<ref_text><![CDATA[Pottmann, H., Scattered Data Interpolation Based upon Generalized Minimum Norm Networks, Preprint Nr. 1232, Technische Hochschule, Darmstadt, May 1989.]]></ref_text>
				<ref_id>25</ref_id>
			</ref>
			<ref>
				<ref_seq_no>26</ref_seq_no>
				<ref_text><![CDATA[Pramila, A., Ship Hull Surface Using Finite Elements, International Shipbuilding Progress 25, 284 (1978), 97-107.]]></ref_text>
				<ref_id>26</ref_id>
			</ref>
			<ref>
				<ref_obj_id>87561</ref_obj_id>
				<ref_obj_pid>87526</ref_obj_pid>
				<ref_seq_no>27</ref_seq_no>
				<ref_text><![CDATA[Pratt, M.J., Cyclides in Computer Aided Geometric Design, Computer Aided Geometric Design 7 (1990), 221-242.]]></ref_text>
				<ref_id>27</ref_id>
			</ref>
			<ref>
				<ref_seq_no>28</ref_seq_no>
				<ref_text><![CDATA[Rando, T. and Roulier, J.A., Designing Faired Parametric Surfaces, Computer Aided Design 23, 7 (Sept. 1991), 492- 497.]]></ref_text>
				<ref_id>28</ref_id>
			</ref>
			<ref>
				<ref_obj_id>36716</ref_obj_id>
				<ref_obj_pid>36713</ref_obj_pid>
				<ref_seq_no>29</ref_seq_no>
				<ref_text><![CDATA[Sarraga, R.E, G1 Interpolation of Generally Unrestricted Cubic B~zier Curves, Computer Aided Geometric Design 6, 2 (1987), 23-40.]]></ref_text>
				<ref_id>29</ref_id>
			</ref>
			<ref>
				<ref_seq_no>30</ref_seq_no>
				<ref_text><![CDATA[Shirman, L. and S6quin, C.H., Local Surface Interpolation with B6zier Patches, Computer Aided Geometric Design 4 (1987), 279-295.]]></ref_text>
				<ref_id>30</ref_id>
			</ref>
			<ref>
				<ref_obj_id>18554</ref_obj_id>
				<ref_obj_pid>18548</ref_obj_pid>
				<ref_seq_no>31</ref_seq_no>
				<ref_text><![CDATA[Todd P.H. and McLeod, R.J.Y., Numerical Estimation of the Curvature of Surfaces, Computer Aided Design 18, 1 (Jan./ Feb. 1986),-33-37.]]></ref_text>
				<ref_id>31</ref_id>
			</ref>
			<ref>
				<ref_obj_id>34718</ref_obj_id>
				<ref_obj_pid>34713</ref_obj_pid>
				<ref_seq_no>32</ref_seq_no>
				<ref_text><![CDATA[Williams, C.J.K., Use of Structural Analogy in Generation of Smooth Surfaces for Engineering Purposes, Computer Aided Design 19, 6 (Jul./Aug. 1987), 310-322.]]></ref_text>
				<ref_id>32</ref_id>
			</ref>
			<ref>
				<ref_obj_id>129711</ref_obj_id>
				<ref_seq_no>33</ref_seq_no>
				<ref_text><![CDATA[Wolfram, S., Mathematica, A System for Doing Mathematics by Computer, 2nd ed., Addison-Wesley, Redwood City, California, 1991.]]></ref_text>
				<ref_id>33</ref_id>
			</ref>
			<ref>
				<ref_seq_no>34</ref_seq_no>
				<ref_text><![CDATA[Zienkiewicz, O.C., The Finite Element Method, McGraw-Hill, London, England, 1977.]]></ref_text>
				<ref_id>34</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 to solve satisfactorily. Most techniques use heuristics to set extra degrees of freedom and sufficient 
but not necessary constructions to guarantee G1 continuity; however they typically produce unnec­essary 
and undesirable wrinkles . An extensive survey by mem­bers of the Graphics Group at the University of 
Washington [17] demonstrates these common flaws. The curve and surface functional that we have derived 
rrsini­mize the variation of curvature; thus we refer to the curves as min­imum variation curves (MVC 
1) and to the surfaces as minimum varia~iorr surjaces (MVS). In the case of curves, the integral of the 
squared magnitude of the derivative of curvature is minimized (1) Note that this integral evaluates to 
zero for circular arcs and straight lines. For surfaces, the functional is the integral of the squared 
magnitude of the derivatives of normal curvature taken in the principle directions drcn= dK 2 +~dA. J-d2, 
d~z Note that analogous to the MVC, the MVS functional evaluates to zero for cyclides: spheres, cones, 
cylinders, tori, and planes. Section 2 reviews pcevious related work, discussing approach­es, advantages, 
and shortcomings. Section 3 presents an overview of our approach outlining the steps taken to produce 
a surface model from specified constraints. Section 4 provides details of the representation of the surfaces, 
and a description of the optimi­zation techniques used to compute them. Section 5 details the computation 
of the minimum energy networks used in our algo­rithm. Section 6 presents a comparison of our approach 
with oth­er methods; it exhibits examples of complex surfaces created from simple, compact specifications. 
2 Previous Work The work described in this paper touches on several problems and thus several areas of 
study. First, we discuss work on creating a G surface out of a collection of nondegenerate polynomial 
patches. Second, we reference work on functional minimization, constrained optimization, and finite element 
analysis, all applied to surface design. The last portion of this section reviews mini­mum energy networks. 
2.1 G1 Continuity Peters [22] provides a good classification and review of G1 in­terpolation techniques. 
All of the methods discussed are constmc­tive, using heuristics to set those degrees of freedom that 
are not fixed by continuity constraints or set as side effects of the con­struction method. These methods 
rely on the computation of a net­work of curves that interpolate the data, subject to various continuity 
and connectivity constraints. Peters has done a great deal of work on the construction of geometrically 
continuous sur­faces. His most recent work outlines a method for creating @ surfaces. Relevant to this 
discussion, Peters [23] shows that a curve network maintaining G* continuity is sufficient and in gen­eral 
necessary for the construction of a G1 surface. This result as­sumes that a single quintic polynomial 
patch is placed in each network opening, and that the opening boundaries are fixed. In ad­dition, there 
are no restrictions on the order of (i.e., the number of edges joining) the network nodes. 1. Emery Jou 
coined this name/acronym, 2. It is our convention that a hat , e.g. .?, indicates a unit vector.  Our 
work combines a solution to the G1 continuity problem with the setting of the unconstrained degrees of 
freedom to form a fair G1 continuous surface. No explicit G 1 construction is used; rather a suitable 
penalty function is incorporated into the objec­tive function. In related work, DeRose [10] presents 
the necessary and strtli­cient conditions for G1 continuity between adjacent triangular and quadrilateral 
B6zier patches of equal degree. We use these re­sults to formulate the penalty function that imposes 
G* continuity. 2.2 Optimization, Minimization, and Finite Element Analysis In [32] Williams describes 
a system using finite difference methods for the computation of smcdt surfaces. The system min­imizes 
the total energy of a fictitious elastic plate. In [26] Pramila describes techniques for ship hull design 
that employ finite ele­ment analysis to minimize a quadratic functional approximating strain energy. 
Celniker and Gossard [6] present ~ free form design system that uses finite element analysis to simulate 
physical mod­els. Interactive deformation is carried out by simulating forces ap­plied to the subject 
model. Surfaces are represented by triangular patches meeting with C* continuity. Approximations are 
used to model deformations. As a result, surfaces converge on their theo­retical shape after multiple 
elements are inserted between con­straints. Rando and Roulier [28] propose several specialized geometrically 
based fairness ftrnctionals. These functional are re­ferred to as flattening: rounding; and rolling. 
They apply these functional to B6zier patches. Some of the B6zier control points are fixed in order to 
guarantee continuity, while others are varied to minimize the functional. Hagen and Schulze [13] use 
the calculus of variations to fit generalized Coons patches to three-dimensional data. The resulting 
patches minimize a strain energy fairness criterion. The analysis uses simplifying approxi­mations to 
limit the complexity of calculations. Most recently, Krdlay and Ravani [15] discuss a method for determining 
opti­mal twist vectors for the surface formed by a rectangular mesh of cubic curves. In their work, twist 
vectors are computed to mini­mize a quadratic energy term. Our work uses higher order patches and the 
full nonlinear ex­pression for the functional to achieve the highest possible surface quality from the 
fewest underlying patches. 2.3 Minimum Energy Networks Nielson [20] introduced the minimum norm network 
(MNN) using linear energy terms to produce a C] network and a resulting C] surface. Pottmann [25] presents 
a generalization of MNN to produce a C2 surface. Most recently, we [19] describe an algo­rithm for the 
computation of a G= minimum energy network com­posed of curves minimizing (1) along the edges of the 
network. These MVC networks are of higher fairness and are usually clos­er to the corresponding minimum 
variation surface than networks computed heuristically or using linear energy terms.  3 Our Algorithm 
We treat the problem of creating a surface interpolating a col­lection of geometric constraints as one 
of scattered data interpola­tion. The interpolation problem is broken into three steps (Fig. 3); 1) connectivity 
definition, 2) curve network computation, 3) patch blending. In accordance with the topological type 
of the desired surface, the geometric constraints are first connected into a net­work of straight edges. 
A curve is then placed at each edge of the network, and an optimized network is computed composed of 
minimum vmiation curves (MVC) subject to the specified geomet­ric constraints and the additional constraint 
that the curve seg­ments meet with second order geometric continuity, G*, at the  4.2 Fairness Functional 
Our choice of functional for minimization was prompted by the need for very high quality surfaces with 
predictable, intuitive be­havior, and the desire to capture shapes commonly used in geo­metric modeling. 
The fairness of curves and surfaces has been studied extensively and has been shown to be closely related 
to how little and how smoothly a curve or surface bends. For an ear­ly and interesting reference see 
[2]. Work on the fairness of curves has traditionally focused on the minimization of strain energy or 
the arc length integral of the squared magnitude of curvature [18] .2 K ds. r We u~e an alternative 
fairness metric based on the minimization of the arc length integral of the squared magnitude of the 
derivative of curvature 1; ds. This new functional results in curves with noticeably smoother curvature 
plots, and it has the added benefit that circular arcs are formed when constraints permit, since according 
to this new functional they are optimally curved. Traditional work on the fairness of surfaces also focuses 
on strain energy, minimizing the area integral of the sum of the pri­nciplecurvatures squared [13, 16,21, 
32] Again, our approach minimizes the variation of curvature, rather than its magnitude. For surfaces, 
we minimize the area integral of the sum of the squared magnitudes of the derivatives of the normal curvatures 
taken in the principle directions: dKn2 dK 2 +~d4. (2) F dt, d22 The normal curvature at a point on a 
surface in a direction specified by a surface tangent vector is determined from the intersection curve 
of the surface with the plane spanned by the surface normal and the given tangent vector. The principle 
directions, 21 and 22, and the principle curvatures, K~ and K2 ,,at a point on a surface are the directions 
and magnitudes of the mmlmum and maximum of all possible normal curvatures at that point[11] (Fig. 4). 
Like the MVC functional, the MVS functional has associated shapes that are optimal in the sense that 
the functional evaluates to zero. In the case of the MVS functional, the shapes belong to a special family 
of curved surfaces call cyclides [4, 27] that in­cludes spheres, cylinders, cones, and tori. These all 
have lines of principal curvature where the associated normal curvature re­mains constant. Lines of principal 
curvature follow the paths of minimum and maximum normal curvature across a surface. 4.3 Parametric 
Functlonals The fairness functional for surfaces (2) is defined in terms of an area integral. To evaluate 
the functional and its gradient in the context of the parametric polynomial surfaces patches described 
in section 4.1, the functional must be converted to a compatible form. Here we outline the crdculations 
necessary to evaluate the functional. The fairness functional is computed for each patch, and the value 
of the functional for the surface as a whole is the sum of the values for each patch. The area based 
definition dK2 dK2 n +~dA J-d2, d22 is converted to integrals of functions of the independent parameters 
fi P 4 / 1  7-py . n .2, (b) F@tre 4. (a) Normal curvature is tie curvature of the curve formed by 
the intersection of the surface and a plane contain­ing the normal and tangent. (b) Principle directions 
and prin­ciple curvatures are the dkections and magnitudes of the maximum and minimum normal curvature. 
u and v in ;(u, v). For quadrilateral patches, the bounds of the integrals are set to vary over the unit 
square, and the differential with respect to area is converted to differentials in u and v 11dK2 d~2 
~ + ~ llSUx Svlldudv Jf( d2, d22 ) 00 where !ls.x~,ll= dEG-#, and E=~u.ju F=ju.~v G=;v.~v. (3) The variables 
E, E and G, are from the fust fundamental form from differential geometry [11 ]. The principal curvatures 
K1 and K are the normal curvatures in the principle directions. Thus the pro i Iem of computing dKn/d81 
and dKn/d22 becomes one of computing dlc /d.?, and dK2/~2. First we find expressions for these in terms 
of d envatives taken m the parametric dirzw(ions dK2 dK2 dK2  (22. 3U) += (22.3 ) ~ dii where L = ~u/(ll~u[[) 
~v=S ql S [l . Next we define the derivatives of K}, K2 taken in the parametric directions using parametric 
derivatives: dKi dKi , drci dKi 1 % = du IIjull ~ = dv IIjvll Finally, the parametric derivatives of 
K and K2 are computed from an expression derived from the fact /hat the principle curva­tures are the 
eigenvahses of the curvature tensor. The expression for the curvature tensor is r. all ~21 7  a12 022 
11 where fF-eG eF -fE all = a21= EG-$ EG-$ gF fG fF -gE a22= a12= EC $ EG-$ e=il. iuuf= fi; uv g=il~vv. 
(4) E, E and G are defined as in equation (3), e, j and g are the terms of the second fundamental form 
from differential geometry [11]. Since K, and K2 are the eigenvahtes of the curvature tensor, we get 
the following expression: a,, +a22* Ja~, +4a,2a21 -za1,a22+ai2 K; =  2 This expression is in terms of 
the surface parameters u and v. Using the chain rule, it is simple to compute the required parametric 
derivatives, dKi/du, drci/dv. Note that in computing the parametric derivatives of e, ~, and g, it is 
helpful to have a simple way of computing ilu and ?rV: >, 6 = K*(SU.2, )21+ K2(SU 22)22 nu  4.4 Numerical 
Integration In section 4.3 we discussed a method for evaluating the quanti­ty on the inside of the fairness 
integral (2). Because it is impracti­cal to compute the integral analytically, we use numerical integration 
to evaluate the integral. Instead of using standard Gauss-Legendre quadrature, we use Lobatto quadrature 
[ 1]. Lo­batto quadrature has approximately the same convergence and samples the perimeter of the integration 
domain: 1 n-1 flx)dx = WJ70.0) + ~ Wflxi) + WJ1.0) ~ 1=2 b We have found Lobatto s integration formula 
to be more effective than Gauss-Legendre quadrature for our application. As a default, we use ten integration 
points in each parametric direction, a satisfactory number for the modeling problems we have encountered 
so far, If the number of sample points is reduced, the surface might form a cusp or crease between sample 
points where the integrator will not see it. The first ten sets of abscissas and weight factors for Lobatto 
s integration formula are tabulated in [1]. The computation of other sets of weights and abscissas requires 
finding the roots of the first derivative of a Legendre polynomial. Mathematical [33] may be used to 
generate larger tables. Because finding the roots of high order polynomials is ditllcuh and prone to 
numerical errors, the results calculated for a new table should be checked for accuracy, e.g. verifying 
that the weights sum to 1. An alternative to computing higher order sets of weights and abscissas is 
to subdivide the domain and integrate over the subdomains. 4.5 Differentlatlon During the optimization 
process, it is necessary to compute the gradient of the functional with respect to all the available 
degrees of freedom. When computing the curve network, analytical par- Computer Graphics, 26,2, July 1992 
tial derivatives are used in conjunction with numerical integration to compute the gradient. In the case 
of surfaces, the functional is of such complexity that it is impractical to compute the gradient in this 
fashion. Instead we use central differences [7] to approxi­mate the partial derivatives. The standard 
central difference for­mula for computing the derivative of flu) with respect to a follows: f,(a)= fla 
+ h)-flu -h) (5) 2h In order to get accurate derivative estimates, it is necessary to choose the difference 
value h carefully. An optimum value of h balances the trade-off between the discretization error resulting 
from a large h and an increasing relative roundoff error resulting from too small a value for h. The 
analysis used to compute his taken from [7]. First we find the approximate roundoff error in computing 
our functional. By computing the fairness functional, FE in both single and double precision, we find 
the number of significant digits in the single precision calculation: FF$ingle FFdOuble = log ,0 FF single 
double The roundoff error R in (5) is approximately R = * 2FFX Io- g g 2h The discretization error 
T is approximately ~=_!h2 6 To find the optimum h we must minimize FFx 10-s ingie+ !hz, (6) h 6 To find 
the value of h for which (6) is a minimum, we differentiate with respect to h and find the positive root. 
FFx 10-Ssi gle hh= 3 3FFxlo mlc +j=l) r. h2 Currently our calculations are carried out in double precision. 
Because we can only directly compute Sstigle =5.1, we presume a value of Stiuble = 9 by extrapolation. 
We recalculate h for each new value of the functional. For example, FF = 10.0 yields h= 0.006. Note that 
because the functional (FF) and its derivatives are computed on a patch by patch basis, the value of 
h is also set on a patch by patch basis. 4.6 Tangent Continuity In [10] DeRose sets forth the necessary 
and sufficient condi­tions for G 1 continuity. The G conditions take the form of a se­ries of formulas, 
eq i, all of which must be zero for G 1 continuity to exist. Using the notation of DeRose, NF,, NGi and 
NH. refer to the degree of the cross-boundary tangent functions (F , G ) and the degree of the tangent 
function (H ) along the boundary (Fig. 5). For example, a pair of abutting bi-quintic patches have NFt 
=NG, = 5, NH, = 4 and formulas eqm= F;, G;, H; I=0 ~1 j+k+l=m (7) m= O... D D= NF+NG+N~< where F; = F 
F j G; = NG G*k H;= N; H/ J k [) [) [)where the Fy G k and H ~ are difference vectors as shown in Figure 
5, The result per shared boundary, for our example of bi ­quintic patches, is a set of fifteen equations, 
made up of one hundred distinct 3 x 3 determinants. The complexity of solving this i 5 Figure 5. Difference 
vectors for a pair of hi-quintic patches. system of equations has been outlined by a number of authors 
[14, 23, 29, 30]. This complexity arises because the comer interior control points (A Fig. 6) appear 
in the cross-boundary equations for multiple sides. This multiple appearance couples different patch-patch 
continuity equations and thereby creates a global system of equations with a very large number of variables. 
In the context of the optimization described here, it is impractical and unproductive to solve this explicitly. 
We have described how the fairness functional is evaluated. We complete the objective function to be 
minimized by adding a pen­alty for lack of G1 continuity. In formulating the penalty function, we square 
the terms from equation (7) yielding (8) ~=o j+k+l=m The penalty is computed for every patch-patch boundary 
and added to the fairness functional forming the objective function. 4.7 Initialization The gradient 
descent scheme described in section 3 starts with an initial surface and iteratively refines that surface 
until the sur­face functional reaches a (local) minimum and an optimal surface is reached. In this section 
we discuss a method for finding a suit­able initial surface. In terms of the desired optimization, the 
goal is to find an initial point in the proper valley of the solution space such that the desired surface 
is found as the minimal point in that valley. The optimization requires that initial values be pro­vided 
for any parameters not explicitly set. The use of an opti­mized curve network initializes the control 
points on the perimeter of each patch. The interior control points are positioned Figure6. The control 
points of a B&#38;ier patch are grouped as the 20 rimeter control points (0), the 12 adjacent control 
pointa rA, A), and the 4 central control points (O). As an ex­ample of initialization, ~ ~q is computed 
by linearly interpolat­ing the surface normal vectors at the comers and the magnitudes of the correspondktg 
diffen?nce vectors. so as to: 1) achieve approximate G1 continuity and 2) set the high order derivatives 
at the patch comers equal to zero. The first step initializes the twelve control points adjacent to the 
perimeter (A, A), and the second step initializes the four points in the center of the patch (Cl) (Fig. 
6). The heuristic used to position the control points adjacent to the perimeter linearly interpolates 
the normal vectors and the magnitudes of difference vectors. Figure 6 and equation (9) demonstrate the 
approach, with the calculation of ),3: )*3= )03+F 3 F s = \lF 311P~ ff 2xfi03+ fi 3)(fio3 F3 = llti,~fi03+fi3xfi~311 
 llfi311 = ;IF 011 +;113511 (9) 2. 3. 5Wl+5~05 fio3 = 23 fi@J+-fio5 55 Alternatively, one could also 
use the construction due to Peters [23]. 4.8 G* Vertices The order of the derivatives in the surface 
functional indicate a requirement for G2 continuity. Rather than imposing G2 cross boundary continuity 
at the cost of many more equations to evalu­ate, we construct the network of patches to meet with G* 
continu­ity at the vertices only, and we maintain this continuity by construction during the minimization 
process. Because of this, the elements used in these optimizations are classified as noncon­forming elements, 
and the patch test [34] must be used to guar­antee convergence. Intuitively, because of the nature of 
the fairness functional, G2 continuity tends to propagate along the patch-patch boundaries. If the surface 
elements are subdivided into smaller and more numerous elements and G2 vertex continu­ity is maintained, 
the overall surface converges on G2 continuity. A comparison of surfaces with and without G2 vertex continuity 
shows those with G2 continuity to have superior overall curvature distribution. The construction used 
to maintain G2 vertex continuity of the surface is a simple extension of the construction used to maintain 
G2 compatibility of the MVC network (section 5). An additional step is carried out after the principle 
directions and curvatures at the vertices of the network have been established. This extra step of the 
construction requires that the twist vector of each incident patch comer,bc compatible with the established 
curvature. The re­striction on SUVis derived from the formulas for mean and Gauss­ian curvature: eg -~ 
Gaussian = K, K2 = EG-ti and K1 +K2 lgE-2fF+eG mean = 2= ~ EG-f+ where e,~ g, E, F, G are defined 
as in equations (3) ~and (4). The twist vector must be adjusted to satiffy f = h ~Suv. This is accomplished 
by forcing the tip of SUV to lie in the plane Pewndicular to fi, offsetby distance jfrom the vertex k 
v = iuv+(f-ft. i.v)fi. f can be computed frqm the values of K1, K2 and the first and second order derivatives 
of S(u, v). 5 MVC Network Computation MVC networks are used to initialize the boundaries of the patches 
from which the surface is composed. Many of the tech­niques used in computing the network are used in 
the computa­tion of an MVS where the initial shape of the curve network is allowed to change. In this 
section we outline the methods used to compute the G2 curve network. 5.1 Network Representation and Continuity 
 The network of curves is defined via the second order parame­ters of a surface description at each vertex 
of the network and via a description of how each curve segment emerges from within the surfaces specified 
at its endpoints. Each surface is defined by the vertex position ~, a pair of conjugate directions, 01, 
02, and the normal curvatures in those directions K , KW, Conjugate direc­tions are equivalent to principle 
directi~~s m2that, coupled with the associated curvatures, they fully characterize the curvature of a 
surface at a point [11]. Conjugate directions are more amenable to optimization because they do not have 
to be constrained to mu­tual orthogonality, The network is represented by quintic Hermite curves. These 
Hermite curves are defined by the positions and first two parametric derivatives at their endpoints. 
Each curve in the network is defined by the position ~, tangent direction ?, and three scalar parameters, 
m,a, c, at each endpoint. The mapping from these values to the parameters defining the corresponding 
Hermite curve is $=; ~ = m2? @ = m46+am2i ~= K# r+c&#38; b= fix? .1 -1 ~ 1 /r > -/\T (lo) [~= Note that 
thl curvature of the curve is the sum of two orthoszonal components; Kn, the component in the normal 
direction-is a function of the surface at the vertex and the tangent direction of the curve at its end 
point; c. the component in the binormal direction is independent of the surface curvature at the vertex 
and represents the curvature of the curve within the surface. During the optimization process, those 
variables not fixed by constraints are iteratively adjusted to minimize the MVC functional ( I). At each 
iteration step, ii, and tiz are renormalized, and ? is projected onto the plane spanned by i,, ti2 and 
also renormalized. It is this normalization step in combination with the construction outlined in equation 
( 10) that guarantees G2 continuity is maintained. 5.2 Network Initialization The curve network must 
be initialized to some reasonable val­ues before optimization can proceed. First a vertex normal vector 
is initialized, then the tangent vectors of the incident curves are computed, next the principle directions 
and curvatures are de­fined, and finally each curve s scalar coefficients are initialized. The vertex 
normal is initialized as an average of the incident face normals weighted inversely proportional to the 
area of the in­cident face. i.e. the smaller the face the greater its influence on the vertex normal 
[5]. The tangent vectors of curves incident to a vertex are set to the direction of the incident chords 
projected onto the plane defined by the vertex position pi and the normal h (Fig. 7). Computer Graphics, 
26,2, July 1992 Figure7. Tangent initialization. The projection of incident chordsontotheplanedefined 
by the normal. Once vertex normal vectors and incident tangent directions have been computed, the principle 
curvatures and principle direc­tions at a vertex are calculated. Both Calladine [5] and Todd and McLeod 
[3 I ] describe approaches for estimating the curvature of polyhedral surfaces, Calladine s methwi only 
estimates Gaussian curvature, Todd and McLeod require that a pairing be established among the points 
neighboring a point; this is not possible at verti­ces of odd order. At even order vertices, it remains 
problematic since the results vary greatly depending on the pairing chosen; logically opposite curves 
are not always appropriate partners. Our approach uses a least squares fit of sample tangent direc­tions 
and normal curvatures to compute the principle directions and curvatures. The initialization of these 
values is very impor­tant to the speed of convergence. First consider the situation shown in Figure 7. 
A vertex is shown with a number of incident edges. For each edge we calculate the curvature implied by 
that edge emanating from the vertex. Starting with edge ~il~n we re­flect ~ through the normal and tit 
a circle through p ~, ~, and ~n. The radius of the resulting circle is the radius of curvature (Fig. 
8). Repeating this procedure for each of the incident edges Figure 8. Calculating an approximate radius 
of curvature in the direction of in. provides a set of sample tangent directions and normal curva­tures. 
This set is used to compute a least squares fit for the princi­ple directions and principle curvatures 
of the surface at the vertex as follows. I 73    7. Conte, S.D. and de Boor, C. Elementary Numerical 
Analysis, An Algorithmic Apptvach, McGraw-Hill, New York, N. Y., 1980. 8. Courant, R. and Hilbert, D., 
Methods of Mathernafical Physics, Volume 1, Wiley-InterScience, New York, N.Y., 1953. 9. DeRose, T.D. 
and Mann, S., An Approximately G1 Cubic Surface Interpolation. To appear in the Proceedings of the 1991 
Biri Conference. 10. DeRose, T.D., Necessary and Sufficient Conditions for Tangent Plane Continuity 
of Bt?zier Surfaces, Computer Aided Geometric Design 7 (1990), 165-179. 11. Do Carmo, M. P., Differential 
Geometty of Curves and Su~aces, Prentice-Hall, Englewood Cliffs, New Jersey, 1976. 12. Greene, N., Environment 
Mapping and Other Applications of World Projections, IEEE Computer Gmphics and Applications 6, 11 (Nov. 
1986), 21-29. 13. Hagen, H. and Schulze, G., Automatic Smoothing with Geometric Surface Patches, Computer 
Aided Geometric Design 4, (1987), 231-236. 14. Jones, A. K., Nonrectangtslar Surface Patches with Curvature 
Continuity, Computer Aided Design 20, 6 (Jul. fAug. 1988), 325-335. 15. Kallay, M. and Ravani, B., Optimal 
llvist Vectors as a Tool for Interpolating a Network of Curves with a Minimum Energy Surface, Computer 
Aided Geometric Design 7, 6 (1990), 465-473. 16. Lott, N.J. and Pullin, D. L., Method for Fairing B-spline 
Surfaces, Computer Aided Design 20, 10 (Dec. 1988), 597­ 604. 17. Mann, S., Loop, C., Lounsbery, M., 
Meyers, D., Painter, J., DeRose, T., and Sloan, K., A Survey of Parametric Scattered Data Fitting Using 
Triangular Interpolants. In Curve and Su@aceModeling, Hagen, H. (editor), SIAM. 18. Mehlum, E., Nonlinear 
Splines. in Computer Aided Geometric Design, R.E. Barnhill and R.F. Riesenfeld (editors), Academic, Orlando, 
Florida, 1974, pp. 173-207. 19. Moreton, H.P. and S6quin, C. H., Surface Design with Minimum Enesgy 
Networks. In Proceeding of the Symposium on Solid Modeling Foundations and CAD/CAM Applications (Austin, 
Tex., June 5-7). ACM, New York, N. Y., 1991, pp. 291-301. 20. Nielson, G. M., A Method for Interpolating 
Scattered Data Based Upon a Minimum Norm Network, Mathematics of Computation 40, 161 (1983), 253-271. 
 21. Nowacki, H. and Reese, D., Design and Fairing of Ship Surfaces. In Surjaces in Computer Aided Geometric 
Design, Barnhill, R,E. and Boehm, W. (editors), North-Holland, Amsterdam, The Netherlands 1983, pp. 121-134. 
 22. Peters, J., Local Smooth Surface Interpolation: A Classification, Computer Aided Geometric Design 
7 (1990), 191-195. 23. Peters, J., Smooth Interpolation of a Mesh of Curves, Constructive Approximation 
7 (1991),221-247. 24. Poeschl, T., Detecting Surface Irregularities Using Isophotes, Computer Aided 
Geometric Design, 1 (1984), 163-168. 25. Pottmann, H., Scattered Data Interpolation Based upon Generalized 
Minimum Norm Networks, Preprint Nr. 1232, Technische Hochschule, Darmstadt, May 1989. 26. Pramila, A., 
Ship Hull Surface Using Finite Elements, International Shipbuilding Progress 25,284 (1978), 97-107. 
27. Pratt, M. J., Cyclides in Computer Aided Geometric Design, Computer Aided Geometric Design 7 (1990), 
221-242.  28. Rando, T. and Roulier, J. A., Designing Faired Parametric Surfaces, Computer Aided Design 
23, 7 (Sept. 1991), 492­ 497. 29. Sarraga, R. F., Gl Interpolation of Generally Unrestricted Cubic B4zier 
Curves, Computer Aided Geometric Design 6, 2 (1987), 23-40. 30. Shirmsm, L. and !Mquin, C, H., Local 
Surface Interpolation with B6zier Patches, Computer Aided Geometric Design 4 (1987), 279-295. 31. Todd 
P.H. and McLeod, R.J,Y., Numerical Estimation of the Curvature of Surfaces, Computer Aided Design 18, 
1 (Jan./ Feb. 1986),33-37. 32. Williams, C.J.K., Use of Structural Analogy in Generation of Smooth Surfaces 
for Engineering Purposes, Computer Aided Design 19,6 (Jul./Aug. 1987), 310-322. 33. Wolfram, S., Mathetnatica, 
A System for Doing Mathematics by Computer, 2nd ed., Addison-Wesley, Redwood City, California, 1991, 
 34. Zienkiewicz, O. C., The Finite Element Method, McGraw-HN, London, England, 1977.    
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134036</article_id>
		<sort_key>177</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>20</seq_no>
		<title><![CDATA[Direct manipulation of free-form deformations]]></title>
		<page_from>177</page_from>
		<page_to>184</page_to>
		<doi_number>10.1145/133994.134036</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134036</url>
		<keywords>
			<kw><![CDATA[direct manipulation]]></kw>
			<kw><![CDATA[free-form deformations]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Curve, surface, solid, and object representations</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>I.3.6</cat_node>
				<descriptor>Interaction techniques</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>H.5.2</cat_node>
				<descriptor>Interaction styles (e.g., commands, menus, forms, direct manipulation)</descriptor>
				<type>S</type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010147.10010371.10010387</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Graphics systems and interfaces</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003120.10003121.10003125.10010391</concept_id>
				<concept_desc>CCS->Human-centered computing->Human computer interaction (HCI)->Interaction devices->Graphics input devices</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003120.10003121.10003124</concept_id>
				<concept_desc>CCS->Human-centered computing->Human computer interaction (HCI)->Interaction paradigms</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010399</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Parametric curve and surface models</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010401</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Volumetric models</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
			<gt>Human Factors</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>PP31037177</person_id>
				<author_profile_id><![CDATA[81100321790]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[William]]></first_name>
				<middle_name><![CDATA[M.]]></middle_name>
				<last_name><![CDATA[Hsu]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Cambridge Research Lab, Digital Equipment Corporation,  Kendall Square, Cambridge, MA]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>PP40024462</person_id>
				<author_profile_id><![CDATA[81100166298]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[John]]></first_name>
				<middle_name><![CDATA[F.]]></middle_name>
				<last_name><![CDATA[Hughes]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Department of Computer Science, Brown University,BOX 1910, Providence, RI 02912]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P109576</person_id>
				<author_profile_id><![CDATA[81538426656]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>3</seq_no>
				<first_name><![CDATA[Henry]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Kaufman]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Department of Computer Science, Brown University, 3D Ltd.4 Belinson Street, Tel-Aviv 63567. Israel]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Allen, Jeff B., Wy~, Brian, and WiRen, lan I-L A Method for Direct Manipulation of Polygon Meshes. Proceedings of Computer Graphics International '89, pages 451--469, 1989.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Barrels, Richard H. and Beatty, John C. A Technique for the Direct Manipulation of Spline Curves. Proceedings of Graphics Interface' 89, June 1989.]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_obj_id>35072</ref_obj_id>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Bartels, Richard H., Beatty, john C., and Barsky, Brian A. An Introduction to Splines for use in Computer Graphics and Geometric Modeling. Morgan Kaufmann, 1987.]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[Carroll, John M. and Thomas, John C. Metaphor and the Cognitive Representation of Computing Systems. Trans Systems, Man, and Cybernetics, 12(2):107-116, March/April 1982.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_obj_id>911441</ref_obj_id>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[Cobb, Elizabeth S. Design of Sculptured Surfaces Using the B.spline Representation. Phi) thesis, University of Utah, June 1984.]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_obj_id>97900</ref_obj_id>
				<ref_obj_pid>97880</ref_obj_pid>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[Coquillart, Sabine. Extended Free-Form Deformation: A Sculpting Tool for 3D Geometric Modeling. Proceedings of SIGGRAPH '90, In Computer Graphics, 24, 4, pages 187-196, August 1990.]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122720</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Coquillart, Sabine and Janc~ne, Pierre. Animated Free- Form Deformation: An Interactive Animation Technique. Proceedings of SIGGRAPH '91, In Computer Graphics, 25, 4, pages 23--26, July 1991.]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_obj_id>617618</ref_obj_id>
				<ref_obj_pid>616015</ref_obj_pid>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[Csuri, Charles A. Art and Animation. IEEE Computer Graphics and Applications, pages 30-35, January 1991.]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378512</ref_obj_id>
				<ref_obj_pid>54852</ref_obj_pid>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Forsey, David R. and Barrels, Richard H. Hierarchical B-spline Refinemen. Proceedings of SIGGRAPH '88, In Computer Graphics, 22, 4, pages 205-212, August 1988.]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[Fowler, Barry M. and Barrels, Richard H. Constraint Based Curve Manipulation. SIGGRAPH '91 course 25 notes, Topics in the Construction, Manipulation, and Assessment of Spline Surfaces, pages 4.0--4.16, July 1991.]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
			<ref>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[Hsu, W'flliam M. Direct Manipulation of Free-Form Deformations. Master's thesis, Brown University, March 1991.]]></ref_text>
				<ref_id>11</ref_id>
			</ref>
			<ref>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[Noble, Ben and Daniel, James W. Applied la'near Al. $ebra. Prentice-Hall, 2nd edition, 1977.]]></ref_text>
				<ref_id>12</ref_id>
			</ref>
			<ref>
				<ref_obj_id>563884</ref_obj_id>
				<ref_obj_pid>965141</ref_obj_pid>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[Parent, Richard E. A System for Sculpting 3D Data. Computer Graphics, 11(2): 138-147, August 1977.]]></ref_text>
				<ref_id>13</ref_id>
			</ref>
			<ref>
				<ref_obj_id>93840</ref_obj_id>
				<ref_obj_pid>93803</ref_obj_pid>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[Riesenfield, Richard E Design Tools for Shaping Spline Models. In Lyche and Schumaker, editors, Mathematical Models in Computer Aided Geometric Design, pages 499-519. Academic Press, 1989.]]></ref_text>
				<ref_id>14</ref_id>
			</ref>
			<ref>
				<ref_obj_id>15903</ref_obj_id>
				<ref_obj_pid>15886</ref_obj_pid>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[Sederberg, Thomas W. and Parry, Scott R. Free-Form Deformation of Solid Geometric Models. Proceedings of SIGGRAPH '86, In Computer Graphics, 20, 4, pages 151-160, August 1986.]]></ref_text>
				<ref_id>15</ref_id>
			</ref>
			<ref>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[Welch, Wflliam, Gleicher, Michael, and Witkin, Andrew. Manipulating Surfaces Differentially. Tedmical Report CS-91-175, CMU, September 1991.]]></ref_text>
				<ref_id>16</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 z Computer Graphics, 26,2, July 1992 Direct Manipulation of Free-Form Deformations William M Hsu Cambridge 
Research Lab Digital Equipment Corporation  John F. Hughes2 and Henry Kaufman3 Department of Computer 
Science Brown University Abstract Fme-form defommtion (FFD) is a powerful modeting tool, but contmtling 
the shape of an object under complex deformations is often ~cult. fhe interface to FFD in most conventional 
syetems simply mpments the unddying mathematics directly, ur3ent&#38;­acdbe deformations by manipulating 
control points. lhe difEculty in controlling shape precisely is largely due to the control pcdnte being 
extmneous to the objec~ the deformed object does not follow the control pointn exactly. In addition, 
the number of &#38;gmes of freedom pre@entedto the user cm be ovenvhelming. We present a method that 
allows a uacr to control a fme-form deformation of an object by manipulating the object dhectly, leading 
to better contmd of the deformation and a more intuitive interface. CR Categories: 1.3.5 [Computer Oraphics]: 
Computa­tional Oeometry and Object Modeling -Curve, Surface, Solid, and Object Repn%entatiomx1.3.6 [Computer 
Oraph­ics]: Methodology and lkchniques -InteractionTechniques. Additional Keywords: Direct manipulation, 
free-form de­formations.  1 Introduction Oeometric modeling of complex objects is a difficult task. 
Sophisticated techniques for shaping and creating complex objects are generally awkward and tedious to 
use [8]. Free­formdeformation[15] fallaintothia category. Itis apowerfid modeling technique that enables 
the deformation of objects bydeformingthespace aroundthem,butusing thistechnique is sometimes difficult. 
The deformations aredeiined by para­metric functions (3D splines) whose values are determined I ~ Ke~all 
~um, c~btige, MA 02 I39. emsik hsu@crMecmcomm phone: 617-62 I-6645 2BOX 1910, ~v~ti, RI 02912. emsik 
jfh@cs.browrr.cdu. phone: 401-863-763S 3mmnt ~~~: 3D ~. 4 ~lkn !hcc~ Tel-Aviv 63567. ~~1 Permission to 
copy without fee all or parI of this material is granted provided that the cupies are not made or distributed 
for direct commercial advantage, the ACM copyright notice and the title of the publication and its date 
appear, and notice is given that copying is by permission of the Association for Computing Machinery. 
To copy otherwise. or m republish, requires a fee and/or specific pa-mission. by the location of controlpoints. 
Describing a free-formde­formation (FFD) in conventional modeling systems is done bymanipulatingthesecontrolpoints, 
aninterfacethatreflects the underlying mathematics of the modeling method. Iltis type of interface can 
be contbsing because the control point movement merelyhintsatthetypeof deformationtheobjecl will be subjected 
to. I%efollowing examples will help to clarify this. Although the movement of the control points gives 
an indication of the teaulting deformation, some shapes am not intuitivetoform.As afirstexample,tocreateabulgewitha 
flat top one may think to align the control points to a plane, as shown in Figure 1s. However, it is 
actually necessq to position the control points as shown in Figure lb to create the flat top. As a second 
example, F@res 6 and 7 show the prongs of a ring modeled with he-form deformations. Preciseplacementof 
theprongsisneededtoensurethatthey do notpenetratethegem stone. Complex deformation operations ot?en require 
a large number of control points resulting in semen clutter. They also tend to get buried within the 
model being deformed. As aresult,it is virtuallyimpossible to seieu ormanipulatethe control points efficiently. 
Thuswe cansee fourproblemsinmanipulatingdefor­mations via control points. 1. Exac4shape isdifficultto 
achieve. 2. Exact placement of objecl points is difficult to achieve. 3. Users unfamiliarwith splines 
do not understandthe pur­pose ofthecontrolpointsandtheresultsoftheirmove­ment. 4. The control points 
become difficult to manipulatewhen occluded by-the object being deformed, o; when there ate so many they 
clutterthe screen.  One way to improve the usability of this technique is to move controlpointsingroups,andthenapplylinearandnon­linear 
transformationsto them, similar to the group control point manipulationpresentedin [51forspline surfaces. 
While helping the user move many control points at one time, this ~?]99~ ACM-O-89791 $01.50 -479-I192KH1710177 
 SIGGRAPH 92 Chicago, July 26-31, 1992 (a) (b) Figure 1: An FFD in the plane. me dashed line shows the 
original shape, and the solid line shows the shape after the deformation. (a) shows the result of a flat 
line of control points. (b) shows the controlpoint configurationto createa flat top. does nothing to 
alleviate the shape and placement problems. It is unclear which control points should be moved and how 
transformationswill affect the object. The limited usefulness of this approach for spline surfaces was 
noted by [14]; the 3D volume of control points for FFDs (in contmat to the 2D mesh of control points 
for spline surfaces) exacerbates the difficulties of deciding how an aggregate move should be performed, 
Another approachto an easier and more intuitive inter­face is the Extended Free-Form Deformation (EFFD) 
tech­nique of [6]. WMI EFFDs, the user configures the initial lattice of control points to the approximate 
shape of the in­tended deformation, instead of stming with the FFD s par­allelepipedsof control points. 
EFFDa am quite ellxlive for creating impressions, reliefs, and other fairly simple defor­mations that 
might otherwise be difficult to achieve with FFDa. However, the user must know the general shape of thedeformationbeforestartingtomodel, 
andtheinterfaceis atitl a direct representationof the underlying mathematics. Both FFDs and EFFDs are 
based on the notion of de­forming the un&#38;rlying space in which an object lies. ~s has the advantage 
that it can be applied to any parametric or polygomd model, and is therefore not restricted to any class 
of objects. On the other hand, the control lattice used to manipulate the underlying space is not directly 
related to the objet%being deformed. l%exefore,a control point that happens to be close to the surface 
of the objecl (which is, afteratl,thefocusof theuser sattention)maybe farfromthe object surface after 
the deformation. Thus, these methods may surpriseauserwho doeanot understandthedistinction between the 
object and the space in which it lies. In this paper, we develop a direct manipulation tech­nique which 
makes formation and placement of deforma­tions easier. The essential idea is that the user selects (with 
some sort of pointer) a point on an object and then moves the pointer to a location where that object 
point should be. Our technique computes the neasaary alterationto the con­trol points of the FFD spline 
that will induce this change. This alterationis generally underdeterm=, we use a least squan%approachto 
select a particularalteration. me restofthepaperisstructuredin4sections. Section 2 describes FFDs, and 
introduces B-spline FFDs. Section 3 describesadirectmanipuhtioninterface toB-splineFFDs, in which the 
user describes actions, and these actions are con­verted into control point displacements that will effect 
the actions. Section4discussesrelatedworkindirectmanipula­tioninterfaces,possible applicationsanddirectionsforfuture 
research. Section 5 aurnmari~ the results of the paper. 2 Free-Form Deformation The FFD method deforms 
an object by first assigning to each of its points within the deformation lattice a set of lo­cal coordinates 
The local coordinate system is defined by a parallelepiped-shaped lattice of control points with axes 
defined by the orthogonal vectors s, t,and u, as shown in Figure 2. All object points within this parallelepipedsare 
ss­signed locat cocudinateathrough a mapping applied to their z yz-cxxwdinateg;we describe this mapping 
later. Oncethecontrolpoints aremoved, thenewlocationof an object point is then determined by a weighted 
SUMof the control points. me weights are functions of the load coor­dinates originally assigned to the 
point. Hence, a positional changeof thecontrolpointschangesthelocationof theobject point. -&#38;ut 8 
Figure 2: A lattice of control points. The s, t, and u vectors define the local coordinate system In 
our implementation, the deformation function is a trivariateB-spline tensor product. We w the B-spline 
baais instead of the Bematein polynomials used by Sede@ and Parry because of the local control properties 
of B-spiines. Local control is desirable for both wxthetic value and for efficient computation with large 
control point lattices. We also preferB-splines for its guaranteedcontinuity when any of its control 
points are moved, in contrastto, for example, B&#38;ier splines. Computer Graphics, 26,2, July 1992 In 
summary, then, the deformed position, q, of any arbitrarypoint with local coordinates, (s, t, u), is 
given by o qi,j,k(g~ ~, ) = Pi+i,j+~,~+~B/( 9) B~(t)B~(U) E /,m, n= 3 (1) wherePi,j,~istheith,jth, ktkcontrolpointinthes, 
t,andu direction, respectively, and the ES am the B-spline blending timctions. In our implementation 
of PPD we allow both direct manipulation of the object and manipulation of the control points. A drawbackof 
using B-splines is thatthe image of the B-spline doea not fill the convex hull of the control lattice, 
if thecontrollatticeisevenly spacedandallcontrolpointshave multiplicity one. We compensate for this by 
giving the outer control points of the lattice a multiplicity of three, which ensures that the image 
of the B-spline is the convex hull of thecontrollatth. Phantomcontrolpointscouldbeusedas well; constmhting 
their positions guarantees C2 continuity along the borders. See [3] for more details. Before the deformation 
is applied, object points must that be assigned local (s, t, u) coordinates, as already men­tioned. When 
the control lattice is in its initiat position, it definesaninjectivemapfromitsdomaintotheconvex hullof 
the lattice. Thus each point w within this hull is q(so, b, UO) for some m, b, w in the parameterspace 
of the B-spline. l%enumbers so, b, w are the local coordinates we assign. lb compute them, we must invert 
the B-spline map. We first determine the spline segment ~i,j,k that COlltShlS the object point. Then 
we compute So, to, and w by explicitly solving the cubic equations ~l,j,k (SO, i!o, UO) = W.s Note that 
the local coordinates need only be computed once for a given lattice, and not for each deformation calculation. 
 3 Direct Manipulation In this section, we describe an interaction technique that con­verts a user action 
of the form move this point of the object to there and finds control point positions that will effecl 
this action. We first describe the method in the case where the user wants to move a single selected 
object point to anew position, orturgetpoint. Wethen build upon this techniqueto describe how multiple 
selected points can be moved simul­taneously. Although we demonstrate this method with the B-spline FFD, 
it can be used in conjunction with any other spline basis. If control points sm not displayed at all, 
then .ll the control points in tfIS lattice CM k of multiplicity one, srtd ths rssion dsformcd cm be 
rcpre­sctttcdby tftc brxcfsr of ths B-splintinmgs. lkiasintplifks tfts &#38;formation s+mtion, snd ths 
Mtsr portion of section 3.I cur bc diamisscd. s~mml -t findingisneeded only for the outer two scsmcnts 
due to the tripling of control points at tk borders. Othcrwk, (SO, to, W) can be found by the position 
of the object point in relation to the segments that contain it directty, M WMdone in the original PFD 
paper [ 15]. 3.1 Single point constraint Aa the user moves a target point our goal is to contigutv the 
control points such that the deformed location of the se­lected point matches the target point location. 
TMs problem is underdeterrnined; there are many control-point configu­rations that will yield the same 
deformed location for the selected point. One obvious, but not very usefid, solution is to simply translate 
all the control points by the target point s translation. Another solution is to choose the nearest control 
point and translate it until the target point reaches the desired location. A more natural solution is 
one that move, the con­trol points the least (in the least-squarea sense). The blending functions of 
Equation(1) assign weights to the control points for a given target point. Ilw closer the control point 
is to the targetpointthegreatertheweight,or influam, thecontrol pointhas. By using a least squareasolution, 
controlpoints aremoved suchthattheresultingsurfacereachesitsintended destination while the el%ct of the 
deformation smoothly ta­pers off. This effect provides predictable and physically intuitive behavior. 
We begin with some tinear atgebra. Recall from Equation (1) that the deformed object point location, 
q, is a linear fimction of 64 control points, P, which can bevnittenin matrix formasq =BP, where Bisasingle 
row matrix of the blending functions, and P is an 64 x 3 array whose rows are control point coordinates. 
(Henceforth we write coordinates of all points as row vectors.) A new location for the point q, q.,W, 
is then q..W = B(P + AP), or Aq= BAP (2) where AP is the change in position of the control points and 
Aq is the change in position of the object point. We me given Aq (the difference between the target point 
and the selected point), and wish to fmd a value of AP satisfying Equation 2. To do this we use the pseudoinverse 
(often referredto as the generalized inverse) B+ ofB. Digression on Paeudoinverses Oiven a system of 
tinear equations y = Bx, the pseudoinverse B+ is a maaix when w = B+ y is the best solution, in the least 
squares sense, to the system of equations, (i.e., for which IlBb yl I is minimkdand I[xoll isassmall 
aspoasible [12]). Thepaeu­doinverseiscomputedbyfimtrepresentingthem xnmatrix Bintheform B= CD, where 
Cismx kand Diskxn, so thatall three matrices B, C,and Dhave rank k.l%e general formula for the pseudoinverse 
B+ of B is then given by B+ ==CT(CCT)-l (DTD)-l DT (3) This formulacanbeused forbothunderdete3minedand 
over-determinedsystems of equations. Whentheproblemis under-determined,as with the single targetpoint 
constrm nt, only (DTD)- DT is needed to compute the paeudoinverae, and B = D. 14cewise, the paeudoinveme 
for the over­determined case is computed by CT(CCT)-l. (DDT)-* reduces to 1/llD 112,and the paeudoinveme 
of the single-row matrix B can now be found by the equation I79 SIGGRAPH 92 Chicago, July 26-31, 1992 
1 ~T B+= (4) IIJM2 (end of digression). Once the pseudoinverse of B is determined, the change in position 
of the control points baaed on the movement of the targetpoint can be expressed as AP = B+Aq (5) Because 
the pseudoinveraegives a least-squaressolution, the change in control point positions is mhimkd. This 
solution, however, applies only when all control points me allowed to move independently. Recall from 
SeG tion 2 that in our implementation the control points on the outerbcmlerhaveamultiplicityof three,andthereforemust 
be coincident. lb formulate the pseudoinverse equation to reflect this constraint, a matrim S, which 
selects the proper control point position is added to Equation (2), so that the deformed object point 
location is deiined by Aq = BSAP (6) Thematrix S is the identity m-if all control points are allowed 
to move freely. Control points that must be coin­cident with one another have the one in their row shifted 
to the column that corresponds to the control point it must fotlow. Forexample, in the one-dimensional 
bordercase, if P = [p-2p-lpopl]T, where p-zand p-1 ammquimdtobe coincident with PO(i.e., POhaa a multiplicity 
of three), then 0010 0010 s= 0010 0001 [1  The equation for the pseudoinveme (BS)+ is (BS)+ = (DS)T(DSSTDT)-l 
(7) Foretliciency, Scanbecompmwedtoavector,andB+ need be computed only once for a given targetpoint. 
3.2 Multiple target point constraints l%esametechniqueis usedtomoveseveralselectedpoints tonewtargetssimultaneously.Precisecontrolover 
shaping objectsbecomeseasier. Whenthemultipleselectedpointsare independent(i.e., whentheysharenocontrolpoints),solving 
forcontrolpoint position is a straightforwardextensionof the single targetpoint method. When selected 
points am influenced by the same control point,thesystemofequationsmustbedesignedso thateach control 
point only appearsonce in the arrayP. he number of columns of B is the number of distinct control points 
aflkcdng the selected points. The number of rows of B will be the numberof targetpoints. In a one-dimensional 
analog of this situation, if we want to move two selected points that 180 sharethreecontrol points, thenthedimensionof 
B is 2 x 5 and P would list 5 control points. The blending functions in B are arrangedin accordance to 
the listing of the control points. In this example, the equation becomes [Pol LP4J whexe q. is kcted 
by control points O-3 and ql is affected by controlpoints 1-4, and b; are the blending functions used 
to computethelocation of the ithselected point. Once again, the pseudoinverse of B is calculatedusing 
Equation3 andthenewcontrolpointlocations aredetermined by Equation 5. Figures 3 to 5 show how multiple 
constraints can quickly effect a change in the shape of an object. As more target points are added, the 
problem can be­ comeoverdetermined. Forexample,ifausertriestocreatea wavy surface with more undulations 
than is possible to gen­erate with the given B-spline, then the pseudoinverse can­ not provide a complete 
solution. l he pseudoinverse has, however, the property of providing the solution with the least squared 
error, which is the best solution considering the given constraints. Futiermore, the failure to move 
the selected points to the target points can be quantiti, huge errorssuggest to the user the need to 
use a B-spline with a finer mesh. 4 Discussion 4.1 Other direct manipulation techniques Directmanipulation 
has long been used as a 3D modeling technique for polygonal meshes [13]. However, we find that couplingthefree-formdeformationtechniquewithM 
ma­nipulationis arichermodelingtool withseveraladvantages over polygonat and purely spline-baaed modeling 
methods. FFDsworkindependentlyof theunderlyingdatastructureof the object being deformed, and henca can 
be applied to any parametricorpolygonalmodel. Animplicationofthisisthat FFDs are %solution independent. 
Complex objects can be modeled in real-time by rendering them in low resolution, which canlaterberenderedathighresolutionusingthesame 
deformationdescription. Though aprocedurallanguagemay provide similar capabilities for a polygonat modeler, 
some restrictionsapply. Forexample,verticesmovedbytheuser in one level of mesh refinement must have a 
corresponding, coincident vetiex in every otherlevel of m6nement [1]. Since the FFD technique &#38;forms 
the spaa within it, another advantage is that the same description can be used for several objects. The 
deformation is dependent on the relative position of the control points. Ilw control pointa undergo rigid 
transformationsand scaling without at%cting the general shape of the deformation, which is useful when 
applyingthesame deformationdefinitiontoobjectsof dMer­ent aim. If more than one object lies within the 
deformation space,thedeformationcanbeappliedto allobjects,preserv­ing automatically their relative position 
and spacing. Recent developments have been made in the direct ma­nipulation of B-splinea. Forsey and 
Bartels allow direct ma­nipulation of hierarchical B-spline surfaces [9], but only at the B-spline joints, 
severely limiting the possible shapea that can be formed. The method was extended by Bartels and Beatty 
to manipulate spline cmves at arbitrary points [2]. Their method is based on the Householder transformation, 
which computes a weighting function that relates positional changes in the target point to positional 
changes in the con­trol points. In [10], Fowler and Bartels have extended the technique to include the 
manipulation of the first and second derivatives of the function at an arbitrary point as well. Recently, 
[16] independently developed a system for direct manipulation of B-spline surfaces, based on their dif­ferential 
manipulation technique. This technique uses the Ja­cobian to suggest the direction of movement, and through 
least square projection uses the inverse of the Jacobian to solve for the position of the control points. 
Though this method for direct manipulation is similar to the method pre­sented in this paper, it is applied 
only to B-spline surfaces. In contrast, the method described in this paper merely requires that the substrate 
in which the model lives (namely 3-space) be the image of a 3D spIine; this is a property of the substrate 
and not of the model, and hence lets the technique apply to all polygonal models as well. Also, since 
our FFD technique is an indirect method of modeling, lattices of diffenmt size and resolution can be 
used on the same object to create a multitude of different curvatures. 4.2 Application In addition to 
modeling static models, the direu manipula­tion technique can automate some forms of animated defor­mations. 
For instance, the technique can be used to simulate Play-Doh@b physics: where objects deform when they 
are pressed against other objects, but without the complexities of simulating momentum transfer and non-rigid 
behavior. TM level of simulation is usethl to animators who want full object motion control, while still 
desiring automatic deformation in response to interpenetration or object collisions. In addition, this 
technique could be used to construct the finat deforma­tion lattices for Animated Free-Form Deformations 
(AFFD) [7]. In general, direct manipulation could W easily incorpo­ rated into EFFD (which AFFD is based 
upon) as a means for interactive shape control. 4.3 Future Research Though the general technique for 
dhect manipulation of free­form deformations has been implemented, further research is needed to provide 
a complete and robust user interface. Intuitive and easy to use techniques for moving aggregates 6~ay.~h 
iB~ ~giB@~ tr~mti of Tonka Corporation. It is a soft modeling compound similar to clay. Computer Graphics, 
26, 2, July 1992 of object points are needed. Some widgets we have devel­oped am based on the idea of 
using a magnet or suction cup to move several points at a time [11]. It would be desirable for users 
(especially naive users) not to deal with control points at all. The proper metaphors for controlling 
the reso­lution of the lattice of control points and the spacing between the points must therefore be 
developed. Other aids, such as highlighting the area affected by the deformation can con­vey information 
that was previously conveyed by displaying control points. In general, a comprehensive metaphor needs 
to be developed to fully hide the details of the FFD technique and make the interface as transparent 
as possible. Creating a metaphor that is both believable and general enough to encompass all operations 
is a difficult task and will require tkher study [4]. We envision an environment where users will be 
able to sculpt objects using a Dataglove-tike input device. The finger tips, digits, and palm of the 
hand will be tracked to offset selected points in a matleable object, with smooth valleys and hills attained 
by the FFD operation. Dif­ferent elasticities can be assigned to the object by varying the resolution 
of the control-point lattice. Perhaps a metaphor of molten metal or glass may be appropriate, where a 
blow torch and cold air am used to heat and cool the object to give it different molding properties. 
By making modeling as natural as poaaibIe, or by imitating the ways it is done in the real world, a greater 
number of users can be reached and an increase in expressiveness in modeling attained. WM the technique 
described in this paper, there are oc­casions when the user can create over-mwtrained situations, and 
although the resulting solution has the minimum error it may not be what the user expects. A more gracious 
solution needs to be found, perhaps one that reconfigures the lattice of control points automatically, 
without disturbing the previous deformations.  5 Conclusion With direct manipulation, using FFDs for 
modeling complex objects becomes more intuitive. Better control over the shape and placement of the deformation 
is gained. By eliminating the need to display control points (and its associated control lattice) the 
interface is more transparent, allowing the user to concentrate on his or her work. WM the proper metaphor, 
users no longer need to understand splint%in order to use this powerful modeling tool. By adding greater 
control over how an object is shaped, new modeling paradigms and environ­ments can be explored. 6 Acknowledgments 
The authors of this paper would like to thank the members of the (3aphics Group at Brown for their helpful 
comments and support, especially Daniel C. Robbins for creating the gargoyle bust. This paper is based 
on the Master s thesis of the first author, whose attendance at Brown University was made possible by 
Digital Equipment Coqmation s Graduate Engineering Education Program. Special thanks to Richard SIGGRAPH 
92 Chicago, July 26-31, 1992 Szeliski for hia review and augge?tiona of this work, and to the other membem 
of the Visualization group at DEC S Cambridge Rmearch Lab for theirreview of this paper. l%is workwas 
supportedin partby grantsfrom Digital Bquipment Corporation,NSF, DARPA, IBM, NCR, Sun Mkrosysterns, and 
HP. [12] [13] [14] References [1] Allen, Jeff B., Wyvil, Brian, and WMen, Ian I-L A Method for Direct 
Manipulation of Polygon Meshes. Ptvceedings of Computer Graphics International 89, pWeS 451469,1989. 
[15] [2] Bartels, RichardH. andBeatty,JohnC. Alkchnique for the Direct Manipulation of Spline curves. 
Proceedings of Graphics Inte@ace 89, June 1989. [16] [3] Bartels, Richard H., Beatty, John C., and Baraky, 
Brian A. An Introduction to Splinesfor use in Computer Graphics and Geometric Modeling. Morgan Kauf­mann, 
1987. [4] Carroll, John M. and Ihomas, John C. Metaphor and the Cognitive Representation of Computing 
Systems. Trans Systems, Man, and Cybernetics, 12(2):107-116, March/April 1982. [5] Cobb, Elizabeth S. 
Design of Sculptured Surfaces Using the B-spline Representation. PhD thesis, University of Utah, June 
1984. [6] Coquillart, Sabine. Bxtended Free-Form Deformation: A Sculpting Tbol for 3D Geometric Modeling. 
Pro­ceedings of SIGGRAPH 90, In Computer Graphics, 24,4, pages 187-1%, August 1990. [7] Coquillart, Sabine 
and Janc?me, Pierre. Animated Free-Form Deformation: An Interactive Animation l&#38;ch­nique. Proceedings 
of SIGGRAPH 91, In Computer Graphics, 25,4, pages 23-26, July 1991. [8] Csuri, C&#38;irks A. Art and 
Animation. H?EE Computer Graphics andApplications, pagea 30-35, January 1991. [9] Foraey, David R, and 
Bartels, Richard H. Hierarchical B-spline Reiinemen. Proceedings of SIGGRAPH 88, In Computer Graphics, 
22,4, pages 205-212, August 1988. [10] Fowler, Barry M. and Bartela, Richard H. Constraint Based Curve 
Manipulation. SZGGRAPH 91 course 25 notes, Topics in the Construction, Manipulation, and Assessment of 
Spline Suflaces, pages 4.0416, July 1991. [11] Hsu, WWam M. Dir&#38;3 Manipulation of Fme-Form De­formations. 
Master s thesis, Brown University, March 1991. Noble, Ben and Daniel, James W. Applied LinemAl­gebra. 
Prentice-Hall, 2nd edition, 1977. Parent, Richad E. A System for Sculpting 3D Data. Computer Graphics, 
11(2}138-147, August 1977. Rieser@eld,RichaNIF.Design IbcdsforShapingSpline Models. In Lyche and Schumaker, 
editors, Mathe­matical Models in Computer Aided Geometn cDesign, pages 499-519. Academic press, 1989. 
Se&#38;z&#38;g, Thomas W. and Parry, Scott R. Free-Form Deformation of Solid Geomelric Models. Proceedings 
of SIGGRAPH 86, in Computer Graphics, 20,4, pages 151-160, Au@at 1986. Welch, William, ffleicher, Michxd, 
and Witkin, An­drew. Manipulating Surfaces Differentially. lkclmical Report CS-91-175, CMU, September 
1991.   
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134037</article_id>
		<sort_key>185</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>21</seq_no>
		<title><![CDATA[Surface modeling with oriented particle systems]]></title>
		<page_from>185</page_from>
		<page_to>194</page_to>
		<doi_number>10.1145/133994.134037</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134037</url>
		<keywords>
			<kw><![CDATA[oriented particles]]></kw>
			<kw><![CDATA[particle systems]]></kw>
			<kw><![CDATA[physically-based modeling]]></kw>
			<kw><![CDATA[self-organizing systems]]></kw>
			<kw><![CDATA[surface interpolation]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Curve, surface, solid, and object representations</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>G.1.1</cat_node>
				<descriptor>Spline and piecewise polynomial interpolation</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Geometric algorithms, languages, and systems</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Animation</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>J.6</cat_node>
				<descriptor>Computer-aided design (CAD)</descriptor>
				<type>S</type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010405.10010469.10010472.10010440</concept_id>
				<concept_desc>CCS->Applied computing->Arts and humanities->Architecture (buildings)->Computer-aided design</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002950.10003714.10003715.10003722</concept_id>
				<concept_desc>CCS->Mathematics of computing->Mathematical analysis->Numerical analysis->Interpolation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003752.10010061</concept_id>
				<concept_desc>CCS->Theory of computation->Randomness, geometry and discrete structures</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010405.10010432.10010439.10010440</concept_id>
				<concept_desc>CCS->Applied computing->Physical sciences and engineering->Engineering->Computer-aided design</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002950.10003648.10003649.10003657.10003659</concept_id>
				<concept_desc>CCS->Mathematics of computing->Probability and statistics->Probabilistic representations->Nonparametric representations->Spline models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010352</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Animation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010401</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Volumetric models</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010399</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Parametric curve and surface models</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
			<gt>Design</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>PP15023234</person_id>
				<author_profile_id><![CDATA[81100122769]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Richard]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Szeliski]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Digital Equipment Corp.,Cambridge Research Lab, One Kendall Square, Bldg. 700, Cambridge, MA]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P64120</person_id>
				<author_profile_id><![CDATA[81100261013]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[David]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Tonnesen]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Dept.of Computer Science, University of Toronto, Toronto, Canada M5S 1A4]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Appel, Andrew. An Efficient Algorithm for Many-body Simulations. SlAM J. Sci. Stat. Comput., 6(1), 1985.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Bartels, Richard. H. and Beatty, John. C. A Technique for the Direct Manipulation of Spline Curves. In Graphics Interface '89, pages 33-39, June 1989.]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_obj_id>35072</ref_obj_id>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Bartels, Richard. H., Beatty, John. C., and Barsky, Brian. A. An Introduction to Splines for use in Computer Graphics and Geeometric Modeling. Morgan Kaufmann Publishers, Los Altos, California, 1987.]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_obj_id>357310</ref_obj_id>
				<ref_obj_pid>357306</ref_obj_pid>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[Blinn, James E A Generalization of Algebraic Surface Drawing. ACM Transactions on Graphics, 1(3):235- 256, July 1982.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[Boissonat, J.-D. Representing 2D and 3D Shapes with the Delaunay Triangulation. In Seventh International Conference on Pattern Recognition (ICPR'84), pages 745-748, Montreal, Canada, July 1984.]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_obj_id>139850</ref_obj_id>
				<ref_obj_pid>139834</ref_obj_pid>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[Breen, David E., House, Donald H., and Getto, Phillip H. A Particle-Based Computational Model of Cloth Draping Behavior. In Patrikalakis, N. M., editor, Scientific Visualization of Physical Phenomena, pages 113-134. Springer-Verlag, New York, 1991.]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_obj_id>97900</ref_obj_id>
				<ref_obj_pid>97880</ref_obj_pid>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Coquillart, Sabine. Extended Free-Form Deformations: A Sculpturing Tool for 3 D Geometric Modeling. Computer Graphics (SIGGRAPH' 90), 24(4): 187-196, August 1990.]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_obj_id>83600</ref_obj_id>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[Farin, Gerald. E. Curves and Surfaces for Computer Aided Geometric Design: A Practical Guide. Academic Press, Boston, Massachusetts, 2rid edition, 1990.]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_obj_id>648676</ref_obj_id>
				<ref_obj_pid>645305</ref_obj_pid>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Fua, Pascal and Sander, Peter. Reconstructing Surfaces from Unstructured 3D Points. In Second European Conference on Computer Vision (ECCV'92), Sta. Margherita, Italy, May 1992. Springer- Verlag.]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_obj_id>62815</ref_obj_id>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[Hockney, Roger W. and Eastwood, James W. Computer Simulation using Particles. McGraw-Hill Inc., New York, 1988.]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
			<ref>
				<ref_obj_id>97917</ref_obj_id>
				<ref_obj_pid>97880</ref_obj_pid>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[Loop, Charles and DeRose, Tony. Generalized B-spline Surfaces of Arbitrary Topology. Computer Graphics (SIGGRAPH' 90), 24(4):347-356, August 1990.]]></ref_text>
				<ref_id>11</ref_id>
			</ref>
			<ref>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[Miller, Gavin and Pearce, Andrew. Globular Dynamics: A Connected Particle System for Animating Viscous Fluids. In SIGGRAPH '89, Course 30 notes: Topics in Physically-based Modeling, pages R 1 - R23. S IG- GRAPH, August 1989. Boston, Massachusetts.]]></ref_text>
				<ref_id>12</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122742</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[Miller, James V., Breen, David E., Lorensen, William E., O'Bara, Robert M., and Wozny, Michael J. Geometrically Deformed Models: A Method of Extracting Closed Geometric Models from Volume Data. Computer Graphics (SIGGRAPH' 91), 25(4):217-226, July 1991.]]></ref_text>
				<ref_id>13</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378524</ref_obj_id>
				<ref_obj_pid>378456</ref_obj_pid>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[Platt, John C. and Barr, Alan H. Constraint Methods for Flexible Models. Computer Graphics (SIG- GRAPH' 88), 22(4):279-288, August 1988.]]></ref_text>
				<ref_id>14</ref_id>
			</ref>
			<ref>
				<ref_obj_id>42249</ref_obj_id>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[Press, William H., Flannery, Brian P., Teukolsky, Saul A., and Vetterling, William T. Numerical Recipes in C: The Art of Scientific Computing. Cambridge University Press, Cambridge, England, 1988.]]></ref_text>
				<ref_id>15</ref_id>
			</ref>
			<ref>
				<ref_obj_id>357320</ref_obj_id>
				<ref_obj_pid>357318</ref_obj_pid>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[Reeves, William. T. Particle Systems~A Technique for Modeling a Class of Fuzzy Objects. ACM Transactions of Graphics, 2(2):91-108, April 1983.]]></ref_text>
				<ref_id>16</ref_id>
			</ref>
			<ref>
				<ref_obj_id>37406</ref_obj_id>
				<ref_obj_pid>37402</ref_obj_pid>
				<ref_seq_no>17</ref_seq_no>
				<ref_text><![CDATA[Reynolds, Craig. W. Flocks, Herds, and Schools: A Distributed Behavioral Model. Computer Graphics (SIGGRAPH'87), 21 (4):25-34, July 1987.]]></ref_text>
				<ref_id>17</ref_id>
			</ref>
			<ref>
				<ref_obj_id>617702</ref_obj_id>
				<ref_obj_pid>616020</ref_obj_pid>
				<ref_seq_no>18</ref_seq_no>
				<ref_text><![CDATA[Sachs, Emanuel, Roberts, Andrew, and Stoops, David. 3-Draw: A Tool for Designing 3D Shapes. IEEE Computer Graphics &amp; Applications, 11 (6): 18-26, November 1991.]]></ref_text>
				<ref_id>18</ref_id>
			</ref>
			<ref>
				<ref_obj_id>77589</ref_obj_id>
				<ref_seq_no>19</ref_seq_no>
				<ref_text><![CDATA[Samet, Hanan. The Design andAnalysis of SpatialData Structures. Addison-Wesley, Reading, Massachusetts, 1989.]]></ref_text>
				<ref_id>19</ref_id>
			</ref>
			<ref>
				<ref_obj_id>325242</ref_obj_id>
				<ref_obj_pid>325165</ref_obj_pid>
				<ref_seq_no>20</ref_seq_no>
				<ref_text><![CDATA[Shoemake, Ken. Animating Rotation with Quaternion Curves. Computer Graphics (SIGGRAPH'85), 19(3):245-2540, July 1985.]]></ref_text>
				<ref_id>20</ref_id>
			</ref>
			<ref>
				<ref_obj_id>97923</ref_obj_id>
				<ref_obj_pid>97880</ref_obj_pid>
				<ref_seq_no>21</ref_seq_no>
				<ref_text><![CDATA[Sims, Karl. Particle Animation and Rendering Using Data Parallel Computation. Computer Graphics (SIG- GRAPH' 90), 24(4):405-413, August 1990.]]></ref_text>
				<ref_id>21</ref_id>
			</ref>
			<ref>
				<ref_seq_no>22</ref_seq_no>
				<ref_text><![CDATA[Szeliski, Richard. Shape from Rotation. In IEEE Computer Society Conference on Computer Vision and Pattern Recognition (CVPR'91), pages 625-630, Maui, Hawaii, June 1991. IEEE Computer Society Press.]]></ref_text>
				<ref_id>22</ref_id>
			</ref>
			<ref>
				<ref_seq_no>23</ref_seq_no>
				<ref_text><![CDATA[Szeliski, Richard and Tonnesen, David. Surface Modeling with Oriented Particle Systems. Technical Report 91/14, Digital Equipment Corporation, Cambridge Research Lab, December 1991.]]></ref_text>
				<ref_id>23</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378522</ref_obj_id>
				<ref_obj_pid>378456</ref_obj_pid>
				<ref_seq_no>24</ref_seq_no>
				<ref_text><![CDATA[Terzopoulos, Demetri and Fleischer, Kurt. Modeling Inelastic Deformations: Visoelasticity, Plasticity, Fracture. Computer Graphics (SIGGRAPH'88), 22(4):269- 278, August 1988.]]></ref_text>
				<ref_id>24</ref_id>
			</ref>
			<ref>
				<ref_obj_id>37427</ref_obj_id>
				<ref_obj_pid>37402</ref_obj_pid>
				<ref_seq_no>25</ref_seq_no>
				<ref_text><![CDATA[Terzopoulos, Demetri, Platt, John, Barr, Alan, and Fleischer, Kurt. Elastically deformable models. Computer Graphics (SIGGRAPH'87), 21 (4):205-214, July 1987.]]></ref_text>
				<ref_id>25</ref_id>
			</ref>
			<ref>
				<ref_seq_no>26</ref_seq_no>
				<ref_text><![CDATA[Terzopoulos, Demetri, Platt, John, and Fleischer, Kurt. From Goop to Glop: Heating and Melting Deformable Models. In Proceedings Graphics Interface, pages 219- 226. Graphics Interface, June 1989.]]></ref_text>
				<ref_id>26</ref_id>
			</ref>
			<ref>
				<ref_seq_no>27</ref_seq_no>
				<ref_text><![CDATA[Terzopoulos, Demetri, Witkin, Andrew, and Kass, Michael. Symmetry-Seeking Models and 3D Object Reconstruction. International Journal of Computer Vision, 1(3):211-221, October 1987.]]></ref_text>
				<ref_id>27</ref_id>
			</ref>
			<ref>
				<ref_seq_no>28</ref_seq_no>
				<ref_text><![CDATA[Tonnesen, David. Ray-tracing implicit Surfaces Resulting from the Summation of Bounded Polynomial Functions. Technical Report TR-89003, Rensselaer Design Research Center, Rensselaer Polytechnic Institute, Troy, New York, 1989.]]></ref_text>
				<ref_id>28</ref_id>
			</ref>
			<ref>
				<ref_seq_no>29</ref_seq_no>
				<ref_text><![CDATA[Tonnesen, David. Modeling Liquids and Solids using Thermal Particles. In Graphics Interface '91, pages 255-262, 1991.]]></ref_text>
				<ref_id>29</ref_id>
			</ref>
			<ref>
				<ref_obj_id>15891</ref_obj_id>
				<ref_obj_pid>15886</ref_obj_pid>
				<ref_seq_no>30</ref_seq_no>
				<ref_text><![CDATA[Weil, Jerry. The Synthesis of Cloth Objects. Computer Graphics (SIGGRAPH'86), 20(4):49-54, August 1986.]]></ref_text>
				<ref_id>30</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 Surface Modeling with Oriented Particle Systems Richard Szeliskit and David Tonnesen$ tlligltal EquipmentCorp.,Cambridge 
Research Lab, One Kendall Square, Bldg. 700, Cambridge, MA 02139 lDept.of Computer Science, University 
of Toronto, Toronto, Canada M5S 1A4 Abstract abilities to join severrd surfaces together, to split surfaces 
Splines and deformable surface models are widely used in computer along arbitrary lines, or to extend 
existing surfaces, without graphics to describe free-form surfaces. These methods require specifying 
exact connectivity. For scientific visualization, manual preprocessing to discretize the surface into 
patches and to data interpretation, and robotics applications, we require a specify their connectivity. 
We present a new model of elastic sur-modeling system that can interpolate a set of scattered 3-D faces 
based on interacting particle systems, which, unlike previous data without knowing the topology of the 
surface. To con­ techniques, can be used to sptiL join, or extend surfaces without struct such a system, 
we will keep the ideas of deformation the need for manual intervention. The particles we use have long­ 
energies from elastic surface models, but use interacting par­ range attraction forces and short-range 
repulsion forces and follow ticles to build our surfaces. Newtonian dynamics, much tiie recent computational 
models of fluids and solids. To enable our particles to model surface elements Particle systems have 
been used in computer graphics instead of point masses or volume elements, we add an orientation by Reeves 
[16] and Sims [21] to model natural phenomena to each particle s state. We devise new interaction potentials 
for such as fire and waterfalls. In these models, particles move our oriented particles which favor locally 
planar or spherical ar­ under the influence of force fields and constraints but do rangements. We atso 
develop techniques for adding new particles not interact with each other. More recent particle systems 
automatically, which enables our surfaces to stretch and grow. We borrow ideas from molecular dynamics 
to model liquids and demonstrate the application of our new particle system to modefing solids [12, 26, 
29]. In these models, which have spherically surfaces in 3-D and the interpolation of 3-D point sets. 
symmetric potentiaf fields, particles arrange themselves into Keywords: Surface interpolation, particle 
systems, physically-volumes rather than surfaces. based modeling, oriented particles, self-organizing 
systems, sim- In this paper, we develop orienfedparlicles, which over­ ulation. come this natural tendency 
to form solids and prefer to form CR Categories and Subject Descriptors: 1.3.5 [Computer Graph­ surfaces 
instead. Each particle has a local coordinate frame ics]: Computational Geometry and Object Modeling 
 Curve, sur­jace, solid, and object represe~adons; 1.3.7 [Computer Graphics]: which is updated during 
the simulation [171. We de­Three-Dimensional Graphics and Realism Animation. sign new interaction potentials 
which favor locally planar or locally spherical arrangements of particles. These interac­1 Introduction 
tion potentials are used in conjunction with more traditional long-range attraction forces and short-range 
repulsion forces The modeling of free-form surfaces is one of thecentraf issues which control the average 
inter-particle spacing. of computer graphics. Spline models [3, 8] and deformable surface models [25] 
have been very successful in creating Our new surface model thus shares characteristics of and animating 
such surfaces. However, these methods ei-both deformable surface models and particle systems. Like ther 
require the discretization of the surface into patches (for traditional spline models, it can be used 
to model free-form spline surfaces) or the specification of local connectivity (for surfaces and to smoothly 
interpolate sparse data. Like in­spring-mass systems). These steps can involve a significant teracting 
particle models of solids and liquids, our surfaces amount of manual preprocessing before the surface 
model can be split, joined, or extended without the need for re­can be used. pararneterization or manual 
intervention. We can thus use For shape design and rapid prototyping applications, we our new technique 
as a tool for modeling a wider range of require a highly interactive system which does not force the 
surface shapes. designer to think about the underlying representation or be The remainder of the paper 
is organized as follows. limited by its choice [18]. For example, we require the basic In Section 2 we 
review traditional splines and deformable surface models, as well as particle systems and the poten- 
Permission [u copy without fee all or part nf this material is granted prnvided that the copies are not 
made or distributed for direct tial functions traditionally used in molecular dynamics. In commercial 
advantage. the ACM copyright nntice and the title of the Section 3 we present our new oriented particle 
model and publication and its date appear. and notice is given tha[ copying is by the new interaction 
potentials which favor locally planar and permission of the Asstxiatinn for Cnmputing Machinery. To copy 
otherwise, or tn republlsh, requires a fee and/or spxitic permission. locally spherical arrangements. 
Section 4 presents the dy ­ !(1199~ ACM-O-8979 1-479-I/92/007/0185 sol.50 SIGGRAPH 92 Chicago, July 
26-31, 1992 namics (equations of motion) associated with our interacting particle system and discusses 
numerical time integration and complexity issues. Section 5 discusses alternative rendering techniques 
for particles and surfaces. In Section 6 we present simple shaping operations for surfaces built out 
of pwticles. In Section 7 we show how to extend existing surfaces by adding new particles, and how to 
use this approach to auto­matically fit surfaces to 3-D point collections. In Section 8 we discuss applications 
of our system to geometric modeling.   2 Background Our new surface modeling technique is based on 
two pre­viously separate areas of computer graphics, namely de­formable surface models and particle systems. 
Below, we present a brief review of these two fields. 2.1 Deformable Surface Models Traditional spline 
techniques [3,8] model an object s surface as a collection of piecewise-polynomial patches, with appro­priate 
continuity constraints between the patches to achieve the desired degree of smoothness. Within a particular 
patch, the surface s shape can be expressed using a superposition of basis functions S(u], IQ)= ~ vil?i(ul, 
IQ) (1) i where S(U1, W) are the 3D coordinates of the surface as a function of the underlying parameters 
(u1, %), vi are the control vertices, and B~(U1,W) are the piecewise polynomial basis functions. The 
surface shape can then be adjusted by interactively positioning the control vertices or by directly manipulating 
points on the surface [2]. Elastically deformable surface models [25] also start with a parametric representation 
for the surface S(U1, w). To define the dynamics of the surface, Terzopoulos ef al. [25] use weighted 
combinations of different tensor (stretching and bending) measures to define a simplified deformation 
energy which controls the elastic restoring forces for the surface. Additional forces to model gravity, 
external spring constraints, viscous drag, and collisions with impenetrable objects can then be added. 
To simulate the deformable surface, these analytic equa­tions are discretized using either finite element 
or finite dif­ference methods. This results in a set of coupled differential equations governing the 
temporat evolution of the set of con­trol points. Physically-based surface models can be thought of as 
adding temporal dynamics and elastic forces to an oth­erwise inert spline model. They can also be thought 
of as a collection of point masses connected with a set of finite­length springs [26]. Physically-based 
surface models have been used to model a wide variety of materials, including cloth [30, 6], membranes 
[25], and paper [24]. Viscoelasticity, plasticity, and fracture have been incorporated to widen the range 
of modeled phenomena [24]. 186 T Figure 1: Lennard-Jones type function, ~(r) = B/r A/rm. The solid 
line shows the potentiaJ function ~(r), and the dashed line shows the force function ~(r) = $~(r). The 
main drawback of both splines and deformable sur­face models is that the rough shape of the object must 
be known or specified in advance [27]. For spline models, this means discretizing the surface into a 
collection of patches with appropriate continuity conditions, which is generally a difficult problem 
[1 1]. For deformable surface models, we can bypass the patch formation stage by specifying the lo­cation 
and interconnectivity of the point masses in the finite element approximation. In either case, defining 
the model topology in advance remains a tedious process. Furthermore, it severely limits the flexibility 
of a given surface model. 2.2 Particle Systems Particle systems consist of a large number of point masses 
(particles) moving under the influence of extemat forces such as gravity, vortex fields, and collisions 
with stationary obsta­cles. Each particle is represented by its position, velocity, acceleration, mass, 
and other attributes such as color. The ensemble of particles moves according to Newton s laws of motion. 
Particle systems built from non-interacting parti­cles have been used to realistically model a range 
of natural phenomena including fire [16] and waterfalls [21]. Interact­ing (oriented) particles have 
been used to simulate flocks of boids [17]. Ideas from molecular dynamics have been used to de­velop 
models of deformable materials using collections of interacting particles [26, 12, 29]. In these models, 
long­range attraction forces and short-range repulsion forces con­trol the dynamics of the system. Typically, 
these forces are derived from an intermolecular potential function such as the Lennard-Jones function 
4U shown in Figure 1. The force f;j attracting a molecule to its neighbor is computed from the derivative 
of the potential function fi~ = Vrk(llrijll)j (2) where r;j = Pj pi is the vwtor distance betwtxm molecules 
z and j (Figure 2). Physical systems whose dynamics are governed by po­tential functions and damping 
will evolve towards lower en­ergy states. When extemrd forces are insignificant, molecules t k (Pi, R) 
 Figure 2: Global and local coordinate frames. The global interparticle distance rij is computed from 
the global coor­dinates pi ttnd Pj of particles i ~d j. The lod distance dij is computed from rij and 
the rotation matrix I&#38;. will arrange themselves into closely packed structures to minimize their 
total energy. For circularly symmetric po­tential energy functions in 2-D, the molecules will arrange 
themselves into hexagonal orderings. In 3-D, the molecules will arrange themselves into hexagonally ordered 
2-D lay­ers, and therefore make good models of deformable solids [29]. When external forces become huger 
or internal particle forces smaller, the behavior resembles that of viscous fluids [26, 12]. More sophisticated 
models of molecular dynamics are used in simulations of physics and chemistry [10]; how­ever, these are 
designed for high accuracy and are usually too slow for animation or modeling applications.  3 Oriented 
Particles While particle systems are much more flexible than de­formable surface models in arranging 
themselves into ar­bitrary shapes and topologies, they do suffer from one major drawback: in the absence 
of external forces and constraints, 3-D particle systems prefer to arrange themselves into solids rather 
than surfaces. To overcome this limitation, we in­troduce a new distributed model of surface shape which 
we call orienled particles, in which each particle represents a small surface element (which we could 
call a surfel ). In addition to having a position, an oriented particle also has its own local coordinate 
frame, which adds three new degrees of freedom to each particle s state. To force oriented particles 
to group themselves into surface-like arrangements, we devise a collection of new potential functions. 
These potential functions can be derived from the deformation energies of local triangular patches us­ing 
finite element analysis [23]. Each oriented particle defines both a normal vector (z in Figure 2) and 
a local tangent plane to the surface (defined by the local z and y vectors). More formally, we write 
the state of each particle as (pi, I&#38;), where pi is the particle s position and Ri is a 3 x 3 rotation 
matrix which defines the orientation of its local coordinate frame (relative to the global frame (X, 
Y, Z)). The third column of R is the local normal Pi rij Pj Pi rij P] (a) co-planarity (b) co-normality 
 L-Yn; Pi rij Pj (c) co-circularity Figure 3: The three oriented particle interaction potentials. The 
open circles and thin arrows indicate a possible new position or orientation for the second particle 
which would lead to a null potential. valor 11~. For surfaces whose rest (minimum energy) configura­tions 
are flat planes, we would expect neighboring particles to lie in each other s tangent planes. We can 
express this co-planarity condition as h(ni, rij) = (ni -rij)2#(l/rij 11), (3) i.e., the energy is proportional 
to the dot product between the surface normal and the vector to the neighboring particle (13gure 3a). 
The weighting function t(r) is a monotone decreasing function used to limit the range of inter-particle 
interactions. The co-planarity condition does not control the twist in the surface between two particles. 
To limit this, we intro­duce a co-normality potential ~N(ni~nj~rij)= [Ini- j[lzt(lkijll), (4) which attempts 
to line up neighboring normals, much like interacting magnetic dipoles (Figure 3b), An alternative to 
surfaces which prefer zero curvature (local planarity) are surfaces which favor constant curvatures. 
This can be enforced with a co-circularity potential k(ni, %,rij) = ((ni + j) ij) +(llrijll) (5) which 
is zero when normals are antisymmetrical with respect to the vector joining two particles (Figure 3c). 
This is the natural configuration for surface normals on a sphere. The above potentials can also be written 
in term of a par­ticle s local coordinates, e.g., by replacing the interparticle distance rij by dij 
= Rt~lrij = R~l(Pj pi), (6) SIGGRAPH 92 Chicago, July 26-31, 1992 which gives the coordinates of particle 
j in particle i s locat coordinate frame. This not only simplifies certain potentiat equations such as 
(3), but also enables us to write use a weighting function #(dij ) which is not circularly symmetric, 
e.g., one which weights particles more if they are near a given particle s tangent plane. In practice, 
we use ( Zz+y= z= #(22, y,z) =Kexp  (7) 2a2 2~ ) with b< u. To control the bending and stiffness characteristics 
of our deformable surface, we use a weighted sum of potentiat energies E1j = ~U~U(Ilrajll) + ~p~p(ni, 
rij) (8) + ~N#N(na> nj, rij ) + W+c(ni,nj,rij). The first term controls the average inter-particle spacing, 
the next two terms control the surface s resistance to bending, and the last controls the surface s tendency 
towards uniform local curvature. The total internal energy of the system Etit is computed by summing 
the inter-particle energies Ekt = ~~Eij. ij  4 Particle Dynamics Having defined the internal energy 
associated with our sys­tem, we can derive its equations of motion. The variation of inter-particle potential 
with respect to the particle position and orientations gives rise to forces acting on the positions and 
torques acting on the orientations. The formulas for the inter-particle forces fij and torques Tij are 
given in Ap­pendix A. These forces and torques can be summed over all interacting particles to obtain 
f;= ~ fij + f~~~(pa) fiVij (9) j CJVi i= ~ Tij ~l~i) (lo) j EN; where Afl are the neighbors of i (Section 
4.2). Here, we have lumped all external forces such as gravity, user-defined control forces, and non-linear 
constraints into fe,l, and added velocity-dependent damping &#38;vi and ~l~i. Using these forces and 
torques, we can write the stan­dard Newtonian equations of motion at = fi/~ Ui = I,~17i ~=~~ %= ai ~=vi 
= Wij % where rni is the particle s mass, and Ii is its rotationat inertia (which for a circularly symmetric 
particle is diagonal). The equations for translational acceleration a, velocity v, and po­sition p are 
the same as those commonly used in physically­based modeling and particle systems. The equations for 
ro­tational acceleration a, velocity w, and orientation q are less commonly used. The rotational accelerations 
and velocities are vector quantities representing infinitesimal changes and can be added and scaled as 
regular vectors. The computation of the orientation (local coordinate frame) is more complex, and a variety 
of representations could be used. While we use the rotation matrix R to convert from local coordinates 
to global coordinates and vice versa, we use a unit quatemion q as the state to be updated. The unit 
quatemion = n sin(t?/2) q= (w,s) with ~ = cos(e/2) represents a rotation of 0 about the unit normal axis 
n. To update this quatemion, we simply forma new unit quatemion from the current angular velocity w and 
the time step At, and use quatemion multiplication [20], 4.1 Numerical Time Integration To simulate 
the dynamics of our particle system, we integrate the above system of differential equations through 
time. At each time step tj+l = tj + At we sum W of the forces act­ing on each particle i and integrate 
over the time interval. The forces include the inter-particle forces, collision forces, gravity, and 
damping forces. We use Euler s method [15] to advance the current velocity and position over the time 
step. More sophisticated numerical integration techniques such as Runge-Kutta [15] or semi-implicit methods 
[25] could also be used, and would result in better convergence and larger timesteps, at the expense 
of a more complicated implemen­tation. 4.2 Controlling Complexity The straightforward evaluation of 
(9) and (10) to compute the forces and torques at atl of the particles requires 0(iV2) computation. For 
large values of N, this can be prohibitively expensive. This computation has been shown to be reducible 
to O(N log N) time by hierarchical structuring of the data [1]. In our work, we use a k-d tree [19] to 
subdivide space sufficiently so that we can efficiently find all of a point s neighbors within some radius 
(e.g., 3 To,where Tois the nat­ural inter-particle spacing). To further reduce computation, we perform 
this operation only occasionally and cache the list of neighbors for intermediate time steps.  5 Rendering 
A variety of techniques have km developed for rendering particle systems, including light emitting points 
[16, 21] and iso-surfaces or blobbies [4, 28] for modeling volumes. For rendering oriented particles, 
simple icons such as axes (Fig­ure 4a) or flat discs (Figure 4b) can be used to indicate the location 
and orientation of each particle. A more realistic Figure 4: Rendering techniques for particle-based 
surfaces: triangulation. looking surface display requires the generation of a triangu­lation over our 
set of particles, which can then be displayed as a wireframe (Figure 4c) or shaded surface (Figure 4d). 
For shaded rendering, Gouraud, Phong, or flat shading can be applied to each triangle. For a smoother 
looking surface, a cubic patch can be interpolated at each triangle (since we know the normals at each 
comer). Because our particle system does not explicitly give us a triangulation of the surface, we have 
developed an algorithm for computing it. A commonly used technique for triangu­lating a surface in 2-D 
or a volume in 3-D is the Delaunay triangulation [5]. In 2-D, a triangle is part of the Delaunay triangulation 
if no other vertices are within the circle circum­scribing the triarrglc. To extend this idea to 3-D, 
we check the smallest sphere circumscribing each triangle. This heuristic works well in practice when 
the surface is sufficiently sam­pled with respect to the curvature. The results of using our triangulation 
algorithm arc shown in Figures 4C and 4d. 6 Basic modeling operations This section describes some basic 
operations for interactively creating, editing, and shaping particle-based surfaces. The most basic operations 
are adding, moving, and deleting single particles. We can forma simple surface patch by creating a number 
of particles in a plane and allowing the system dynamics to adjust the particles into a smooth surface. 
We can enlarge the surface by adding more particles (either inside or at the edges), shape the surface 
by moving particles around or changing their orientation, or trim the surface by deleting particles. 
All particle editing uses direct manipula­tion. Currently, we use a 2-D locator (mouse) to perform 3-D 
locating and manipulation, inferring the missing depth coor­dinate when necessary from the depths of 
nearby particles. Adding 3-D input devices for direct 3-D manipulation [18] would bc of obvious benefit. 
In addition to particle-based surfaces, our modeling sys­tem also contains user-definable solid objects 
such as planes, spheres, cylinders, and arbitrary polyhedra. These objects are used to shape particle-based 
surfaces, by acting as solid tools [14], as attracting surfaces, as movers which grab all of the particles 
inside them, or as large erasers. These geomet­(a) axes, (b) discs, (c) wireframe triangulation (d) flat-shaded 
 ric objects are positioned and oriented using the same direct manipulation techniques as are used with 
particles. Another possibility for direct particle or surface manipulation would be extended free-form 
deformations [7]. Using these tools, particle-based surfaces can be cold welded together by abutting 
their edges (Figure 5). Inter­particle forces pull the surfaces together and readjust the particle locations 
to obtain a seamless surface with uniform sampling density. We can cut a surface into two by separat­ing 
it with a knife-like constraint surface (Figure 6). Here, we use the heat of the cutting tool to weaken 
the inter-particle bonds [29]. Or we can crease a surface by designating a line of particles to be unorien[ed, 
thereby locally disabling surface smoothness forces (co-phmarit y, etc.) without re­moving inter-particle 
spacing interactions (Figure 7).  7 Particle creation and 3-D interpolation Our particle-based modeling 
system can be used to shape a wide variety of surfaces by interactively creating and manip­ulating particles. 
This modeling system becomes even more flexible and powerful if surface extension occurs automati­cally 
or semi-automatically. For example, we would like to stretch a surface and have new particles appear 
in the elon­gated region, or to till small gaps in the surface, or extend the surface at its edges. Another 
useful capability would be a system which can fit a surface to an arbitrary collection of 3-D points. 
Below, we describe how our system can be extended to generate such behaviors. The basic components of 
our particle-based surface ex­tension algorithm are two heuristic rules controlling the ad­dition of 
new particles. These rules are based on the assump­tion that the particles on the surface are in a near-equilibrium 
configuration with respect to the flatness, bending, and inter­particle spacing potentials. The first 
(stretching) rule checks to see if two neighbor­ing particles have a large enough opening between them 
to add anew particle. If lwo particles are separated by a distance d such that +~ ~ d g &#38;,X, we create 
a candidate particle at the midpoint and check if there are no other particles within l/zo&#38;~. Vpically 
Lm = 2.0 TO and A.. x 2.5 TO, where SIGGRAPH 92 Chicago, July 26-31, 1992 Figure 5: Welding two surfaces 
together. The two surfaces are brought together through interactive user manipulation, and join to become 
one seamless surface. Figure 6: Cutting a surface into two. The movement of the knife edge pushes the 
particles in the two surfaces apart. -- L : . Figure 7: Putting a crease into a surface. The center 
row of particles is turned into unoriented particles which ignore smoothness forces. Figure 8: Particle 
creation during stretching. As the ball pushes up through the sheet, new particles are created in the 
gaps between pairs of particles. r. is the natural inter-particle spacing. An exampleof this stretchingrule 
in action is shown in Figure 8, where a ball pushing against a sheet stretches it to the point where 
new particles are added. The second (growing) rule allows particles to be added in all directions with 
respect to a particle s local z-y plane. The rule is generalized to allow a minimum and maximum number 
of neighbors and to limit growth in regions of few neighboring particles, such as at the edge of a surface. 
The rule counts the number of immediate neighbors n~ to see if it falls within a valid range ~~ ~ rtN 
< ~~X, It also computes the angles between successive neighbors AO~ = ~i+l Oa using the particle s locat 
coordinate frame, and checks if these fall within a suitable range 6~ti ~ A6a s &#38;,X. If these conditions 
are met, one or more particles are created in the gap. In generat, a sheet at equilibrium will have interior 
particles with six neighbors spaced 60° apart while edge particles will have four neighbors with one 
pair of neighbors 180° apart. With these two rules, we can automatically build a sur­face from collections 
of 3-D points. We create particles at each sample location and fix their positions and orientations. 
We then start filling in gaps by growing particles away from isolated points and edges, After a rough 
surface approxima­tion is complete we can release the originat sampled particles to smooth the final 
surface thereby eliminating excessive noise. If the set of data points is reasonably distributed, this 
approach will result in a smooth continuous closed surface (Figure 9). The fitted surface is not limited 
to a particular topology, unlike previous 3-D surface fitting models such as [25, 13]. We can also fit 
surfaces to data that does not originate from closed surfaces, such as stereo range data [9, 22]. Sim­ply 
growing particles away from the sample points poses several problems. For example, if we allow growth 
in all directions, the surface may grow indefinitely at the edges, whereas if we limit the growth at 
edges, we may not be able to fill in certain gaps. Instead, we apply the stretching heuris­tic to effectively 
interpolate the surface between the sample points (Figure 10). When the surface being reconstructed has 
holes or gaps, we can control the size of gaps that are filled in by limiting the search range. This 
is evident in Figure 10, where the cheek and neck regions have few samples and were therefore not reconstructed. 
We could have easily filled in these regions by using a larger search range. Geometric Modeling Applications 
The particle-based surface models we have presented can be used in a wide range of geometric modeling 
and animation applications. These include applications which have been previously demonstrated with physically-based 
deformable surface models, such as cloth draping [30, 25, 6], plastic surface deformations [24], and 
tearing [24]. Using our surface model as an interactive design tool we can spray collections of points 
into space to form elastic Computer Graphics, 26, 2, .IuIY1992 sheets, shape them under interactive user 
control, and then freeze them into the desired final configuration. We can cre­ate any desired topology 
with this technique. For example, we can form a flat sheet into an object with a stem and then a handle 
(Figure 11). Forming such surface with traditional spline patches is a difficult problem that requires 
careful at­tention to patch continuities [11]. To make this example work, we add the concept of heating 
the surface near the tool [29] and only allowing the hot parts of the surface to deform and stretch. 
Without this modification, the extruded part of the surface has a tendency to pinch off similar to how 
soap bubbles pinch before breaking away. As another example, we can start with a sphere, and by pushing 
in the two ends, form it into a torus (Fig 12). New particles are created inside the torus due to stretching 
during the formation process, and some old sphere particles are deleted when trapped between the two 
shaping tools. Another interesting application of our oriented particle systems is the interpolation 
and extrapolation of sparse 3-D data. This is a difficult problem when the topology or rough shape of 
the surface to be fitted is unknown. As described in the previous section, oriented particles provide 
a solution by extending the surface out from known data points. We believe that these techniques will 
be particularly useful in machine vision applications where it can be used to interpolate sparse position 
measurements available from stereo or tactile sensing [22], 9 Discussion The particle-based surface model 
we have developed has a number of advantages over traditional spline-based and physically-based surface 
models. Particle-based surfaces are easy to shape, extend, join, and separate. By adjusting the relative 
strengths of various potential functions, the surface s resistance to stretching, bending, or variation 
in curvature can atl be controlled. The topology of particle-based surfaces can easily be modified, as 
can the sampling density, and surfaces can be fitted to arbitrary collections of 3-D data points. One 
limitation of particle-based surfaces is that it is harder to achieve exact anatytic (mathematical) control 
over the shape of the surface. For example, the torus shaped from a sphere is not circularly symmetric, 
due to the discretization effects of the relatively small number of particles. This be­haviorcould be 
remedied by adding additional constraints in the form of extra potentials, e.g., a circular symmetry 
poten­tial for the torus. Particle-based surfaces also require more computation to simulate their dynamics 
than spline-based surfaces; the latter may therefore be more appropriate when shape flexibility is not 
paramount. One could easily envision a hybrid system where spline or other parametric surfaces co-exist 
with particle-based sur­faces, using each system s relative advantages where appro­priate. For example, 
particle-based surface patches could be added to a constructive solid geometry (CSG) modeling system 
to perform fileting at part junctions. SIGGRAPH 92 Chicago, July 26-31, 1992 Figure 9: Surface interpolation 
through a collection of 3-D points. The surface extends outward from the seed points until it fills in 
the gaps and forms a complete surface. Figure 10: Interpolation of an open surface through a collection 
of 3-D points. Particles are added between control points until all gaps less than a specified size are 
filled in. Increasing the range would allow the suarse areas of the cheek and neck to filled L Figure 
11: Forming a complex object. The initial surface is deformed upwards and then looped around. The new 
topology (a handle) is created automatically. Figure 12: Deformation from sphere to torus using two spherical 
shaping tools. The final view is from the side, showing the toroidal shape. In future work, we plan to 
apply particle-based surfaces to iso-surfaces in volumetric data sets. When combined with the stretching 
heuristic for particle creation and an inflation force, this model would behave in a manner similar to 
the geometrically deformed models (GDM) of [13]. We could extend this idea by tracking a volumetric data 
set through time by deforming the particle surface from one frame to the next. In another application, 
we could distribute the particles over the surface of a CAD model and allow the particles to change position 
and orientation while remaining on the sur­face of the model, thereby creating a uniform triangulation 
of the surface. Figure 10 shows how this can be achieved, even without the presence of the CAD model 
surface to attract the particles. A curvature-dependent adaptive meshing of the surface could also be 
obtained by locally adjusting the pre­ferred inter-particle spacing. This would be very useful for efficiently 
rendering parametric surfaces such as NURBS. 10 Conclusion In this paper, we have developed a particle-based 
model of deformable surfaces. Our new model, which is based on oriented particles with new interaction 
potentials, has char­acteristics of both physically-based surface models and of particle systems. It 
can be used to model smooth, elastic, moldable surfaces, like traditional splines, and it allows for 
arbitrary interactions and topologies, like particle systems. A potential drawback of our technique is 
the lack of precise control over the mathematical form of the surface, which may be important in engineering 
applications. Like previous deformable surface models, our new particle-based surfaces can simulate cloth, 
elastic and plastic films, and other deformable surfaces. The ability to grow new particles gives these 
model more fluid-like properties which extend the range of interactions. For example, the surfaces can 
be joined and cut at arbitrary locations. These charac­teristics make particle-based surfaces a powerful 
new tool for the interactive construction and modeling of free-form surfaces. Oriented particles can 
also be used to automatically fit a surface to sparse 3-D data even when the topology of the surface 
is unknown. Both open and closed surfaces can be re­constructed, either with or without holes. The reconstructed 
model can be used as the starting point to interactively create anew shape and then animated within a 
virtual environment. Thus oriented particle systems providea convenient interface between surface reconstruction 
in computer vision, freeform modeling in computer graphics, and animation. References [1] Appel, Andrew. 
An Efficient Algorithm for Many-body Simulations. SIAM J. Sci. Stat. Comput., 6(l), 1985. [2] Bartels, 
Richard. H. and Beatty, John. C. A Technique for the Direct Manipulation of SplineCurves. In Graph­ics 
Interface 89, pages 33 39, June 1989. [3] Bartels, Richard. H., Beatty, John. C., and Barsky, Brian. 
A. An introduction 10Splinesfor use in Computer Graphics and Geometric Modeling. Morgan Kauf­mann Publishers, 
Los Altos, California, 1987. [4] Blinn, James F. A Generalization of Algebraic Surface Drawing. ACM Transactions 
on Graphics, 1(3):235­256, July 1982. [5] Boissonat, J.-D, Representing 2D and 3D Shapes with the Ddaunay 
Triangulation. In Seventh International Conference on Pauern Recognition (ICPR 84), pages 745 748, Montreal, 
Canada, July 1984. [6] Breen, David E., House, Donald H., and Getto, Phillip H. A Particle-Based Computational 
Model of Cloth Draping Behavior. In Patrikalakis, N. M., editor, Scientijlc Visualization of Physical 
Phenomena, pages 113 1 34. Springer-Verlag, New York, 1991. [7] Coquillart, Sabine. Extended Free-Form 
Deformations: A Sculpturing Tool for 3D Geometric Modeling. Com­puter Graphics (SIGGRAPH 90), 24(4):187-196, 
Au­gust 1990. [8] Farin, Gerald. E. Curves and Surfaces for Computer Aided Geometric Design: A Practical 
Guide. Academic Press, Boston, Massachusetts, 2nd edition, 1990. [9] Fua, Pascat and Sander, Peter. Reconstructing 
Sur­faces from Unstructured 3D Points. In Second Euro­pean Conference on Computer Vision (ECCV 92), Sta. 
Margherita, Italy, May 1992. Springer-Verlag. [10] Hockney, Roger W. and Eastwood, James W. Computer 
Simulation using Particles. McGraw-Hill Inc., New York, 1988. [11] Loop, Charles and DeRose, Tony. Generalized 
B-spline Surfaces of Arbitrary Topology. Computer Graphics (S[GGRAPH 90), 24(4):347-356, August 1990. 
[12] Miller, Gavin and Pearce, Andrew. Globular Dynamics: A Conntxted Particle System for Animating Vkcous 
Fluids. In SIGGRAPH 89, Course 30 noles: Topics in Physically-based Modeling, pages R 1-R23. SIG-GRAPH, 
August 1989. Boston, Massachusetts. [13] Miller, James V., Brcxm, David E., Lorensen, William E., O Bara, 
Robert M., and Wozny, Michael J. Geometrically Deformed Models: A Method of Ex­tracting Closed Geometric 
Models from Volume Data. Computer Graphics (SIGGRAPH91), 25(4):217-226, July 1991. [14] Platt, John 
C. and Barr, Alan H. Constraint Meth­ods for Flexible Models. Computer Graphics (SIG-GRAPH 88), 22(4):279-288, 
August 1988. [15] Press, William H., Flannery, Brian P., Teukolsky, Saul A., and Vetteding, William T. 
Numerical Recipes in C: The Art of Scientific Compuling. Cambridge Uni­versity Press, Cambridge, England, 
1988. I93 SIGGRAPH 92 Chicago, July 26-31, 1992 [16] Reeves, William. T. Particle Systems A Technique 
for Modeling a Class of Fuzzy Objects. ACM Transactions of Graphics, 2(2):9 1 108, April 1983. [17] Reynolds, 
Craig. W. Ftocks, Herds, and Schools: A Distributed Behavioral Model. Compuler Graphics (SIGGRAPH87), 
21(4):25-34, hlly 1987. [18] Sachs, Emanuel, Roberts, Andrew, and Stoops, David. 3-Draw: A Tool for Designing 
3D Shapes. IEEE Com­puter Graphics &#38; Applications, 11(6): 18 26, Novem­ber 1991. [19] Samet, Hanan. 
The Design andAnalysis of SpalialData Structures. Addison-Wesley, Reading, Massachusetts, 1989. [20] 
Shoemake, Ken. Animating Rotation with Quater­nion Curves. Computer Graphics (SIGGRAPH85), 19(3):245-2540, 
July 1985. [21] Sims, Karl. Particle Animation and Rendering Using Data Parallel Computation. Computer 
Graphics (SIG-GRAPH90), 24(4):405+13, August 1990. [22] Szeliski, Richard. Shape from Rotation. In IEEE 
Com­puter Society Conference on Computer Vision and Pat­tern Recognition (CVPR 91), pages 625-630, Maui, 
Hawaii, June 1991. IEEE Computer Society Press. [23] Szeliski, Richmd and Tonnesen, David. Surface Mod­eling 
with Oriented Particle Systems. Technical Report 91/14, Digitat Equipment Corporation, Cambridge Re­search 
Lab, December 1991. [24] Terzopoulos, Demetri and Fleischer, Kurt. Modeling Inelastic Deformations: Visoelasticity, 
Plasticity, Frac­ture. Computer Graphics (SIGGRAPH 88), 22(4):269 278, August 1988. [25] Terzopmdos, 
Demetri, Platt, John, Barr, Alan, and Fleischer, Kurt. Elastically deformable models. Com­puter Graphics 
(S1GGRAPH87), 21(4):205-214, July 1987. [26] Terzopoulos, Demetri, Platt, John, and Fleischer, Kurt. 
From Goop to Glop: Heating and Melting Deformable Models. In Proceedings Graphics Inte~ace, pages 219­ 
226. Graphics Interface, June 1989. [27] Terzopoulos, Demetri, Witkin, Andrew, and Kass, Michael. Symmetry-S&#38;king 
Models and 3D Object Reconstruction. International Journal of Computer Vi­sion, 1(3):21 l 221,0ctober 
1987. [28] Tonnesen, David. Ray-tracing Implicit Surfaces Re­sulting from the Summation of Bounded Polynomial 
Functions. Technical Report TR-89003, Rensselaer De­sign Research Center, Rensselaer Polytechnic Institute, 
Troy, New York, 1989. [29] Tonnesen, David. Modeling Liquids and Solids using Thermal Particles. In Graphics 
[nterface 91, pages 255-262, 1991. [30] Weil, Jerry. The Synthesis of Cloth Objects. Computer Graphics 
(SIGGRAPH 86), 20(4):49 54, August 1986.  A Computation of internal forces To compute the internal inter-particle 
forces and torques, we compute the variation of inter-particle potentials with respect to particle positions 
and orientations. We can compute these forces and torques using the equations f = VP~ and Vp(p. v)=v 
r= VW~ and Vw(n. v)=nxv where u is the incremental change in orientation R, i.e., lianxw. Applying these 
equations to the four internal potentials, we obtain f~(r~j) n fiij &#38;(llrijll) fp(I ii, r;j) = lli(ni 
rij)+(llrijll) -~ij(rli . rij)2 %$ (llrijll) ~P(ni, rij) = rij x ni(ni rij)~(llrijll) = rij xfp fN(Ilijlljjrij) 
= fiijllni -njllz%$ (llrijll) N(ni~nj, rij) = i x j ~(llrij[l) fi(nilnj>rij) = ni((ni + nj) rij)d(llrijll) 
Fij((lli + nj) .rij)z@ (llrijll) ~c(nitnj, rij) = rij X fc  where tij is the unit vtxtor along rij. 
These forces have the following simple physical interpretations. The co-planarity potential gives rise 
to a force parallel to the particle normat and proportional to the distance between the neighboring particle 
and the local tangent plane. The second term in the force, which can often be ignored, arises from the 
gradient of the spatial weighting function. The cross product of this force with the inter-particle vector 
produces a torque on the particle. The co-normality potential produces a torque proportional to the cross-product 
of the two particle normrds, which acts to Iign up the normals. The co-circularity force is similar to 
the co-planarity force, except that the local tangent plane is defined from the average of the two normal 
vectors. To compute the total inter-particle force and torque from atl three potentials, we use the formulas 
fa = ~ 2~~f~(rij) + ~p(fp(ni, rij) fp(nj, rji)) j~tii + 2~NfP(Ili, Ilj, rij) + 2~cf&#38;(ni, nj} rij) 
i= ~ adni,rij) jEN; + 2~N~p(ni, nj, rij )+ 2W~c(ni, nj, rij) I94  
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134039</article_id>
		<sort_key>195</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>22</seq_no>
		<title><![CDATA[High resolution virtual reality]]></title>
		<page_from>195</page_from>
		<page_to>202</page_to>
		<doi_number>10.1145/133994.134039</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134039</url>
		<keywords>
			<kw><![CDATA[head-tracking]]></kw>
			<kw><![CDATA[stereoscopic display]]></kw>
			<kw><![CDATA[virtual reality]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.3</cat_node>
				<descriptor>Display algorithms</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>I.3.3</cat_node>
				<descriptor>Viewing algorithms</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Virtual reality</descriptor>
				<type>S</type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010147.10010371.10010387.10010866</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Graphics systems and interfaces->Virtual reality</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010382</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Image manipulation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010372</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Rendering</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010372</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Rendering</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010382</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Image manipulation</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
			<gt>Experimentation</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>P196764</person_id>
				<author_profile_id><![CDATA[81100240083]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Michael]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Deering]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Sun Microsystems Computer Corporation, 2550 Garcia Avenue, MountainView, CA]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Benton, Stephen. Survey of Holographic Stereograms. Processing and Display of Three-Dimensional Data. In Proceedings o.{the SPIE 367 (1982), 15-19.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Diamond, R., A. Wynn, K. Thomsen, and J. Turner. Three dimensional perception for one-eyed guys, or the use of dynamic parallax. In Computational CI3'stallography, 286-293, ed. David Sayre, Clarendon Press, Oxford, 1982.]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Fisher, Scott. Viewpoint dependent imaging: an interactive stereoscopic display. Processing and Display of Three-Dimensional Data. In Pr~'eedings o/'the SPIE 367 (1982), 41- 45.]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_obj_id>83821</ref_obj_id>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[Foley, James, Andries van Dam, Steven Feiner, and John Hughes. Computer Graphics: Principles and Practice, 2nd ed., Addison-Wesley, 1990.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_obj_id>147164</ref_obj_id>
				<ref_obj_pid>147156</ref_obj_pid>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[Friedmann, Martin, Tad Starner, and Alex Pentland. Device Synchronization Using an Optimal Linear Filter. In Proceedings of the ACM Symposium on lnterac'tive 3D Graphics (Cambridge, Massachusetts, March 29- April 1. 1992), 57-62.]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_obj_id>617719</ref_obj_id>
				<ref_obj_pid>616021</ref_obj_pid>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[Haines, Kenneth, and Debby Haines. Computer Graphics for Holography. in IEEE Computer Graphics and Applications 12, 1 (January 1992), 37-46.]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Hibbard, Erie et al. On the Theory and Application of Stereographics in Scientific Visualization. EUROGRAPHICS '91 (Vienna, Austria, September 2-6, 1991 ). In Eurographi~s "91: State of the Art Reports (1991), 1-21.]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[Hodges, Larry. Basic Principles of stereographic Software Development. Stereoscopic Displays and Applications. In Proceedings of the SPIE 1457 ( 1991 ), 9-17.]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Kubitz, W. and W. Poppelbaum. Stereomatrix Interactive Three-Dimensional Computer Display. in Proceedings of the SID 14, 3 (Third Quarter 1973) 94-98.]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_obj_id>120784</ref_obj_id>
				<ref_obj_pid>120782</ref_obj_pid>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[Liang, Jiandong, Chris Shaw, and Mark Green. On Temporal-Spatial Realism in the Virtual Reality Environment. in Proceedings of the ACM Symposium on User lntelfa~'e Software and Techm~logy (Hilton Head, South Carolina, November 11-13, 1991 ), 19-25.]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
			<ref>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[Lipton, Lenny. Temporal Artifacts in Field-Sequential Stereoscopic Displays. Proceedings of SID '91 (Anaheim, California, May 6-10, 1991 ). In Proceedings q{the SID 22 (May 1991), 834-835.]]></ref_text>
				<ref_id>11</ref_id>
			</ref>
			<ref>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[Lipton, Lenny. The CrvstalEves Handbook. StereoGraphics Corporation, 199 I.]]></ref_text>
				<ref_id>12</ref_id>
			</ref>
			<ref>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[Ogle, Kenneth. Opri~'s. Charles C. Thomas, Publisher, Springfield, illinois, 1968.]]></ref_text>
				<ref_id>13</ref_id>
			</ref>
			<ref>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[Paley, W. Bradford. Head-Tracking Stereo Display: Experiments and Applications. Stereoscopic Displays and Applications III (San Jose, California, February 12-13, 1992.). In Proceedings of the SPIE 1669, 1992.]]></ref_text>
				<ref_id>14</ref_id>
			</ref>
			<ref>
				<ref_obj_id>128951</ref_obj_id>
				<ref_obj_pid>128947</ref_obj_pid>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[Robinett, Warren, and Jannick Rolland. A Computational Model for the Stereoscopic Optics of a Head-Mounted Display. In Presem'e 1. 1 (Winter 1992), 45-62.]]></ref_text>
				<ref_id>15</ref_id>
			</ref>
			<ref>
				<ref_obj_id>807423</ref_obj_id>
				<ref_obj_pid>800249</ref_obj_pid>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[Roese, John, and Lawrence McCleary. Stereoscopic Computer Graphics for Simulation and Modeling. Proceedings of SIGGRAPH '79 (Chicago, Illinois, August 8-10. 1979). In Computer Graphics 13, 2 (August 1979), 41-47.]]></ref_text>
				<ref_id>16</ref_id>
			</ref>
			<ref>
				<ref_obj_id>801156</ref_obj_id>
				<ref_obj_pid>800059</ref_obj_pid>
				<ref_seq_no>17</ref_seq_no>
				<ref_text><![CDATA[Schmandt, Christopher. Spatial Input/Display Correspondence in a Stereoscopic Computer Graphic Work Station. Proceedings of SIGGRAPH '83 (Detroit, Michigan, July 25-29, 1983). In Computer Graphi~'s 17.3 (July 1983). 253-261.]]></ref_text>
				<ref_id>17</ref_id>
			</ref>
			<ref>
				<ref_seq_no>18</ref_seq_no>
				<ref_text><![CDATA[Sutherland, Ivan. The Ultimate Display. In Prmeedings q{ the IFIPS Conference 2 (1965), 5(}6-508.]]></ref_text>
				<ref_id>18</ref_id>
			</ref>
			<ref>
				<ref_seq_no>19</ref_seq_no>
				<ref_text><![CDATA[Sutherland, Ivan. A Head Mounted Three Dimensional Display. In Fall Joint Computer Conferem e, AFIPS Conference Proceedings 33 (1968), 757-764.]]></ref_text>
				<ref_id>19</ref_id>
			</ref>
			<ref>
				<ref_seq_no>20</ref_seq_no>
				<ref_text><![CDATA[Tyler, William. Induced Stereomovement. Vision Res 14 (1974), 609-613.]]></ref_text>
				<ref_id>20</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 Comwter GraDhiea, 26, 2, Julv 1992 High Resolution Virtual Reality A4ichael Deering Sun Microsystems 
Computer Corporation ABSTRACT An important component of many virtual reality systems is head-tracked 
stereo display. The head-tracker enables the im­age rendering system to produce images from a viewpoint 
lo­cation that dynamically tracks the viewers head movement, creating a convincing 3D illusion. A viewer 
can achieve intri­cate hand/eye coordination on virtual objects if virtual and physical objects can be 
registered [o within a fraction of a centimeter. Computer graphics has traditionally been con­cerned 
with forming the correct image on a screen. When this goal is expanded to forming the correct pair of 
images on the viewers retinas, a number of additional physical factors must be taken into account. This 
paper presents the general steps that must be taken to achieve accurate high resolution head­tracked 
stereo display on a workstation CRT: the need for predictive head-tracking, the dynamic optical location 
of the viewers eyepoints, physically accurate stereo perspective viewing matrices, and corrections for 
refractive and curvature distortions of glass CRTs. Employing these steps, a system is described that 
achieves sub-centimeter virtual to physical registration. CR Categories and Subject Descriptors: 1.3.3 
[Computer Graph­ics]: Picture/fmage Generation -Disp/ay algorithms; 1.3.7 [Com­puter Graphics]: Three 
Dimensional Graphics and Realism. Additional Keywords and Phrases: Stereoscopic Display, Virtual Reality, 
Head-Tracking. 1 INTRODUCTION Computer graphics traditionally deals with the formation of an im­age on 
a screen in a manner visually faithful to the formation of an image by a camera. However, the human visual 
system evolved not for viewing photographs, but for close range binocular (stereo) 2551)A,enueGaKKi MountainV,w, 
CA940.L.1I(Ml michaeldeenn@En@m COM Permissionto copywithoutfeeall or part of this materialis granted 
provided[hatthecopiesarc not madeor distributedfor direct commercial advantage, the ACM copyrightnoticeandthe 
title of the publicationanditsdateappear,andnoticeis giventhatcopyingisby permissionof the Associationfor 
Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific permission. viewing 
of 3D objects, with unrestricted head motion. Holograms and holographic stereograms support this, provi~ing 
proper per­spective and motion parallax effects [I ][6]. Unfortunately, technol­ogy does not yet allow 
these forms of display to be created in real­time. An alternate technique for emulating close range examination 
of a physical object by a user is employed by marry virtual reality systems. If a 3D stereo image display 
system is augmented by a head-tracking device, the synthetic viewpoint of the rendering pro­cess can 
be made to correspond to the actual dynamic physical viewpoint of the user [ 18][ 19][9][2][3][ 14]. 
In principle, such a sys­tem dynamically computes a stereo pair of images that has the same appearance 
as a hologram: the virtual object appears to remain sta­tionary when the viewer tilts his head, or moves 
his head look around its side or over its top. Making a head-tracked stereo display system work in practice 
in­volves achieving an accurate mapping of the mathematical viewing pyramid onto the real world of physical 
CRTs and biological heads and eyeballs. But how accurate must this mapping be? In the case of the head 
mounted displays that are used in today s virtual reality systems whose image resolution is typically 
below the threshold of legal blindness the mathematical-to-physical mapping can be quite loose. But 
many potential applications of virtual reality will require highly accuracy co-siting of physical and 
virtual objects. For example, for a surgeon viewing 3D CAT scan data overlaid on a patient during surgery, 
the positions of the virtual and real objects must coincide within a fraction of an inch. In electronics 
and me­chanical repair it might be desirable to overlay diagnostic and sche­matic information directly 
on physical components having dimen­sions of the order of fractions of an inch. With accurate physical/ 
virtual correspondent, direct interactive sculpting of objects is pos­sible using tools such as the virtual 
lathe shown in Figures I and 7. This paper describes the general steps required for head-tracked ste­reo 
display on a workstation stereo CRT, and the corrections neces­sary to achieve accurate visual correspondent 
of physical and virtu­al objects. The system used for these investigations comprises a graphics workstation 
augmented by a stereo CRT, stereo shuttered glasses, a 3D 6-axis head-tracker and a 3D 6-axis mouse. 
The sys­tem is pictured in Figure 1.  2 STEREO VIEWING MODELS A stereo 3D display pipeline is specified 
by two 4x4 perspective viewing matrices (effectively, one monocular pipeline for each eye). These matrices 
implicitly contain information about the over­all physical configuration of the viewing. Previous work 
in stereo computer graphics concentrated on the gen­eration of a stereo pairs for viewing in environments 
where the viewers position was not well controlled [ 16][ 17][7][8]. For view­ 01992 ACM-O-8979 1-479-1/92/007/0195 
$01.50 I95   izontal. [f a viewer observes the display with his eyes oriented ver­tically, than the 
parallax at the screen will be completely vertical. The amount of parallax at the screen is not constant 
even for a given head distance and object location: a viewer with his head turned 3(Y to one side of 
the screen has parallax at the screen surface that is less than when he squarely faces the screen. If 
two fixed eye positions are substituted into the equation above, than the equation of [7] results. Both 
[7] and [ 12] start with a com­patible model, but introduce modifications that directly control the maximum 
amount of parallax in the image to lessen viewer discom­fort. A number of techniques can satisfy the 
important application goal of ensuring that a user can comfortably converge the stereo pair. Accomplishing 
this objective by deforming the matrix P will cause the viewing matrices to diverge from the real physical 
projec­tion, and preclude our physical and virtual object correlation goal. Our approach was to get the 
projection geometry completely cor­rect for arbitrary viewer head position, and deal with convergence 
as a separably issue, and is discussed in section 10. 3 EYEPOINT In traditional computer graphics, 
the viewing projection point is re­ferred to as the eyepoint or viewpoint and is intended to corre­spond 
to the viewers eye. However. for the purpose of accurate dis­play, this location must be identified much 
more precisely physio­logically. 1 t Nodal Point ___ Iris I n&#38;-rn h\ I Figure 3: The human eye and 
its first nodal point. Optically, in general the viewpoint of a lens system is the first nodal point. 
As seen in Figure 3, the human eye can be modeled as a compound lens system with two lenses. The first 
nodal point of this system lies inside the second lens, approximately 0.6 cm from the center of the eye, 
For a discussion of nodal points and human eye models, see [13], chapter 9. Bespectacled viewers such 
as the author may require a more complex model. Because the real eyepoint does not lie at the center 
of rotation of the eye, the exact location of the eyepoint changes slightly depend­ing on the direction 
of the viewers gaze. As the eye can readily ro­tate *45 or more from center during normal viewing, this 
repre­sents a potential displacement of eyepoint location of about M).4 cm. In stereo viewing the gaze 
direction is eye specific: the closer the object the larger the angle between gaze directions (the Computer 
Graphics, 26,2, July 1992 ang/e of con},ergence). Error in the distance between the two eye­points is 
more critical than in the absolute eye point locations: the former incudes perceived depth errors. This 
error is potentially most damaging at vary close distances: in applications having min­imum object distances 
greater than several feet, the eyepoint loca­tions can be assumed to be fixed relative to the head (as 
was as­sumed in [19]). Near-perfect compensation for eyepoint location could be achieved by using eye-tracking 
hardware to acquire information about the di­rection of gaze of each of the viewers eyes, in addition 
to his head position and orientation. This is a promising long term solution. since gaze direction information 
can be exploited for other purposes such as identifying the region of screen space corresponding to 
the fovial portion of the retina that deserves to be rendered with high spatial detail. In the absence 
of directly-acquired gaze direction information, er­rors due to uncertainty in eye nodal point location 
can be minimized by guessing the likely direction of gaze. The obvious guess is the center of the stereo 
window. When a 3D mouse is in use, a better guess is that the viewers gaze is in the direction of its 
hot spot , as it is likely that the tightest accuracy requirement reflects touching the mouse to a virtual 
object. At the mouse tip, this assumption per­fectly compensates for errors due to rotation of the eyes. 
 4 HEAD TRACKING Many different technologies have been employed to acquire dy­namic viewer head position 
and orientation information. At present no single technology is superior for all applications. Devices 
based on magnetic fields tend to have problems with lag and spatial non-Iinearities. Devices based on 
ultrasound have line of sight limita­tions and limited orientational accuracy. The prototype system de­scribed 
in this paper employed an ultrasonic tracking device. None of the mathematics of this paper depend on 
the tracking technology used. Head-tracking location and orientation data is used to derive the ro­tational 
centers of the viewers eyes moment to moment, using fixed (head coordinate) vectors from tbe location 
of the head tracker to the viewers eyes. The nominal human intraocular distance of 6.3 cm can vary between 
individuals by as much as *2.6 cm; it is therefore important that these vectors be viewer specific. The 
vec­tors must also account for the registration of the head tracking de­vice to the viewers head. In 
the case of our system, this means ac­counting for how the head tracking stereo glasses sit on a particular 
individual s face relative to his eyes. Errors in intraocular distance on the order of a fraction of 
a centimeter can change the stereo per­ception of depth by an amount several times greater. Our goal 
in head-tracked synthetic stereo imagery is for the viewer to perceive computer generated objects as 
solid, rigid, three dimen­sional physical objects. In common with monocular systems, it is necessary 
to have a display frame rate sufficient for motion fusion. With stereo imagery there is the additional 
phenomenon ofimked stereo mo] emenr [20], where objects displayed at a low frame rate appear to deform 
and twist. An even more important issue is perceived lag. Perceived lag is caused by the visual difference 
between the stereo image generated by the system, and the physically correct image given the viewers 
true head position at the time of perception. A number of factors contribute to this lag: errors in head 
position due to the tracking de­vice; the latency of the head-tracking device; and the latency of the 
image generation bardware. Just as for motion fusion, there appears to be a (soft) maximum degree of 
perceived lag beyond which the illusion begins to break up. The visual effect is for the virtual object 
to distort and jump . While much more detailed formal physiolog­ t97 SIGGRAPH 92 Chicago, July 26-31, 
1992 ical studies of this issue remain to be performed, initial empirical re­sults are similar to that 
for motion fusion, e.g., perceived lags should be no more than 50-100 ms. The effect of latency can be 
reduced by using, instead of the directly sensed location of the viewers head, a forward prediction of 
where the viewers head is likely to be when rendering and display of the next frame is completed. Prediction 
works best when limited to a few hundreds of milliseconds: the overshoot resulting from longer­term prediction 
is more visually objectionable than the lag. The simplest prediction method is linear interpolation, 
where the two most recent samples of position are interpolated in a straight line. This works reasonably 
well when the rendering-to-display la­tency is less than about 100 ms, however, this technique overshoots 
during rapid deceleration. Higher order interpolators based on Kal­man filtering have been used [10][5]. 
Use of such filters involves a trade-off between lag reduction with the potential of further ampli­fying 
sensor noise. It is important to correctly choose the parameters to lx predicted. If the two eye nodal 
points are independently extrapolated, than in­traocular distance is not necessary be maintained, resulting 
in dis­tortion of depth. A better alternative is to extrapolate the location and orientation of the head, 
compute the eyeball centers from the predicted head location, and than derive the eye nodal points. The 
head-location prediction strategy may have to take the characteris­tics of the particular head tracking 
device into account. Improved prediction might be possible if a head-tracking device were to pro­vide 
velocity and/or acceleration data in addhion to position and orientation data. At low head velocities 
 below about 4 cm/s the visual advan­tage due to forward head prediction is small, while the potential 
for amplifying sensor jitter is large. Thus, depending on the specifics of the sensors used, a filter 
to ramp down the contribution of the head prediction function at small velocities generally reduces jitter 
of the virtual objects image when the viewer is trying to hold their head still or making vary fine head 
movements. An image on a CRT is not flashed instantaneously on the screen, but takes almost a frame time 
to be fully scanned out. Furthermore, for field sequential stereoscopic displays, the left and right 
images are offset in time by one field. At a 120 Hz field rate, this comesponds to an 8.3 ms temporal 
offset between the two eyes views. Fortunate­ly, the actual perception of the displayed image is also 
not instanta­neous. The human visual system takes several tens of milliseconds to perceive a stereo pair, 
and apparently is not sensitive to small temporal errors [11 ]. This does not put a lower limit on perceivable 
temporal effects, as high head velocities can cause visual blur of virtual objects whose physical counterpart 
retinal images would have been stabilized. The head position prediction algorithm currently used by our 
sys­tem is linear interpolation with low velocity and low frame rate ramp down. We are actively experimenting 
with a number of differ­ent sensing technologies and higher order prediction algorithms. 5 THE IMAGE 
PLANE OF A CRT The classic viewing projection used in computer graphics assumes that the light-emitting 
image plane is planar. However the phosphor screen of a typical CRT is by design a section of a sphere 
or of a cylinder. Also, the phosphor screen is viewed through a thick glass faceplate that has an index 
of refraction significantly higher than that of air. In conventional computer graphics the inaccuracies 
pro­duced by ignoring these effects are imperceptible. But for high res­olution stereo, the errors produced 
are significant enough to require correction. (The corresponding problem for head mounted displays are 
the distortions caused by the wide field of view lenses placed in front of the viewer s eyes. [15] presents 
an accurate model of the distortion function of a commonly used lens, showing it to be quite nonlinear, 
and not amenable to any computationally simple correc­tion function.) As will be shown, CRT glass induced 
errors are viewpoint depen­dent and nonlinear. To exploit conventional rendering accelerators, we implement 
the correction by modifying the viewing matrix equation P (of section 2) by adjusting the values of L 
and H. This correction is approximate, but very effective: at present, more accu­rate correction would 
impose a prohibitive computational load. One approach to improve the correction for this effect would 
be to model the CRT surface as multiple flat patches positioned and tilted to approximate the spherical 
or cylindrical shape of the actual screen. Each patch would than be rendered separately with a patch­specific 
viewing matrix. This piecewise approximation would take longer to render than a single patch, although 
with effective use of bounding box data structures the rendering time increase need not grow as rapidly 
as the number of patches. Another approach at higher accuracy correction takes into account direction 
of view information. Most of the distortions discussed in this paper are only visible to the fovea, that 
is within an angle of 20­6° of the gaze direction. If angle of view information is available either 
directly as a result of eye tracking, or indirectly through the hot spot assumption than the correction 
can be biased to be correct at the point of view, but representable as a single 4x4 view­ing matrix. 
 Phosphor image refraction by faceplate glass Every direct-view CRT display has a glass faceplate that 
intervenes between the image formed on the phosphor and the eye of the view­er. [n addition to its obvious 
function of enclosing the vacuum with­in the tube, the faceplate provides implosion protection, antiglare 
and contrast-improvement functions. For a 21 inch CRT the face­plate is about 2 cm thick and has an index 
of refraction in the range of 1.5 to 1.6. At an angle of view 60° normal to the plane of the CRT glass, 
Snell s law dictates that the glass will bend the light from the phosphor by 25 at the glass/air interface 
([4] pp. 756), This effect introduces an apparent positional error of up to 2 cm, depending on eyepoint 
location. Figure 4 shows the geometry of the ray paths. (Point O is the projection of point E onto the 
xy plane.) Approxi­mating the calculation of the incident angle 6, the refraction distor­tion function 
of a point S when viewed from the eyepoint E is: s-o ~ = sin-l(~)ref(S) = S+h. (tarr Et-tan~) f R t3=tan-1~, 
f = J(S., -%)*+ (S, -E,)2 Effect of curvature of CRT screen As explained above, the actual image raster 
of a modem CRT is a sections of a sphere or a cylinder. Modem CRTs of the so-called flat-square-tube 
(FST) variety have a radius of curvature of about 2 m. The curvature is more severe for less flat CRTs. 
This curvature causes the actual image to deviate from a plane by as much as 1 cm across its faceplate. 
(Certain CRTs are truly flat, but none of those are presently manufactured with horizontal scan rates 
sufficient for high resolution 120 Hz stereo.) At a view angle of 60°, and a head position to one side 
of the CRT and 50 cm away, this curvature represents a potential positional er­ror on the order of 1.8 
cm in position. Figure 5 depicts the geometry of the ray paths. Point C is the tangent to the sphere 
in display plate ComDuter GraDhics. 26.2, Julv 1992 s s 0  z Figure 4: Effect of refraction of CRT front 
glass. Viewed from poinl E, the pixel at point S on phosphor appears to come from point S . z Figure 
5: Effect of curvature of CRT front glass. Viewed from point E. the pixel at point S on the phosphor 
appears to come from point S . coordinates. The screen curvature distortion function for a CRT with spherical 
section of effective radius r is: .5-0 ,sph(.$) = .S c1, tantll d=r(l. o-cosr+r) f  Combining the corrections 
These two distortions apply in opposite directions: the glass tends to magnify fhe image; the curvature 
minifies. But they by no means cancel out. The effects do interact: to be completely accurate the re­fraction 
incident angle must be measured relative to the normal of the curving glass. Including this, the combined 
refraction and cur­vature distortion function is: di.s(.$) = S+ {h (tant3 tan$ -r. (]. O COSV) .tant3) 
s-o - ,f sine ~ = sin-i( ). ?1 s ; = (E, .S,, EV S \ -E. ) This distortion function can be used in 
a number of ways to help correct the screen image. A simple use is to linearly approximate a corrected 
display. The idea is just to adjust the 3D location of two comers of the display area. This yields a 
final modification to the L and H values to be input to the viewing equation: L = di.s(.L), H = dis(H) 
or to bias the correction for a hot spot Q: L = L.+ Q-di.!(Q), H = H+ Q -di.~(Q)  6 LIGHTING While 
it does not change the location of pixels, making the light source directions and colors in the virtual 
world roughly match those in the physical world enhances the illusion of the virtual ob­ject inhabiting 
our world. In one experiment we put a blinking green spotlight in both worlds; the illusion was so natural 
that even many graphics experts didn t understand why there was a blinking light until we disabled one 
of them. As may be expected, additional sensory inpuls to the viewer ampli­fy the illusion of reality, 
For our virtual lathe, we dynamically var­ied the grindiog sound by the amount of material being cut 
away at any instant.  7 HARDWARECONFIGURATION The hardware in our system consisted of a standard 3D 
graphics workstation augmented with off the shelf stereo and 3D tracking pe­ripherals: SIGGRAPH 92 Chicago, 
Julv 26-31, 1992 Sun SPARCstationT 2GT 3D graphics workstation Hitachi 21 Color CRT CM2 187M (85 KHz 
horizontal) monitor 960 X680@ 108 Hz Logitech 3D mouse specified positional accuracy - and head-tracker 
+.0635 cm, angular +1/20 StereoGraphics stereo LCD shutter glasses with CrystalEyes VR M integral Logitech 
head-tracker  8 EXPERIMENTALRESULTS Figures 6, 7, and 8 are (divergent) stereo pairs from the system 
in operation. The operational accuracy of the system is presented em­pirically in Figure 6. The photograph 
is of two metric rulers; one physical, one virtual. The physical ruler was placed directly below the 
virtual ruler. This photograph was taken at an angle of about 35° from normal to the screen. In stereo, 
the virtual ruler appears to stick out of the screen at the same angle and horizontal location as its 
physical counterpart. Even viewed monocularly, it can be seen that the real and synthetic images are 
closely aligned to within a fraction of a centimeter. The CRT correction was based on the hot spot assumption. 
The penny was included not only for scale, but to show where the front of the CRT glass was, relative 
to the caret cur­sor on the inner surface. All three image pairs are extreme close­ups, and represent 
only a small portion of the usable area of the screen. An emulation of a lathe is shown in Figure 7. 
The tip of the (phys­ical) plastic rod is the 3D mouse hot spot. Wherever in space it is touched to the 
stock, virtual material is cut away accompanied by virtual sparks and a grinding sound. Precise shape 
cutting would not be possible here without accurate registration between the viewers retinal image of 
the virtual material being cut and the retinal image physical tip of the 3D mouse. Figure 8 shows a drawing 
application where a thin tube of virtual material is laid down wherever the 3D mouse has been; here a 
knot has been drawn. An earlier version of our system has been tried on several thousand different individuals 
during 3 minute demonstrations. Almost uni­versally, individuals with normal stereo vision reported good 
stereo perception. Most first time users who attempted to were able to suc­cessfully tie a knot with 
the drawing package. In the system of [ 17], knot tying was also possible. They reported that: ... only 
an experienced viewer could reliably and comfortably see the proper depth... . They went on to speculate 
that this was due to pure stereo missing important depth cues: shadows, textures, per­spective, and motion 
parallax. While our system adds motion par­allax, we found that high quality results could be obtained 
even from a fixed viewpoint, so long as that viewpoint had the absolutely correct perspective image pairs 
computed. This paper details several techniques for improving the accuracy of visual registration of 
the virtual and physical worlds. How much did each technique contribute? Are all of them necessary? Are 
there other sources of error not covered? The visual effect of many of the errors is frustratingly similar. 
For example, errors in registering the tracker to display plate coordinates look vary much like errors 
in the head to eyepoint vectors. However, once the complete system was functioning and calibrated, it 
became possible to observe the con­tribution of the correction steps by disabling them one by one. In­vestigations 
of these observations can both explain and validate their effect. The specific error amounts described 
in each section were arrived at in this manner. The visual registration of the virtual and physical worlds 
is limited by the accuracy of the head-tracking technology, and the accuracy and stability of the calibration 
measurements of the physical setup. The specified accuracy of the tracking subsystem is 200 dpi, e.g. 
a potential spatial error of +1/400 of an inch (f.0635 cm). The orien­tational accuracy is specified 
as tl/200. The calibration of the sen­sors to the viewers eyes and the CRT phosphor was done with fairly 
crude techniques, probably only accurate to within 0.5 cm. The overall system accuracy varies with head 
position, but for a large re­gion, centimeter virtual to physical registration accuracies are ob­tained. 
The error becomes larger at extreme angles to the CRT glass, and wherever the 3D tracking device delivers 
measurements substantially below its rated accuracy. 9 OTHER APPLICATIONS The technology described in 
this paper can Ix applied to other 3D display configurations besides real-time projected geometry. If 
six­teen or so images have been precomputed (or sixteen real photo­graphs taken and digitized), than 
a form of Ienticular lens emulation display is possible. The idea is to compute the predicted eye nodal 
points as before, but now use them to select which two of the six­teen existing images will be displayed 
as a stereo image during the next frame. We have tried this approach on our system with satis­factory 
results. Such a system assumes that the viewers head is up­right, and allows only for vary limited side 
to side head motion, just as is true for a physical lenticular lens display. Unlike a real Ienticular 
lens system, there is no need to stop at six­teen side-to-side samples. As a refinement to the system 
described in [3], a general precomputed head-tracked display could always use the eyes predicted nodal 
point to select the image with the clos­est precomputed (or pre-photographed) viewpoint. [f hundreds 
of viewpoints have been densely sampled over a reasonably large 3D range, one once again achieves a full 
hologram-like effect; visually the overall display is vary similar to a holographic stereogram. (And 
just as has been found with holographic stereograms, the viewpoints need not be sampled as frequently 
in the vertical direc­tion, reducing the number of samples needed. ) A space optimiza­tion could employ 
image compression technology to pre-compress the sampled images, than decompress the two selected images. 
If sufficient compression is achieved, moving displays are possible by temporal viewpoint sampling. The 
techniques described here apply not only to live stereo dis­plays. The head tracker can be attached to 
a video, film, or still cam­era. With proper lens first nodal point location, the camera can be placed 
anywhere within the tracking region and registered images of synthetic and real objects can be captured 
live. The stereo images in this paper were photographed this way. For video or mov ie film­ing, so long 
as the camera field of view is wide enough to include some of the physical world beyond the CRT, and 
the camera is moved about while recording, significant amounts of shape from motion can be perceived 
by later viewers. 10 LIMITATIONS Justas vector refresh displays in the early days of computer graph­ics 
were limited in object display complexity to that which could be redrawn at an acceptable frame rate, 
so too are the sort of virtual display systems described in this paper. The display techniques here implicitly 
assume a single viewer at a time; additional viewers would be presented with incorrect image pairs. The 
viewer is currently constrained to wear a pair of special glasses and stay within the working range of 
the 3D tracking tech­nology. At practical viewing distances, the viewers field of view of a stereo CRT 
is limited to 20° to 60°. Projection stereo displays (perhaps multiple thereof) can support wider fields 
of view. Current stereo CRT phosphors have long secondary decays; this re­sults in distracting ghosting 
of one eyes image into the other. im­proved phosphors are in development. The depth of field (focus) 
of the virtual object is u/w a~s at the CRT surface (unless additional optics are employed), while the 
stereo cues are indicating that the focus should be at a different distance. When the apparent stereo 
location of an object is significantly dis­placed from the CRT surface, the mismatch in accommodation 
cues can make it uncomfortable 10 impossible for a viewer to converge the display image. Getting other 
visual depth cues right can greatly extend the displacement range: we have had a much greater per­centage 
of users drawing 3D doodles inches in front of their noses than experts familiar with other stereo display 
systems thought pos­sible, The amount of CRT to virtual object distance acceptable var­ies greatly from 
one individual to another. In general for CRTs a conservative approach is to keep it within plus or minus 
ten centi­meter of the physical display surface. This can be achieved by scal­ing, clipping planes, or 
in extremes even nonuniform object scaling, in place of the direct parallax control of [7] and [ 12]. 
In the future, systems including gaze tracking and computer controlled active op­tics may allow stereo 
images to be synthesized with proper optical depth of field. 11 CONCLUSIONS 3D synthetic image rendering 
can be extended beyond tbe confines of the frame buffer to encompass the physical and optical details 
of the path to the viewers retina. These techniques allow computer generated worlds to be superimposed 
onto the physical world with registration accuracy better than a centimeter. Such registration al­lows 
users to use their normal binocular vision to accurately judge distances to virtual objects. and allows 
virtual and physical objects to be intermixed. The ability of users to move their heads enables even 
naive users to rapidly perceive the spatial relationships of complex 3D shapes in a natural way. These 
techniques further blur the distinction between the physical and computer worlds. ACKNOWLEDGEMENTS 
Many thanks to Salem Abi-Az.zi and Laon Shirman combing through the math. and to Mike Lavelle, Scott 
Nelson, Greg Schechter, and most especially Charles Poynton and Will Shelton f orcombing through the 
English. REFERENCES 1. Benton, Stephen. Survey of Holographic Stereograms. Pro­cessing and Display 
of Tbree-Dimensional Data. In Proceed­irt~.sof fhe SP/E 367 ( 1982), 15-19. 2. Diamond, R., A. Wynn, 
K. Thomsen, and J. Turner. Three dimensional perception for one-eyed guys. or the use of dy­namic parallax. 
In Cornputulional Cl:vslallography. 286-293. ed. David Sayre, Clarendon Press. Oxford, 1982.  3 Fisher, 
Scott. Viewpoint dependent imaging: an . . interactive stereoscopic display. Processing and Display 
of Three-Di­mensional Data. In Pr~xeedin,qs of rhe SP/E 367 ( 1982), 4 I ­45, 4. Foley, James, Andries 
van Dam, Steven Feiner, and John Hughes. Computer Gruphics: Principles und Practice, 2nd cd,, Addison-Wesley. 
1990. 5. Friedmann, Martin, Tad Starrier, and Alex Pentland. De­vice Synchronization Using an Optimal 
Linear Filter. In Ptv- Computer Graphics, 26, 2, July 1992 ceedings of the ACM Symposium on lnteruc tile 
3D Gruphils (Cambridge, Massachusetts, March 29-April 1. 1992), 57-62. 6. Haines, Kenneth, and Debby 
Haines. Computer Graphics for Holography. In IEEE Computer Graphi(.s und Applicu ­riorrs 12, I (January 
1992). 37-46. 7. Hibbard, Eric ef al. On the Theory and Application of Ste­reographic in Scientific 
Visualization. EUROGRAPHICS 9I (Vienna, Austria, September 2-6, 1991 ). In Eww,qruphi[.\ 91: State of 
the Art Reports ( 1991 ), I-21.  8. Hodges, Larry. Basic Principles of stereographic Soffware Development. 
Stereoscopic Displays and Applications. in Proceedings of the SPIE 1457 ( 1991 ), 9-17. 9. Kubitz, W. 
and W. Poppelbaum. Stereomatrix Interactive Three-Dimensional Computer Display. In Proceedings Offhe 
S/D 14, 3 (Third Quarter 1973) 94-98. 10. Liang, Jiandong, Chris Shaw, and Mark Green. On Tem­poral-Spatial 
Realism in the Virtual Reality Environment. In  Proceedings of the ACM Symposiwn (m User lrm rfuce Soft­ 
ware and Techmdo,qy (Hilton Head, South Carolina, Novem­ ber II-13, 1991), 19-25. 11. Lipton, Lenny. 
Temporal Artifacts in Field-Sequential Ste­reoscopic Displays. Proceedings of SID 91 (Anaheim, Cali­fornia, 
May 6-10, 1991 ). [n Proceedit~,y.\ of the S/D 22 (May 1991 ), 834-835. 12. Lipton, Lenny. The Cry.srulEye.s 
Handbook. StereoGraphics Corporation, I99 I. 13. Ogle, Kenneth. Opfics. Charles C. Thomas, Publisher. 
Springfield, Illinois. 1968. 14. Paley, W. Bradford. Head-Tracking Stereo Display: Experi­ments and 
Applications. Stereoscopic Displays and Applica­  tions 111(San Jose, California, February 12-13, 1992.). 
[n Pr/~­ceedings of the SPIE 1669, 1992. 15. Robinett, Warren, and Jannick Rolland. A Computational Model 
for the Stereoscopic Optics of a Head-Mounted Dis­play. In Presctrc 1. I (Winter 1992), 45-62. 16. Reese, 
John, and Lawrence McCleary. Stereoscopic Com­puter Graphics for Simulation and Modeling. Proceedings 
of SIGGRAPH 79 (Chicago. IllinoiS. August S-10. 1979). In Computer Gruphi[s 13,2 (August 1979 ).4 I-47. 
 17. Schmandt, Christopher. Spatial Input/Display Correspon­dence in a Stereoscopic Computer Graphic 
Work Station. Pro­ceedings of SIGGRAPH 83 (Detroit. Michigan. July 25-29. 1983). In Compufcr Gruphi~.s 
17.3 (July 1983). 253-261. 18. Sutherland, Ivan. The Ultimate Display. In Pr(weeditf,~\ ~,~ /he IFIPS 
Confereme 2 ( 1965), 506-508. 19. Sutherland, Ivan, A Head Mounted Three Dimensional Dis­play. In Fall 
.foinr C{mlpu[er Conference. AFIPS Conference Proceedings 33 ( 1968), 757-764. 20. Tyler, William. Induced 
Stereomovement. t i.~i~mRes 14 ( 1974), 609-613.  20 I 92 Chicago, July 26-31, 1992 Figure 6: Stereogram 
of physical and virtual rulers in correspondent. Figure 7: Stereogram of virtual lathe. The tip of the 
plastic rod is reg­istered to the virtual cutting tip. Figure 8: Stereogram of 3D drawing example: a 
freehand knot.   
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134061</article_id>
		<sort_key>203</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>23</seq_no>
		<title><![CDATA[Merging virtual objects with the real world]]></title>
		<subtitle><![CDATA[seeing ultrasound imagery within the patient]]></subtitle>
		<page_from>203</page_from>
		<page_to>210</page_to>
		<doi_number>10.1145/133994.134061</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134061</url>
		<keywords>
			<kw><![CDATA[3D medical imaging]]></kw>
			<kw><![CDATA[see-through head-mounted display]]></kw>
			<kw><![CDATA[ultrasound echography]]></kw>
			<kw><![CDATA[virtual reality]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Virtual reality</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>I.3.6</cat_node>
				<descriptor>Interaction techniques</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>J.3</cat_node>
				<descriptor>Health</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>J.3</cat_node>
				<descriptor>Medical information systems</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.1</cat_node>
				<descriptor>Three-dimensional displays**</descriptor>
				<type>S</type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010405.10010444.10010446</concept_id>
				<concept_desc>CCS->Applied computing->Life and medical sciences->Consumer health</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010405.10010444.10010447</concept_id>
				<concept_desc>CCS->Applied computing->Life and medical sciences->Health care information systems</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010405.10010444.10010449</concept_id>
				<concept_desc>CCS->Applied computing->Life and medical sciences->Health informatics</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010583.10010588.10010591</concept_id>
				<concept_desc>CCS->Hardware->Communication hardware, interfaces and storage->Displays and imagers</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003120.10003121.10003125.10010391</concept_id>
				<concept_desc>CCS->Human-centered computing->Human computer interaction (HCI)->Interaction devices->Graphics input devices</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010387</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Graphics systems and interfaces</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010387.10010866</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Graphics systems and interfaces->Virtual reality</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
			<gt>Experimentation</gt>
			<gt>Human Factors</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>PP15035815</person_id>
				<author_profile_id><![CDATA[81100543619]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Michael]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Bajura]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Department of Computer Science, University of North Carolina, Chapel Hill, NC]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>PP43124435</person_id>
				<author_profile_id><![CDATA[81339500019]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[Henry]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Fuchs]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Department of Computer Science, University of North Carolina, Chapel Hill, NC]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P250880</person_id>
				<author_profile_id><![CDATA[81100592189]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>3</seq_no>
				<first_name><![CDATA[Ryutarou]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Ohbuchi]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Department of Computer Science, University of North Carolina, Chapel Hill, NC]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Brinkley, J. F., Moritz, W.E., and Baker, D.W. "Ultrasonic Three-Dimensional Imaging and Volume From a Series of Arbitrary Sector Scans." Ultrasound in Med. &amp;Biol., 4, pp317-327.]]></ref_text>
				<ref_id>Brinkley 1978</ref_id>
			</ref>
			<ref>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Collet Billon, A., Philips Paris Research Lab. Personal Communication.]]></ref_text>
				<ref_id>Collet Billon 1990</ref_id>
			</ref>
			<ref>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Fornage, B. D., Sneige, N., Faroux, M.J., and Andry, E. "Sonographic appearance and ultrasound guided fine-nee~Jle aspiration biopsy of brest carcinomas smaller than 1 cm . lournal of Ultrasound in Medicine, 9, pp559-568.]]></ref_text>
				<ref_id>Fornage 1990</ref_id>
			</ref>
			<ref>
				<ref_obj_id>325205</ref_obj_id>
				<ref_obj_pid>325165</ref_obj_pid>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[Fuchs, H., GoldFeather, j., Hultiquist, J.P., Spach, S., Austin, J., Brooks, Jr., F.P. Eyles, J., and Poulton, J. "Fast Spheres, Textures, Transparencies, and Image Enhancements in Pixel Planes." Computer Graph&amp;'s (Proceedings of SIGGRAPH' 85 ), 19(3), ppl 11-120.]]></ref_text>
				<ref_id>Fuchs 1985</ref_id>
			</ref>
			<ref>
				<ref_obj_id>74341</ref_obj_id>
				<ref_obj_pid>74334</ref_obj_pid>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[Fuchs, H., Poulton, J., Eyles, J., Greer, T., Goldfeather, j., Ellsworth, D., Molnar. S., and israel, L. "'Pixel Planes 5: A Heterogeneous Multiprocessor Graphics System Using Processor-Enhanced Memories." Computer Graphit's (Proceedings of SIGGRAPH' 89), 23(3), pp79-88.]]></ref_text>
				<ref_id>Fuchs 1989</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122747</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[Galyean, T. A., and Hughes, J.F. "'Sculpting: An Interactive Volumetric Modeling Technique." ComputerGraphits (Prot'eedings of SIGGRAPH' 89), 25(4 ), pp267-274.]]></ref_text>
				<ref_id>Galyean 1991</ref_id>
			</ref>
			<ref>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Geiser, E. A. Ariet, M., Conetta, D.A., Lupkiewicz, S.M., Christie, L.G., and Conti, C.R. "Dynamic three-dimensional echocardiographic reconstruction of the intact human left ventricle: Technique and initial observations in patients."Amerit'an Heart journal, 10316), pp1056-1065.]]></ref_text>
				<ref_id>Geiser 1982a</ref_id>
			</ref>
			<ref>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[Geiser, E. A., Christie, L.G., Conetta, D.A., Conti, C.R., and Gossman, G.S. "Mechanical Arm for Spatial Registration of Two-Dimensional Echographic Sections." Cathet. Cariovas~'. Diagn., 8, pp89- I01.]]></ref_text>
				<ref_id>Geiser 1982b</ref_id>
			</ref>
			<ref>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Ghosh, A., Nanda, C.N., and Maurer, G. "'Three- Dimensional Reconstruction of Echo-Cardiographics Images Using The Rotation Method." Ultrasound in Med. &amp; Biol.,S(6), pp655-661.]]></ref_text>
				<ref_id>Ghosh 1982</ref_id>
			</ref>
			<ref>
				<ref_obj_id>133884</ref_obj_id>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[Haddad, R. A., and Parsons, T.W. Digital Signal Processing, Theory, Appli~'ations, and Hardware. New York, Computer Science Press.]]></ref_text>
				<ref_id>Haddad 1991</ref_id>
			</ref>
			<ref>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[Harris, R. A., Follett, D.H., Halliwell, M, and Wells, P.N.T. "Ultimate limits in ultrasonic imaging resolution." Ultrasound in Medicine and Biology, 17(6), pp547-558.]]></ref_text>
				<ref_id>Harris 1990</ref_id>
			</ref>
			<ref>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[Hildreth, E. C. "The Detection of Intensity Changes by Computer and Biological Vision Systems." Computer Vision, Graphites, and Image Processing, 22, ppl-27.]]></ref_text>
				<ref_id>Hildreth 1983</ref_id>
			</ref>
			<ref>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[Hottier, F., Philips Paris Research Lab. Personal Communication.]]></ref_text>
				<ref_id>Hottier 1989</ref_id>
			</ref>
			<ref>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[Hottier, F., Collet Billon, A. 3D Echography: Status and Perspective. 3D Imaging in Medicine. Springer-Verlag. pp2 i-41.]]></ref_text>
				<ref_id>Hottier 1990</ref_id>
			</ref>
			<ref>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[Itoh, M., and Yokoi, H. "'A computer-aided threedimensional display system for ultrasonic diagnosis of a breast tumor." Ultrasonics,, pp261-268.]]></ref_text>
				<ref_id>Itoh 1979</ref_id>
			</ref>
			<ref>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[King, D. L., King Jr., D.L., and Shao, M.Y. "Three- Dimensional Spatial Registration and interactive Display of Position and Orientation of Real-Time Ultrasound Images." Journal of Ultrasound Med, 9, pp525-532.]]></ref_text>
				<ref_id>King 1990</ref_id>
			</ref>
			<ref>
				<ref_seq_no>17</ref_seq_no>
				<ref_text><![CDATA[Lalouche, R. C., Bickmore, D., Tessler, F., Mankovich, H.K., and Kangaraloo, H. "Three-dimensional reconstruction of ultrasound images "SPIE'89, Medical imaging, pp59-66.]]></ref_text>
				<ref_id>Lalouche 1989</ref_id>
			</ref>
			<ref>
				<ref_seq_no>18</ref_seq_no>
				<ref_text><![CDATA[Leipnik, R. "The extended entropy uncertainty principle." Info. Control, 3, ppl 8-25.]]></ref_text>
				<ref_id>Leipnik 1960</ref_id>
			</ref>
			<ref>
				<ref_obj_id>44652</ref_obj_id>
				<ref_obj_pid>44650</ref_obj_pid>
				<ref_seq_no>19</ref_seq_no>
				<ref_text><![CDATA[Levoy, M. "Display of Surface from Volume Data." IEEE CG&amp;A, 8(5), pp29-37.]]></ref_text>
				<ref_id>Levoy 1988</ref_id>
			</ref>
			<ref>
				<ref_obj_id>617545</ref_obj_id>
				<ref_obj_pid>616010</ref_obj_pid>
				<ref_seq_no>20</ref_seq_no>
				<ref_text><![CDATA[Levoy, M. "A Hybrid Ray Tracer for Rendering Polygon and Volume Data." IEEE CG&amp;A, 10(2), pp33-40.]]></ref_text>
				<ref_id>Levoy 1990</ref_id>
			</ref>
			<ref>
				<ref_obj_id>120784</ref_obj_id>
				<ref_obj_pid>120782</ref_obj_pid>
				<ref_seq_no>21</ref_seq_no>
				<ref_text><![CDATA[Liang, J., Shaw, C., and Green, M. "On Temporal- Spatial Realism in the Virtual Reality Environment." User Interface Software and Technology, 1991, Hilton Head, SC., U.S.A., pp19-25.]]></ref_text>
				<ref_id>Liang 1991</ref_id>
			</ref>
			<ref>
				<ref_obj_id>660242</ref_obj_id>
				<ref_obj_pid>645593</ref_obj_pid>
				<ref_seq_no>22</ref_seq_no>
				<ref_text><![CDATA[Lin, W., Pizer, S.M., and Johnson, V.E. "Surface Estimation in Ultrasound Images." Information Processing in Medical Imaging 1991, Wye, U.K., Springer-Verlag, Heidelberg, pp285- 299.]]></ref_text>
				<ref_id>Lin 1991</ref_id>
			</ref>
			<ref>
				<ref_seq_no>23</ref_seq_no>
				<ref_text><![CDATA[Matsumoto, M., lnoue, M., Tamura, S., Tanaka, K., and Abe, H. "Three-Dimensional Echocardiography for Spatial Visualization and Volume Calculation of Cardiac Structures." J. Clin. Ultrasound, 9, pp157-165.]]></ref_text>
				<ref_id>Matsumoto 1981</ref_id>
			</ref>
			<ref>
				<ref_seq_no>24</ref_seq_no>
				<ref_text><![CDATA[McCann, H. A., Sharp, J.S., Kinter, T.M., McEwan, C.N., Bariliot, C., and Greenleaf, J.F. "Multidimensional Ultrasonic Imaging for Cardiology." Proc.IEEE, 76(9), pp1063- 1073.]]></ref_text>
				<ref_id>McCann 1988</ref_id>
			</ref>
			<ref>
				<ref_seq_no>25</ref_seq_no>
				<ref_text><![CDATA[Mills, P. H., and Fuchs, H. "3D Ultrasound Display Using Optical Tracking." First Conference on Visualization for Biomedical Computing, Atlanta, GA, IEEE, pp490-497.]]></ref_text>
				<ref_id>Mills 1990</ref_id>
			</ref>
			<ref>
				<ref_seq_no>26</ref_seq_no>
				<ref_text><![CDATA[Miyazawa, T. "A high-speed integrated rendering for interpreting multiple variable 3D data." SPIE, 1459(5),]]></ref_text>
				<ref_id>Miyazawa 1991</ref_id>
			</ref>
			<ref>
				<ref_obj_id>134067</ref_obj_id>
				<ref_obj_pid>142920</ref_obj_pid>
				<ref_seq_no>27</ref_seq_no>
				<ref_text><![CDATA[Molnar, S., Eyles, J., and Poulton, J. "PixelFlow: High-Speed Rendering Using Image Composition." Computer Graphics (Proceedings of SIGGRAPH'92), ((In this issue)),]]></ref_text>
				<ref_id>Molnar 1992</ref_id>
			</ref>
			<ref>
				<ref_seq_no>28</ref_seq_no>
				<ref_text><![CDATA[Moritz, W. E., Pearlman, A.S., McCabe, D.H., Medema, D.K., Ainsworth, M.E., and Boles, M.S. "An Ultrasonic Techinique for Imaging the Ventricle in Three Dimensions and Calculating Its Volume." IEEE Trans. Biota. Eng., BME-30(8), pp482-492.]]></ref_text>
				<ref_id>Moritz 1983</ref_id>
			</ref>
			<ref>
				<ref_obj_id>1300297</ref_obj_id>
				<ref_obj_pid>1299958</ref_obj_pid>
				<ref_seq_no>29</ref_seq_no>
				<ref_text><![CDATA[Nakamura, S. "Three-Dimensional Digital Display of Ultrasonograms." IEEE CG&amp;A, 4(5), pp36-45.]]></ref_text>
				<ref_id>Nakamura 1984</ref_id>
			</ref>
			<ref>
				<ref_seq_no>30</ref_seq_no>
				<ref_text><![CDATA[Ohbuchi, R., and Fuchs, H. "Incremental 3D Ultrasound Imaging from a 2D Scanner." First Conference on Visualization in Biomedical Computing, Atlanta, GA, IEEE, pp360- 367.]]></ref_text>
				<ref_id>Ohbuchi 1990</ref_id>
			</ref>
			<ref>
				<ref_obj_id>660112</ref_obj_id>
				<ref_obj_pid>645593</ref_obj_pid>
				<ref_seq_no>31</ref_seq_no>
				<ref_text><![CDATA[Ohbuchi, R., and Fuchs, H. "Incremental Volume Rendering Algorithm for Interactive 3D Ultrasound Imaging." information Processing in Medical Imaging 1991 (Lecture Notes in Computer Science, Springer-Verlag), Wye, UK, Springer- Verlag, pp486-500.]]></ref_text>
				<ref_id>Ohbuchi 1991</ref_id>
			</ref>
			<ref>
				<ref_seq_no>32</ref_seq_no>
				<ref_text><![CDATA[Pini, R., Monnini, E., Masotti, L., Novins, K. L., Greenberg, D. P., Greppi, B., Cerofolini, M., and Devereux, R. B. "Echocardiographic Three-Dimensional Visualization of the Heart." 3D Imaging in Medicine, Travemiinde, Germany, F 60, Springer-Verlag, pp263-274.]]></ref_text>
				<ref_id>Pini 1990</ref_id>
			</ref>
			<ref>
				<ref_seq_no>33</ref_seq_no>
				<ref_text><![CDATA[Polhemus. 3Space Isotrak User's Manual.]]></ref_text>
				<ref_id>Polhemus 1980</ref_id>
			</ref>
			<ref>
				<ref_seq_no>34</ref_seq_no>
				<ref_text><![CDATA[Raichelen, J. S., Trivedi, S.S., Herman, G.T., Sutton, M.G., and Reichek, N. "Dynamic Three Dimensional Reconstruction of the Left Ventricle From Two-Dimensional Echocardiograms." Journal. Amer. Coll. of Cardiology, 8(2), pp364-370.]]></ref_text>
				<ref_id>Raichelen 1986</ref_id>
			</ref>
			<ref>
				<ref_obj_id>128951</ref_obj_id>
				<ref_obj_pid>128947</ref_obj_pid>
				<ref_seq_no>35</ref_seq_no>
				<ref_text><![CDATA[Robinett, W., and Rolland, J.P. "A Computational Model for the Stereoscopic Optics of a Head-Mounted Display." Presence, 1(1), pp45-62.]]></ref_text>
				<ref_id>Robinett 1991</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378476</ref_obj_id>
				<ref_obj_pid>378456</ref_obj_pid>
				<ref_seq_no>36</ref_seq_no>
				<ref_text><![CDATA[Sabeila, P. "A Rendering Algorithm for Visualizing 3D Scalar Fields." Computer Graphics (Proceedings of SIGGRAPH'88), 22(4), pp51-58.]]></ref_text>
				<ref_id>Sabella 1988</ref_id>
			</ref>
			<ref>
				<ref_seq_no>37</ref_seq_no>
				<ref_text><![CDATA[Shattuck, D. P., Weishenker, M.D., Smith, S.W., and yon Ramm, O.T. "Explososcan: A Parallel Processing Technique for High Speed Ultrasound Imaging with Linear Phased Arrays." JASA, 75(4), pp1273-1282.]]></ref_text>
				<ref_id>Shattuck 1984</ref_id>
			</ref>
			<ref>
				<ref_seq_no>38</ref_seq_no>
				<ref_text><![CDATA[Smith, S. W., Pavy, Jr., S.G., and yon Ramm, O.T. "High-Speed Ultrasound Volumetric Imaging System - Part I: Transducer Design and Beam Steering." IEEE Transaction on Ultrasonics, Ferroelectrics, and Frequency Control, 38(2), ppl00-108.]]></ref_text>
				<ref_id>Smith 1991</ref_id>
			</ref>
			<ref>
				<ref_seq_no>39</ref_seq_no>
				<ref_text><![CDATA[Stickels, K. R., and Warm, L.S. "An Analysis of Three-Dimensional Reconstructive Echocardiography." Ultrasound in Med. &amp; Biol., 10(5), pp575-580.]]></ref_text>
				<ref_id>Stickels 1984</ref_id>
			</ref>
			<ref>
				<ref_seq_no>40</ref_seq_no>
				<ref_text><![CDATA[Thijssen, J. M., and Oosterveld, B.J. "Texture in Tissue Echograms, Speckle or Information ?" Journal of Ultrasound in Medicine, 9, pp215-229.]]></ref_text>
				<ref_id>Thijssen 1990</ref_id>
			</ref>
			<ref>
				<ref_seq_no>41</ref_seq_no>
				<ref_text><![CDATA[Tomographic Technologies, G. Echo-CT.]]></ref_text>
				<ref_id>Tomographic Technologies 1991</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378482</ref_obj_id>
				<ref_obj_pid>378456</ref_obj_pid>
				<ref_seq_no>42</ref_seq_no>
				<ref_text><![CDATA[Upson, C., and Keeler, M. "VBUFFER: Visible Volume Rendering." ACM Computer Graphics (Proceedings of SIGGRAPH' 88 ), 22(4), pp59-64.]]></ref_text>
				<ref_id>Upson 1988</ref_id>
			</ref>
			<ref>
				<ref_seq_no>43</ref_seq_no>
				<ref_text><![CDATA[von Ramm, O. T., Smith, S.W., and Pavy, Jr., H.G. "High-Speed Ultrasound Volumetric Imaging System - Part II: Parallel Processing and Image Display." IEEE Transaction on Ultrasonics, Ferroelectrics, and Frequency Control, 38(2), ppl09-115.]]></ref_text>
				<ref_id>von Ramm 1991</ref_id>
			</ref>
			<ref>
				<ref_obj_id>147162</ref_obj_id>
				<ref_obj_pid>147156</ref_obj_pid>
				<ref_seq_no>44</ref_seq_no>
				<ref_text><![CDATA[Ward, M., Azuma, R., Bennett, R., Gottschalk, S., and Fuchs, H. "A Demonstrated Optical Tracker with Scalable Work Area for Head-Mounted Display Systems." 1992 Symposium on Interactive 3D Graphics, Cambridge, MA., ACM, pp43-52.]]></ref_text>
				<ref_id>Ward 1992</ref_id>
			</ref>
			<ref>
				<ref_seq_no>45</ref_seq_no>
				<ref_text><![CDATA[Wells, P. N. T. Biomedical ultrasonics. London, Academic Press.]]></ref_text>
				<ref_id>Wells 1977</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 Computer Graphics, 26,2, July 1992 Merging Virtual Objects with the Real World: Seeing Ultrasound Imagery 
within the Patient Michael Bajura, Henry Fuchs, and Ryutarou Ohbuchi Department of Computer Science 
University of North Carolina Chapel Hill, NC 27599-3175 Abstract 2) creating a working virtual environment 
which acquires and dis­plays 3D ultrasound data in real time, and 3) recovering structural We describe 
initial results which show live ultrasound information for volume rendering specifically from ultrasound 
data, echography data visualized within a pregnant human subject. The which has unique image processing 
requirements. This third area is visualization is achieved by using a small video camera mounted in presented 
in [Lin 199 I ] and is not covered here. front of a conventional head-mounted display worn by an observer. 
Section 2 of this paper reviews previous work in 3D ultra-The camera s video images are composite with 
computer-gener­sound and Section 3 discusses our research on processing, rendering,ated ones that contain 
one or more 2D ultrasound images properly and displaying echographic data without a head-mounted display. 
 transformed to the observer s current viewing position. As the Since the only real-time volume data 
scanners available today are 2D observer walks around the subject. the ultrasound images appear ultrasound 
scanners. we try to approximate our ultimate system by stationary in 3-space within the subject. This 
kind of enhancement incrementally visualizing a 3D volume dataset reconstructed from a of the observer 
s vision may have many other applications, e.g., never-ending sequence of 2Ddata slices [Ohbuchi 1990; 
199 I ]. This image guided surgical procedures and on location 3D interactive is difftcult because the 
volume consisting of multiple 2D slices needs architecture preview. to be visualized incrementally as 
the 2D slices are acquired. This CR Categories: 1.3.7 [Three-Dimensional Graphics and Realism] incremental 
method has been successfully used in off line experi-Virtual Reality, 1,3.I [Hardware architecture]: 
Three-dimensional ments with a 3-degree-of-freedom (DOF) mechanical arm tracker displays, 1.3.6 [Methodology 
and Techniques]: Interaction tech-and is extendible to 6 degrees of freedom, e.g., a 3D translation and 
niques, J.3 ILife and Medical Sciences]: Medical information sys-a 3D rotation, at greater computational 
cost. tems. Sections 4 and 5 present our research on video see-through Additional Keywords and Phrases: 
Virtual reality, see-through head-mounted display (HMD) techniques involving the merging of head-mounted 
display, ultrasound echography, 3D medical imaging computer generated images with real-world images. 
Our video see­ through HMD system displays ultrasound echography image data in the context of real (3D) 
objects. This is part of our continuing see­ 1. Introduction through HMD research, which includes both 
optical see-through HMD and video see-through HMD, Even though we concentrate We have been working toward 
an ultimate 3D ultrasound here on medical ultrasound imaging, applications of this displaysystem which 
acquires and displays 3D volume data in real time. technology are not limited to it (see Section 6.2). 
 Real-time display can be crucial for applications such as cardiac diagnosis which need to detect certain 
kinetic features. Our ulti­mate system design requires advances in both 3D volume data 2. Previous Research 
in 3D Ultrasound acquisition and 3D volume data display. Our collaborators, Dr. Olaf von Ramm s group 
at Duke University, are working toward real-time The advantages of ultrasound echography are that it 
is rela­3D volume data acquisition [Smith 1991; von Ramm 1991]. At tively safe compared with other imaging 
modalities and that images UNC-Chapel Hill, we have been conducting research on real-time are generated 
in real time [Wells 1977]. This makes it the preferred 3D volume data visualization. imaging technique 
for fetal examination, cardiac study, and guided surgical procedures such as fine-needle aspiration biopsy 
of breast Our research efforts at UNC have been focused in three areas: tumors [Fomage 1990]. Ultrasound 
echography offers the best real-I ) algorithms for acquiring and rendering real-time ultrasound data, 
time performance in 3D data acquisition, although slower imaging modalities such as MRI are improving. 
 Permlssmn to copy with{wt lee all or part of this material is gmrrted The drawbacks of ultrasound imaging 
include a low signal to provdd that the copim are not made or distriimned for direct noise ratio and 
poor spatial resolution. Ultrasound images exhibit commercial advantage, the ACM copyright nntfce and 
the title of the speckle which appears as grainy areas in images. Speckle arises  publication and its 
date appear, and notice is given that copying is by from coherent sound interference effects from tissue 
substructure. permission of the Association for Computing Machinery. To cnpy otherwise. t]r [o repuhllsh, 
requires a fee and/or specific permission. Information such as blood flow can be derived from speckle 
but in ,( 1992 ACM -()-89791 -479-1/92/007/0203 $0150 203 SIGGRAPH 92 Chicago, July 26-31, 1992 general 
speckle is hard to utilize [Thijssen 1990]. Other problems with ultrasound imaging include attenuation 
that increases with frequency, phase aberration due to tissue inhomogeneity, and reflec­tion and refraction 
artifacts [Harris 1990] 2.1 3D Ultrasound Image Acquisition Just as ultrasound echography has evolved 
from 1D data acquisition to 2D data acquisition, work is in progress to advance to 3D data acquisition. 
Dr. Olaf von Ramm s group at Duke University is developing a 3D scanner which will acquire 3D data in 
real time [Shattuck 1984; Smith 1991; von Ramm 1991 ]. The 3D scanner uses a 2D phased array transducer 
to sweep out an imaging volume. A parallel processing technique called Explososcan is used on return 
echoes to boost the data acquisition rate. Since such a real-time 3D medical ultrasound scanning sys­tem 
is not yet available, prior studies on 3D ultrasound imaging known to the authors have tried to reconstruct 
3D data from imaging primitives of a lesser dimension (usually 2D images). To reconstruct a 3D image 
from images of a lesser dimension, the location and orientation of the imaging primitives must be known. 
Coordinate values are explicitly tracked either acoustically [Brinkley 1978; King 1990; Moritz 1983], 
mechanically [Geiser 1982a; Geiser 1982b; Hottier 1989; McCann 1988; Ohbuchi 1990; Raichelen 1986; Stickels 
1984], or optically [Mills 1990]. In other systems, a human or a machine makes scans at predetermined 
locations and/or orientations [Collet Billon 1990; Ghosh 1982; Itoh 1979; Lalouche 1989; Matsumoto 1981; 
Nakamura 198A Tomographic Technologies 1991]. A particularly interesting system under development at 
Philips Paris Research Laboratory is one of the closest yet to a real-time 3D ultrasound scanner [Collet 
Billon 1990]. It is a follow on to earlier work which featured a manually guided scanner with mechanical 
tracking [Hottier 1990]. This near real-time 3D scanner is a mechani­cal sector scanner, in which a conventional 
2D sector scanhead with an annular array transducer is rotated by a stepper motor to get a third scanning 
dimension. In a period of 3 to 5 seconds, 50 to 100 slices of 2D sector scan images are acquired. Currently 
the annular array transducer in this system provides better spatial resolution, but less temporal resolution, 
than the real-time 3D phased array system by von Ramm et al., mentioned above. A commercial product, 
the Echo-CT system by Tomographic Technologies, GMBH, uses the linear translation of a transducer inside 
a tube inserted into the esophagus to acquire parallel slices of the heart. Image acquisition is gated 
by respiration and an EKG to reduce registration problems [Tomographic Technologies 1991]. 2.2 3D Ultrasound 
Image Display One should note that 3D image data can be presented not only in visual form, but also as 
a set of calculated values, e.g., a ventricular volume. The visual form can be classified further by 
the rendering primitives used, which can be either geometric (e.g., polygons) or image-based (e.g., voxels). 
Many early studies focused on non­invasively estimating of the volume of the heart chamber [Brinkley 
1978; Ghosh 1982; Raichelen 1986; Stickels 1984]. Typically, 2D echography (2 DE) images were stored 
on video tape and manually processed off-line. Since visual presentation was of secondary interest, wire 
frames or a stack of contours were often used to render An interesting extension to 2D display is a system 
that tracks the location and orientation of 2D image slices with 6 DOF [King 1990]. On each 2D displayed 
image, the system overlays lines indicating the intersection of the current image with other 2D images 
already acquired. The authors claim that these lines help the viewer understand the relationship of the 
2D image slices in 3D space. Other studies reconstructed 3D grey level images preserving grey scale, 
which can be crucial to tissue characterization [Collet Billon 1990; Hottier 1989; Lalouche 1989; McCann 
1988; Nakamura 1984; Pini 1990; Tomographic Technologies 199 1]. [Lalouche 1989] is a mammogram study 
using a special 2DE scanner that can acquire and store 45 consecutive parallel slices at 1 mm intervals. 
A volume is reconstructed by cubic-spline interpolation and then volume ren­dered. [McCann 1988] performed 
gated acquisition of a heart s image over a cardiac cycle by storing 2DE images on video tape and then 
reconstructing and volume rendering them. Repetitive low­pass filtering was used during reconstruction 
to fill the spaces between radial slices, which suppressed aliasing artifacts. [Tomographic Technologies 
1991] provides flexible re-slicingby up to 6 planes as well other imaging modes. [Collet Billon 1990] 
uses two visualization techniques: re-slicing by an arbitrary plane and volume rendering. The former 
allows faster but only 2D viewing on a current workstation. The latter allows 3D viewing but often involves 
cumbersome manual segmentation. The reconstruction algorithm uses straightforward low pass filtering. 
3. Incremental Volume Visualization We have been experimenting with volume rendering as one alternative 
for visualizing dynamic ultrasound volume data. Stan­dard volume rendering techniques which rely heavily 
on preprocess­ing do not apply well to dynamic data which must be visualized in real time [Levoy 1988; 
Sabella 1988; Upson 1988]. We review here an incremental , interactive, 3D ultrasound visualization technique 
which visualizes a 3D volume as it is incrementally updated by a sequence of registered 2D ultrasound 
images [Ohbuchi 1990; 1991]. Our target function is sampled at irregular points and may change over time. 
Instead of directly visualizing samples from this target, we reconstruct a reguktr 3D volume from this 
time series of spatially irregular sample points. This places a limit on storage and computation requirements 
which would grow without bound if we retained all the past sample points. The reconstructed volume is 
then rendered with an incremental volume-rendering technique. The reconstruction is a 4D convolution 
precess. A 3D Gaussian kernel is used for spatial reconstruction followed by a temporal reconstruction 
based on simple auto regressive moving average (ARM A) filtering [Haddad 1991]. Time stamps are as­signed 
to each 3D voxel, which are updated during reconstruction. The time stamp difference between a reconstructed 
voxel and an incoming sample is used to compute coefficients for the ARMA filter. The 3D Gaussian filter 
is loosely matched to the point spread function of the ultrasound transducer and is a good choice because 
it minimizes the product of spatial bandwidth and spatial frequency bandwidth [Hildreth 1983; Leipnik 
1%0]. An image-order, ray-casting algorithm based on [Levoy 1988] renders the final images incrementally. 
Rendering is incre­mental and fast only if the viewpoint is fixed and if the updated volume is relatively 
small. Shading and ray sampling are done only for voxels proximate to incoming data. The ray samples 
are stored Computer Graphics, 26, 2, July 1992 Figure 1. Two of 90 2D ultrasound echography images of 
a plastic toy doll phantom which was scanned in a water tank. The scans shown are at the torso (left) 
and at the head (right). The clouds at the bottom of the scans are artifacts due to reflections from 
the bottom of the water tank. in a 3D array in screen space called a ray cache for later use. The ray 
cache is hierarchical so that a small partial update of the ray cache can be composited quickly (0(&#38;(n))) 
[Ohbuchi 19911. The hierar- chical ray cache also allows fast rendering of polygons properly composited 
with volume data, which can enhance the volume visu-alization [Levoy 1990, Miyazawa 19913. This incremental 
volume rendering algorithm is not restricted to ultrasound and is applicable to other problems which 
update volume data incrementally, e.g., interactive volume modeling by sculpting [Galyean 19911. To test 
this visualization technique, we acquired a series of 2D images with a manually guided conventional 2DE 
scanhead attached to a mechanical tracking arm with 3 DOF (two translations and one rotation). As we 
scanned various targets in a water tank, their images and their corresponding geometry were stored off-line. 
We then ran the incremental volume visualization algorithm on a DECstation 5000 with 256 MB of memory 
using this data. With a reconstruction buffer size of 150 x 150 x 300 and an image size of 256 x 256, 
it took 15-20 seconds to reconstruct and render a typical image after insertion of a 2D data slice. This 
time varied with reconstruction, shading, and viewing parameters. Figure 1 shows 2 out of 90 2D images 
of a plastic toy doll phantom which is visualized in Figure 2. The 2D images were producedbyanATLMark-4Scannerwitha3.5MHzlinearscanhead. 
The 2D images overlap but are roughly parallel at approximately 2 mm intervals.  4. Virtual Environment 
Ultrasound Imaging Various medical ultrasound imaging applications require a registration of ultrasound 
images with anatomical references, e.g., in performing a fine needle aspiration biopsy of a suspected 
breast tumor [Fomage 19901. A virtual environment which displays images acquired by ultrasoundequipment 
in place within a patient s anatomy could facilitate such an application. We have developed an experi- 
mental system that displays multiple 2D medical ultrasound images overlaid on real-world images. In January 
1992, after months of development with test objects in water tanks, we performed our first experiment 
with a human subject. Our virtual environment ultrasound imaging system works as follows (note that this 
is a different system than our older one described in the previous section): as each echography image 
is acquired by an ultrasound scanner, its position and orientation in 3D world space are tracked with 
6 degrees of freedom (DOF). Simulta-neously the position and orientation of a HMD are also tracked with 
6 DOF. Using this geometry, an image-generation system generates 3D renderings of the 2D ultrasound images. 
These images are video mixed with real-world images from a miniature TV camera mounted on the HMD. The 
resulting composite image shows the 2D ultra- sound data registered in its true 3D location. Figure 3 
is a block diagram of our system s hardware. There are three major components: 1) an image-acquisition 
and tracking system, which consists of an ultrasound scanner and a Polhemus tracking system, 2) an image-generation 
system, which is our Pixel- Planes 5 graphics multicomputer, and 3) a HMD which includes a portable TV 
camera, a video mixer, and a VPL EyePhone. Each component is described in more detail in Sections 4.14.3. 
Figure 2. Reconstructed and rendered image of the toy doll phantom using incremental volume visualization. 
 SIGGRAPH 92 Chicago, July 26-31, 1992 environment are registered to the real world within the update-rate 
m k Ultrasound scanhead 2D B-mode II Ultrasound scanner m m mm arrays lE%E!Lr -32Prw s ~ Figure 3. 
Hardware block diagram for the virtual environment ultrasound system. 4.1 Image Acquisition and Tracking 
Two dimensional ultrasound images are generated by an IREX System III echography scanner with a 16 mm 
aperture 2.5 MHz phased array transducer. These images are digitized by a SUN 4 with a Matrox MVP/S real-time 
video digitizer and trans­ferred to our Pixel-Planes 5 graphics multicomputer [Fuchs 1989]. The SUN 4 
operates as a 2DE image server for requests from the Pixel-Planes 5 system. Images are distributed among 
the Graphics Processors (GPs) on a round-robin scan-line by scan-line basis. Due to the bandwidth limitations 
of the SUN 4 VME bus, transfer of the 512 x 480x 8 bits/pixel images is limited to 2 Hz. A Polhemus system 
with one source and two receivers is used for tracking [Polhemus 1980]. One receiver tracks the HMD. 
The other tracks the ultrasound transducer. The Polhemus system is mounted in non ferrous materials away 
from magnetic interference sources such as the ultrasound transducer, HMD, and other lab equipment. A 
calibration procedure is used to relate both the ultrasound transducer to its Polhemus receiver and the 
HMD TV camera to its Polhemus receiver mounted on the HMD. This calibration procedure is described in 
Section 4.4. 4.2 Image Generation Images are generated by the Pixel-Planes 5 system based on geometry 
information from the tracking system. Pixel-Planes 5 runs a custom PHIGS implementation which incorporates 
a facility to update display structures asynchronously from the display process. This separates the interactive 
virtual environment update rate from the 2D ultrasound image data acquisition rate. Images in the virtual 
limit of the tracking and display system and not within the acquisi­tion-rate limit of the image-acquisition 
system. Pixels from the 2D ultrasound images are rendered as small, unshaded sphere primitives in the 
virtual environment. The 2D ultrasound images appear as space-filling slices registered in their correct 
3D position. The ultrasound images are distributed among the GPs where they are clipped to remove unnecessary 
margins and transformed into sphere primitives, which are then sent to the Renderer boards for direct 
rasterization. Pixel-Planes 5 renders spheres very rapidly, even faster than it renders triangles, over 
2 million per second [Fuchs 1985; 1989]. Final images are assembled in double buffered NTSC frame buffers 
for display on the HMD. To reduce the number of sphere primitives displayed, the ultrasound images are 
filtered and subsampled at every 4th pixel. Due to the low resolution of the HMD and inherent bandwidth 
limitation of the ultrasound scanner, this subsampling does not result in a substantial loss of image 
quality. An option to threshold lower intensity pixels in 2D ultrasound images prior to 3D rendering 
can suppress lower intensity pixels from being displayed. 4.3 Video See. Through HMD A video see-through 
HMD system combines real-world im­ages captured by head-mounted TV cameras with synthetic images generated 
to correspond with the real-world images. The important issues are tracking the real-world cameras accurately 
and generating the correct synthetic images to model the views of the cameras. Correct stereo modeling 
adds concerns about matching a pair of cameras to each other as well as tracking and modeling them. [Roblnett 
1991] discusses stereo HMD in detail and includes an analysis of the VPL EyePhone. A Panasonic GP-KS 
102 camera provides monocular see­through capability for the left eye in our current system. Images from 
this camera are mixed with synthetic images from the Pixel-Planes 5 system using the luminance (brightness) 
keying feature on a Grass Valley Group Model 100 video mixer. With luminance keying, the pixels in the 
output image are selected from either the real-world image or the synthetic image, depending on the luminance 
of pixels in the synthetic image. The combined image for the left eye and a synthetic image only for 
the right eye are displayed on a VPL EyePhone. 4.4 Calibration Two transformations, a transducer transformation 
and a camera transformation, are needed to calibrate our test system. The transducer transformation relates 
the position and orientation of the Polhemus tracker attached to the ultrasound transducer to the position 
and scale of 2D ultrasound image pixels in 3D space. The camera transformation relates the position and 
orientation of the head-mounted Polhemus tracker to the HMD TV camera position, orientation, and field 
of view. Both transformations are calculated by first locating a cali­bration jig in both the lab (real) 
and tracker (virtual) 3D coordinate systems. This is accomplished by performing rigid body rotations 
with the transducer tracker about axes which are to be fixed in both the real and virtual coordinate 
systems. Two samples from the tracker, each consisting of both a position and an orientation, are  
 generation systems are needed if we are 10 be able to visualize usefully detailed 3D imagery.  6.2 
(lther Applications 1) Vision in surgery: In neurosurgery, ultrasound is already used m image nearby 
arteries that should be avoided by an impending surgical incision. 2) Burning buildings: With close-range, 
millimeter wavelength radar, rescuers may be able to see through the smoke in the interior of burning 
buildings. 3) Building geometry: Geometry or other structural data could be added to a live scene. In 
the above burning building scenario, parts of a building plan could be superimposed onto the visual scene, 
such as the location olstairways, hallways, or the best exits out of the building. 4) Service information: 
Information could be displayed to a service technician working on complicated machinery such as a jet 
engine. Even simpler head-mounted displays, ones without head tracking, already provide information to 
users on site and avoid using a large cumbersome video screens. Adding head tracking would allow 3D superimposition 
to show, for instance, the location of special parts within an engine. or the easiest path for removal 
or insertion of a subassembly. 5) Architecture on site: Portable systems could allow builders and architects 
to preview buildings on site before construction or visual­ize additions to existing architecture. With 
the work presented here and the identification of prob­lems and possibilities for further research. we 
hope to encourage applications not only of virtual environments (imaginary worlds), but also applications 
that involve an enhancement of vision in our real world. Acknowledgments We would like to thank the 
following people: David Chen and Andrew Brandt for experimental assistance: General Electric Medical 
Systems (and especially R. Scott Ray) for the loan of an ultrasound scannen Stefan Gottschalk for much 
assistance with video acquisition, editing, and printing; Professor Olaf von Ramm (Duke University) for 
donation of the IREX ukrdsound scannefi ultrasound technician George Blanchard, RDMS, for scanning the 
subject; David Harrison and John Hughes for video and laboratory setup: Andrei State for experimental 
assistance; John Thomas for fabrication of a custom camera mount; Terry Yoo for video tape editing: Vem 
Katz, MD, for assistance with multiple ultrasound machines and scanning experiments; Nancy Chescheir, 
MD, for loan of an ultrasound machine and arrangements with the ultrasound technician: Warren Newton. 
MD, and Melanie Mintzer, MD, for finding our subject; Warren Robinett and Rich Holloway, for consul­tation 
with HMD optics and software; Professor Stephen Pizer and Charlie Kurak for consultation on the difficulty 
of enhancing ultra­sound images: David Adam (Duke University) for instruction in the use of tbe IREX 
scanner: and our subject and her husband for their time and patience. This research is partially supported 
by DARPA ISTO con­tract DAEA 1R-90 -C-(W44,NSFERC grant CDR-86-2220 1, DARPA Computer Graphics, 26,2, 
JUIV 1992 ISTO contract 7510, NSF grant MI P-9000894, NSF cooperative agreement ASC-89202 19, and NIH 
MIP grant PO I CA 47982, and by Digital Equipment Corporation. References [Brinkley 1978] Brinkley, J. 
F., Moritz, W. E., and Baker, D.W. Ultrasonic Three-Dimensional Imaging and Volume From a Series of Arbitrary 
Sector Scans. Ultrasound in Med. &#38; Biol,, 4, pp~ 17-327. [Collet Billon 1990] Collet Billon, A., 
Phi/ips Paris Research Ld. Personal Communication. [Fomage 1990j Fomage, B. D., Sneige, N., Faroux, M,J,, 
and Andry, E. Sonographic appearance and ultrasound guided fine-nee le ! aspiration biopsy of brest carcinomas 
smaller than 1 cm . Jaurnal of Ultrasound in Medicine. 9, pp559-568. [Fuchs 1985] Fuchs, H., GoldFeather, 
J,, Hultiquist, J. P., Spach, S., Austin, J., Brooks, Jr,, F,P,. Eyles. J., and Poulton, J. Fast Spheres. 
Textures, Transparencies, and Image Enhancements in Pixel Planes. Computer Graphi[s (Proceedings of 
.WGGRAPH 8.$). 19(3), ppi 11-120. [Fuchs 19891 Fuchs, H., Poulton, J., Eyles, J., Greer. T., Goldfeather, 
J., Ellsworth, D., Molnar. S., and Israel, L. Pixel Planes 5: A Heterogeneous Multiprocessor Graphics 
System Using Proces­sor-Enhanced Memories. Computer Graphics (Proceedings of SIGGRAPH 89). 23(3). pp79-X8. 
[Galyean 1991] Galyean, T. A., and Hughes. J.F. Sculpting: An Interactive Volumetric Modeling Technique. 
 Conrpurer Graph­ic,s (Pro(eedin<y,v of SIGGRAPH 89), 25(4), pp267-274. lGeiser 1982a] Geiser, E. A.. 
Ariet, M,, Conetta, D. A., Lupkiewicz, S.M., Christie, L.C., and Con[i, C.R. Dynamic three-dimen­sional 
echocardiographic reconstruction of the intact human left ventricle: Technique and initial observations 
in patients . Arneri­can Heart ./mows/, 103(6). pp 1056-1065. [Geiser 1982b] Geiser, E. A.. Christie, 
L.C., Conetta, D.A., Conti, C. R., and Gossman, G.S. Mechanical Arm for Spatial Registra­tion of Two-Dimensional 
Echographic Sections. Carher. Cariora.w. Diagn.,8,pp89-101, [Ghosb 1982] Ghosh, A,, Nanda, C. N., and 
Maurer, G. Three-Dimensional Reconstruction of Echo-Cardiographics Images Using The Rotation Method. 
U/trusound in Med. &#38; Bird., 8(6), pp655-661. [Haddad 199 I I Haddad, R, A., and Parsons, T.W. Digital 
Signal Proce.xsin,q, Theory, Applications, and Hard~are. New York. Computer Science Press. [Harris 1990] 
Harris, R. A., Follett, D. H., Halliwell, M, and Wells, P.N.T. Ultimate limits in ultrasonic imaging 
resolution. U/fra­.soutrd in Medicine urrd Biology, 17(6), pp547-558. [Hildreth 1983] Hildreth, E, C. 
The Detection of Intensity Changes by Computer and Biological Vision Systems. Compu[er Vision, Graphi[s, 
and lmu~e Processing, 22, pp 1-27. [Hottier 1989] Hottier. F.. Phi/ips Paris Research Lub. Personal Communication. 
[Hottier 1990] Hottier, F.. Collet Billon, A, 3D Echngruphy: Stafus and Perspecrire. 3D Imaging in Medicine. 
Springer-Verlag. pp21-41. [Itoh 19791 Itoh, M., and Yokoi, H. A computer-aided three­dimensional display 
system for ultrasonic diagnosis of a breast tumor. Ukra.wmics, , pp26 I -268. [King 1990] King. D. L., 
King Jr., D. L., and Shao, M.Y, Three-Dimensional Spatial Registration and Interactive Display of SIGGRAPH 
92 Chicago, July 26-31, 1992 Position and Orientation of Real-Time Ultrasound Images. Journal of Ultrasound 
Meal,9, pp525-532. [Lalouche 1989] Lalouche, R. C., Bickmore, D., Tessler, F., Mankovich, H. K., and 
Kangaraloo, H. Three-dimensional re­construction of ultrasound images. SPIE 89, Medical Imaging, pp59-66. 
[Leipnik 1%0] Leipnik, R. The extended entropy uncertainty principle. Info. Control, 3, ppl 8-25. [I-soy 
1988] Levoy, M. Display of Surface from Volume Data. IEEE CG&#38;A, 8(5), pp29-37. [Levoy 1990] Levoy, 
M. A Hybrid Ray Tracer for Rendering Polygon and Volume Data. IEEE CG&#38;A, 10(2), pp33-40. [Liang 1991] 
Liang, J., Shaw, C., and Green, M. On Temporal-Spatial Realism in the Virtual Reality Environment. User 
Interface Sofware and Technology, 1991, Hilton Head, SC., U. S. A., pp19-25. [Lin 1991] Lint W., Pizer, 
S. M., and Johnson, V.E. Surface Estima­tion in Ultrasound Images. Information Processing in Medical 
imaging i99J, Wye, U. K., Spnnger-Verlag, Heidelberg, pp285­ 299. [Matsumoto 1981] Matsumoto, M., Inoue, 
M., Tamura, S., Tanaka, K., and Abe, H. Three-Dimensional Echocardiography for Spatial Visualization 
and Volume Calculation of Cardiac Struc­tures. J. Clin. Ultrasound, 9, ppl 57-165. [McCann 1988] McCann, 
H. A., Sharp, J. S., Kinter, T. M., McEwrm, C.N., Barillot, C., and Greerdeaf, J.F. Multidimensional 
Ultra­sonic Imaging for Cardiology. Proc.lEEE, 76(9), pp 1063­1073. [Mills 1990] Mills, P. H., and Fuchs, 
H. 3D Ultrasound Display Using Optical Tracking. First Conference on Visualization for Biomedical Computing, 
Atlanta, GA, IEEE, pp490-497. [Miyazawa 1991] Miyazawa, T. A high-speed integrated rendering for interpreting 
multiple variable 3D data. SPIE, 1459(5), [Molnar 1992] Molnar, S., Eyles, J., and Poulton, J. PixelFlow: 
High-Speed Rendering Using Image Composition. Computer Graphics (Proceedings of SIGGRAPH 92), ((In this 
issue)), [Moritz 1983] Moritz, W. E., Pearlman,A.S., McCabe, D.H., Medema, D. K., Ainsworth, M. E., and 
Boles, M.S. An Ultrasonic Technique for Imaging the Ventricle in Three Dimensions and Calculating Its 
Volume. IEEE Trans. Biom. Eng., BME-30(8), pp482-492. [Nakamura 1984] Nakamura, S. Three-Dimensional 
Digital Dis­play of Ultrasonograms. lEEE CG&#38;A, 4(5), pp36-45. [Ohbuchi 1990] Ohbuchi, R., and Fuchs, 
H. Incremental 3D Ultra­sound Imaging from a 2D Scanner. First Conference on Visu­alization in Biomedical 
Computing, Atlanta, GA, IEEE, pp360­ 367. [Ohbuchi 1991] Ohbuchi, R., and Fuchs, H. Incremental Volume 
Rendering Algorithm for Interactive 3D Ultrasound Imaging. Information Processing in Medical Imaging 
1991 (L-ectureNotes in Computer Science, Springer-Verlag), Wye, UK, Springer-Verlag, pp486-500. [Pini 
1990] Pini, R., Monnini, E., Masotti, L., Novins, K. L., Greenberg, D. P., Greppi, B., Cerofolini, M., 
and Devereux, R. B. Echocardiographic Three-Dimensional Visualization of the Heart. 3D Imaging in Medicine, 
Travemunde, Germany, F 60, Spnnger-Verlag, pp263-274. [Polhemus 1980] Polhemus. 3Space Isotrak User s 
Manual. [Raichelen 1986] Raichelen, J. S., Trivedi, S. S., Herman, G.T., Sutton, M.G., and Reichek, N. 
Dynamic Thee Dimensional Reconstruction of the Left Ventricle From Two-Dimensional Echocardiograms. Journal. 
Amer. Coil. of Cardiology, 8(2), pp364-370. [Robinett 1991] Robinett, W., and Rolland, J.P. A Computational 
Model for the Stereoscopic Optics of a Head-Mounted Display. Presence, l(l), pp45-62. [Sabella 1988] 
Sabella, P. A Rendering Algorithm for Visualizing 3D Scalar Fields. Computer Graphics (Proceedings of 
SIGGRAPH 88), 22(4), pp5 1-58. [Shattuck 1984] Shattuck, D. P., Weishenker, M. D., Smith, S.W., and von 
Ramm, O.T. Explososcan: A Parallel Processing Technique for High Speed Ultrasound Imaging with Linear 
Phased Arrays. JASA, 75(4), pp1273-1282. [Smith 1991] Smith, S. W., Pavy, Jr., S.G., and von Ramm, O.T. 
High-Speed Ultrasound Volumetric Imaging System -Part I: Transducer Design artd Beam Steering. IEEE 7 
ransacfion on Ultrasonics, Ferroelectrics, and Frequency Control, 38(2), pp100-108. [Stickels 1984] Stickels, 
K. R., and Warm, L.S. An Analysis of Three-Dimensional Reconstructive Echocardiography. Ultra­sound in 
Med. &#38; Biol., 10(5), pp575-580. ~ijssen 1990] Thijssen, J. M., and Oosterveld, B.J. Texture in Tissue 
Echograms, Speckle or Information ? Journal of Ultra­sound in Medicine,9,pp215-229. [Tomographic Technologies 
1991 ] Tomographic Technologies, G. Echo-CT. [Upson 1988] Upson, C., and Keeler, M. VBUFFER: Visible 
Volume Rendering. ACM Computer Graphics (Proceedings of SIGGRAPH 88), 22(4), pp59-64. [vonRarnm 1991 
]von Ramm, O. T., Smith, S.W., and Pavy,Jr., H.G. High-Speed Ultrasound Volumetric Imaging System -Part 
II: Parallel Processing and Image Display. IEEE Transaction on Ultrasonics, Ferroeiectrics, and Frequency 
Control, 38(2), pplo9-115. [Ward 1992] Ward, M., Azuma, R., Bemett, R., Gottschalk, S., and Fuchs, H. 
A Demonstrated Optical Tracker with Scalable Work Area for Head-Mounted Display Systems. 1992 Symposium 
on Interactive 3D Graphics, Cambridge, MA., ACM, pp43-52. [Wells 1977] Wells, P. N. T. Biomedical ultrasonics. 
London, Academic Press.  
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134063</article_id>
		<sort_key>211</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>24</seq_no>
		<title><![CDATA[Sound rendering]]></title>
		<page_from>211</page_from>
		<page_to>220</page_to>
		<doi_number>10.1145/133994.134063</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134063</url>
		<keywords>
			<kw><![CDATA[audio]]></kw>
			<kw><![CDATA[multimedia]]></kw>
			<kw><![CDATA[physically-based modeling]]></kw>
			<kw><![CDATA[soundtrack]]></kw>
			<kw><![CDATA[virtual reality]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Animation</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>H.5.1</cat_node>
				<descriptor>Audio input/output</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Virtual reality</descriptor>
				<type>S</type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10003120.10003121.10003124.10010870</concept_id>
				<concept_desc>CCS->Human-centered computing->Human computer interaction (HCI)->Interaction paradigms->Natural language interfaces</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010387.10010866</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Graphics systems and interfaces->Virtual reality</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010583.10010588.10003247</concept_id>
				<concept_desc>CCS->Hardware->Communication hardware, interfaces and storage->Signal processing systems</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002951.10003317.10003371.10003386.10003389</concept_id>
				<concept_desc>CCS->Information systems->Information retrieval->Specialized information retrieval->Multimedia and multimodal retrieval->Speech / audio search</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010352</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Animation</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
			<gt>Design</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>PP31046923</person_id>
				<author_profile_id><![CDATA[81100543225]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Tapio]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Takala]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Helsinki University of Technology, 02150 Espoo, Finland]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>PP77036947</person_id>
				<author_profile_id><![CDATA[81100617606]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[James]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Hahn]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[The George Washington University, Washington, DC 20052]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_obj_id>378509</ref_obj_id>
				<ref_obj_pid>378456</ref_obj_pid>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Barzel, R, A.Barr. Modeling with Dynamic Constraints. Prec. SIGGRAPH'88, ACM Computer Graphics, Vol.22, No.3, pp.178-188.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Blattner, Meera, D.Sumikawa, R.Greenberg. Earcons and Icons: Their Structure and Common Design Principles. Human-Computer Interaction, Vol.4, No.I, 1989, pp.ll-44. Also reprinted in" E.Glinert (ed.), Visual Programming Environments- Applications and Issues, IEEE Computer Society Press 1990, pp.582-606.]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_obj_id>808602</ref_obj_id>
				<ref_obj_pid>964965</ref_obj_pid>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Cook, Robert. Shade Trees. Prec. SIGGRAPH'84, ACM Computer Graphics, Vol. 18, No.3, pp.195- 206.]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_obj_id>807507</ref_obj_id>
				<ref_obj_pid>800250</ref_obj_pid>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[Feibush, E.A., M.Levoy, R.Cook. Synthetic Texturing Using Digital Filters. Proc. SIGGRAPH'80, ACM Computer Graphics, Vol.14, No.3, pp.294-301.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[Foster, S, E.Wenzel. Virtual Acoustic Environments: TheConvolvotron. {multimedia installation} SIGGRAPH'91 Virtual reality and hypermedia show (August 1991).]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_obj_id>533396</ref_obj_id>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[Gaver, William. The SonicFinder: An Interface That Uses Auditory Icons. Human-Computer Interaction, Vol.4, No.I, 1989, pp.67-94. Also reprinted in: E.Glinert (ed.), Visual Programming Environments- Applications and Issues, IEEE Computer Society Press 1990, pp.561-58 I.]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378530</ref_obj_id>
				<ref_obj_pid>378456</ref_obj_pid>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Hahn, James. Realistic Animation of Rigid Bodies. Proc. SIGGRAPH'88, ACM Computer Graphics, Vol.22, No.3, pp.299-308]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122738</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[He, Xiao, K.Torrance, F.Sillion, D.Greenberg. A Comprehensive Physical Model for Light Reflection. Proc. SIGGRAPH'91, ACM Computer Graphics, Vol.25, No.3, pp. 175-186.]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_obj_id>110888</ref_obj_id>
				<ref_obj_pid>110883</ref_obj_pid>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Lytle, Wayne. More Bells and Whistles. {video} in SIGGRAPH'90 film show. Also described in Computer, Vol.24, No.7, July 1991, p.4 and cover.]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[NCSA Visualization Group and CERL Sound Group. Using Sound to Extract Meaning from Complex Data. {video} SIGGRAPH'91 Screening Room, Visualization &amp; Technical series (August 1991).]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
			<ref>
				<ref_obj_id>74355</ref_obj_id>
				<ref_obj_pid>74334</ref_obj_pid>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[Pentland, Alex, J.Williams. Good Vibrations: Modal Dynamics for Graphics and Animation. Proc. SIGGRAPH'89, ACM Computer Graphics, Vol.23, No.3, pp.215-222.]]></ref_text>
				<ref_id>11</ref_id>
			</ref>
			<ref>
				<ref_obj_id>325247</ref_obj_id>
				<ref_obj_pid>325165</ref_obj_pid>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[Perlin, K. An Image Synthesizer. Proc. SIGGRAPH'85, ACM Computer Graphics, Vol. 19, No.3, pp.287-296.]]></ref_text>
				<ref_id>12</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122739</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[Sillion, Franqois., J.Arvo, S.Westin, D.Greenberg. A Global Illumination Solution for General Reflectance Distributions. Proc. SIGGRAPH'91, ACM Computer Graphics, Vol.25, No.3, pp. 187-196.]]></ref_text>
				<ref_id>13</ref_id>
			</ref>
			<ref>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[Smith, J.W. Vibration of Structures - Applications in Civil Engineering Design. Chapman &amp; Hall 1988]]></ref_text>
				<ref_id>14</ref_id>
			</ref>
			<ref>
				<ref_obj_id>74353</ref_obj_id>
				<ref_obj_pid>74334</ref_obj_pid>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[Stettner, Adam, D.Greenberg. Computer Graphics Visualization for Acoustic Simulation. Proc. SIGGRAPH'89, ACM Computer Graphics, Vol.23, No.3, pp. 195-206.]]></ref_text>
				<ref_id>15</ref_id>
			</ref>
			<ref>
				<ref_obj_id>37427</ref_obj_id>
				<ref_obj_pid>37402</ref_obj_pid>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[Terzopoulos, Dimitri, J.Platt, A.Barr, K.Fleischer. Elastically Deformable Models. Proc. SIGGRAPH'87, ACM Computer Graphics, Vol.21, No.3, pp.205- 214.]]></ref_text>
				<ref_id>16</ref_id>
			</ref>
			<ref>
				<ref_seq_no>17</ref_seq_no>
				<ref_text><![CDATA[Thomas, Frank, O.Johnston. Disney Animation - The Illusion of Life, chapter 11. Abbeville Press 1981.]]></ref_text>
				<ref_id>17</ref_id>
			</ref>
			<ref>
				<ref_seq_no>18</ref_seq_no>
				<ref_text><![CDATA[Upstill, Steve. The RenderMan Companion. Pixar/Addison-Wesley, 1989.]]></ref_text>
				<ref_id>18</ref_id>
			</ref>
			<ref>
				<ref_seq_no>19</ref_seq_no>
				<ref_text><![CDATA[Voss, Richard and J.Clarke. "l/f noise" in Music: Music from 1/f Noise. J. Acoust. Soc. Am. 63 (I), January 1978, pp.258-263.]]></ref_text>
				<ref_id>19</ref_id>
			</ref>
			<ref>
				<ref_seq_no>20</ref_seq_no>
				<ref_text><![CDATA[Voss, Richard. Fractals in Nature: Characterization, Measurement, and Simulation. SIGGRAPH'87 Course Notes.]]></ref_text>
				<ref_id>20</ref_id>
			</ref>
			<ref>
				<ref_seq_no>21</ref_seq_no>
				<ref_text><![CDATA[Wightman, Frederick, D.Kistler. Headphone Simulation of Free-Field Listening. I" Stimulus Synthesis. J. Acoust. Soc. Am. 85 (2), February 1989, pp.858-867.]]></ref_text>
				<ref_id>21</ref_id>
			</ref>
			<ref>
				<ref_seq_no>22</ref_seq_no>
				<ref_text><![CDATA[Wyshynski Susan, The Vivid Group. The Mandala VR System. {multimedia installation} in SIGGRAPH'91 virtual reality and hyl~rmedia show (August 1991).]]></ref_text>
				<ref_id>22</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 4! Computer Graphics, 26,2, July 1992 Sound Rendering Tapio Takala* and James Hahn~ *Helsinki University 
of Technology 02150 Espoo, Finland tThe George Washington University Washington, DC 20052 Abstract 1 
Introduction We present a general methodology to produce synchronized In traditional hand-drawn animation, 
sound effects and their soundtracks for animations. A sound world is modeled by synchronization to the 
motion are of utmost importance. associating a characteristic sound for each object in a scene. Often 
the whole story is first composed as a musical bar These sounds can be generated from a behavioral or 
sheet, on which the movements are designed based on keyphysically-based simulation. Collision sounds 
can be events [17]. Sounds are usually dubbed onto the action after computed from vibrational response 
of elastic bodies to the the motions are generated but this is a tedious manual collision impulse. Alternatively, 
stereotypic recorded sound process and requires expertise to synchronize correctly. In effects can be 
associated with each interaction of objects. computer animation, similar techniques have been used in 
Sounds may also be generated procedurally, The sound key-framing and rotoscoping. However, most of the 
world is described with a sound event file, and is rendered in computer animations produced have emphasized 
the motion two passes. First the propagation paths from 3D objects to itself and have added sound during 
post-production. The each microphone are analyzed and used to calculate sound major reason is that there 
does not yet exist a generaltransformations according to the acoustic environment. framework for sound 
synchronization. This is especially These effects are convolutions, encoded into two essential true in 
behavioral or physically-based motion control where parameters, delay and attenuation of each sound. 
Time­the lack of absolute control have made the motion-to-sound ciependency of these two parameters is 
represented with synchronization difficult. A notable exception from thekey frames, thus being completely 
independent of the mainstream is the film More Bells and Whistles [9]. original 3D animation script. 
In the second pass the sounds There, both music and animation were designed as a single associated with 
objects are instantiated, modulated by score, which served as a synchronizing controller for both interpolated 
key parameters, and summed up to the final MIDI-driven music synthesizers and animated syntheticsoundtrack. 
The advantage of a modular architecture is that actors. the same methods can be used for all types of 
animations, keyframed, physically-based and behavioral. We also discuss Video games and multimedia installations 
[22] have the differences of sound and light, and the remarkable also relied on synchronized sound. Sound 
as another similarities in their rendering processes. dimension of interaction has been utilized in user 
interfaces to symbolize objects and to draw attention to alerts [6, 2]. In scientific visualization, 
sound can be used to characterize CR Categories and Subject Descriptors: 1.3.7 objects attributes and 
to emphasize timing of events [10]. [Computer Graphics]: Animation. Simulations of sound wave propagation 
have been done to analyze room acoustics or dummy head models [21], and Additional keywords: audio, multimedia, 
soundtrack, special hardware built to perform these effects in real time physically-based modeling, virtual 
reality. [5], but to our knowledge none of these has been combined with animated graphics except for 
visualizing the acoustical parameters [15]. 1.1 The Nature of Sound Permiwltm h} copy without fee all 
or part of this material !s granted provided that the copies orc not made or distributed for direci As 
waves, both light and sound behave similarly in many commercial advantage, the ACM cupyrigh[ notice and 
the title nf the ways. Both propagate as wavefronts, spreading in all publication and Its date appear, 
and nmice is gwen that copying is by directions according to the Huygens principle. They reflect permission 
of the Association fur Computing Machinery. To COPY ntherwise, or to republish, requires a fee and/or 
specific permission. and refract whenever there are discontinuities in the <,.ly)~ 211 AcM-()-89791-479 
-1192/(x171()211 $01.50 medium, and obstacle edges cause diffraction. However, their different propagation 
speeds and wavelengths cause essentialpracticaldifferences.Light travelsinstantaneously withoutnoticeabledelay,andits 
wavenatureonlyappears when it interacts with structures of microscopic size. On the other hand, the speed 
of sound easily causes delays perceived as echo or reverberation. There is considerable diffraction, 
too, because the wavelength is of human proportions the sound propagates around the edges of objects. 
For these reasons, sound propagation cannot be accurately traced using simple ray optics. The human sensory 
organs for light and sound are sensitive to different characteristics. The eye has good spatial resolution, 
whereas the ear integrates signals from all directions. Light is sensed as a color spectrum integrated 
over a period of time, and not as individual waveforms. Sound instead is perceived in time rather than 
as a stationary spectrum in frequency domain. 1.2 Sound Signals and Convolutions Sound is a one-dimensional 
signal that can be represented as an intensity regularly sampled in time. Out of possible representations 
this appears to be the most general and suitable for our purposes. The concepts of pitch and note length 
are akin to traditional music but are unable to describe speech or noise. A spectral distribution (Fourier 
transform) with phase and amplitude of each component is theoretically complete, but is intuitively difficult 
for other than stationary waveforms, and is not at all suitable for time-dependent effects like echo. 
Similar arguments apply to other integral representations, like Laplace transform for example. As an 
object generates sound in a three-dimensional environment, it acts like a light source in image rendering. 
Its signal is propagated in all directions, reflected and refracted by other objects and participating 
media, and finally caught by a receiver. The received signal is an integral of signals via multiple simultaneous 
paths from the emitter to the receiver. To compute this integral, each possible path can be independently 
traced through the environment, its effects on the sound signal calculated, and the results composed 
as a convolution of the original sound m received(t) = w(t,%) oemitted(t ~) dr ~ o where w(t,~) is 
the amount of signal received through all paths with delay z. The convolution weighting function w(t,@ 
corresponds to the paths of different lengths causing different delays and attenuations for the same 
signal. Generally it is time­dependent, continuous and semi-infinite. For computational purposes it has 
to be discretized into a finite number of samples. The script format we are going to present is a possible 
way to do this, emphasizing the role of moving objects as the cause of time-dependencies in convolution. 
1.3 Outline of the Paper In this paper we present a structured methodology for generation, representation, 
and synchronization of sounds in computer animation. In section 2, we will outline the overall system 
structure as a pipeline with sound signals flowing through it. This is followed by a detailed description 
of each module of the system. First, (swtion 3) we describe how natural sounds may be generated by physical 
phenomena and how characteristic sounds are attached to geometric objects in three-dimensional space 
(section 4). Next, we show how the modulation of signals due to their propagation in an environment can 
be represented as convolutions (section 5). The finat process is the rendering of key-framed sounds by 
resampling the original signals (section 6). Examples of various effects are also presented.  2 Sound 
Rendering Pipeline Thebasic idea in our approach is that sounds are treated as one-dimensional data objects 
associated with geometric objects of a three-dimensional world. Each sound is a time­dependent signal. 
Much like a graphical texture map, it is located on a geometric object, but extends in time instead of 
spatial dimensions. It may be bounded or semi-infinite. In the latter case it can be either a repeated 
waveform or a fractal-like continuously changing noise pattern. We call sound rendering the process of 
forming the composite soundtrack from component sound objects. This is due to its methodological similarity 
to image rendering and texture mapping and its close connections to the same geometric data. To keep 
the process manageable, we have divided it into a pipeline of processes, as shown by the overall system 
architecture in figure 1. First process (I) is the generation of the prototype sounds that are characteristic 
of each object and its interaction with others. These can be eitherbased on modal analysis of elastic 
body vibrations, or they can be user-defined (recorded or synthesized). In the next process (II), the 
prototype sounds are instantiated arid attached to moving three-dimensional objects, based on the same 
physical or behavioral simulation that controls motion. Following that, (111)the modulatoq effects of 
the three-dimensional environment are computed as transformations from sounds on the objects to sounds 
at a microphone. These time-dependent sound transformations are represented independently of the original 
object sounds, and are finally (IV) applied to the sounds in the last process. Thus just a reference 
of prototype sound goes through processes 11and 111,and the samples are actually used only in process 
IV, The sounds produced by objects may be endogenous like barking, yelling or talking. Such prototypes 
can be digitally recorded, analogous to using digitized photographic images as textures. Alternatively 
they may be synthesized by behavioral models, like the buzz of a bee determined by the way it flies. 
Other, more physically-based sounds emanate from vibrations of bodies, caused by interactive Computer 
Graphics, 26, 2, July 1992 physical objeel data m c .­= -characteristictOeech u objecl ad interaction 
E ~ ~ v ssound event U1 -cdlialms ript and friction -promlype sounds modulatd by the object s or intaracsion 
senergy asounds attached to 3D objeets D animation script -sound objectstransformed to the microphonecoordinate 
system(timetrame) m c.­ &#38; ~ I dala I ab ~ frames = Im.yb m user-defined of sound scrip! Figure 
1: Parallel pipelines for image and sound rendering. may undergo various modulations during its course 
from a forces between objects and their environment. Examples of geometric object to the microphone, 
through the simulated these are collisions, friction, and turbulent air flow around environment. It is 
attenuated due to the dispersion of energy an object. Spectral composition may be used for these in space, 
and is delayed by fhe traveling time along a sound sounds, as has been used for textures [12]. path. 
The emission of sound from an object may vary by In our system, we separate a sound and its association 
direction, and it maybe reflected, refracted or obscured by to objects. The characteristic potential 
sound is represented other objects, much as light waves are. The sound s as a sampled signal or procedure, 
whereas its instantiation spectrum (sound color or timbre) may be modified in these is described in a 
sound script. The script describes when and interactions, as well as due to the participating medium. 
how a characteristic sound is actually generated, determined Finally, the intensity of a sound hemd by 
a microphone by certain events in the animation, like physically may vary due to its directional sensitivity. 
These processes calculated collisions. Attachment of prototype sounds to correspond to the mapping of 
textures from geometric objects located in space-time is comparable to the geometric objects to the image 
plane. This is why we use the terms mapping of textures to object s surfaces. objec[ space and image 
space for the time-frames of sounds as well as for the corresponding geometric coordinateFor an animation, 
the sounds are recorded by virtual systems. microphones usually attached to a virtual camera. A sound 
Since sound signals are additive, all the effects described above are computed in a resampling process 
independently for each emitted sound, and summed up (mixed) to make a complete soundtrack. In stereo, 
this will be done separately for each channel. We have implemented an experimental sound renderer as 
a collection of software modules that can be pipelined together. Our implementation is written in C language 
and currently runs on a Macintosh IIci. For this equipment the sound intensities are represented with 
only 8-bit sample resolution, causing noticeable digitization noise. For higher quality sounds, we have 
used AIFF files with 16-bit resolution, from which the sounda are reproduced with Silicon Graphics Indigo. 
As an alternative, we have also considereda MIDI-basedinterfaceto a high-quality music synthesizer, with 
object sounds selected from its library and modulated in real time. However, it has appeared rather difficult 
to find suitable MIDI-driven components to produce all the effects needed. v do(x) ~ x-D  x -0.0 x. 
1.0 n=l 0.3s 0.17 n=2 n.3 0.10 0.07   =4rT l 0.04 numb.r .mplitud. Figure 2: Vibration modes of 
a guitar string. 3 Sound Synthesis Sound can be synthesized from physical principles in the same way 
as physically-based motion control generates motion [1, 16]. However, this is a much more difficult problem, 
because many material factors involved are poorly known. In this sense it is analogous to determining 
color of a material based on its physical properties [8]. Some heuristics can be used to simplify the 
process for certain classes of sounds. 3.1 Vibration of Bodies Many sounds are generated when objects 
vibrak after being struck. The process is difficult to model for arbhm.ry objects without using complex 
finite-element models [14]. One way to attack this problem is to calculate the natural vibration modes 
of a body, and to approximate a complex vibration as a weighted sum of them [11]. Though not strictly 
correct for transient vibrations, this approach can be developed to give subjectively quite acceptable 
results. Crucial in it is the ability to calculate the appropriate weight for each mode, based on the 
body s deformation at a collision. This is generally a complex problem. In the following we demonstrate 
it with a simple example. In thin bars or strings of musical instruments, the natural harmonics are standing 
waves with displacements along the string given as dn(x) = wn sin(nnx). The vibration modes are orthogonal, 
so assuming the initial rest position of the string as dJx), the weighting factor of each mode is the 
integral * 1 Wn = Ido(x) .dn(x) dx o For example, we assumed the initial displacement to be triangular, 
as when stretching a guitar string with a pick (figure 2). Then do(x) = ~ for x SD, do(x) =% forx2D and 
the weights will be The sum of the weighted components is multiplied by an exponential decay function, 
with damping factor proportional to the frequency. This gives a waveform corresponding to the displacement 
of string at the point where it was struck, which can be used as a prototype collision sound for the 
string. Each stroke of the string will then generate an instance of that sound, with amplitude proportional 
to the magnitude of the collision impulse. 3.2 Friction and Turbulence Noise Sounds generated by two 
objects rubbing against each other is a poorly understood process caused by microscopic surface features 
of the materials of the two objects. We have chosen to represent the process as a combination of two 
factors. First, the surface features cause both of the objects to vibrate in the same way as a phonograph 
needle vibrates when dragged in the groove of a record disk. The waveform of the sound generated is similar 
to the shape of surface imperfections of the objects. The so-called I/f-noise [19, 20] could be used 
to model this phenomenon for rough surfaces. Another type of frictional noise we have simulated is generated 
by an object which alternates between sliding and sticking on a surface. This kind of interaction happens, 
for example, between a violin string and the bow. The resulting sound signal is approximated as a sawtooth 
waveform. Variation in the coefficients of friction can be modeled by adding some randomness to the wavelength, 
introducing noise to the sound. Objects that disturb the air by causing turbulence a~so generate sounds. 
Modeling the frequency components of this phenomenon is difficult and outside the scope of this paper. 
We simply represent this as white noise modulated by the velocity of the object through the air and by 
the amount of air that it disturbs (a purely geometric factor with experimental values). 3.3 Other Procedural 
Sounds Other subjectively interesting sounds can be genemted with procedures that are not physically-based 
but model the behavior of an object. For example, we have synthesized the sound of an ambulance siren 
as a single tone frequency­modulated by a slow sine wave (figures 4 and 7). The insect-like sound for 
behaviorally animated bees (figure 9), was generated as a constant wave-form with a noisy but narrowly 
tuned wave-length. Each bee of a swarm has a distinct base frequency that slowly drifts around a preselected 
mean frequency, either randomly or according to the bee s velocity.  4 Attaching Sounds to Objects 
In hand-drawn animation, all important events, like the bounce of a hit in figure 3, are located at frame 
times. These key frames can k used to synchronize sound effects. For example, we can mark the starting 
times of each recorded sound effect and use a sequencer and mixer to put them all together. Comouter 
GraDhics, 26.2. Julv 1992 In addition to the starting time, we can also specify the sound s amplitude 
any time along its duration. Between these key values the amplitude can be interpolated (lower part of 
figure 3). What we have described are sound [breads. These are sequences of key values extending over 
the sounds lifetime for each sound event. They can be put in an interface file as a sound script, described 
in detail in section 6. The key events of a script cart be either defined by the animator, like in the 
example above, or automatically computed by a behavioral or physically-based motion control. For example, 
we have used the impulse after a collision calculated by a physically-based motion control for rigid 
bodies [7] to define the script (figure 8 shows a frame from the animation). For each object involved 
in a collision, a sound thread is started at the time of collision with an amplitude proportional to 
the impulse. With this method we can automatically produce accurately synchronized sound effects for 
complex situations that would be very difficult to achieve by other means. Some sounds, like the turbulent 
wind noise, have infinite extent. They are represented in the script as threads extending throughout 
the duration of an animation scene. 5 Sound Propagation In the following, we overview various effects 
of the acoustical environment and demonstrate how they can be incorporated into the system. The purpose 
is not to make detailed modeling of acoustics, but to show that each effect can be encoded as a transformation 
in the sound rendering script. Figure 3: Keyframedsound threadfor a hand-drawn animation. ~om position 
 IIIII III[II -50 -40 -30 -20 -lo 0 10 20 30 4050m object space sound image space sound  Figure 4: Key-framed 
values of amplitude and delay for a moving sound source, and the corresponding mapping of sound signal 
from object to image space. Figure 4 illustrates sound animation of an ambulance 5.1 Effects of Distance 
and Direction passing a standing listener. The image space sound envelope shows the amplitude variation 
due to the 1:5 ratio The simplest acoustic effect is due to the dispersion of in minimum and maximum 
distance between source andsound waves into the environment. Assuming no other receiver of sound. Driving 
speed of 100 km/h gives aattenuation, the intensity decays proportionally to the noticeable Doppler effect, 
with a deviation in pitch roughly square of the distance travelled, and the signal is delayed by corresponding 
to two halftones up and down from the car s a time proportional to the same distance. Denoting sound 
original sound. When the car moves from the left field of velocity by vS, we have for amplitude and delay 
view to the right, it gives a stereophonic illusion of movement. The emission of sound may be directional. 
However, usually some sound is emitted in all directions. There where d is the distance traveled, and 
A. is the sound seldom are as abrupt edges in its directional distribution as intensity at a certain 
reference distance ~. The effect of there are in directed light sources with flaps. Thus a spherical 
harmonics approximation [13] is appropriate. delay should be taken into account if the scene dimensions 
are of macroscopic magnitude, comparable to the sound Similarly, the microphone s dhwtional sensitivity 
can speed. A delay of less than 50 ms is already clearly be described with a spherical harmonic function. 
A noticeable, corresponding to a distance of 15 m in representation sufficient in practice is given by 
the formula atmosphere with a sound velocity of approximately 330 s(~) =c+(1 + Cosp)k m/s. 216 where 
p. is the angle between the microphone s principal axis and the incoming sound wave. Value k=O defines 
an omnidirectional shape, and k=l produces the typical cardioid sensitivity shape (figure 5). Lateral 
stereophonic hearing, due to differences in directional sensitivity of left and right ears, can be easily 
simulated with hvo microphones attached to opposite directions on a camera. With the sensitivity parameter 
k= 1, the sum of left and right channels will be omnidirectional. Both sensitivities can be multiplied 
by a fonvard directed shape function, if rear attenuation is desired. s / dlredbnor8ound principaldlmtlon 
M ofmicrophone . .. . w / Figure 5: Microphone sensitivity shape (with k=l, C=O). The total modulation 
of sound intensity is now the product of all directional functions in addition to the attenuation by 
distance. where c and u are the angles between the sound ray and the principal directions of sound source 
and microphone, respectively. 5.4 Sound Tracing in an Acoustic Environment A common effect in acoustic 
environments is reverberation. It is caused by reflective objects in the scene acting as secondary sound 
sources. Algorithmically, this means making multiple instances of sound threads, with different delay 
and amplitude corresponding to each path through the environment. Generally this transformation would 
be a convolution of the signal with a continuous weighting function. In practical calculations, the weighting 
function is discretized to a finite number of samples. Reverberation is thus modeled with multiple echoes. 
In our approach each echo generates a separate thread for the sound renderer. Because the sound wavelength 
is comparable to the geometric features of the objects, reflections are usually very diffuse. Specular 
reflection is soft, and refraction can in most cases be neglected. Due to diffraction, sound waves can 
propagate around a comer. Thus an obstacle occluding Comouter GraDhics. 26, 2. Julv 1992 visibility does 
not completely cut off a direct sound, but only gives a smooth damping. Based on these arguments and 
the fact that the purpose of sound in animation is rather illustrative than exact acoustical analysis, 
we use a heuristically simplified sound tracing model to calculate the effects of interfering objects. 
The basic idea is to find all major paths of sound from a source to the microphone. Each of them is represented 
as a separate sound thread with delay and attenuation corresponding to the path length and reflectivity 
coefficients. As in radiosity calculation, each reflecting surface is considered a secondary diffuse 
point source receiving energy proportional to its area and the cosine of the angle between its normal 
and sound source direction. To calculate the amount of re-radiated sound we use the same reflection formula 
as is traditionally used for shading, consisting of a diffuse radiation in all directions, and a Phong-like 
specular term. The ambient sound in an environment is not modeled as a separate term for each object, 
but as a global background sound at each microphone. Due to diffraction, the shadowing effect of objects 
obscuring a sound path (the form factor) is more approximate than with radiosity. In this paper we do 
not attempt to make a detailed geometric analysis, but use a rule of thumb. Attenuation is approximated 
with a form factor proportional to the amount of occlusion. Figure 6: Principle of sound rracing. A frame 
from an animation to demonstrate these effects is shown in figure 6. A standing car is producing continuous 
sound, which is received through two paths, directly and reflected by a wall. As the wall rotates, the 
echo is strongest when it is in an ideal mirroring position, and disappears when the tangent plane of 
the wall separates the car and the listener. As another wall moves by, it obscures visibility of the 
car first and then the mirror, darnping each sound for a period. . 6 Representation and Processing 
of Sound Scripts The sound script defines how a prototype sound signal will be instantiated, and how 
it is transformed by the acoustic environment. This process will be best understood by an analogy with 
the mapping of a texture from texture to image space. In a sound script all acoustic effects of the three­dimensional 
world are encoded in a geometry-fke form. An advantage of making this transformation a separate process 
is that all the complex effects can be precomputed and combined in the same way as a sequence of geometric 
transformations can be concatenated into a single transformation matrix. Then each object sound can be 
rendered and checked separately, before mixing (overlaying) all sounds together. Another benefit is that 
this part of the sound renderer can be used for any key-framed animation, without necessarily having 
a three-dimensional model. In this section we first describe how a sound script is used to describe transformations 
of sounds from prototypes to the soundtrack. Then the resampling algorithms interpreting the script and 
performing the transformation for each sound are discussed. 6.1 Representing Sound Transformations by 
Key-Framing For describing a sound signal we have two independent coordinates, time and intensity, each 
of which can be transformed. For intensity, only scaling (amplitude modulation) is usually acceptable, 
since any non-linearity is perceived as distortion. Simple translation in time defines when a sound begins 
or how much it is delayed, whereas modifying the time scale causes change in pitch (frequency modulation). 
An arbitrary monotonic mapping excluding reversal of time, which would be rather unnatural can be approximated 
by interpolating specified key values of sound attenuation and delay (corresponding to the amplitude 
and phase angle of stationaq signals), Our script format for sound transformations consists of threads 
of values for attenuation and delay, one thread for each instantiated object sound. Each line of a script 
file contains the following information: -keyword (start, in-between key, or end of a thread) -ID (number) 
of a thread -time stamp of the key -attenuation and delay (for each stereo channel). The file may be 
sorted by thread ID and or time s?amp, depending on the resampling algorithm that calculates the soundtrack. 
Key values may be specified at any points of time. In between the values are interpolated. Since the 
ear s resolution of intensity is not very high, we have found that linear interpolation is usually sufficient 
for amplitude values. However, the ear is very sensitive to abrupt changes in pitch. Thus, in order to 
keep the delay s rate of change (pitch level) continuous, either higher order interpolation or dense 
spacing of keys is needed. For simplicity, we have used the latter solution, specifying keys at each 
frame of an animation. 6.2 Resampling Algorithm Just as in texture mapping, a sound transformation can 
be computed with an algorithm doing resampling either in sound object space or sound image space. With 
an object space algorithm, each sample of a prototype sound is multiplied by the corresponding interpolated 
amplitude, and is written to a sound image buffer translated in time according to the corresponding interpolated 
delay (figure 4). A major problem with this approach is that gaps may be left in image space if the signal 
is expanded An image space algorithm determines the value for each image buffer position by sampling 
in object space at a point determined by the inverse transformation. The inverse mapping cannot be directly 
computed in our case, because the mapping of time (the delay) is defined in object space. We solve this 
problem by mapping the key positions from object space to image space, and interpolating the mapping 
parameters linearly. The interpolated delay gives the inverse mapping for each sample. The same aliasing 
problems arise in sound transformations and sampling, just as they do in texture mapping, and could be 
solved similarly [4].  7 Conclusions Sound rendering is a novel approach allowing the motion to define 
the sound, as opposed to the traditional way of starting with a soundtrack. This allows all types of 
motion control schemes to synchronize sound. With a physically­based motion control the sound events 
can be automatically produced, even if the objects prototype sounds are not physically defined. With 
keyframed motion, the sound parameters can be keyframed as well. If the motion is three­dimensional, 
physically-based simulation of sound propagation can determine many acoustical parameters in a natural 
way. In this work we have defined a modular sonic extension of the image rendering pipeline. Analogies 
have been drawn between sound and texture. Both are transformed from object to image space using similar 
algorithms with similar aliasing problems. We have simulated acoustical effects by sound tracing, analogous 
to forward ray-tracing and radiosity. With this analogy, the sound transformations correspond to shaders 
in a shade tree during its traversal from a source to a camera [3, 18]. We have applied the technique 
to generate sounds for a complex animation using key framing, behavioral, and physically-based motion 
controls that illustrates its generality and flexibility. 218 Computer Graphics, 26,2, July 1992 One 
area we are currently working on is more rigorous physically-based modeling of sound-causing phenomena 
and sound propagation in acoustical environments. In this paper we have only given hints on how to approach 
the problem heuristically.  Acknowledgements This work has been made possible in part by Helsinki University 
of Technology, who provided support for Tapio Takala s sabbatical to the George Washington University. 
This work was also partly supported by funding from NASA (NCC 5-43) and NRL (NAVY NOO014-91-K-203). We 
would like to thank the students in the Computer Graphics and User Interface Group at George Washington 
University for their assistance. Special thanks go to Larry Gritz, Daria Bergen, and Rudy Darken for 
providing the image from Graphic Violence . We would also like to thank the reviewers for their enthusiastic 
comments and many useful suggestions.  References [1] Barzel, R, A. Barr. Modeling with Dynamic Constraints. 
Proc. SIGGRAPH88, ACM Computer Graphics, VO1.22, No.3, pp.178-188. [2] Blattner, Meera, D, Sumikawa, 
R.Greenberg. EarCons and Icons: Their Structure and Common Design Principles. Human-Computer Interaction, 
VO1.4, No. 1, 1989, pp. 11-44. Also reprinted in: E.Glinert (cd.), Visual Programming Environments -Applications 
and Issues, IEEE Computer Society Press 1990, pp.582-606. [3] Cook, Robert. Shade Trees. Prcx. SIGGRAPH84, 
ACM Computer Graphics, Vol. 18, No.3, pp.195­ 206. [4] Feibush, E. A., M. Levoy, R. Cook. Synthetic Texturing 
Using Digital Filters. Proc. SIGGRAPH 80, ACM Computer Graphics, VO1.14, No.3, pp.294-301. [5] Foster, 
S, E.Wenzel. Virtual Acoustic Environments: TheConvolvotron. [multimedia installation] SIGGRAPH91 Virtual 
reality and hypermedia show (August 1991). [6] Gaver, William. The SonicFindec An Interface That Uses 
Auditory Icons. Human-Computer Interaction, VO1.4, No. 1, 1989, pp.67-94. Also reprinted in: E.Glinert 
(cd.), Visual Programming Environments Applications and Issues, IEEE Computer Society Press 1990, pp.561-581. 
[7] Hahn, James. Realistic Animation of Rigid Bodies. Proc. SIGGRAPH 88, ACM Computer Graphics, V01,22, 
No.3, pp.299-308 [8] He, Xiao, K.Torrance, F.Sillion, D.Greenberg. A Comprehensive Physical Model for 
Light Reflection. Proc. SIGGRAPH91, ACM Computer Graphics, VO1.25,No.3, pp.175-186. [9] Lytle, Wayne. 
More Bells and Whistles. [video] in SIGGRAPH90 film show. Also described in Computer, VO1.24,No.7, July 
1991, p.4 and cover. [10] NCSA Visualization Group and CERL Sound Group. Using Sound to Extract Meaning 
fmm Complex Data. [video] SIGGRAPH 91 Screening Room, Visualization &#38; Technical series (August 1991). 
[11] Pentland, Alex, J.Williams. Good Vibrations: Modal Dynamics for Graphics and Animation. Proc. SIGGRAPH89, 
ACM Computer Graphics, VOI.23, No.3, pp.215-222. [12] Perlin, K. An Image Synthesizer. Proc. SIGGRAPH 
85, ACM Computer Graphics, Vol. 19, No.3, pp.287-296. [13] Sillion, Fran$ois., J.Arvo, S.Westin, D.Greenberg. 
A Global Illumination Solution for General Reflectance Distributions. Proc. SIGGRAPH 91, ACM Computer 
Graphics, VO1.25,No.3, pp.187-196. [14] Smith, J.W. Vibration of Structures -Applications in Civil Engineering 
Design. Chapman &#38; Hall 1988 [15] Stettner, Adam, D.Greenberg. Computer Graphics Visualization for 
Acoustic Simulation. Proc. SIGGRAPH 89, ACM Computer Graphics, VO1.23, No.3, pp.195-206. [16] Terzopoulos, 
Dimitri, J.Platt , A.Barr, K.Fleischer. Elastically Deformable Models. Proc. SIGGRAPH 87, ACM Computer 
Graphics, VO1.21, No.3, pp.205­ 214. [171 Thomas, Frank, O.Johnston. Disney Animation The Illusion of 
Life, chapter 11. Abbeville Press 1981. [18] Upstill, Steve. The RenderMan Companion. Pixar/Addison-Wesley, 
1989. [19] Voss, Richard and J.Clarke. I/f noise in Music: Music from l/f Noise. J. Acoust. Sot. Am. 
63 (l), January 1978, PP.258-263. [20] Voss, Richard. Fractals in Nature: Characterization, Measurement, 
and Simulation. SIGGRAPH 87 Course Notes. [21] Wightman, Frederick, D. Kistler. Headphone Simulation 
of Free-Field Listening. I: Stimulus Synthesis. J. Acoust. Sot. Am. 85 (2), February 1989, pp.858-867. 
 [22] Wyshynski Susan, The Vivid Group. The Mandala VR System. [multimedia installation] in SIGGRAPH 
91 virtual reality and hypermedia show (August 1991). Figures 7: Frame from a key-framed animation. 
Figure 8: Frame from a physically based animation. Figure 9: Frame from a behavioral animation. 
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134065</article_id>
		<sort_key>221</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>25</seq_no>
		<title><![CDATA[An algorithm with linear complexity for interactive, physically-based modeling of large proteins]]></title>
		<page_from>221</page_from>
		<page_to>230</page_to>
		<doi_number>10.1145/133994.134065</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134065</url>
		<keywords>
			<kw><![CDATA[Lagrange multiplier method]]></kw>
			<kw><![CDATA[constrain systems]]></kw>
			<kw><![CDATA[molecular modeling]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.6</cat_node>
				<descriptor>Interaction techniques</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>F.2.1</cat_node>
				<descriptor>Computations on matrices</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Animation</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>J.2</cat_node>
				<descriptor>Chemistry</descriptor>
				<type>S</type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010405.10010432.10010436</concept_id>
				<concept_desc>CCS->Applied computing->Physical sciences and engineering->Chemistry</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010352</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Animation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002950.10003714.10003715.10003719</concept_id>
				<concept_desc>CCS->Mathematics of computing->Mathematical analysis->Numerical analysis->Computations on matrices</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010387</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Graphics systems and interfaces</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003120.10003121.10003125.10010391</concept_id>
				<concept_desc>CCS->Human-centered computing->Human computer interaction (HCI)->Interaction devices->Graphics input devices</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>P191175</person_id>
				<author_profile_id><![CDATA[81100055477]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Mark]]></first_name>
				<middle_name><![CDATA[C.]]></middle_name>
				<last_name><![CDATA[Surles]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Department of Computer Science, University of North Carolina at Chapel Hill, Chapel Hill, NC]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_obj_id>378516</ref_obj_id>
				<ref_obj_pid>378456</ref_obj_pid>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Akeley, K. and Jermoluk, T. High-Performance Polygon Rendering. Computer Graphics. 22, 4 (1988), 239-246.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_obj_id>356797</ref_obj_id>
				<ref_obj_pid>356789</ref_obj_pid>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Bentley, J. L. and Friedman, J. H. Data Structures for Range Searching. Computing Surveys. I 1, 4 (1979), 397-409.]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Insight. Biosym Technologies Inc., 1991.]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[Brooks, B. R., Bruccoleri, R. E., Olafson, B. D., States, D. J., Swaminathan, S. and Karplus, M. CHARMM: A Program for Macromolecular Energy, Minimization, and Dynamics Calculations. Journal of Computational Chemistry. 4, 2 (1983), 187-217.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_obj_id>18753</ref_obj_id>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[Duff, I. S., Erisman, A. M. and Reid, J. K. Direct Methods for Sparse Matrices. Clarendon Press, Oxford, 1986.]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_obj_id>39857</ref_obj_id>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[Fletcher, R. Practical Methods of Optimization. John Wiley and Sons, 1987.]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Gill, P., Murray, W. and Wright, M. Practical Optimization. Academic Press, 1981.]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[Hecht, M. H., Richardson, J. S., Richardson, D. C. and Ogden, R. C. De Novo Design, Expression, and Characterization of Felix: A Four-Helix Bundle Protein of Native-Like Sequence. Science. 249, 4964 (1990), 884-891.]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Hestenes, M. R. Optimization Theory, The Finite Dimensional Case. John Wiley and Sons, New York, 1975.]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_obj_id>578603</ref_obj_id>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[Knuth, D. E. Fundamental Algorithms, The Art of Computer Programming. Addison-Wesley, 1973.]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
			<ref>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[Levinthal, C. Molecular Model-building by Computer. Scienn'fic American. 214, 6 (1966).]]></ref_text>
				<ref_id>11</ref_id>
			</ref>
			<ref>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[Luenberger, D. G. Introduction to Linear and Nonlinear Programming. Addison-Wesley, 1973.]]></ref_text>
				<ref_id>12</ref_id>
			</ref>
			<ref>
				<ref_obj_id>74355</ref_obj_id>
				<ref_obj_pid>74334</ref_obj_pid>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[Pentland, A. and Williams, J. Good Vibrations: Modal Dynamics for Graphics and Animation. Computer Graphics. 23, 3 (1989), 215-222.]]></ref_text>
				<ref_id>13</ref_id>
			</ref>
			<ref>
				<ref_obj_id>76524</ref_obj_id>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[Platt, J. Constraint Methods for Neural Networks and Computer Graphics. Ph.D. Dissertation, California Institute of Technology, 1989.]]></ref_text>
				<ref_id>14</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378524</ref_obj_id>
				<ref_obj_pid>378456</ref_obj_pid>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[Platt, J. and Barr, A. Constraint Methods for Flexible Models. Computer Graphics. 22, 4 (1988), 279-288.]]></ref_text>
				<ref_id>15</ref_id>
			</ref>
			<ref>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[Quanta. Polygen Corporation, 1991.]]></ref_text>
				<ref_id>16</ref_id>
			</ref>
			<ref>
				<ref_seq_no>17</ref_seq_no>
				<ref_text><![CDATA[Schulz, G. E. and Schirmer, R. H. Principles of Protein Structure. Springer-Verlag, New York, 1979.]]></ref_text>
				<ref_id>17</ref_id>
			</ref>
			<ref>
				<ref_obj_id>6645</ref_obj_id>
				<ref_seq_no>18</ref_seq_no>
				<ref_text><![CDATA[Stroustrup, B. The C+ + Programming Language. Addison- Wesley, 1986.]]></ref_text>
				<ref_id>18</ref_id>
			</ref>
			<ref>
				<ref_obj_id>147196</ref_obj_id>
				<ref_obj_pid>147156</ref_obj_pid>
				<ref_seq_no>19</ref_seq_no>
				<ref_text><![CDATA[Surles, M. Interactive Modeling Enhanced with Constraints and PhysicslWith Applications in Molecular Modeling. Symposium on Interactive 3D Graphics. 26, 2 (i 992), 175- 182.]]></ref_text>
				<ref_id>19</ref_id>
			</ref>
			<ref>
				<ref_obj_id>170538</ref_obj_id>
				<ref_seq_no>20</ref_seq_no>
				<ref_text><![CDATA[Surles, M. Techniques For Interactive Manipulation of Graphical Protein Models. Ph.D. Dissertation, University of North Carolina at Chapel Hill, 1992.]]></ref_text>
				<ref_id>20</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378522</ref_obj_id>
				<ref_obj_pid>378456</ref_obj_pid>
				<ref_seq_no>21</ref_seq_no>
				<ref_text><![CDATA[Terzopoulos, D. and Fleischer, K. Modeling Inelastic Deformation: Viscoelasticity, Plasticity, Fracture. Computer Graphics. 22, 4 (1988), 269-278.]]></ref_text>
				<ref_id>21</ref_id>
			</ref>
			<ref>
				<ref_seq_no>22</ref_seq_no>
				<ref_text><![CDATA[Sybyl. Tripos Associates, 1988.]]></ref_text>
				<ref_id>22</ref_id>
			</ref>
			<ref>
				<ref_seq_no>23</ref_seq_no>
				<ref_text><![CDATA[Weiner, S. J., Kollman, P. A., Case, D. A., Singh, C., Ghio, C., Alagona, G., Profeta, S. and Weiner, P. A New Force Field for Molecular Mechanical Simulation of Nucleic Acids and Proteins. Journal of the American Chemical Society. 106, (1984), 765-784.]]></ref_text>
				<ref_id>23</ref_id>
			</ref>
			<ref>
				<ref_obj_id>91400</ref_obj_id>
				<ref_obj_pid>91394</ref_obj_pid>
				<ref_seq_no>24</ref_seq_no>
				<ref_text><![CDATA[Witkin, A., Gleicher, M. and Welch, W. Interactive Dynamics. Symposium on Interactive 3D Graphics. 24, 2 (1990), 11-21.]]></ref_text>
				<ref_id>24</ref_id>
			</ref>
			<ref>
				<ref_seq_no>25</ref_seq_no>
				<ref_text><![CDATA[Witkin, A. and Welch, W. Fast Animation and Control of Nonrigid Structures. Computer Graphics. 24, 4 (1990), 243- 252.]]></ref_text>
				<ref_id>25</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 Computer Graphics, 26,2, July 1992 An Algorithm With Linear Complexity For Interactive, Physically-based 
Modeling of Large Proteins Mark C. Surles Department of Computer Science University of North Carolina 
at Chapel Hiii Chapei Hill, NC 27599-3175 Abstract Physically-based modeling applications usually require 
batch processing for each frame of an animation or simulation. This paper describes a graphics modeling 
system, called Sculpr, that maintains physically-valid protein properties while a user interactively 
moves atoms. Sculpt models stiff properties such as bond lengths and angles as rigid constraints and 
models weak properties such as non-bonded interactions as potential energies. Sculpr continually satisfies 
the constraints and maintains a local energy minimum throughout user interaction. On a Silicon Graphics 
240-GTX, Sculpt maintains 1,9 updates per second on a molecular model with 355 atoms ( 1065 variables, 
1027 constraints, and 3465 potential energies). Performance decreases /r nearly with increased problem 
size. This paper presents a Lagrange multiplier method with linear computational complexity that finds 
a constrained minimum for articulated figures with many more joints in their spines than in any limb 
(e.g. reptiles, mammals, and proteins). The method computes the Jacobian matrix of the constraints and 
solves a system of linear equations that results from muhiplying the Jacobian by its transpose. The paper 
proves that a sort of the Jacobian yields a band-diagonal pattern of nonzeros. The pattern does not change 
during a modeling session, so the sort can run during a pre-processing step. Multiplication and solution 
of band-diagonal matrices require computation that increases linearly with problem size. Previous applications 
of Lagrange multipliers to constrained, physically-based modeling did not take advantage of the constraint 
connectivity in the spine. They either required many iterations of a linear algorithm or few iterations 
of a quadratic algorithm for each frame of a simulation. This application finds a constrained minimum 
with a linear algorithm in a few iterations. Additionally, most of the algorithm s steps execute in parallel 
for increased performance, CR Categories and Subject Descriptors: 1.3.6 [Computer Graphics]: Methodology 
and Techniques; J.2 [Computer Applications]: Physical Sciences. Additional Keywords and Phrases: Constraint 
systems, Lagrange multiplier method, molecular modeling. 1. introduction Two factors hinder large, interactive 
applications of physically­based modeling model complexity and algorithm complexity. Most physically-based 
modeling applications in computer graphics simulate Newtonian dynamics of complex models to generate 
realistic motions and shapes. The complexity of the models requires batch processing to evaluate their 
properties for each frame in an animation. For example, Platt models surface tensors and finite elements 
to create incompressible Jello and compressible clay [15], and Terzopoulos models fracture and elasticity 
to simulate tearing paper [21]. The algorithms that generate frames in physically-based modeling animations 
usually require a few iterations with quadratic (or higher) computational complexity or numerous iterations 
with linear complexity, Linear algorithms such as those that explicitly integrate differential equations 
of motion usually require many iterations with small time steps for each frame in a simulation, Algorithms 
that constrain stiff model components (e.g. stiff springs) allow larger time steps, but require more 
operations per iteration to satisfy the constraints [ 14]. One physically-based modeling algorithm that 
maintains constraints among arbitrary objects requires only a few iterations per screen update, but the 
computation in each iteration increases quadratically with the number of constraints [24, 25]. Algorithm 
and model complexities limit the size of models that run interactively on current graphics workstations. 
1 show an algorithm and system that interactively models large proteins with physically-based modeling. 
The system, called Scu/pr, maintains rigid bond lengths and angles and minimizes potential energy while 
a user interactively moves atoms. Sculpt lets a user tug atoms in an existing model into new conformations 
(e.g. twist a sequence of bonded atoms into a helix) while automatically maintaining physically-valid 
protein geometry. The computation in Scu/pl increases linearly with protein size. On a Silicon Graphics 
240-GTX, Sculpt maintains 1.9 updates per second on a model with 1065 variables, 1027 constraints, and 
3465 energy functions. Chemists have used Sculpf to create new protein conformations and examine interactions 
within protein interiors [19]. An algorithm in Sculpf with linear computational complexity in problem 
size satisfies a set of connectivity constraints and minimizes the ensemble model energy. The algorithm 
is applicable to articulated figures that have many more joints in the spine than in any limb. The algorithm 
assumes the atom positions at a local energy minima are more important than the 1 1992 A( M-1)-H9791-479-l/92/( 
K)7/0221 $01.50 22 I trajectory for reaching them. This assumption lets the algorithm minimize strain 
energy in the model rather than simulate model dynamics. The time steps in the algorithm are large enough 
for interactive physically-based modeling of large models. Most of the algorithm s steps can execute 
in parallel for additional performance. This paper concentrates on the constrained minimization algorithm 
and the class of problems for which the algorithm runs with linear complexity. Two issues in this application 
are important to the computer graphics community. First, the algorithm that finds a constrained minimum 
is not protein specific. Proteins, to a first approximation, are articulated figures with many more joints 
in their backbone than in any limb. The constrained minimization algorithm is applicable to any articulated 
figure with this property (e.g. vertebrates such as reptiles, fish, and most mammals). Second, Sculpt 
significantly expands the benefits of interactive graphics in biochemistry by maintaining physical-realism 
during interactive modeling. Biochemists use interactive graphics to study three-dimensional molecular 
structures and visualize results from supercomputer molecular dynamics simulations. However, commercial 
interactive modeling systems [3, 16, 22] restrict modeling operations to simple geometric transformations 
that do not maintain a physically-valid model. Returning a model to a physically­valid configuration 
is left to the user. Sections 2 and 3 describe the driving problem and the Sculpt interface. Section 
4 details specific articulated bodies for which the Lagrange multiplier method in Section 5 runs with 
linear complexity. Section 6 shows a pre-processing step that lets subsequent constrained minimizations 
run with linear computational complexity. Section 7 outlines parallel components of the algorithm. Section 
8 describes some application-specific complications, and Section 9 presents performance results. 2. 
Problem description Chemists build and change molecular models with interactive graphics systems. Commercial 
molecular modeling systems only model a small set of protein properties in order to preserve interactive 
performance. In these systems, simple changes often leave the model in a physically-invalid configuration. 
Chemists spend much of their modeling effort returning the model to a physically-valid configuration. 
The driving problem in this research is to create an interactive protein modeling system that relieves 
the chemist of the repair process by maintaining a physically-valid model throughout a modeling session. 
Protein modeling was picked as a starting point before generalizing to other molecules. This section 
describes relevant protein properties and commercial interactive modeling systems for proteins. A protein, 
to a first approximation, contains fixed bond lengths, bond angles, and planar segments. Figure 1 shows 
three sequential segments in a protein with vectors representing bonds between atoms and gray areas denoting 
planar regions. The only degrees of freedom in the figure are rotations between the planar segments (shown 
with arrows about the N-Ca and Ca-C bonds). A linear sequence of the segments comprise the protein backbone. 
Attached to the atom (Ca) between each segment are sidechains (not shown) with additional fixed length 
and angle properties. The number of atoms in the sidechain is small relative to the backbone (up to eighteen 
atoms versus hundreds to thousands of atoms). 0 /    \_/ ~ Figure 1: Three planar segments in the 
backbone. Proteins also contain attractions and repulsions between non­bonded atoms (points without connecting 
vectors). Attractions hold nearby atoms together, whereas repulsions maintain a minimal separation defined 
by the atom s electron shells. Figure 1 shows near-ideal separation between H and O atoms with adjacent 
circles. If two circles overlap, their atoms repel each othefi otherwise, they attract. Molecular modeling 
systems [3, 16, 22] usually restrict modeling operations to rotations about the N-Ca and Cm-C bonds so 
that bond lengths and angles between segments remain correct. Adjusting an interior segment with this 
restriction often requires numerous rotations (an inverse­kinematics problem with hundreds of joints), 
since even a small rotation moves all the atoms further along the backbone. Additionally, interactive 
systems do not maintain proper non­bonded atom separations during a modeling session. A user must return 
a protein to valid geometry by either laborious manual adjustments using these rotations or batch energy 
minimization. Batch minimization automates model repair but often changes the model differently than 
desired. Modal dynamics allows interactive, physically-based model deformations by linearly interpolating 
independent, principal normal (or vibrational) modes of an object [13]. Modal dynamics requires a batch 
pre-processing step that determines the principal axes of change in a given model. As the deformed model 
differs more from the original model, the results of the normal-mode analysis become less accurate. After 
the model changes a specified amount, a new normal-mode analysis must determine the modes for the new 
structure. Modal dynamics is not a good choice for this molecular modeling problem since a user may significantly 
change the protein structure during a modeling session. Running a new modal analysis of a medium­size 
protein in the middle of a session requires too much time for an interactive application. 3. The Sculpt 
system Scrdpt lets a user move any atom by first attaching a simulated spring between it and the cursor 
and then dragging the cursor in the desired direction. Throughout the dragging process, Sculpt polls 
the cursor position and adds the strain energy of that spring to the energy in the protein. Sculpr then 
finds a local minimum of the new total energy that also maintains rigid bond lengths, angles, and planar 
segments. Lastly, Sculpt displays the results. 222 three arcs, respectively. Each constraint function, 
ci(x), has an ideal value, ~, and is represented as ci(~) -Z = O. At program initialization all constraints 
must be satisfied. In the protein application, all the constraints are specified at program initialization. 
Constraints that meet these criteria can be added or removed during a session with some loss of interactivity. 
k~o~ain specifies the maximum dimension of any constraint function s domain. This gives the maximum number 
of variables referenced by a constraint. In Sculp( the dihedral angle function references the most variables 
twelve, four atoms each with three variables. This constant and the requirement that constraints, in 
general, are defined on connected nodes restrict constraint functions to nodes in close topological proximity. 
Assume during the subsequent analysis that a constraint function cannot reference nodes arbitrarily separated 
in the topology graph; local loops, however, are allowed. Section 6.4 shows that the linear complexity 
analysis remains valid given a fixed number (independent of n) of constraints defined on arbitrary nodes. 
kcv specifies the maximum number of constraints defined on a given variable. This constant is a function 
of kbranch and Consider the number of constraints that can reference a particular node in a protein. 
At most kbranch length functions contain the same atom. Each of the connected atoms connect to at SnOSt 
kbranch -1 other atoms, giving a maximum of kdomain. -1) angle functions that reference the initial atom. 
A similar argument follows for dihedral angle functions. kbranch(kbranch Jc specifies the total number 
of constraint functions. An upper bound on this number is the number of variables times the maximum number 
of constraints per variable, kc},n. k ,Pan defines the maximum separation between the lowest and the 
highest variable indices in a constraint. This constant is a function of kdomajn and k~ide. In proteins, 
this constant is derived by examining a dihedral angle function defined on atoms before and after the 
largest sidechain. c(x) is a column vector that contains all the constraint functions in a model. Row 
i in c(x) represents the constraint function, ci(x)j minus its constrained value, ~, as follows: Cl(x) 
il o C2(X) :2 =(1 c(x) = [ Cfc(x) ~ ifc ![1 o 4.3. Energy functions e(x) equals the sum of all the energy 
functions in the model. Energy functions model weak and multi-value properties. In Sculpt some energy 
functions are defined throughout a modeling session (e.g. a weak bond length between two atoms) and some 
are defined only when atoms are within a given neighborhood of each other. The latter functions model 
attractions and repulsions among nearby, non-bonded atoms (detailed in Section 8). Most of the previous 
restrictions on constraints are not placed on energy functions. For example, an arbitrary number of energy 
functions can reference arbitrary nodes and can be added and removed during a modeling session without 
significant loss in interactivity. The only restriction on energy functions is that the number of energy 
functions, ~e, increases at most linearly with the number of variables. kc,,n bounds the number of energy 
functions if the kcv constant is increased to account for length, angle, and dihedral angle energy functions. 
Section 8 shows that the number of non-bonded interactions also meets this criterion. 4.4. Similar applications 
Many articulated bodies such as mammals, reptiles, and fish have limbs with few joints attached to spines 
with numerous joints. A human skeleton marginally fits this characterization due to the large number 
of bones in the hands and feet. A human skeleton does meet the model restrictions if the hands and feet 
are approximated with fewer bones. Since an energy function can reference arbitrary variables, operations 
such as clap hands and pat knee wirh hand can place a spring between the two bones. In order to keep 
the constrained minimization algorithm and modeling system general, Sculpt does not take advantage of 
specific protein properties to reduce variables and improve performance. For example, a protein is modeled 
as a set of points with length and angle constraints rather than a set of rigid segments connected with 
free rotations between them. A planar segment in Figure 1 remains rigid by constraining the lengths, 
angles, and dihedral angles among its atoms.   5. Finding a locally constrained minimum This section 
presents an algorithm that finds a local solution to the following problem: minimize e(x) such that c(x) 
= O. Minimizing an arbitrary function subject to arbitrary constraints is an open research problem. Different 
constrained minimization algorithms work better for problems with different properties. Some common classes 
of properties include the following: linear, quadratic, or nonlinear energy function; linear or nonlinear 
constraints; equality and/or inequality constraints; smooth and continuous functions in zero or more 
derivatives; starting value of variables satisfies (or does not satisfy) the constraints. The class of 
problems in this research has the following properties: 1. nonlinear energy and constraint functions; 
 2. equality constraints; 3. continuous functions through the second derivative; 4. initial variables 
satisfy or nearly satisfy constraints.  Additionally, a local minimum is usually very close to the starting 
point. A new constrained minimization mns each time a user tugs an atom. The only difference in the total 
energy from the previous invocation is energy from a user spring and near-neighbor interactions resulting 
from prior atom movements. Neither case changes the total system energy very much. A small change in 
the total energy typically shifts the minimum only slightly. This property lets the following algorithm 
converge usually in one or two iterations. Sculp/ finds a local constrained minimum with the augmented 
Lagrange method. This method is based on the first-order necessary conditions of a local solution. This 
section tlrst states the necessary conditions and the augmented Lagrange method and then presents the 
particular implementation of the method used in Sculpt. Computer Graphics, 26,2, July 1992 5.1. Notation 
The gradient operator, V, is a column vector of partial derivatives. In particular, the gradient of the 
energy function, Ve(x), is defined as follows: ~e(x)= &#38; &#38; ,,~ T T denotes the transpose. [ axl 
ax2 axn ] The gradient of the constraints, Vc(x), is called the Jacobian malrix. Element (i,j) of the 
Jacobian represents the partia[ derivative with respect to variable .ri of constraint j. Sometimes this 
is denoted by J for notational clarity. 5.2. Necessary conditions First-order. necessary conditions require 
that a locally constrained minimum, x*, satisfy two conditions [6, p. 200]: 1. C(X*)=O constraints are 
satisfied 7 -. Ve(x ) = VC(X*)A* energy gradient is a linear combination of constraint = X, VCi(X*)kl* 
gradients There is one scalar, called a Lagrange multiplier, A,, for each constraint. The vector A* denotes 
the vector of Lagrange multipliers at the minimum, x*, Figure 4 illustrates these conditions with a two-dimensional 
energy function and one constraint. At the point x the gradient of the energy is not a linear combination 
of the constraint gradients. A step in the direction d reduces the energy and maintains the constraints, 
At the local minimum, x*, the conditions are satisfied and no descent direction remains that satisfies 
the constraints. \ Ve(x) # Vc(x)k Ve(x*) = Vc(x*)L* P x d c(x) =o _ \ ._ \ x* \\ \\ \\ \ < e(x*)~ \ 
\ ~> e(x*)\ e(x*) Contours of e(x) , , I Figure 4: Example of first-order necessary conditions at a constrained 
minimum. 5.3. Augmented Lagrange function Algorithms that find a locally constrained minimum using Lagrange 
multipliers seek a vector (x*,1 ) that satisfies the first­order necessary conditions. No direct, general 
solution exists because these conditions give n +f, nonlinear equations with n+~{,unknowns for problems 
with n variables and ${.constraints. Rather than solving these equations directly, I find a saddlepoint 
of another function, called the augmented Lagrange function, that contains no constraints. Finding an 
unconstrained saddlepoint is easier than solving the nonlinear equations associated with a constrained 
minimum. A soiution (x*, A*) of the following minimax probiem, for sufficiently large p, is also a solution 
to the constrained minimization problem [9]: m~n ~ax L(x, k, p) = m~n ~ax e(x) -kTC(x) +~(x)Tc(x), The 
solution of the minimax problem is a saddlepoint of the augmented Lagrange function, L(x, A,p). The gradient 
of a function evaluated at a saddlepoint is zero. In this case, the gradient with respect to A set to 
zero gives necessary condition (1). The gradient with respect to x set to zero gives V e(x) -VC(X)A + 
p Vc(x)c(x) = 0. Rearranging this equation gives necessary condition (2) plus an extra te~, called the 
penalry. Notice the penalty is zero when the constraints are satisfied. For penalties greater than some 
finite value, a point x minimizes L(x, A*,p) if and only if it is a constrained minimum of the original 
problem [7, p. 226]. Additionally, a sequence x~ that minimizes L(x, A;,p), for a sequence of multipliers 
that converge to A*, converges to x* [9, p. 308], 5.4. Aigorithm Numerous iterative algorithms can find 
a saddlepoint of a function [12]. The method of steepest descent follows the negative gradient with respect 
to x to find the minimum and the gradient with respect to I to find the maximum. The steepest descent 
evaluates the gradient during each iteration but usually requires numerous iterations. Newton s method 
finds a zero of an equation (in this case, the gradient of the Lagrange function) using its value and 
derivative. The derivative of the Lagrange gradient is actually the second derivative of the Lagrange 
function, a matrix (n+fc) x (rs+fc) in dimension. Newton s method should converge rapidly, since we assume 
the solution is near. However, solving a system of n+fc equations destroys interactive performance. The 
algorithm used in Sculpt blends these two approaches (see Figure 5). First, estimate the optimal Lagrange 
multipliers using the current value of the variables. Second, compute a penalty. Third, minimize the 
Lagrange function with respect to x using the estimated Lagrange multipliers. Fourth, repeat the algorithm 
until sufficiently close to the constrained minimum. The method is first presented in Gill [7, p. 227]; 
Witkin presents a similar algorithm for constrained dynamics [24]. O. Given initial x 1. Estimate the 
Lagrange multipliers, A 2. Determine a penalty term, p 3. xnc e min~mize .L(x; A, p) 4. x + x ~ ; 
Goto step 1  Figure 5: The constrained minimization algorithm. 5.4.1. Estimate Lagrange multipliers 
The first-order multiplier method [7, p. 248] estimates the Lagrange multipliers. Given the current variables, 
x, this method finds the Lagrange multipliers that best satisfy necessary condition (2). The algorithm 
estimates the ideal Lagrange multipliers at each iteration by solving the following system of equations 
for A: [Vc(xJ]A = Ve(x). The dimension of the Jacobian matrix, Vc(x), is n X~c, and the Lagrange multiplier 
vector has dimension fCx 1. Since the number of constraints is typically less than the number of variables, 
this system of equations is overconstrained (note, ~ is overconstrained, not the free variables, x). 
Sculpt fiids a least-squares approximation to the system of equations by multiplying both sides of the 
~lity by the tmmpose of the matrix and solving for 1: [Vc(x) Vc(x)] 2 = Vc(x)TVe(x). 5.4.2. Determine 
e penalty term The penalty, p, pulls the solution towards one that satisfies the constraints. The previous 
step estimates the Lagrange multipliers using a first-order approximation of the constraints. Since the 
constraints are nonlinear, this approximation lets the solution drift from the constraints. The penalty 
keeps this from moving beyond some limit. The penalty is set to the error in the least-squarea approximation 
(i.e. p (-llVe(x) -Vc(x)l.11). 5.4.3. Minimize augmented Lagrange function This step minimizes the augmented 
Lagrangiart with respect to x using the multipliers and penalty term from previous steps. The steepest 
descent method, in practice, converges in one or two iterations since the starting point is close to 
a minimum. The steepest descent method requires the negative gradient of the Lagrange function: -Ve(x) 
+ VC(X)A -p Vc(x)c(x). 5.4.4. Exit or repeat If the previous step changes x more than a user-defiied 
threshold, the algorithm repeats with the new value of x. Since the starting point is usually close to 
the local minimum, only one or two iterations typically run. Users occasionally decrease the threshold 
near the end of a modeling session so the model will settle closer to the 10CSIminimum. 6. Aigorithm 
anaiysis The step that estimates the Lagrange multipliers requires multiplying the fC xn Jacobian transpose 
by the n x fC Jacobian and solving the fCxfc system of linear equations. In a general problem, the multiplication 
requires O@n) operations and the solution of linear equations requires O@) operations. Since the number 
of constraints increases linearly with the problem size (i.e. fC=O(n)), the Lagrange multiplier estimate 
requires O(N) steps in a general problem. Constraint properties in this application let the estimation 
of Lagrange multipliers run in O(n) oprations. A pre-processing step that sorts rows in the Jacobian 
transpose gives a matrix with nonzeros width a constant bandwidth, independent of problem size, from 
the diagonal. Multiplication and solution of matrices with this structure require O(n) operations. This 
section explains the sort and analyzes the complexity of the minimization algorithm. Figure 6 summarizes 
the computational complexity of each step. The Jacobian is represented with ~ in the following discussion. 
6.1. Matrix properties Sculpt stores two matrices, the transpose of the Jacobiatr (JT) and its product 
with the Jacobian (JTJ). Both matrices are very sparse (typically more than ninety-five percent of the 
entries 226 10(~k&#38;,,, x n) ; 1 ..----Function/derivativeevaluation I1 v I EstimateLagrangemultipliers 
; o(~,~m. x n) Multiply vector b = J% v : O(kj,k&#38;x n) Solvefor 1.: Ak=b O(kc, x n) : MinimizeLagrangefunction 
I Figure 6: Computational complexity of algorithm. are zero). Algorithms and data structures that exploit 
the sparsity drastically reduce the computational and memory requirements. 6.1.1. Contents of matrices 
Jacobian transpose, JT. The Jacobian transpose contains f= rows and n columns. Element (ij) holds the 
first partial derivative of constraint i with respect to variable j. Most of the entries in each row 
are zero since each constraint only references a small number of variables (much smaller than the total 
number of variables). For example, art average row in a model with 300 atoms is 94.7 percent zero; the 
percentage increases with more atoms. .%+ stores a linked list for each constraint in the Jacobian transpose, 
A linked list contains a node for each variable referenced by its constraint. Each node in the list has 
pointers to the next nonzero element in the row and in the column [10, p. 300]. Matrix product, A=JTJ. 
Nortzero elements in this matrix are related to nonzero elements in the Jacobian transpose. Matrix multiplication 
defines an element a,,= in A as the inner product of row r in the left matrix and column c in the right 
matrix (i.e. ar,C s ~ J~*J&#38;z). Column c in a matrix is *o row c in its matrix transpose. Rewriting 
the definition of u,,= using this gives = Jfk.J~&#38; The element is information arz , nonzero only when 
rows r and c in &#38; e Jacobian transpose contain a nonzero entry in the same column (i.e. when constraints 
r and c reference the same variable). At program initialization Sculpt determines the nonzero elements 
of A by comparing each row in the Jacobian transpose with the other rows for common, nonzero columns. 
Since rows (constraints) are not added or removed during an interactive session, the sparsity patterns 
of J f and A remain constant. 6.1.2. Sparsity pattern using a sort Matrix A is a band-diagonal matrix 
when the rows of the Jacobian transpose are sort~ relative to the smallest nonzero column index, before 
determining the nortzero elements in A. All the nonzero elements in a band-diagonal matrix are within 
a constant distance (bandwidth) from the diagonal (Figure 7 shows a band-diagonal matrix with bandwidth 
b). The bandwidth of a matrix depends on the maximum separation of nonzero column indices. The bandwidth 
of A is found by considering an arbkrary row i. Coltmm j in row i is nonzero if and only if constraints 
i and j reference the same variable. The worst-case structure of the sorted Jacobian transpose shows 
the maximum separation between i and j. b Figure 7: A band-diagonal matrix with bandwidth b. White squares 
represent zeros. Assume constraint i references variables L and L + k~Pa*, the maximum separation of 
variable indices allowed in one constraint. Figure 8 shows the worst-case separation of nonzero elements 
around constraint i in the sort~ Jacobian transpose. One constraint references variables L and L-ktpcn, 
and one references L + ka en and L + 2k8Pa6. At most kc constraints reference each o[ the variables between 
L-kr ~ and L+k8pan. Therefore, the smallest-numbered constraint &#38;at can reference a variable in constraint 
i is i-kcJ*pan and the largest is i+ k=vk=pan. k Cv w H=l kcv I +++ kc, Htx+#+t k HFHHm Cv $EHHm kc, 
WE+* I? { ikt~i## ,, Figure 8: Worst-case structure of sorted Jacob Ian transpose around constraint i. 
Computer Graphics, 26, 2, July 1992 An arbitrary row in matrix A, therefore, contains nonzero elem~~ 
at most kc,k~~n COIWIUMtsefme ~d kc~~ columns after the diagonal element. The bandwidth, b, or matrix 
A is kc&#38;=m. The positiona of nonzero elements in the Jacobian transpose and A do not change since 
constraints are not added or removed during an interactive modelrng session. Therefore, only one sort 
at or before program initialization is necessary. 6.2. Matrix algorithms Matrix-vector multiplication, 
b-JTVe. This step multiplies each of the f= rows in the Jacobian transpose by a vector. Since each row 
contains at most kdomain nonzero elements, the entire muhiplicatlon reqrnres O(kdO~=, ~ ­ ,J)-O(k&#38;mtinkC~) 
operations. Matrix-matrix multiplication, A-JTJ. The bandwidth limits the number of nonzero elements 
in A to twice the bandwidth times the number of rows. Computing the value of a given elemenq (r,c), requires 
multiplying rows r and c of the Jacobhtrt transpose. This requires O(k&#38;mim) operations since a row 
in the Jacobian transpose contains at most kdO~=l@ nonzero elements. The entire multiplication requires 
o(~domain~~.) o+wrations. Substituting for b and ~C gives O(k&#38;mai.k,PaJc~) operations. Linear equation 
solutlon, Ak=b. Gaussian elimination reduces the band-diagonal matrix in 0(b2fc) operations. Figure 7 
highlights one block of a band-diagonal matrix. Consider the operations necessary to eliminate the elements 
under the diagonal in the left-most column of the highlighted block. This requires eliminating the value 
in the b-f rows following the first row in the block. Each row elimination requires multiplying and adding 
b elements in the row. Therefore, eliminating the column elements below a diagonal element requires O(N) 
operations. This elimination is then repeated for each diagonal element. Substituting gives the foliowing 
complexity: 0(b2~C) = 0(&#38;3 k~pati). 6.3. Vector operations Function and derivative evaluation. Evaluating 
the partial derivative of a function with respect Lo each of its variables requires O(k&#38;Win) operations. 
This is done for the constraints and the energy functions, resulting in O(kbnAI(~.+~t)) = o(kbw nkc~) 
operations. Lagrange function minimization. Sculpl finds a minimum over x of the Lagrange function with 
the steepest descent method by following the negative gradient with respect tox: -Ve +~a -p,lc. Both 
vector additions require O(n) operations. Both matrix-vector multiplications multiply each of the n rows 
in the Jacobian matrix by a vector. A row in the Jacobian matrix contains partial derivatives of ail 
the constraints with respect to a particular variable. Each row contains at most kcV nonzero entries 
since at most ~C constraints reference the same variable. The entire matrlx­vector multiplication (and 
also the Lagrange minimization step), therefore, requires O(kc~) operations. 6.4. Summary of analyala 
and generalizations The analysis shows the computational complexity of an iteration in the constrained 
mtilmization algorithm increases linearly with problem size for a class of articulated figures. The values 
of the proportionality constants listed for the protein application are very conservative and fit mart 
y applications. 227 The parameter that varies the most among applications is the maximum number of joints 
(nodes) in a limb. The bandwidth increases with both this parameter and the number of variables referenced 
by a constraint in the topology graph. The matrix properties are actually invariant to the variable numbering 
and the row sort. I use these to show that the articulated figures yield a matrix with the same properties 
as a band-diagonal matrix. This analysis applies to applications with the same constraint topology that 
use a different numbering scheme. Sparse matrix packages (e.g. [5]) employ a similar sort during a pre-processing 
step that tries to align the nonzeros near the diagonal. Also, the fixed-width band along the diagonal 
shows a worst-case scenario. In practice some rows span the maximum bandwidth while most do not. Using 
this information can reduce the average computation. The algorithm still has linear computational complexity 
when the model contains a fixed number of constraints defined on arbitrary nodes. Consider a distance 
constraint, i, defined between two arbitrary nodes. The constraint can reference variables in kcv other 
constraints that may be arbitrarily separated from i. The nonzeros in this matrix are either within the 
original bandwidth or at a few stray places such as (i,j) and (j, i), where constraint references a variable 
in i. The order of Gaussian elimination s computational complexity does not change, since only elements 
in the column under these stray elements are tilled. Similarly, the complexity remains linear when there 
is some constant number of constraints defined among arbitrary atoms; an unbounded number of these constraints, 
however, yields a general matrix which requires 0(/) operations to solve. At the loss of some interactivity, 
Sculpt can add or remove a constraint that satisfies the other criteria. Sculpt removes a constraint 
by removing its row in the Jacobian transpose and its row and column in the matrix product. Sculpt adds 
a constraint with an in-order row insertion in the Jacobian transpose and adds a row and a column in 
the matrix product. Scu/pt then searches the Jacobian transpose for nonzero elements in the same columns 
that the new constraint references to determine the new nonzeros in the matrix product. 7. Parallel and 
concurrent processing The constrained minimization algorithm contains computationally-intensive steps 
that can execute concurrently and in parallel. Figure 9 presents steps that can run in parallel (apply 
one algorithm to data in parallel) and concurrently (simultaneous algorithms). Boxes with round comers 
represent independent steps in the minimization. The vertical axis shows data dependencies; a stage cannot 
begin until the previous stage completes. The horizontal axis shows parallel processing within a step 
and concurrent processing between steps. Algorithms beside one another (in Stages 2 and 4) can execute 
concurrently. Square boxes within an algorithm represent processing elements that can execute in parallel. 
Vector and function operations. Stage 1 evaluates the constraint and energy functions and their derivatives 
in parallel. Writing the constraint value and constraint gradient does not require synchronization since 
Sculp/ stores constraint values in separate array elements and constraint gradients in separate rows 
of the Jacobian transpose. Synchronization is necessary when energy gradients are stored because Sculpt 
stores the sum of all the energy gradients. Since energy functions can reference the same variable, simultaneously 
eque tia stages~ 2 3 Ak=b I/ 4 ~(~]j 5 Figure 9: Algorithm concurrency (adjacent boxes with round corners) 
and data parallelism (square boxes) in algorithm. updating the sum can cause errors. Sculpt adjusts for 
this by computing the energy gradients on a small number (four or eight) of processors that each holds 
a local copy of the sum. When all the processors complete, a final step combines the local copies, Stage 
5 performs a vector addition, and Stages 2 and 4 calculate a matrix-vector multiplication. Separate processors 
can compute elements of the resulting vector in parallel. Linear equation solution. Parallel execution 
of Gaussian elimination can reduce the constant of proportionality but not the linear order of complexity. 
Before reducing any row, all prior rows must be reduced. Consider a tri-diagonal mattix-a band­diagonal 
matrix with one band of nonzeros above and below the diagonal. Eliminating the rows below the diagonal 
element (i,i) affects the next row, i+ 1. This prevents processing row i+ 1 until completion of row i. 
Therefore, processing row 1 must complete before beginning row 2, which must complete before beginning 
row 3, etc. 8. Near-neighbor interactions Modeling proteins also requires computing attractions and repulsions 
among nearby atoms. For each atom, Sculpi determines the atoms within a given distance, rneigh, and evaluates 
the van der Waals attractive/repulsive energy function [ 17] betwee~ them (the energy becomes infinitesimal 
beyond six or seven Angstroms). Only a finite number of atoms tit within this neighborhood because each 
atom s electron shell occupies a nonzero volume [11]. A very conservative bound on this number is r~elgh, 
the neighborhood volume divided by the volume of the smallest atom, hydrogen, with a radius of one Angstrom. 
Sculpt uses an algorithm described in [2] to determine neighbor lists. First, uniformly subdivide space 
into cubes with rncigh on each side. Second, deposit each atom into the cube that contains its three-dimensional 
position. Third, set the neighbor list for each atom to the atoms in its cube and adjacent cubes. The 
algorithm takes O(n) steps and runs before Stage 1 in Figure 9, Comtwter GraDhics, 26, 2, JUIV1992 Model 
statistics Without near-neighhor With near-neighbor interactions interactions Model (1) (2) (3)  (4) 
[ Atoms Variables Constraints Energies 1 rocessor 4 rocessors air-m--i 1.405 0.954 0,586 0.396 T 0.147 
0. I05 36 108 96 18 0.045 i 0.048 I Figure 10: Seconds per update with four models using a Silicon 9. 
Implementation and performance Scu@runsona SiliconGraphics240-GTXB[1]. This machine contains four general-purpose, 
MIPS R3000 processors that run at 25 MHz. Figures 10 and 11 show performance results with four protein 
models. The performance (seconds per update) includes the time to receive a user tug, run an iteration 
of the constrained minimization, and re-display the screen. All calculations use double-precision floating-point 
arithmetic. The data on near­neighbor interactions show the perfon-nance with and without a new neighbor 
list determined on each iteration (most batch molecular modeling systems create a new list every few 
iterations), The ln@-actim~.s column lists the average number of interactions per iteration, The models 
include ( 1) the medium-size protein in Figure 2, (2) two of the four helices from that model, (3) a 
segment of ten residues, and (4) a small segment with four residues, The variable field equals the number 
of atoms times three (a three-dimensional coordinate). All data sets model bond lengths, bond angles, 
and single-value dihedral angles with constraints and model multi­value dihedral angles with energy functions. 
Data sets (I) and (2) also contain hydrogen bonds (a weak attraction between nearby atoms, far along 
the backbone) modeled with length and angle springs. 1.8 A I Processor. no near-neighbors 1.6 : * 4 Processors. 
no near-neighbors + o 4 Processors. same neighbor list [.4  4 Processors, new neighbor list I A o * 
A 0 0.4 * 0.2 4 oh o 500 1000 1500 2000 2500 Variables Figure 11: Plot showing linear increase in computation 
with model size. Sculpf contains display, user interface. and minimization modules written in C++ [18]. 
Only five percent of the total code is specific to molecular modeling. That code evaluates the near-neighbor 
potential energy given a list of neighboring atoms and parses optional, protein-specific input. 0.047 
, 0.054 198 I raphics 240-GTX. The input file specifies a protein as a list of three-dimensional points 
with functions defined among them. Figure 12 shows the input for one amino acid residue. Beside each 
point are optional fields specifying protein-specific information used in near­neighbor calculations. 
A sequence of functions appears after the list of points, Each function contains the points that define 
it, the ideal value, and energy constant. This format lets a chemist choose their energy model and parameters 
(e.g. from [4] or [23]). The energy constrains 3: .1: constant is ignored if, at program initialization, 
a user them to their ideal value. -i: -3, -~, _. .. .,: -3. -2. ., ., Glutamate .! ,,: , 4-~ . . ,,1 
,.J ,7 . , .,1 ,,1 le2 , .. ..d . Figure 12: Input file specifying atom positions and topology for a 
glutamate residue. The update rates. though far from those needed for smooth interaction, allow productive 
new research in biochemistry. Professors David and Jane Richardson, collaborators from Duke University 
s Department of Biochemistry, use a preliminary version of Sculp/ for de now design of proteins. They 
believe Sculpt improves productivity and understanding over previous molecular modeling systems [19, 
20]. Maintaining a physically­valid model throughout a modeling session relieves the user from the time-consuming 
task of returning the model to a physically­valid state. Immediately viewing the effect of an atom movement 
provides better awareness of intricate interactions among atoms. 10. Future Work With faster machines, 
Sculpt could model long-distance electrostatic interactions at interactive rates. These interactions 
are commonly modeled between atoms within a ten ~gstrom neighborhood (approximately sixty-five percent 
longer than the current radius). The number of atoms in the neighborhood is still bounded, so the linear 
complexity remains valid. However, the larger radius yields substantially more interactions which destroys 
interactivity on a 240-GTX. The number of t%nctions and variables limits Sculpt s interactive performance 
on current graphics workstations to medium-size proteins. An area for future research is to reduce the 
number of fimctions and variables by using rigid and deformable bodies. A rigid object with few variables 
could replace large segments of a model that a user does not want to change. For example, a user could 
twist a backbone into a helix replacing its atoms and bonds with movable position. The bottleneck in 
the minimization and then freeze the helix by a cylinder of rigid shape but algorithm is the solution 
of linear equations. With four processors, approximately fifty percent of the time in model (1) is used 
to solve the linear equations. Two approaches can significantly reduce this bottleneck. First, an iterative 
method, such as Gauss-Seidel or Conjugate Gradient [12], should converge to a solution faster than direct 
Gaussian elimination. Iterative methods can reduce the average computation but camot reduce the linear 
complexity. Second, the constrained minimization can use a different Lagrange multiplier estimation that 
does not require solving a system of equations. A zero-order method estimates the Lagrange multipliers 
using previous values of the constraints rather than the first-order information contained in the Jacobian 
[7]. A zero-order estimator, in practice, does not make as accurate a prediction as the first-order method, 
so the constrained minimization algorithm requires more iterations. However, the estimation can execute 
in parallel. A constrained minimizer using a zero-order estimator may run significantly faster on a massively-parallel 
machine than the current implementation. Acknowledgements Professors David and Jane Richardson of Duke 
University conceived the idea of interactively sculpting proteins. I thank them for continued guidance 
and encouragement. I thank Professor Frederick Brooks for usefil critiques about the research and the 
manuscript. This work is supported by NIH National Center for Research Resources grant RR-02 170. References 
1. Akeley, K. and Jermoluk, T. High-Performance Polygon Renderirig. Computer Graphics. 22,4 (1988), 239-246. 
 2. Bentley, J. L. and Friedman, J. H. Data Structures for Range Searching. Computing Surveys. 11,4 (1979), 
397-409. 3. Insight. Biosym Technologies Inc., 1991. 4. Brcoks, B. R., Bruccoleri, R. E., Olafson, 
B. D., States, D. J., Swaminathtm, S. and Karplus, M. CHARMM: A Program for Macromolecular Energy, Minimization, 
and Dynamics Calculations. Journal of Computational Chemishy. 4, 2 (1983), 187-217. 5. Duff, I. S., 
Ensman, A. M. and Reid, J. K. Direct Methods for Sparse Matrices. Ckmmdon Press, Oxford, 1986.  6. Fletcher, 
R. Practical Methods of Optimization. John Wiley and Sons, 1987. 7. Gill, P., Murray, W. and Wright, 
M. Practical Optimization. Academic Press, 1981. 8. Hecht, M. H., Richardson, J. S., Richardson, D. 
C. and Ogden, R. C. De Novo Design, Expression, and Characterization of Felix: A Four-Helix Bundle Protein 
of Native-Like Sequence. Science. 249,4964 (1990), 884-891. 9. Hestenes, M. R. Optimization Theory, 
The Finite Dimensional Case. John Wiley and Sons, New York, 1975. 10. Knuth, D. E. Fundamental Algorithms, 
The Art of Computer Programming. Addison-Wesley, 1973. 11. Levinthal, C. Molecular Model-building by 
Computer. Scienhyc American. 214,6 (1966). 12. Luenberger, D. G. Introduction to Linear and Nonlinear 
Programming. Addison-Wesley, 1973. 13. Pentland, A. and Williams, J. Good Vibrations: Modal Dynamics 
for Graphics and Animation. Computer Graphics. 23,3 (1989 ),2 15-222. 14. Platt, J. Constraint Methods 
for Neural Networks and Computer Graphics. Ph.D. Dissertation, California Institute of Technology, 1989. 
 15. Platt, J. Models. 16. Quanta. 17. Schulz, Structure.  and Barr, A. Constraint Methods for Flexible 
Computer Graphics. 22,4 (1988), 279-288. Polygen Corporation, 1991. G. E. and Schirmer, R. H. Principles 
of Protein Springer-Verlag, New York, 1979. 18. Stroustmp, B. The C++ Programming Language. Addison-Wesley, 
1986. 19. Surles, M. Interactive Modeling Enhanced with Constraints and Physics With Applications in 
Molecular Modeling. Symposium on Interactive 3D Graphics. 26,2 (1992), 175­ 182. 20. Surles, M. Techniques 
For Interactive Manipulation of Graphical Protein Models. Ph.D. Dissertation, University of North Carolina 
at Chapel Hill, 1992. 21. Terzopoulos, D. and Fleischer, K. Modeling inelastic Deformation: Viscoelasticity, 
Plasticity, Fracture. Computer Graphics. 22,4 (1988), 269-278. 22. Sybyl Tripes Associates, 1988. 23. 
Weiner, S. J., Kollman, P. A., Case, D. A., Singh, C., Ghio, C., Alagona, G., Profeta, S. and Weiner, 
P. A New Force Field for Molecular Mechanical Simulation of Nucleic Acids and Proteins. Journal 106, 
(1984), 765-784. 24. Witkin, A., Gleicher, Dynamics. Symposium (1990), 11-21. 25. Witkin, A. and Welch, 
 of the American Chemical Socie@. M. and Welch, W. Interactive on Interactive 3D Graphics. 24, 2 W. 
Fast Animation and Control of Nonrigid Structures. Computer Graphics. 24,4 (1990), 243­ 252.  
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134067</article_id>
		<sort_key>231</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>26</seq_no>
		<title><![CDATA[PixelFlow: high-speed rendering using image composition]]></title>
		<page_from>231</page_from>
		<page_to>240</page_to>
		<doi_number>10.1145/133994.134067</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134067</url>
		<keywords>
			<kw><![CDATA[anialiasing]]></kw>
			<kw><![CDATA[compositing]]></kw>
			<kw><![CDATA[deferred shading]]></kw>
			<kw><![CDATA[rendering]]></kw>
			<kw><![CDATA[scalable]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.7</cat_node>
				<descriptor/>
				<type/>
			</primary_category>
			<other_category>
				<cat_node>I.3.1</cat_node>
				<descriptor>Raster display devices</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.3</cat_node>
				<descriptor>Display algorithms</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>C.1.2</cat_node>
				<descriptor></descriptor>
				<type></type>
			</other_category>
			<other_category>
				<cat_node>C.5.4</cat_node>
				<descriptor></descriptor>
				<type></type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010583.10010588.10010591</concept_id>
				<concept_desc>CCS->Hardware->Communication hardware, interfaces and storage->Displays and imagers</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010583.10010633.10010659</concept_id>
				<concept_desc>CCS->Hardware->Very large scale integration design->VLSI system specification and constraints</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010382</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Image manipulation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010372</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Rendering</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010520.10010521.10010528.10010531</concept_id>
				<concept_desc>CCS->Computer systems organization->Architectures->Parallel architectures->Multiple instruction, multiple data</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010372.10010373</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Rendering->Rasterization</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010387</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Graphics systems and interfaces</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010583.10010633</concept_id>
				<concept_desc>CCS->Hardware->Very large scale integration design</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010178.10010224.10010226.10010239</concept_id>
				<concept_desc>CCS->Computing methodologies->Artificial intelligence->Computer vision->Image and video acquisition->3D imaging</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010352</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Animation</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Design</gt>
			<gt>Performance</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>PP39076137</person_id>
				<author_profile_id><![CDATA[81332516521]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Steven]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Molnar]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Department of Computer Science, University of North Carolina, Chapel Hill, NC]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>PP31075577</person_id>
				<author_profile_id><![CDATA[81332497960]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[John]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Eyles]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Department of Computer Science, University of North Carolina, Chapel Hill, NC]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>PP14093769</person_id>
				<author_profile_id><![CDATA[81100243410]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>3</seq_no>
				<first_name><![CDATA[John]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Poulton]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Department of Computer Science, University of North Carolina, Chapel Hill, NC]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_obj_id>378516</ref_obj_id>
				<ref_obj_pid>378456</ref_obj_pid>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Akeley, K. and T. Jermoluk, "High-Performance Polygon Rendering," SIGGRAPH '88, Vol. 22, No. 4, pp. 239-246.]]></ref_text>
				<ref_id>AKEL88</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378518</ref_obj_id>
				<ref_obj_pid>378456</ref_obj_pid>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Apgar, B., B. Bersack, and A. Mammen, "A Display System for the Stellar Graphics Supercomputer Model GS 1000," SIGGRAPH '88, Vol. 22, No. 4, pp. 255-262.]]></ref_text>
				<ref_id>APGA88</ref_id>
			</ref>
			<ref>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Bunker, M. and R. Economy, "Evolution of GE CIG Systems," SCSD Document, General Electric Company, Daytona Beach, FL 32015, 1989.]]></ref_text>
				<ref_id>BUNK89</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378468</ref_obj_id>
				<ref_obj_pid>378456</ref_obj_pid>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[Deering, M., S. Winner, B. Schediwy, C. Duffy, and N. Hunt, "The Triangle Processor and Normal Vector Shader: A VLSI System for High Performance Graphics," SIGGRAPH '88, Vol. 22, No. 4, pp. 21- 30.]]></ref_text>
				<ref_id>DEER88</ref_id>
			</ref>
			<ref>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[Demetrescu, S., A VLSl-Based Real-Time Hidden- Surface Elimination Display System, Master's Thesis, Dept. of Computer Science, California Institute of Technology, 1980.]]></ref_text>
				<ref_id>DEME80</ref_id>
			</ref>
			<ref>
				<ref_obj_id>325174</ref_obj_id>
				<ref_obj_pid>325165</ref_obj_pid>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[Duff, T., "Compositing 3D Rendered Images," SIGGRAPH '85, Vol. 19, No. 3, July 1985, pp. 41-44.]]></ref_text>
				<ref_id>DUFF85</ref_id>
			</ref>
			<ref>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Ellis, J., G. Kedem, T. Lyerly, D. Thielman, R. Marisa, J. Menon, H. Voelcker, "The Raycasting Engine and Ray Representation: A Technical Summary," Proc. of the Intl. Jornal of Cornputational Geometn' and Applications, 1991.]]></ref_text>
				<ref_id>ELLI91</ref_id>
			</ref>
			<ref>
				<ref_obj_id>91437</ref_obj_id>
				<ref_obj_pid>91394</ref_obj_pid>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[Ellsworth, D.E., H. Good, and B. Tebbs, "Distributing Display Lists on a Multicomputer," Computer Graphics (Proceedings of the 1990 Symposium on Interactive 3D Graphics), Vol. 24, No. 2, March 1990, p.147-154.]]></ref_text>
				<ref_id>ELLS90</ref_id>
			</ref>
			<ref>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Ellsworth, D.E. "Parallel Architectures and Algorithms for Real-Time Synthesis of High-Quality Images Using Deferred Shading," Workshop on Algorithms and Parallel VLSI Architectures, Pont-a- Mousson, France, June 12, 1990.]]></ref_text>
				<ref_id>ELLS91</ref_id>
			</ref>
			<ref>
				<ref_obj_id>57405</ref_obj_id>
				<ref_obj_pid>57392</ref_obj_pid>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[Eyles, J., J. Austin, H. Fuchs, T. Greer, and J. Poulton, "Pixel-Planes 4: A Summary," Adv. in Computer Graphics Hardware H (1987 Eurographics Workshop on Graphics Hardware), Eurographics Seminars, 1988, pp. 183-208.]]></ref_text>
				<ref_id>EYLE88</ref_id>
			</ref>
			<ref>
				<ref_obj_id>83821</ref_obj_id>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[Foley, J.D., A. van Dam, S.K. Feiner, and J.F. Hughes, Computer Graphics: Principles and Practice, Addison-Wesley, Reading, MA, 1990. (especially Chapter 18, "Advanced Raster Graphics Architecture")]]></ref_text>
				<ref_id>FOLE90</ref_id>
			</ref>
			<ref>
				<ref_obj_id>810237</ref_obj_id>
				<ref_obj_pid>800179</ref_obj_pid>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[Fuchs, H., "Distributing a Visible Surface Algorithm over Multiple Processors," Proceedings of the ACM Annual Conference, pp. 449-451.]]></ref_text>
				<ref_id>FUCH77</ref_id>
			</ref>
			<ref>
				<ref_obj_id>802893</ref_obj_id>
				<ref_obj_pid>800090</ref_obj_pid>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[H. and B. Johnson, prepublication &amp;all of"An Expandable Multiprocessor Architecture for Video Graphics," Proceedings of the 6th ACM-IEEE Symposium on Computer Architecture, April, 1979, pp. 58-67.]]></ref_text>
				<ref_id>FUCH79</ref_id>
			</ref>
			<ref>
				<ref_obj_id>325205</ref_obj_id>
				<ref_obj_pid>325165</ref_obj_pid>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[Fuchs, H., J. Goldfeather, J. Hultquist, S. Spach, J. Austin, F. Brooks, J. Eyles, and J. Poulton, "Fast Spheres, Shadows, Textures, Transparencies, and Image Enhancements in Pixel-planes," SIGGRAPH '85, Vol. 19, No. 3, pp. 111-120.]]></ref_text>
				<ref_id>FUCH85</ref_id>
			</ref>
			<ref>
				<ref_obj_id>74341</ref_obj_id>
				<ref_obj_pid>74334</ref_obj_pid>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[Fuchs, H., J. Poulton, J. Eyles, T. Greer, J. Goldfeather, D. Ellsworth, S. Molnar, G. Turk, B. Tebbs, and L. Israel, "PixeI-Planes 5: A Heterogeneous Multiprocessor Graphics System Using Processor-Enhanced Memories," SIGGRAPH '89, Vol. 23, No. 3, pp. 79-88.]]></ref_text>
				<ref_id>FUCH89</ref_id>
			</ref>
			<ref>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[Fussel, D. and B. D. Rathi, "A VLSI-Oriented Architecture for Real-Time Raster Display of Shaded Polygons." Graphics Interface '82, 1982, pp. 373- 380.]]></ref_text>
				<ref_id>FUSS82</ref_id>
			</ref>
			<ref>
				<ref_seq_no>17</ref_seq_no>
				<ref_text><![CDATA[Gardner, G.Y., E.P. Berlin, Jr., and B.M. Gelman, "A Real-Time Computer image Generation System using Textured Curved Surfaces," Proceedings of IMAGE II, 1981, pp. 59-76.]]></ref_text>
				<ref_id>GARD81</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378474</ref_obj_id>
				<ref_obj_pid>378456</ref_obj_pid>
				<ref_seq_no>18</ref_seq_no>
				<ref_text><![CDATA[Gharachorloo, N., S. Gupta, E. Hokenek, P. Balasubramanian, B. Bogholtz, C. Mathieu, and C. Zoulas, "Subnanosecond Pixel Rendering with Million Transistor Chips," SIGGRAPH 88, Vol. 22, No. 4, pp. 41-49.]]></ref_text>
				<ref_id>GHAR88</ref_id>
			</ref>
			<ref>
				<ref_seq_no>19</ref_seq_no>
				<ref_text><![CDATA[Knight, T. and A. Krimm, "A Self-Terminating Low- Voltage Swing CMOS Output Driver," IEEE Journal of Solid-State Circuits, Vol. 23, No. 2, April 1988, pp. 457-464.]]></ref_text>
				<ref_id>KNIG88</ref_id>
			</ref>
			<ref>
				<ref_seq_no>20</ref_seq_no>
				<ref_text><![CDATA[Martin, P., and H. Baeverstad, "TurboVRX: A High- Performance Graphics Workstation Architecture," Proc. of A USGtL4PH 90, September 1990, pp. 107- 117.]]></ref_text>
				<ref_id>MART90</ref_id>
			</ref>
			<ref>
				<ref_obj_id>108357</ref_obj_id>
				<ref_obj_pid>108345</ref_obj_pid>
				<ref_seq_no>21</ref_seq_no>
				<ref_text><![CDATA[Molnar, S.E., "Combining Z-buffer Engines for Higher-Speed Rendering," Advances in Computer Graphics Hardware 111, Eurographics Seminars, 1988, pp. 171-182.]]></ref_text>
				<ref_id>MOLN88</ref_id>
			</ref>
			<ref>
				<ref_seq_no>22</ref_seq_no>
				<ref_text><![CDATA[Molnar, S.E., "Efficient Supersampling Antialiasing for High-Performance Architectures," Technical Report TR-91-023, Dept. of Computer Science, UNC-Chapel Hill, 199 i.]]></ref_text>
				<ref_id>MOLN91a</ref_id>
			</ref>
			<ref>
				<ref_obj_id>145453</ref_obj_id>
				<ref_seq_no>23</ref_seq_no>
				<ref_text><![CDATA[Motnar, S.E., "Image Composition Architectures for Real-Time Image Generation," Ph.D. dissertation, also available as UNC-Computer Science Technical Report TR91-046, 1991.]]></ref_text>
				<ref_id>MOLN91b</ref_id>
			</ref>
			<ref>
				<ref_obj_id>807467</ref_obj_id>
				<ref_obj_pid>965105</ref_obj_pid>
				<ref_seq_no>24</ref_seq_no>
				<ref_text><![CDATA[Park, F., "Simulation and Expected Performance Analysis of Multiple Processor Z-Buffer Systems," SIGGRAPH '80, Vol. 14, No. 3, pp. 48-56.]]></ref_text>
				<ref_id>PARK80</ref_id>
			</ref>
			<ref>
				<ref_obj_id>74340</ref_obj_id>
				<ref_obj_pid>74334</ref_obj_pid>
				<ref_seq_no>25</ref_seq_no>
				<ref_text><![CDATA[Potmesil, M., and E. Hoffert, "The Pixel Machine: A Parallel Image Computer," SIGGRAPH '89, Vol. 23, No. 3, pp. 69-78.]]></ref_text>
				<ref_id>POTM89</ref_id>
			</ref>
			<ref>
				<ref_seq_no>26</ref_seq_no>
				<ref_text><![CDATA[Poulton, J., H. Fuchs, and A. Paeth, "Pixel-planes graphic engine," Section 9.5 in Principles of CMOS VLSI Design: A System Perspective, by Neil Weste and Kamran Eshrahian, Addison-Wesley, New York, 1985, pp. 448-480.]]></ref_text>
				<ref_id>POUL85</ref_id>
			</ref>
			<ref>
				<ref_seq_no>27</ref_seq_no>
				<ref_text><![CDATA[Silicon Graphics Computer Systems, Vision Graphics System Architecture, Mountain View, CA 94039- 7311, February 1990.]]></ref_text>
				<ref_id>SGI90</ref_id>
			</ref>
			<ref>
				<ref_obj_id>108358</ref_obj_id>
				<ref_obj_pid>108345</ref_obj_pid>
				<ref_seq_no>28</ref_seq_no>
				<ref_text><![CDATA[Shaw, C.D., M. Green, and J. Schaeffer, "A VLSI Architecture for Image Composition," Advances in Computer Graphics Hardware 111,, Eurographics Seminars, 1988, pp. 183-199.]]></ref_text>
				<ref_id>SHAW88</ref_id>
			</ref>
			<ref>
				<ref_obj_id>112090</ref_obj_id>
				<ref_obj_pid>112073</ref_obj_pid>
				<ref_seq_no>29</ref_seq_no>
				<ref_text><![CDATA[Speck, D., "The Mosaic Fast 512K Scalable CMOS DRAM," Proceedings of the 1991 University of California at Santa Cruz Conference on Advanced Research in VLSI, 1991, pp. 229-244.]]></ref_text>
				<ref_id>SPEC91</ref_id>
			</ref>
			<ref>
				<ref_obj_id>108355</ref_obj_id>
				<ref_obj_pid>108345</ref_obj_pid>
				<ref_seq_no>30</ref_seq_no>
				<ref_text><![CDATA[Schneider, B.O. and U. Claussen, "PROOF: An Architecture for Rendering in Object-Space," Advances in Computer Graphics Hardware 111, Eurographics Seminars, 1988, pp. 121-140.]]></ref_text>
				<ref_id>SCHN88</ref_id>
			</ref>
			<ref>
				<ref_obj_id>806789</ref_obj_id>
				<ref_obj_pid>965161</ref_obj_pid>
				<ref_seq_no>31</ref_seq_no>
				<ref_text><![CDATA[Weinberg, R., "Parallel Processing Image Synthesis and Anti-Aliasing," SIGGRAPH '81, Vol. 15, No. 3, pp. 55-61.]]></ref_text>
				<ref_id>WEIN81</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 PixelFlow: High-Speed Rendering Using Image Composition Steven Molnar, John Eyles, John Poulton Department 
of Computer Science University of North Carolina Chapel Hill, NC 27599-3175  ABSTRACT We describe PixelFlow, 
an architecture for high-speed image generation that overcomes the transformation-and frame-buffer access 
bottlenecks of conventional hardware rendering architec­tures. PixelFlow uses the technique of image 
composition: it distributes the rendering task over an array of identical renderers, each of which computes 
a fill-screen image of a fraction of the primitives. A high-performance image-composition network composites 
these images in real time to produce an image of the entire scene. Image-composition architectures offer 
performance that scales linearly with the number of renderers; there is no fundamental limit to the maximum 
performance achievable using this approach. A single PixelFlow renderer rasterizes up to 1.4 million 
triangles per second, and an n-renderer system can rasterize at up to n times this basic rate. PixelFlow 
performs antialiasing by supersampling. It supports defemed shading with separate hardware shaders that 
operate on composite images containing intermediate pixel data. PixelFlow shaders compute complex shading 
algorithms and procedural and image-based textures in real-time. The shading rate is independent of scene 
complexity. A Pixel Flow system can be coupled to a parallel supercomputer to serve as an immediate­mode 
graphics server, or it can maintain a display list for retained­mode rendering. The PixelFlow design 
has been simulated extensively at high level. Custom chip design is underway. We anticipate a working 
system by late 1993. CR Categories and Subject Descriptors: C. 1.2 [Processor Architectures]: Multiprocessors; 
C.5.4 [Computer System Implementation]: VLSI Systems; 1.3.1 [Computer Graphics]: Hardware Architecture; 
1.3,3 [Computer Graphics]: Picture/Image Generation; 1.3.7 [Computer Graphics]: Three-Dimensional Graphics 
and Realism. Additional Keywords and Phrases: antialiasing, compositing, deferred shading, rendering, 
scalable. Permission to copy wilhout fee all or part of this material is granted provided that the copies 
are not madeor distributed for direct commercialadvantage,the ACM copyright notice and the title of the 
publication and its date appear. and notice is given,that copying is by permission of the Association 
for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific permission. 
 1 INTRODUCTION Graphics applications such as flight and vehicle simulation, computer-aided design, scientific 
visualization, and virtual reality demand high-quality rendering, high polygon rates, and high fi-ame 
rates. Existing commercial systems render at peak rates up to 2 million polygons per second (e.g., Silicon 
Graphics SkyWriter and Hewlett-Packard s VRX). If antialiasing or real­istic shading or texturing is 
required, however, their performance falls by an order of magnitude. To support demanding applications, 
future graphics systems must generate high-resolution images of datasets containing hundreds of thousands 
or millions of primitives, with realistic rendering techniques such as Phong shading, antialiasing, and 
texturing, at high frame rates (230 Hz) and with low latency, Attempts to achieve high performance levels 
encounter two bottlenecks: inadequate floating-point performance for geometry processing and insufficient 
memory bandwidth to the frame buffer [FOLE90]. For example, to render a scene with 100,000 polygons updated 
at 30 Hz, geometry processing requires approximately 350 million floating-point operations per second, 
and rastenzation requires approximately 750 million integer operations and 450 million frame-buffer accesses. 
1 Parallel solutions are mandatory. Most current high-performance architectures use object­parallelism 
for geometry processing; they distribute primitives over a parallel array of floating-point processors, 
which perform transformation, clipping, and perspective division [ELLS90; MART90; SG190]. Tbe same systems 
use pixel-parallelism for rastenzation; frame­buffer memory is divided into several interleaved partitions, 
each with its own rasterization processor. [AKEL88; APGA88; POTM89], This multiplies the effective frame-buffer 
bandwidth by the number of partitions, but does not reduce the number of primitives each processor must 
handle, since most primitives contribute to most partitions [FUCH79]. Because of this limitation, and 
the bandwidth limitations of commercial VRAMS, this approach does not scale much beyond today s rates 
of a few million polygons per second. 1Assumes 50-pixel Gouraud-shaded connected triangles; 3/4 of pixels 
initially visible; includes screen clear for 1280x 1024 display. 01992 ACM-O-89791 -479-l/92/(U17/023 
1 WI.50 231 G R \  GGG GGG R RR ii , ii8  biil m \7 md!!/ L (a) Screen SuMivialon (b) Image Compoaitlon 
Figure 1: Rasterization methods that combine both pixel-and object-parallel rasterization (G = geometty 
processor, R = rasterizer, and To achieve higher rendering performance, object-parallelism must be applied 
throughout the rendering process in rasterization, as well as in geometry processing. There appear to 
be two ways to achieve this: screen subdivision and image composition. The two schemes are shown conceptually 
in Figure 1. In the screen-subdivision approach (introduced in [FUCH77] and [PARK80]), the screen is 
divided into disjoint regions of contiguous pixels, and a rasterization processor is provided for each 
region (Figure 1a). The processors simultaneously rasterize primitives that fall into different screen 
regions. These sub­images are concatenated to form a full-screen image. Several systems of this type 
have been described [GARD81; GHAR88] and one built [FUCH89]. This approach is a natural advance from 
a simple rendering system in which a single geometry processor feeds a single raster­izer. Its main additional 
requirement is a global routing network to transfer primitives from geometry processors to the appropriate 
rasterizer. Since the mapping of primitives to rasterizers varies with the viewing transformation, every 
primitive in the database must be transferred over the network every frame. The network bandwidth is 
therefore high, and increases linearly with the rendering rate, so the approach does not scale indefinitely. 
A second limitation, also due to the global routing network, is the software complexity required to sort 
primitives by screen region and to route them to rasterizers at the appropriate time. Finally, the architecture 
is subject to load imbalances when primitives clump into a few screen regions. System performance can 
decrease significantly in this case. In the image-composition approach, rasterization processors are 
associated with a portion of the primitives, rather than with a portion of the screen (Figure 1b). Each 
rastenzer computes a tidl­screen image of its portion of the primitives, and these images are C = pixel 
compositor). composite, based on visibility, to forma final image. In an image-composition architecture, 
geometry processors and rasterizers can be paired into self-contained units, so the global routing network 
for primitives disappears. Instead, an image­composition network is required to composite output pixels 
from the rasterizers to form the final image. This network can be arranged as a binary tree or a pipeline; 
in either case, all traftlc is local. with fixed bandwidth determined bv frame rate and screen size. 
This gives the architecture its prope~ of linear scalability.2 The remainder of this paper explores the 
opportunities and limita­tions of the image-composition approach. Section 2 discusses image-composition 
architectures in general. Section 3 introduces PixelFlow, an image-composition architecture that achieves 
linearly scalable rendering performance and supports highquality rendering. Sections 4 and 5 describe 
its major hardware and soft­ware components. Section 6 discusses performance issues and presents simulated 
performance results. 2 IMAGE COMPOSITION ARCHITECTURES Image composition has been used in various forms 
for many years, particularly in the video industry (e.g., video overlays and chroma-key) and the computer 
graphics community (e.g., for off­line compositing of rendered images). 2A third method, closely related 
to image composition, is to pro­vide separate rendering pipelines for multiple image fi-arrses. This 
technique, used in SGI S SkyWriter, multiplies a system s render­ing rate and fmme rate by the number 
of rendering pipelines, but does not improve its latency over that of a single pipeline. Several graphics 
architectures based on image composition have been proposed. Processor-per-primitive graphics systems 
are a simple type of image-composition architecture. [BUNK89] de­scribes one such system, General Electric 
s 1967 NASA 11flight simulator, In the NASA II system, polygons (faces) in the database were assigned 
to individual processors (face cards). Each face card rendered an image of its respective face, and the 
results were composite using a static priority scheme. Later researchers proposed using z-values to determine 
the image priority at individual pixels [DEME80; FUSS82], [WEIN81 ] pro­posed an antialiasing scheme 
for a processor-per-primitive system. [DEER88] and [SCHN88] proposed deferred shading as a way to support 
high-quality shading in a processor-per-primitive system. [ELL19 I ] describes a processor-per-primitive 
system specialized for CSG rendering. which was built at Duke University and UNC. A few image-composition 
architectures with multi-primitive renderers have been proposed: [SHAW88] described a simplified version 
of Duff s compositing algorithm [DUFF85] cast in VLSI to create a multi-renderer system that performs 
antialiasing. [MOLN88] proposed a simple z-buffer image-composition scheme to achieve linearly scalable 
rendering performance; this idea was expanded into a dissertation on image-composition architectures 
[MOLN9 Ib], which also describes an early version of the Pixel Flow architecture. 2.1 Advantages and 
Disadvantages Image-composition offers two potential advantages over other architectural approaches: 
linear scalability and a simple program­ ming model. An arbitrary number of renderers can be added to 
the system. since the image-composition network has only local traffic with fixed bandwidth determined 
by screen size and frame rate, Also. since renderers compute their sub-images indepen­dently, they can 
operate with little synchronization. This makes the parallel nature of the system largely transparent 
to the programmer. Image-composition architectures have several disadvantages, however. First, the image-composition 
network must support very high bandwidth communication between renderers. Even though the bandwidth is 
fixed, the network must transfer every pixel during every frame, and each pixel must include visibility 
information and color (and possibly even more data, if deferred shading is used), Second, pixels must 
be reduced to a common format for compositing, so the visibility algorithm is more restrictive than in 
some other approaches, Finally, up to a frame of pixel storage is required per renderer, if an entire 
frame is buffered before being composite; fortunately, this storage requirement can be reduced, as we 
will see in Section 3. 2.2 Antialiasing Aliasing artifacts, once ubiquitous in interactive systems, 
are tolerated less and less each year. Future real-time systems must provide ways to reduce or eliminate 
these astifacts. There appear to be two ways to combat aliasing in image-composition systems: supersampling, 
and A-buffer algorithms [MOLN91 b]. In the supersampling approach, the image is generated and composite 
multiple times, once for each sample in a filter kernel. The compositors perform a simple : comparison 
for each subpixel; then subpixels are blended together after composition to form a final image. In the 
A-buffer approach, each pixel is represented by a variable-length packet describing all surfaces potentially 
visible at the pixel, Compositors merge packets together based on visibility and coverage information. 
The output of the network describes all of the surfaces contributing to each pixel, and this information 
is used to compute the pixel s final color. In comparing the two approaches, the critical factors are 
image quality, image-composition bandwidth, and hardware complexity, Supersampling produces good results, 
provided that sufficient samples are taken per pixel. Unfortunately, the number of samples directly affects 
the bandwidth required of the image­composition network; however, we have produced reasonable­quality 
images with as few as 5 samples per pixel by choosing sample locations and weights carefully [MOLN9 Ia], 
Only the simplest A-buffer methods are feasible in current real­time systems. These methods generally 
sample color and z values at pixel centers only, while calculating pixel coverage at higher resolution. 
This can lead to artifacts. To avoid these artifacts, additional information must be added to the surface 
descriptors; the result is that the two approaches require comparable bandwidth. In terms of hardware 
complexity, A-buffer renderers and compositors are fairly complex, while the z-depth compositors for 
supersampling are very simple. The A-buffer approach supports true transparency, however, which is problematic 
in the supersampling approach. 2.3 Deferred Shading Image-composition architectures can take special 
advantage of deferred shading, a general method for reducing the calculations required for complex shading 
models by factoring them out of the rssterization step [DEER88; ELLS91 ]. Many shading calculations depend 
only on geometric and intrinsic attributes, such as surface­normal vectors and surface color. If these 
attributes are calculated and stored during rasterization, shading can be deferred until the entire scene 
has been rasterized, and applied only to the surfaces that are visible. To defer shading in an image-composition 
system, rasterizers compute generic pixel attributes and composite these, rather than pixel colors. A 
separate hardware unit performs shading a~er pixels have been composite. In this manner, shading is performed 
just once per pixel, no matter how many surfaces contribute to it and how many rasterizers are in the 
system. Deferred shading does increase image-composition bandwidth, however, since the number of bits 
per pixel is generally higher. Deferred shading also separates performance concerns between the rendering 
and shading portions of the machine. Renderers can be built to rasterize as fast as possible, and the 
number of renderers can be chosen to achieve a given polygon rate. Shading performance is independent 
of the rastenzing performance of the system, but most be high enough to support the desired shading model. 
3 PIXELFLOW ARCHITECTURAL OVERVIEW PixelFlow is an experimental graphics system designed to demonstrate 
the advantages of image-composition architectures and to provide a research platform for real-time 3D 
graphics algorithms and applications. In this section we describe its major architectural features and 
the rationale under which they were chosen. Section 4 provides details of system components. Supersampling 
antialiasing. PixelFlow uses the supersampling approach because it is general, the compositor hardware 
is simple, and therefore fast, and it can be tuned to trade speed for image quality. This leads to renderers 
based on z-buffer raaterizem and a z-based image-composition network. Unfortunately, this requires screen-door 
or multi-pass algorithms to support transparency. Plpelined image-composition network. Generating Gouraud­ 
shaded, supersampled, high-resolution images at 30 Hz frame rates requires composition-network bandwidth 
of at least 1280x 1024 pixels . 5 samples/pixel . 48 bits/sample . 30 flames/second = 9.4 Gbita/second. 
Deferred shading algorithms require 2 to 3 times this amount, Packaging considerations favor a pipeline 
image-composition network. The image-composition network can be distributed across the system by including 
a compositor on each board and daisy-chaining connections between boards. Logic-enhanced memory rasterizer. 
The renderer should a single-board design, must provide a way to scan out pixels at the bandwidth required, 
and should implement the compositor function at relatively low cost in board area, power, and dollars. 
These considerations mainly affect the design of the rasterizer. The logic-enhanced memory approach used 
in Pixel-Planes 5 allows a powerfid rssterizer and high-bandwidth compositor to be built in a single, 
compact package. In PixelFlow, we use a similar logic-enhanced memory approach. A rasterizer built with 
new PixelFlow enhanced-memory chips (EMCS) can render in excess of one million triangles per second and 
provide image­composition bandwidth exceeding 30 Gbitsfsecond using 64 custom memory chips and one custom 
controller on about 50 square inches of board area. Region-based rendering scheme. The compactness of 
this approach is obtained at the cost of introducing screen subdivision at the level of the individual 
renderers. As in Pixel-Planes 5, each rastcrizer contains only 128x128 pixel processors, and must generate 
a full-screen image in multiple steps. The advantage is that an entire screen s worth of pixel memory 
is not required. Unfortunately, this implementation incurs the load-balancing problems of screen subdivision, 
but these difficulties are greatly reduced by providing several region s worth of buffering within tie 
PixelFlow EMCS. The required image-composition bandwidth is achieved in two ways. First, the network 
operates bit-serially, but in parallel on 256 pixels, each with its own single-wire channel. Bit-serial 
z­comparison simplifies the compositors and thereby allows them to operate at high speed. Second, the 
network consists entirely of point-to-point communication between identical custom chips on neighboring 
boards, so low voltage swings and source termination can be used to save power and provide the necessary 
speed (132 MHz) [KNIG88]. Separate shaders for deferred shading. Deferred shading algorithms, such as 
Phong shading and procedural and image­based textures, are implemented on separate hardware shaders that 
reside just ahead of the flame buffer. Regions of pixels, containing attributes such as intrinsic color, 
surface normals, and texture coordinates are rasterized on the renderers, compositcd on the image-composition 
network, and loaded into the shaders. Shaders operate on entire regions in parallel, to convert raw pixel 
attributes into final RGB values, blend multiple samples together for rmtialiasing, and forward final 
color values to the frame buffer. Regions are assigned to shaders in round-robin fashion. The number 
of shaders required depends on the shading algorithm only, not on the number of primitives, since deferred 
shading is employed. The SIMD rasterizer used in the renderer is an ideal processor for deferred shading, 
since shading calculations can be performed for all pixels simultaneously. Therefore, the shaders can 
simply be designated renderers, with a slight enhancement of the compositor hardware on the EMC to allow 
bidirectional data transfers between the image-composition network and EMC memory. Shaders can be augmented 
with additional hardware to allow them to compute image-based textures in addition to procedural textures. 
4 PIXELFLOW HARDWARE A PixelFlow system is composed of one or more card cages, each containing up to 
20 circuit boards. The backplane contains wiring for the image-composition network and clock and power 
distribution. The system is modular and can be configured with any number of card cages. Each board has 
a high-speed link connecting it to a host computer. Figure 2 shows a block diagram of a PixelFlow system. 
Fast serial Immediate-mode inkr I PJishadm c~p ter I ,,,,,,r,feo r I .omma*ds \..... ...------­ pixel 
values ~~ .A Boaro . , . (256 wires @ 132 MHz  ins; ~kw  Figure 2: Block diagram of a PixelFlow system. 
Renderers operate by sequentially processing 128x128-pixel regions of the screen. They scan out the region 
s rasterized pixels over the image-composition network in synchrony with the other renderers. Shaders 
load pixels from the image-composition network, perform texturing and shading, blend subpixel samples, 
and forward pixel values to the tie buffer, The system is designed to be used in one of two basic modes 
1) Immediate Mode. PixelFlow is hosted by a parallel computer, with each link connected to a separate 
compute node in the host. The host (e.g., an Intel Touchstone) runs an application and generates immediate-mode 
primitives, which are transmitted to renderers over the links. 2) Retained Mode. PixelFlow is hosted 
by a workstation; the high-speed links are bussed together and connected to the host via a single interface. 
The host distributes a display Vldao Renderln Comma J s Shsdlng Commanda , Renderer Board Shader Board 
4 ===?+ . .. ~. ~128x128-Pixei I g~ ~ SiMD Array ~ ­ (64 EMC S) 1? .1 1 .. (a) (b) (c) Figure 3: Block 
diagrams of (a) renderer, (b) shader, and (c) frame-buffer boards. list over the renderers and loads 
a shading model into the Geometry processor. The geometry processor is a fast floating­shaders. On each 
frame, the host broadcasts editing point processor that retains a portion of a distributed dispiay list 
commands and viewing parameters to the renderers, each (retained mode) or receives a fraction of the 
primitives from the of which then computes an image of its fraction of the host on each frame (immediate 
mode). it transforms its portion of dataset. the primitives into screen coordinates, sorts them by screen 
region, and passes them to the rssterizer. It contains 8 MBytes of VRAM memory, serving both as main 
memory and as a iargeEach of the primary board types (renderers, shaders, and frame FIFO queue for buffering 
commands to the rasterizer. A DMAbuffers) includes a core consisting of a geometry processor mid a engine 
controls the flow of commands from the VRAMS serialrasterizer built from the new EMC chips. These core 
elements port to the rasterizer, maintaining separate queues of commandshave different fiction on the 
three board types, and shaders and for rasterization and for transfers over the image-compositiontlame 
buffers contain additional components (Figure 3). network. Rssterizer. The rasterizer is a 128x128 SIMD 
processor array implemented with 64 PixeiFlow EMCS driven by instructions and The image-composition 
network is a wide (256-bit), high-speed data broadcast from an Image Generation Controller (IGC) ASIC. 
(132 MHz) speciai-purpose communication network for rapidly moving pixei data between boards. It is distributed 
across the The PixelFlow EMC (Figure 5) is similar to our previous designs EMCS on each board, with each 
EMC implementing a 4-bit-wide [EYLE88; POUL85]. A linear expression evaluator computes slice (4 input 
pins and 4 output pins). Compositors on the EMCS values of the bilinear expression ,4x+@-t-C at every 
pixel synchronously transmit data unidirectionally to the compositors processor in parailel (XY is the 
pixel processor s screen iocation on the downstream board. and A, B, and C are user-specified). Each 
pixel has a small local ALU that performs arithmetic and logicai operations on locai Compositor modes. 
The basic unit of operation is the transfer of memory and on the iocai value of the bilinear expression. 
one 128x 128-pixel region of pixel data; the amount of data trans-Operation of the pixel processors is 
SIMD (singie-instruction­ferred per pixel is preset according to the specific algorithm. The multiple-data), 
and all processors operate on data items at the compositors operate in one of four modes, as shown in 
Figure 4. same address. Each pixel processor includes an enable register which qualifies writes to memory, 
so that a subset of the processors can be disabled for certain operations (e.g. painting a 4.1 Image-Composition 
Network 4.2 Renderer scan-converted polygon). The renderer block diagram is shown in Figure 3a. Its 
major components are: Load upstream pixels into memory; forward downstream. Unload localpixels Forward 
upstream downstream, pixelsdownstream. Figure 4: Compositor operating modes. Several features distinguish 
the PixelFlow EMC from our previous designs: . Higher clock s~eed. The new EMC, fabricated on a 0.8Lr 
CMOS process: operates at 66 MHz for image-generation operations; its image-composition port transmits 
data at 132 MHz. . 8-bit processors. The pixel processors, linear expression evaluator, and memory bus 
for each pixel are eight bits wide, rather than bit-serial. This increases the performance for many operations 
by nearly a factor of eight. . Fast multiply hardware. Pixel processors include hardware support for 
multiplies, allowing 16-bit multiplies to be performed in less than a microsecond a total of 19 billion 
multiplies per second for a 128x128-pixel array. This feature accelerates multiply-intensive shading 
calculations. . 2048+ bits per pixel. The memory design uses a I­transistor dynamic memory cell [SPEC91 
], rather than the 6-transistor static memory cell used previously. Memory per pixel can be increased 
to 2048 bits, plus two 256-bit communication buffers. . Compositor and local-access ports. The PixelFlow 
EMC-contains two communication ports, one for the image-composition network, and one for communicating 
with texture memory or a frame buffer. Each port contains a 256-bit buffer of pixel memory that can be 
read or written by the pixel ALU or decoupled from it during port operation. The local-port connects 
to external texture memory (on a shader board) or a VRAM fi-ame store (on a frame-buffer board) through 
a custom datapath ASIC.  The IGC is a single custom ASIC which controls the rasterizer array. It converts 
floating-point A, B, and C coefficients into byte­serial, fixed-point form; it sequences EMC operations 
by broadcasting data, control, and address information to the EMC array; and it controls the compositor 
ports on the EMCS. ALU Pixel A,13,C Mlcro-Memory Dakinput instruction Address t I EEIGZsli. Dafs Pixel 
/ PixelFlow EMC Compositor i ..  I c1 4-M slice of Image ComDosifionNetwork Figure 5: Block diagram 
of PixelFlow Enhanced Memory Chip. The lGC contains a subpixel offset register that allows the multiple 
samples of the supersampling filter kernel to be computed from the same set of rasterization commands, 
by repeatedly reading these commands from VRAM memory. This improves system performance when supersampling, 
since additional samples are rasterized without increasing the load on the geometry processor. As a result, 
a single i860XP geometry processor can keep up with the rasterizer when supersampling with 6 or more 
samples per pixel, 4.3 Shader The shader (Figure 3b), like the renderer, contains a geometry processor, 
rasterizer, and compositor. The shader s geometry processor is merely a control processor which passes 
shading commands to the rastenzer. The rasterizer is used as a SIMD shading processor, computing lighting 
and shading models for all pixels in a region in parallel. The compositors are used to load composite 
regions and unload fully-shaded pixels. The local communication port of the EMCS is connected to external 
memory that contains image-based textures (such as Mip­maps). Multiple banks of texture memory, each 
holding an identical copy of the texture data, are required to match the performance of the shader to 
that of the image-composition network. The shader supports general table-lookup operations, so it can 
perform related functions such as bump mapping, environment mapping, and image warping. The shader can 
be loaded with an image, from which it computes a Mip-map that can then be loaded into texture memory. 
These algorithms will be described in a titure publication. 4,4 Frame Buffer The frame buffer (Figure 
3c) closely resembles the shader, but in place of texture storage, it contains a separate double-buffered 
VRAM frame buffer, The ffame buffer board is itself a complete, fairly powerful, self-contained graphics 
system, since it also contains the core elements (geometry processor and rastenzer). Function on Image 
Compoaltlon Network composnormodes  SampleOofregm OIScomposdadandunkicmpcmpcmp Id~ L_lu L-lu* loadedIntoshaderO 
connectionpanem  utlklcmpC@ cmp (WI Id SampleOofregion1IScompos[tedand uuu~ loadedIntoshader1 .. e 
un~ c~,pcnJpcy,p y Sample1ofregionOIScomposltedand loaded,ntoshaderO wld cmpcmfrcmpW (d Sample1ofreg!on1IScompesdedand 
uuu~ loadedmloshader1 . F[nalpixelvaluesforregionOareloaded w 4 mfoFrameBuffer(remamderofImage compcmtlonISIdle) 
network Samp~eOofragon2 IScomposlfedandvnkttc~,pcqp c~lp jl unld Id loadedIntoshaderO,wh[fefinalpixelvalues 
forreg[on1areloadedmtoFrameMfer Wrlddllp ~p Cyp W Id SampleOofregion3 IScomposdedand dumped!ntoshader1 
 Figure 6: Composition network operations for a 4­renderer, 2-shader system computing an image with 2­sample-per-pixel 
antialiasing. SOFTWARE PixelFlow software consists of two parts: rendering software. which transforms 
primitives and produces rasterizationlshading commands for the rasterizer. and control software, which 
sequences region-by-region operations. Both sets of software run on the geometry processor of each system 
board. Geometric transformations are performed using standard algorithms. and rasterization and shading 
are performed using the algorithms developed for Pixel-Planes 4 and 5 [FUCH85; FUCH89], The basic control 
algorithm to compute an image contains four steps: 1) The geometry processor on each renderer transforms 
its portion of the primitives and sorts them by 128x128-pixel regions on the screen. 2) The rastcrizer 
computes pixel values for all primitives in a region and for one sample of the antialiasing kernel. 3) 
When all renderers have finished step (2), the region is composite over the image-composition network 
and deposited into one of the shaders. 4) Steps (2) and (3) are repeated for each sample and for each 
rcg~on on the screen. These steps can be pipelined (i.e. one rcgionlsample is rasterized while the previous 
one is composite). Transfers over the image-composition network are the only operations that require 
tight synchronization between boards. A hardware token chain determines when all of the boards are ready 
to begin efich transfer. Figure 6 shows the sequence of composition network operations in a 4-renderer, 
2-shader system , ,amplc-pcr.antialiasing. pixel computing an image with .-s Tbe large amount of pixel 
memory on the EMCS allows several regions of pixels to be buffered before they are composite. This is 
important for load balancing, since different numbers of primitives may fall into a given region on different 
renderers (see Section 6). To take full advantage of this buffering, regions are processed in a scattered 
pattern, since neighboring regions tend to have similar over-or underloads; successive samples of a given 
region are never handled sequentially. 6 PERFORMANCE The performance of a Pixel Flow system is governed 
by four basic parameters: . Image-Composition Network bandwidtb. Gross bandwidth = 256 bits . 132 MHz 
= 33.8 GBits/sec. Net bandwidth (assuming 10°0 synchronization ovdrhead) = 30 GBits/see, Geometry processor 
performance. A single i860XP microprocessor can process approximately I 50,000 triangles per second, 
independent of the number of samples per pixel. . Rasterizer performance. A 64-EMC rasterizer can process 
approximately 1.4 million Gouraud-shaded triangles per second and 0.8 million Phong-shaded, textured 
triangles per second, but this rate must be divided by the number of samples per pixel. Shader Performance. 
A single shader can Phong-shade and compute procedural textur~s for approximately-l 0,000 128x 128-pixel 
regions per second. It can compute Mip­map textures for approximately 3,700 regions per second. The following 
expression can be used to estimate system performance given the performance above: v ~,,g,,,,,, T. = 
~ t?lax rOld , cmnP shade 1 V,Yha&#38;r.y [) ~rame / ;=I where T/.e,ldi = max( TgC>~,nli.Tra,Yri)(the 
rendering time for R(giotll ) TCOrrTl) = compositing time for a region ( 1282 pixels . bits per pixel 
30 GBitslsec) Tvhu(je = time to shade a region (approx. 270 ysec for Phong shading and texturing) If 
antialiasing is done, the summation is over all regions and over all antialiasing samples. This equation 
says that the frame time is given by the sum of the times required to compute each region. and that each 
region time is given by the maximum of the geometry proeessin~rasterization time, image composition time, 
and shading time for the region. Both Tc.c)n!pand ~$hadc, are constants, for a given rendering algo­rithm. 
Tre17~ivaries depending on the number of renderers, the number of prlmltlvcs. and their distribution 
over the renderers and over the screen. Tcomp provides an UPPer bound on frame rate> as shown in Fi~re 
7 for several rendering algorithms and system configurations. Bits per pixel Samples Screen Frame/see 
64 (Gouraud) 16 1280x I024 22 96 (Phong) 1 1280x 1024 >100 96 (Phong) 5 1280x I024 48 192 (Phong, textured) 
5 128OX1O24 24 192 (Phong, textured) 16 640X5 12 29 Figure 7: Peak performance dictated by composition­ 
network bandwidth under varying conditions. Actual system performance can be lower than predicted by 
this equation because of several factors: First, primitives may cross region boundaries and require processing 
in multiple regions. This increases the rasterization load by approximately 20 %. for 100-pixel polygons. 
Second, primitives may clump in different screen regions on different renderers. This increases the rasterization 
time on certain renderers relative to others. The extra buffering on the EMCS reduces this effect, but 
does not eliminate it entirely. For severely clumped images, system performance can be reduced from 20-60%. 
Finally, rasterization and compositing are pipelined, so that one region is rasterized while the previous 
one is composite. This requires a few idle region times at the start and end of a frame (app~oximately 
5 10% o~erhead). Polio ( 7s) pities ( 1s Poho (P$).­ ~ /.. - .#­ ,; 9/------­ -----­ Spa_c@(69)_ ... 
. - / /­ *,: .0 ... ... . L 12 128 4 8 163264 Number of Renderera Figure 8: Simulated performance for 
various system configurations. Because these factors are scene dependent, they cannot be modelled analytically. 
We have written a timing simulator for PixelFlow that models these effects and have used it to compute 
performance for a variety of images and rendering algorithms. Figure 8 shows simulated performance for 
the four sample databases shown in Figure 9. Simulations were run with 1 to 128 renderers and 4 shaders. 
Two curves are shown for each dataset: one for a supersampled image with 6 samples per pixel (6s), and 
one for a fully-aliases image with one sample per pixel (1s). For the 6s case, we assumed the geometry 
processor is a 66-MHz i860XP; for the is case, we assumed that a sufficiently powerful geometry processor 
is availabie so that renderer performance is rasterizer-iimited. These simuiated results show the behavior 
predicted by the equation above. System performance scales linearly with the number of renderers until 
a knee is reached, where compositing time dominates rasterization time (shading time is not a limiting 
factor for any of these datasets). The space station dataset, in particular, is very smali (3,784 primitives), 
so this knee is reached at only 4 renderers. Only the polio dataset is large enough to show iinear scalability 
to 128 renderers. 7 CONCLUSIONS We have introduced PixelFlow, a new architecture for high-speed image 
generation, and one of the first to use reai-time image composition with multi-primitive renderers. Its 
combination of million-triangle-per-second renderers and high-performance compositing network give it 
linearly scalable performance to tens of millions of polygons per second far above the performance of 
current systems. All of the components of PixelFlow are programmable: its geometry processors are conventional 
microprocessors; its rasterizers are programmable SIMD processors; its image­composition network is a 
general pixel datapath. In addition to standard rendering algorithms, such as Gouraud-and Phong­shading 
of polygonal primitives, PixeiFlow can render primitives such as spheres, quadrics, and voiume data with 
high-quality shading methods, such as local light sources, procedural and image-based texturing, and 
environment mapping. A PixelFiow system can be configured in a variety of ways. Hosted by a single workstation, 
it can render PHIGS-type retained-mode datasets. Coupled to a parallel supercomputer, it can serve as 
a visualization subsystem for immediate-mode rendering. Using PixeiFlow silicon, a million-triangie-per-second 
rasterizer could be built on a small circuit board. At the time this paper was written, logic design 
for the custom chips was nearly complete. We anticipate completing circuit design for the system by mid-1993 
and competing a prototype system by late 1993. ACKNOWLEDGEMENTS We acknowledge the following peopie for 
their suggestions and contributions to this work: Henry Fuchs, Turner Whitted, Anselmo Lastra, Jon Leech, 
Brice Tebbs, Trey Greer, Lee Westover, and the entire Pixel-Planes team. This research is supported in 
part by the Defense Advanced Research Projects Agency, DARPA ISTO Order No, 7510, and the National Science 
Foundation, Grant No. MIP-9000894.  ELLS91 EYLE88 FOLE90 FUCH77 FUCH79 FUCH85 FUCH89 FUSS82 GARD81 
GHAR88 KNIG88 MART90 MOLN88 Ellsworth, D.E. Parallel Architectures and Algorithms for Real-Time Synthesis 
of High-Quality images Using Deferred Shading, Workshop on Algorithms and Parallel VLSI Architectures, 
Pont-a-Mousson, France, June 12, 1990. Eyles, J., J. Austin, H. Fuchs, T. Greer, and J. Poulton, Pixel-Planes 
4: A Summary, Adv. in Compu;er Graphics Hardware II ( 1987 Eurographics Workshop on Graphics Hardware), 
Eurographics Seminars, 1988, pp. 183-208. Foley, J. D., A. van Dam, S.K. Feiner, and J.F. Hughes, Computer 
Graphics: Principles and Practice, Addison-Wesley, Reading, MA, 1990. (especially Chapter 18, Advanced 
Raster Graphics Architecture ) Fuchs, H., Distributing a Visible Surface Algorithm over Multiple Processors, 
 Proceedings of the ACM Annual Conference, pp. 449451. Fuchs, H. and B. Johnson, prepublication draft 
of An Expandable Multiprocessor Architecture for Video Graphics, Proceedings of the 6th ACM-IEEE Symposium 
on Computer Architecture, April, 1979, pp. 58&#38;67. Fuchs, H., J. Goldfeather, J. Hultquist, S. Spach, 
J. Austin, F. Brooks, J. Eyles, and J. Poulton, Fast Spheres, Shadows, Textures, Transparencies, and 
Image Enhancements in Pixel-planes, SIGGRAPH 85, vol. 19, No. 3, pp. 1] 1-120. Fuchs, H., J. Poulton, 
J. Eyles, T. Greer, J. Goldfeather, D. Ellsworth, S. Molnar, G. Turk, B. Tebbs, and L, Israel, Pixel-Planes 
5: A Heterogeneous Multiprocessor Graphics System Using Processor-Enhanced Memories, SIGGRAPH 89, vol. 
23, No. 3, pp. 79 88. Fussel, D. and B. D. Rathi, A VLS1-Oriented Architecture for Real-Time Raster Display 
of Shaded Polygons. Graphics Interface 82, 1982, pp. 373­ 380. Gardner, G. Y., E,P, Berlin, Jr., and 
B.M. Gelman, A Real-Time Computer Image Generation System using Textured Curved Surfaces, Proceedings 
of IMAGE II, 1981, pp. 59 76. Gharachorloo, N., S. Gupta, E. Hokenek, P. Balasubramanian, B. Bogholtz, 
C. Mathieu, and C. Zoulas. Subnanosecond Pixel Rendering with Million Transistor Chips, S/GGRAPH 88, 
Vol. 22, No. 4, pp. 4149. Knight, T. and A. Krimm, A Self-Terminating Low-Voltage Swing CMOS Output Driver, 
IEEE Journal of Solid-State Circuits, Vol. 23, No. 2, April 1988, pp. 457464. Martin, P., and H. Baeverstad, 
TurboVRX: A High-Performance Graphics Workstation Architecture, Proc. of AUSGR4PH 9(?, September 1990, 
pp. 107­ 117. Molnar, SE., Combining Z-buffer Engines for Higher-Speed Rendering, Advances in Computer 
Graphics Hardware 111, Eurographics Seminars, 1988, pp. 171 182. MOLN91 a MOLN91b PARK80 POTM89 POUL85 
SG190 SHAW88 SPEC9 I SCHN88 WEIN81 Moinar, S. E., Efficient Supersampling Antialiasing for High-Performance 
Architectures, Technical Report TR-91 -023, Dept. of Computer Science, UNC-Chapel Hill, 1991. Molnar, 
S. E., Image Composition Architectures for Real-Time Image Generation, Ph.D. dissertation, also available 
as UNC-Computer Science Technical Report TR91-046, 1991. Park, F., Simulation and Expected Performance 
Analysis of Multiple Processor Z-Buffer Systems, SIGGRAPH 80, Vol. 14, No. 3, pp. 48-56, Potmesil, M., 
and E. Hoffert, The Pixel Machine: A Parallel Image Computer, S2GGRAPH 89, Vol. 23, No. 3, pp. 69-78. 
Poulton, J,, H. Fuchs, and A. Paeth, Pixel-planes graphic engine, Section 9.5 in Principles of CMOS VLSI 
Design: A System Perspective, by Neil Weste and Kamran Eshrahian, Addison-Wesley, New York, 1985, pp. 
448-480. Silicon Graphics Computer Systems, Vision Graphics System Architecture, Mountain View, CA 94039­7311, 
February 1990. Shaw, C. D., M. Green, and J. Schaeffer, A VLSI Architecture for Image Composition, Advances 
in Computer Graphics Hardware III,, Eurographics Seminars, 1988, pp. 183-199. Speck, D., The Mosaic Fast 
5 12K Scalable CMOS DRAM, Proceedings of the 1991 University of California at Santa Cruz Conference on 
Advanced Research in VLSI, 1991, pp. 229-244. Schneider, B.O. and U. Claussen, PROOF: An Architecture 
for Rendering in Object-Space, Advances in Computer Graphics Hardware III, Eurographics Seminars, 1988, 
pp. 121-140. Weinberg, R., Parallel Processing Image Synthesis and Anti-Aliasing, SIGGRAPH 81, Vol. 15, 
No. 3, pp. 55 61  
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134069</article_id>
		<sort_key>241</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>27</seq_no>
		<title><![CDATA[A scalable hardware render accelerator using a modified scanline algorithm]]></title>
		<page_from>241</page_from>
		<page_to>248</page_to>
		<doi_number>10.1145/133994.134069</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134069</url>
		<keywords>
			<kw><![CDATA[data sharing]]></kw>
			<kw><![CDATA[low bandwidth]]></kw>
			<kw><![CDATA[low cost]]></kw>
			<kw><![CDATA[scanline]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Visible line/surface algorithms</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>I.3.1</cat_node>
				<descriptor>Raster display devices</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.3</cat_node>
				<descriptor>Display algorithms</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>B.2.1</cat_node>
				<descriptor>Parallel</descriptor>
				<type>S</type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010147.10010371.10010372</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Rendering</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010387</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Graphics systems and interfaces</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010382</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Image manipulation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010583.10010600.10010615</concept_id>
				<concept_desc>CCS->Hardware->Integrated circuits->Logic circuits</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010583.10010588.10010591</concept_id>
				<concept_desc>CCS->Hardware->Communication hardware, interfaces and storage->Displays and imagers</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010372.10010373</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Rendering->Rasterization</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010372.10010377</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Rendering->Visibility</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010382</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Image manipulation</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
			<gt>Design</gt>
			<gt>Measurement</gt>
			<gt>Performance</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>PP14115734</person_id>
				<author_profile_id><![CDATA[81407592847]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Michael]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Kelley]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Apple Computer, Inc., 20525 Mariani Avenue, Cupertino, CA 95014]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>PP31100656</person_id>
				<author_profile_id><![CDATA[81332535902]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[Stephanie]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Winner]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Apple Computer, Inc., 20525 Mariani Avenue, Cupertino, CA 95014]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P161931</person_id>
				<author_profile_id><![CDATA[81332501460]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>3</seq_no>
				<first_name><![CDATA[Kirk]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Gould]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Apple Computer, Inc., 20525 Mariani Avenue, Cupertino, CA 95014]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_obj_id>378516</ref_obj_id>
				<ref_obj_pid>378456</ref_obj_pid>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Akeley, Kurt and T. Jermoluk, "High-Performance Polygon Rendering", Computer Graphics, Vol. 22, No. 4, August 1988, 239-246]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378518</ref_obj_id>
				<ref_obj_pid>378456</ref_obj_pid>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Apgar, Brian, B. Bersack and A. Mammen, "A Display System for the Stellar Graphics Supercomputer Model GS1000", Computer Graphics, Vol. 22, No. 4, August 1988, 255-262]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Catmull, E., "A Subdivision Algorithm for Computer Display of Curved Surfaces", UTEC-CSc-74-133, Computer Science Department, University of Utah, Salt Lake City, UT, December 1974]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_obj_id>801272</ref_obj_id>
				<ref_obj_pid>965145</ref_obj_pid>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[Clark, James, "}'he Geometry Engine: A VLSI Geometry System for Graphics", Computer Graphics, Vol. 16, No. 3, July 1982, 127-133]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378468</ref_obj_id>
				<ref_obj_pid>378456</ref_obj_pid>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[ing, Michael, S. Winner, B. Schediwy, C. Duf~ and N. Hunt, "The Triangle Processor and Normal Vector Shader: A VLSI System for High Performance Graphics", Computer Graphics, Vol. 22, No. 4, August 1988, 21-30]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_obj_id>83821</ref_obj_id>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[Foley, James, A. van Dam, S. Feiner and J. Hughes, "Computer Graphics Principles and Practice, 2nd Edition", Addison-Wesley, 1990, 96-99 (basic scan conversion), 201-283 (transformation), 680-685 (scanline algorithms), 885-887 (scanline rasterization)]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_obj_id>42460</ref_obj_id>
				<ref_obj_pid>42458</ref_obj_pid>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Fournier, Alain and D. Fussell, "On the Power of the Frame Buffer", Transactions on Graphics, Vol. 7, No. 2, April 1988, 103-128]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[Fuchs, Henry and J. Poulton, "Pixel-Planes: A VLSI- Oriented Design for a Raster Graphics Engine", Computer Graphics, Vol. 15, No. 3, August 1981, 80-81]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_obj_id>74370</ref_obj_id>
				<ref_obj_pid>74334</ref_obj_pid>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Gharachorloo, Nader, S. Gupta, R. Sproul} and I. Sutherland, "A Characterization of Ten Rasterization Techniques", Computer Graphics, Vol. 23, No. 3, July 1989, 355-368]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_obj_id>97913</ref_obj_id>
				<ref_obj_pid>97880</ref_obj_pid>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[Haeberli, Paul and K. Akeley, "the Accumulation Buffer: Hardware Support for High-Quality Rendering", Computer Graphics, Vol. 24, No. 4, August 1990, 309-318]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
			<ref>
				<ref_obj_id>97912</ref_obj_id>
				<ref_obj_pid>97880</ref_obj_pid>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[Kirk, David and D. Voorhies, 'The Rendering Architecture of the DN10000VS", Computer Graphics, Vol. 24, No. 4, August 1990, 299-307]]></ref_text>
				<ref_id>11</ref_id>
			</ref>
			<ref>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[Myers, A. J., "An Efficient Visible Surface Program", Report to the National Science Foundation, Computer Graphics Research Group, Ohio State University, Columbus, OH, July 1975]]></ref_text>
				<ref_id>12</ref_id>
			</ref>
			<ref>
				<ref_obj_id>808580</ref_obj_id>
				<ref_obj_pid>964965</ref_obj_pid>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[Niimi, Haruo, Y. Imai, M. Murakami, S. Tomita and H. Hagiwara, "A Parallel Processor System for Three- Dimensional Color Graphics", Computer Graphics, Vol. 18, No. 3, July 1984, 67-76]]></ref_text>
				<ref_id>13</ref_id>
			</ref>
			<ref>
				<ref_obj_id>74339</ref_obj_id>
				<ref_obj_pid>74334</ref_obj_pid>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[Rhoden, Desi and C. Wilcox, "Hardware Acceleration for Window Systems", Computer Graphics, Vol. 23, No. 3, July 1989, 61-67]]></ref_text>
				<ref_id>14</ref_id>
			</ref>
			<ref>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[Watkins, G. "A Real-Time Visible Surface Algorithm", Computer Science Department, University of Utah, UTECH-CSC-70-101, June 1970]]></ref_text>
				<ref_id>15</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 .//$ Computer Graphics, 26, 2, July 1 992 X A Scalable Hardware Render Accelerator using a Modified 
Scanline Algorithm Michsel Kelley Stephanie Winner Kirk Gould Apple Computer, Inc. 20525 Mariani Avenue 
Cupertino, CA 95014 1. ABSTRACT A hardware accelerator for 3D ren&#38;ring, based on a mcdifkd scanline 
algorithm, is presented. The accelerator renders multiple scanlines in parallel with high efficiency, 
and is optimized for integration into systems that suppr[ high speed data streams (such as video). The 
architecture has a very high performance/cost ratio, but maintains a low entry cost and a high degree 
of scalability key issues for incorporation in personal computers. The performance of both the general 
algorithm and the prototype implementation is analyzed. CR Categories and SubJect Descriptors: B.2.1 
[Arithmetic and Logic Structures]: Design Styles -parallel; 1.3.1 [Computer Graphics]: Hardware Architecture 
-raster display devices; 1.3.3 [Computer Graphics]: Picture/Image Generation -display algorithms; 1.3.7 
[Computer Graphics]: Three-Dimensional Graphics and Realism -visible surface algorithms General Terms: 
algorithms, architecture, parallel Additional Key Words and Phrases: scanline, data sharing, low bandwidth, 
low cost  2. INTRODUCTION Advances in CPU technology have given personal computers the compute power 
necessary to run 3D applications. However, interactive applications require faster rendering than can 
be achieved by the CPU alone today s 3D workstations also inclu&#38; sophisticated rendering hardware 
[1, 2, 11, 14]. The goal of our project is to provide similar functionality in a personal computer. We 
began by determining what differences, if arty, there were between the requirements of 3D acceleration 
in a workstation and a personal computer. We identified some key features required for a personal computer 
. Low cost. The accelerator must have a very low entry cost. . Modularity. Itshould be possible to add 
the accelerator to a system as an option. Permission to copy without fee all or pan of this material 
is granted provided that [he cop!es tire not made or distributed for direct cnmmewiid advantage. [hc 
ACM copyrightno!icemd the title of the puhlication and its date trppmr, and nntice is given that cnpying 
is by permission of the Assneitilion for Computing Machinery To copy otherwise. nr 10 republiih, requires 
a fee and/or specific permissmn. . HiEh performance. An intuitive, direct manipulation user in~f~e-requires 
a high frame rate and high ~peed hit testing. . Visual realism. Although schematic representations such 
wireframe are useful, naive users are more comfortable with realistic shaded images with shadows. as 
 Existing workstations meet some of these recpirements, but not all. High end workstations deliver high 
performance shaded rendering, but prices are stratospheric by personal computer standards. Recent entry 
level workstations have redtced this cos~ but at the expense of lower speed, particularly for high quality 
rendering modes. And even these systems are many times the entry price of a typical personal computer. 
Finally, because the graphics accelerator in these systems is tightly coupled to the system frame buffer, 
providing the accelerator as an option, e.g. a plug-in card, is difficult typically a local frame buffer 
must be added to the accelerator, increasing cost. The architecture described in tlis paper has been 
optimized for a personal computer graphics system. It uses a modified scardine rendering algorithm to 
greatly reduce cost by combining the rasterization hardware and scanlie RAM on chip. The architecture 
emphasizes shaded rendering, and new rendering features (e.g. CSG, sntialissing) can be added with little 
cost increase. The design is highly scalable because performance and functionality are limited by ASIC 
complexity (which is rapidly increasing), and because the architecture efficiently supports parallelism 
 a parallel implementation is described which can rasterize 880K triangles per second. This paper primarily 
discusses rasterization, as standard techniques are used for transformation, clipping and shading [e.g. 
4, 6]. We plan to use general purpose RISC or DSP devices to accelerate these tasks [2, 11].  3. BACKGROUND 
AND PREVIOUS WORK 3.1 Screen Z-Buffer Algorithm The screen Z-buffer algorithm was one of the fust shaded 
hidden surface removal algorithms, and was used by both software and hardware implementations [3, 8]. 
Its advantage is simplicity each object to be rendered can be transformed and rasterized independently, 
allowing an arbitrarily large number of objects to be rendered (given enough patience). Hardware implementations 
of this algorithm have been very successful; in fac~ it is the method used in virtually all 3D workstations 
[1, 2, 11]. AcM-()-89791-479 -l/92/() 07/()24i $() I .50 SIGGRAPH 92 Chicaao, Julv 26-31, 1992 However, 
the screen Z-buffer algorithm has disadvantages which make it less suitable for personalcomputers.The 
most obvious of these is memory use the algorithm requires . storing a Z value for every pixel on the 
screen. Storing a 24 bit Z for a lKxIK screen uses 3M bytes of memory, an appreciable amount in an entry 
level computer. More importantly, this memory must be very high performance pixel shading speed is directly 
proportional to the sustained bandwidth to the RAM. For example, rendering one million 100 pixel triangles/second 
requiresl: lM tri/s x 100 pixel/tri = 100M pixelh 100M pixel/s x 3 Z bytes/pixel x 1.5 = 450 MB/s In 
practice, these very high bandwidths are achieved with wide, fast RAM [1], often coupled with sophisticated 
caching and prefetchirtg. Although it s reasonable to add these costs to a dedicated workstation they 
make it impractical to add high performance graphics to a low cost personal computer. More abstractly, 
these disadvantages of the screen Z-buffer algorithm are caused because it stores the state of the rendering 
calculation for each pixel individually, effectively, the state information necessary to render one pixel 
is replicated for every pixel on the screen. As a resul~ rendering algorithms which require additional 
information per pixel (e.g. CSG, shadows, antialiasing) are expensive to implemen~ for example, the system 
described in [10] has over 150 bits per pixel. 3.2 Scanline Z-buffer algorithm To fmd a more cost effective 
implementation of these rendering algorithms, we adopted the same solution used by many software renderers, 
the scardine Z-buffer algorithm [12]. In comparison to the screen Z-buffer algorithm, where the state 
information necesssry for rendering a pixel is stored for every pixel on the screen, the scanline algorithm 
presorts the object database in screest space [15], and renders each scardirte individually only one 
scanline of pixel state information is kept. The difference between the two methods is substantial: for 
a lKxIK screen, the screen Z-buffer algorithm uses 3M bytes for Z, whereas the sardine algorithm uses 
only 3K bytes [9]. Additional information on scardine algorithms can be found in [6]. 4. OVERVIEW OF 
THE PROTOTYPE P tit CPU (trlmdom, Shade, Scsm W RadedZw tdwl Wtl) z. Shdcw e40x40bils SRGS e40x40bils 
u Figwre 1 The prototype (shown above) is based on a Macintosh@ Quadram personal compute~ the scardine 
resterizer is implemented as a Processor Dwect expansion card. The host 1 This assumes 50% of pixeis 
ars visiblq section 8.4 discusses this in more detail. 68040 is used for trsnsformati~ shading, and active 
list maintertan=, faster prototypes, using more pwerful floating point engines, are also being developed. 
The scardiie rasterizer performs Gcmraud shading, hidden surke removal via a 32 bit Z-buffer, shadow 
volumes [71 and alpha blending (with 10 bits of accuracy). The rasterizer is implemented as two 0.8pm 
ICS (Pigure 10, at the end of the paper), designed with silicon compilation tools; the chips operate 
at 40MHz. The frost chip intersects polygons transferred from the active polygon list with the current 
scardine, generating a series of horizontal spans. The second chip raaterizes the resulting spans, doing 
hidden surface remov~ shadow plane tests and alpha blending. Multiple chip sets can be connected m parallel 
with virtually no glue logic, providing very high performance with low chip count (sections 7 smd 8 discuss 
parallel rasterization). The following pseudo-code shows the basic rendering algorithm of the prototype: 
RenderFrame ( ) { I* First pass: transform, shade, sort */ foreach (Poly) ( Transform (Poly) ; if ( 
! Cull (POly) ) Shade (Poly) ; Bucket Sort (Po IY) ; ) /, Second pass: rasterize *I fo. each (Scan 
line) ( AddNewPolys (BucketedPolys [Scan line] ) ; Rasterize (ActiveList, Scanline) ; RemoveFini shedPolys 
(ActiveList, Scanline) ; } ) Rendering begins when the host CPU traverses the 3D database, generating 
transform~ projec~ clipped and shaded polygons. The polygons are then bucket sorted by the number of 
the fwst scanline on which they fwst become active. Once the main database traversal is complete, the 
host traverses the bucket sorted list in screen Y order, maintaining art active polygon list which is 
transferred into the rasterizer to drive rendering.  5. DISADVANTAGES OF THE SCANLINE ALGORITHM 5.1 
Database sorting Computationally, the penalty for the two pass algorithm is relatively minor [5]. Because 
the second pass is driven by the bucket sorted lis~ only a single traversal of the database hierarchy 
is required. The computational overhead of the bucket sort itself is low compared with transformatio~ 
clipping and shadiig, and is principally a problem of efficient memory management. A more substantial 
penalty is the memory used to store the bucket sorted polygons; in the prototype, 40 bytes are required 
for each transforrn~ shaded triangle. However, this is offset by the other memory savings of the scardine 
algorithm; for Computer Graphics, 26,2, July 1992 exampl% the 3 megabytes saved by not using a Z-buffer 
would be enough to store 75K triangles (a large interactive database for a personal mmputer). In practice, 
culling and the use of more efficient primitives (e.g. quadrilaterals) further reduce memory use. 5.2 
Loss of concurrent scan conversion Because bucket sorting must complete before scan conversion begins, 
a simple implementation of the sctmline algorithm can cause poor utilization of the graphics subsystem. 
For example, if the fmt pass (transform, clip, shade) and the second pass (rasterize) require the same 
length of time, the hardware will never exceed 50% utilization. This compares poorly to a claasicaf graphics 
pipeline model, where a well-balanced pipeline cart achieve 100% utilization. One solution to this problem 
is to double buffer the bucket sorted polygon lis~ this allows the two passes of the algorithm to run 
simultaneously, permitting 100% efficiency. Unfortunately this does not reduce latency; a direct manipulation 
interface which requires user feedback every frame will have to flush both buffers, negating the advantage. 
However, for tasks where latency is less critical (e.g. rotating an object for viewing), double buffering 
is effective. A more genersf solution to this problem is to shorten the time required for fwst pass processing, 
which provides more time for rasterization and increases utilization. For polygons, postponing clipping, 
normal normalization and lighting to the second pass reduces first pass computation by approximately 
50% [ 1]2; the savings increase as the lighting model becomes more complex. Curved surfaces can be transformed 
without tessellation, posqmning virtually all computation until the object becomes active during the 
second pass, at which point the object can be decompose-d into renderable primitives. This tecfilque 
also reduces memory use for the bucket sort.  5.3 Poor wireframe performance Although scardine algorithms 
are efficient for shaded primitives, there is a substantial performance loss for wirehne renderirtg 
in the prototype, wirebtne perfOrmIUICG will be roughly equaf to shaded performance, ss opposed to the 
5X -1OX ratio commonly encountered in workstations. Because of our emphasis on shaded rendering, this 
was considered acceptable. 6. ADVANTAGES OF THE SCANLINE ALGORITHM 6.1 On-chip rasterization A key implementation 
advantage of the scanline algorithm is that the Z and aRGB memory used for pixel rendering can be placed 
on the same chip as the rssterizstion hardware. For example, the prototype stores 32 bits for z 8 for 
shadows, and 10 for each of aRGB, a totaf of 80 bits per pixel a 640 pixel scanline requires 51K bits 
of RAM. In the prototype, tltk scstdirte RAM uses only 25% of the rasterizer chip s area. By placing 
the rasterization hardware on-chip with the RAM, very high rasterization speeds can be achieved without 
high off-chip bandwidth the prototype rasterizer runs at 40M alpha-blended Z-buffered pixels per second 
using 720M byteds of on-chip RAM bandwidth. Because chip I/O is not m the critical pam speed is limited 
only by core logic and RAM performance, allowing rapid performartce increase as chip technology advances. 
6.2 Raster output and modularity Mox4ebim mcie s40x40b&#38;s Id Figwe 2 As scardines complete, they are 
transferred from the rssterizer into the frame buffer (Figure 2). To the system, these transfers appear 
as a video-like high speed raster MS sfiiIw@ allows easy integration into future video-capable personal 
computers. Because the datatlow nom rssterizer to tlame buffer is unidirectional, the rastcrizer does 
not require a tightly coupled low latency frame buffer interface. This makes it possible to add a sardine 
rendering accelerator to a system as an option (i.e. a card) without the cost of a local frame buffer. 
6.3 High resolution rendering and antialiasing For an NxN image, the memory requirements of the scanline 
Z­buffer algorithm are proportional to N, whereas the memory requirements of the screen algorithm are 
proportional to N2.3 Ilk allows scsnline algorithms to render large (e.g. 8Kx8K) images with high efficiency. 
Unfortunately, when the scanline buffer is stored on-chip, scardine width is limited by RAM size for 
example, the prototype haa a maximum width of 640 pixels. This limitation can be removed by rendering 
wider scardines in segments. For each scsnlirte, the active object list is traversed multiple times, 
the fmt time rasterizing pixels O to 639, the second time 640 to 1279, etc. The resulting segments abut 
left to right and are indistinguishable from the result had the entire scardine been rendered in a single 
pass. Only a single IraversaI of the main database is required, avoiding the redundant transformation 
and clipping which are caused by a tiling algorithm. Because the scanline algorithm generates the image 
in scardine order, traditional super-sampled sntialiasing techniques can be implemented with an acarrtulation 
buffer of only a few scardines; in particular, hosts with video support may already include such hardware 
for window re-sizing and filtering. More advanced antialissing algorithms (e.g. A-buffer) could be SIGGRAPH 
92 Chicago, July 26-31, 1992 2 Frm Akcley s paper, 23 of 46.5 Mflops = 50%. nese single light SOU­.t 
infinity. figu~s am for a 3 Screen stgoridnns can render high rcsolutiuI images by tiling, but with a 
substantial performance Palty for performing multiple database traversals. 243 implement@ becauseonly 
one scardineis rendered at a time, the limiting factor is complexity, rather than RAM. 7. MODIFYING THE 
SCANLINE ALGORITHM FOR PARALLELISM Thus far has we have dwcuaaed the pros and cons of the tractional 
scardine algorithm. However, a goal of the project was to develop an algorithm with a highly scalable 
implementation, in particular, our goal was to devise an algorithm where performance could be increased 
by rendering multiple scanlines in parallel. 7.1 Previous solutions: Screen partitioning One solution 
to this problem [13] is to partition the screen into a number of relatively large contiguous regiona, 
and render each region with an unmodified scanhne algorithm. When complete, the regions are tiled together 
to produce a complete frame. While simple to implement, this divide-and-conquer solution suffers from 
poor load balancing an image whose complexity is unevenly distributed across the screen will not be 
efficiently parallelized. Adaptive partitioning of the screen can improve load balancing, but the setup 
overhead for a region limits efficiency if fiie subdivision of the screen is attempted. Also, this algorithm 
is expensive: active list hardware, memory, and raaterization hardware are all replicated. Instea4 we 
wanted a solution that renders multiple adjucent scrmlinessimultaneously. This largely solves the load 
balancing problem, as adjacent scanlines usually have similar complex~~. Also, it has the potential to 
exploit scanline coherence by maintaining a single active polygon list which is shared by multiple rasterizers, 
each working on a separate scanline. 7.2 Scanline coherence vs parallelism Unfortunately, the typicrd 
implementation of the scardine algorithm makes this difficult. To increase performance, scadine renderers 
exrioit coherence bv convertirw the interpolation calculation of the edge pi&#38;3tneters at-tie ctment 
scatdine into a forward differencing calculation in Y [6, 15]: ytop. ybottom = top ~d bottom of edge 
top[rt], bottom[n] = parameter n at top, bottom Hinv = inverse of height of edge AP[~] = change/scanline 
of parameter [n] Pin] = interpolated value of parameter [n] Hinv = 1J (Ybottom -Ytop) @[n] = Hinv x (Pbotto~n] 
-Ptop[n]) O[n] = Ptop[n] Pi+l[n] = Pi[n] + AP[n] (The initialization fiutction PO[n~ has been simplified 
for clarity; the actual subpixel accurate function is more complex.) Rendering multiple scardines in 
parallel requires parallelizing this forward differencing calculatio~ which is possible but awkward in 
particular, the calculation of PO/n~ and the end-of­edge test must be replicated for every interpolator. 
7.3 Direct evaluation vs forward differencing A different approach to the problem is to abandon the forward 
differencing solution and directly evaluate the interception calculation of the object edge and the scsnline 
Wy = interpolation weight at Y Wy= (1 -Ytop) / (Ybottom -YtoP) l y[n] = (Ptop(n) x(1 wy)) + (Pbottom(nl 
x wy) Direct evaluation is computationally more expensive than forward differencing (for each scardine, 
art additional divide and two multiplies per parameter). However, because the cost of computation on 
an ASIC ia declining so rapidly, we felt comfortable adopting a computation ally intensive solution, 
as it provides advantages in the following, more problematic areas. 7.3.1 Simplified setup The most obvious 
advantage of direct evaluation is that it greatly simplifies the setup procedure for an active object 
 the calculation of Hinv , AP[n] and P0[n]4 is completely avoided. With direct evaluation, the object 
is simply inserted into the active object list; no other processing is necessary. 7.3.2 Reduced active 
list memory and bandwidth To forward dlfferrmce a parameter Pin) of N bits requires storage of &#38;in] 
, typically 2N bid, and the current parameter value Pi[nl, also 2N bits, for a total of 4N bits. using 
dir=t evaluation, otdy / top[n] and Pbottom[nj are stored, a total of 2N bits, providing a so~o memory 
saving. More irnpartan~ however, is the reduction of memory bandwidth. To directly evaluate a parameter, 
Ptop[n] and Pbottom[n] are read for a total of 2N bits of bandwidth. For forward differencing, AP[n] 
and Pi[n] arere@ ~d then Pi+l[n] is written back, a total of 6N bits or three times the bandwidth of 
direct evaluation. As shown later, active list bandwidth is directly proportional to rasterization speed; 
the reduction from direct evaluation rdlows much higher performance. Also, because direct evaluation 
does not require writing back Pi+l[n], the dataflow is unidirectional, substantially simplifying system 
design. For example, high latency bursting memory such as VRAM can be used for active polygon storage, 
reducing cost. 7.3.3 Data sharing for parallelism The most important advantage of dwect evaluation is 
that the data in the active object list no longer reflects the state of any particular scardine the 
same data can be used to render multiple scardines in parallel. In facL the prototype is designed to 
transfer data from the active object list to multiple rasterizers simultaneously: 4 ~iti ~v~uatia is 
~tfi~i~ly sub-pixel accurate, so sub-pixel alignment does net have to be speciatly treated. 5 The extra 
N bits are fractional guard bits. The number of guard hits is actually logz(max number of iterations), 
i.e. fonvard differencing an 8 bit vahrc across an 8K screen requires 15 guard bits. Computer Graphics, 
26, 2, July 1992 8. PERFORMANCE ANALYSIS I 8.1 Rasterization performance Figure 3 In this example, the 
triangle description is transferred into all three rasterizers simultaneously. Each rasterizer intercepts 
the triangle with its target scanline, and renders the resulting horizontal span. All three rasterizers 
then output their scanlines, generating a three scanline strip of the final image. Because the data 
is shared by all rasterizers, efficiency is high: bandwidth is wasted only when an objeet does not intersect 
all of the scanlines being rendered. In this example, the triangle description is transferred only twice 
to render scardirtes O to 5 (each transfer renders three scanlines), yielding an ideal 62 = 3X increase 
in rasterization speed over a single rasterizer.6 However, when rendering scasdines 6 to 8, the triangle 
intersects only two of the three rasterizers, leaving one idle. Therefore, a frame that would have required 
8 triangle transfers in a single rasterizer design requires 3 transfers, for a speed increase of 8/3 
= 2.7X, and a rmterizer utilization efficiency of (8/3) X (1/3) = 8/9= 89%. In practice, rather than 
allowing the decrease in utilization to reduee rasterization speed, the input data bandwidth is increased. 
Because the rasterizers can discard a triangle that doesn t interseet the scanline much faster than rendering 
it, increasing input bandwidth to compensate for the unnecessary triangle transfers permits all rasterizers 
to run at full speed (an input FIFO on the rasterizer is used to smooth the dataflow). Therefore, the 
efficiency of a given number of parallel scanline rasterizers can be characterized by the increase in 
input bandwidth necessary to keep all rasterizers fully utilized: Np~ = number of parallel sc~lines ~avg 
= average height of an active object bandwidth increase over a single rastenzer Bpar Bpar = (Npar -1) 
I Havg For tie example above, with three parallel rasterizers and an average object height of eight scanlines: 
BpW=(3-1)/8 = 2570 increase In other words, a 25% increase in active list bandwidth over a single rasterizer 
would be enough to keep three rasterizers fully utilized. 6 For this exanrpIe, we assume performance 
is limited by active list bandwidth. More complete performance analysis is irsthe following section. 
Figure 4 Rasterization performance can be characterized by two values: Pim = primitive-scttrdine intersections/s 
Prmler = rasterization speed (pixels/s) The prototype hardware intersects a triangle with the current 
scasdine in 14 clocks, yielding a Pi~ OE Pim = 40 MHz / 14 clocks/intersection = 2.86M interseetions/s 
 Rasterization speed is one pixel per clock, or: Printer = 40M pixels/s From this, rasterization performance 
can be approximated by the formula: Aavg = average pixels per primitive Pprim = @mitives/s~nd = min ((piti 
/ Hmg). (Prurter / &#38;rvg)) PPkI = rendered pixelslseeond = Amg XPpr~ For example, a 100 pixel triangle: 
Havg = 13 scanlines Aavg = 100 pixels Pprim = min (2.86M J 13, 40M J 100) = 220K triangles/s PP~/ = 100 
x 220K = 22M pixels/s 8.2 Active list bandwidth Figure 5 A key factor for system performsuu is Brast 
(shown in Figure 5), the bandwidth used to transfer polygons from the active list to the rastenzer(s), 
For a single raaterizer this cart be computed as: Sprim= size of primitive Brat = Pprim x Sprim x Havg 
For the example given earlier, a triangle requires 40 bytes; the resulting rasterizer input bandwidth 
is: Brat = 220K trijs x 40 bytes x 13 scanlirtesltri = 114 MB/s In addition, new primitives must be added 
to the active objtxt list as they first beeome active: SIGGRAPH 92 Chicaao. Julv 26-31.1992 B-= fpr~ 
x Sprim So total active list bandwidth for a single rasterizer system is: Btitii = B-+ Bra Btotal = pprim 
x sprint + pprim x Sprim x Havg Btotal = pprim ~ sprint x (~ + Havg ) For the previous example Btaa/= 
220K X40 X (1+ 13) = 123M byteS/S 8.3 Parallelism Rewriting the equations for active list bandwidth to 
include NPar ~d Bpar km s~tion 7.3.3 yields (X is Wd to ~di~te the sum of parallel rasterizem): Npw = 
number of parallel scardines Bpar = bandwidthincreaseovera singlerasterizer p~rim = Npar ~ Pprim f~~[ 
= Aog ~ p~ritn Bfiast = @Par + ~) x Pprim x sprint x Havg =(NPW +HWg -~)xPprim x Sprim B> = P@rim x 
Sprim = Nw x PPr~ x SPr~ B~otal = B> i-B~Wt = pprim x Sprim x (~par + Havg -~) Figure 6 graphs B~otal, 
showing the relatively gradual increase in bandwidth nwessary to drive parallel rasterizers: Active List 
Bandwidth vs Parallelism SprimxPprimxQNpar+t-tavg-1)I-tavg=13,sprim=40.Pprim.22tK :L-- Npr (number ofparalklrastahrs) 
Figure 6 This gradual increase is responsible for a rapid improvement in the performance/bandwidth ratio 
(P~ri~B~ora/) as parallelism is increased Performarw#Bandwidth VS ParaUeliam t-W.13=13,S@m=4a 6 4 SmnurleSlgalithm 
Npar/ @@mx(2Npar+I-iavg-1)) / tlis/Kbyk 2/ Np (number ofpmtkl mterlz.ael Figure 7 Repeating the previous 
example from 8.2, but with four parallel rasterizers: P~r~ = 4 x 220K = 880K triartgleeis P~~/ = 100 
x 880K = 88M pixels/s B~a~r = (4 + 13-1)X 220K X 40 = 141M byteS/S B-= 4 X 220K X40= 35M bytes/s B~otal 
= 35M + 141M = 176M bytesls Figure 8 shows the total system dataflow, addiig the assumption of 30 ~ update 
of a lM pixel fiante buffsx Scanline Z-Buffer Algorithm W trials,88Mpixale/.e,80fps T Rseterizem ma BuIler 
9DMW8 Figure 8 Note that the bandwidth is distributed and tmidirection~ allowing an inexpensive high 
latency dataflow design. For thii example, a 4X increase m rasterization performance required a 176M/123M 
= 43% increase in total active object list bandwidth. 8.4 Comparison to screen Z-buffer For comparison, 
we cart analyze the bandwidth that would be required to achieve this performance using a screen Z-buffer 
algoritlun. The combmed Z-buffer/ksne buffer bandwidth necessary can be calculated by: V = % of pixels 
visible a= % of pixels with alpha blending Bz =Z bytes~lxel Bagb = aRGB bytes/pixel Bz@= Pp~el x (Bz+Vx(Bz+Bwgb 
+a x B@gb )) Assuming 50% of the pixels are visible7, 50% are blenw and 32 bits for Z artd aRGB , this 
would be: 7 E.g. .t 30 @s, 88M/30 = 2.9M pixels/frame x 50% = 1.5M visible pixels. Of these, only lM 
are actuatly visible; the others am subsequently overwritten (or blsnded) as rendering ccmtinues. Computer 
Graphics, 26, 2, July 1992 screen algorithm would be perceived as having lower latency, Bzb@= 88M X (4+ 
50% X(4+4+ 50%X 4)) as the screen update would begin sooner. This wasn t considered = 792M bytes}s a 
serious disadvantage, however, as our target ia interactive applications running at high frame rates, 
necessitating a Which is 4.5X the active list bandwidth of the scardine double buffered display. algorithm. 
A diagram of system dataflow for the screen Z­ buffer algorithm shows this more clearly: ( Screen Z-Sufter 
Al@hm eeMpixalsm,50%VisWa,50%bbnrtad (fIumedear notlkWdnd) Fktaizal 4 ~u Figure 9 Here, high performance 
bidirectional (i.e. low latency) bandwidth is required for both the Z and aRGB buffers, increasing cost. 
9. MEASURED PERFORMANCE Figure 11 (at the end of the paper), shows a test image ren&#38;red on the prototype 
hardware. The image has 18 torusus, each composed of 1020 triangles; 9468 tris are rendered after culling. 
Rendering the scene requires a total of 2.06 MBytes of input data to the rasterizer. The current prototype 
(which is primarily a test vehicle) by the 68040 host to is limitedbetween 5K and 10K triangles/s; however, 
we were able to evaluate the performance of the rasterization silicon itself by reducing the rasterizer 
clock until rasterization became the system bottleneck. With the clock reduced to lMHz, Figure 11 requires 
1.5 seconds to render on a single rasterizer. Extrapolating performance to the full 40MHz clock rate: 
Framerate = 1 frame/ 1.5s x (40MHr/lMHz) = 26.7 frames/s Pprim = 9468 tris x 26.7 framesfs = 252K tiisIS 
 The input bandwidth required for this performance is! Brat = 2.06 MBytes/frame x 26.7 fhurtes/s = 54.9 
MBytes/s A higher performance, RISC-based prototype is being developed which wiU provide system performance 
that better matches rasterization capability. 10. OTHER ISSUES 10.1 Latency For the examples presented 
here, the delay from start of database traversal to screen update (i.e. swap buffers) is the same for 
the screen and scardine algorithms. However, if double buffering is rtot being used (for exampl~ a very 
large database is being drawn on the screen while the user watches), a 8 For ~g ~age, ~Pt ~dwidti is 
reduced approxirrtatelY30% by shared ve~x data. 10.2 Hit testing The sardine algorithm has advantages 
for direct manipulation applications wiih an interaction loop like: while (FOREVER) ( OrawDatabase () 
; Get Mouse (&#38;x, &#38;y) ; Select edObject = Hit Test Database (x, y) ; UpdateDatabase (Select edObject) 
; } For this interaction model, the Y-sorted object activation list created during DrawDatabaaeo can 
be used to dramatically accelerate HitTestDatabaseo by providing a list of only those objects visible 
on scanline y. This is an improvement over the classic screen Z-buffer model, where HitTestDatabaseo 
requires a second travemal of the database and hit testing of every primitive. 11. ACKNOWLEDGEMENTS Lee 
Mighdoll was a major contributor to the early stages of this project. This research was performed in 
the Systems Technology Research Group of Apple Computer, Inc. Thanka to Frank Crow, Brian Heaney, Jill 
Huchital, David Jevans, Al Kossow, Lee Mighdcdl and Libby Patterson for their reviews. 12. REFERENCES 
1. Akeley. Kurt and T. Jenrtohtk, High-Performance Polygon Rendering , Computer Graphics, Vol. 22, No. 
4, August 1988, 239-246 2. Apgar, Brian, B. Bersack and A. MammeIL A Display System for the Stellar 
Graphics Supercomputer Model GS1OOO , Computer Graphics, Vol. 22, No. 4, August 1988, 255-262 3. Catmull, 
E., A Subdivision Algorithm for Computer Display of Curved Surfaces , UTEC-CSc-74-133, Computer Science 
University Salt Department,of Utalu Lake City, UT, December 1974 4. Clark James, The Geometry Engine: 
A VLSI Geometry System for Graphics , Computer Graphics, Vol. 16, No. 3, July 1982, 127-133 5. Deering, 
Michael, S. Winner, B. Schediwy, C. Duffy and N. HunL The Triangle Processor and Normal Vmtor Shader: 
A VLSI System for High Performance Graphics , Computer Graphics, Vol. 22, No. 4, August 1988, 21-30 
6. Foley, James, A. van Dam, S. Feiner and J. Hughes, Computer Graphics Rinciples and Ractice, 2nd Edition 
, Addison-Wesley, 1990, 96-99 (basic scan conversion), 201-283 (transformation), 680-685 (sardine algorithms), 
885-887 (scanline rasterization) 7. Foumier, Alain and D. Fussell, On the Power of the Frame Buffer 
, Transactions on Graphics, Vol. 7, No. 2, April 1988, 103-128  247   
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134071</article_id>
		<sort_key>249</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>28</seq_no>
		<title><![CDATA[Fast shadows and lighting effects using texture mapping]]></title>
		<page_from>249</page_from>
		<page_to>252</page_to>
		<doi_number>10.1145/133994.134071</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134071</url>
		<keywords>
			<kw><![CDATA[lighting]]></kw>
			<kw><![CDATA[texture mapping]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.3</cat_node>
				<descriptor/>
				<type/>
			</primary_category>
			<other_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Geometric algorithms, languages, and systems</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Color, shading, shadowing, and texture</descriptor>
				<type>S</type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010147.10010371.10010382.10010384</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Image manipulation->Texturing</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003752.10010061</concept_id>
				<concept_desc>CCS->Theory of computation->Randomness, geometry and discrete structures</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010382</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Image manipulation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010372</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Rendering</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010382</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Image manipulation</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>PP39078512</person_id>
				<author_profile_id><![CDATA[81100242032]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Mark]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Segal]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Silicon Graphics Computer Systems, 2011 N. Shoreline Blvd., Mountain View, CA]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P40807</person_id>
				<author_profile_id><![CDATA[81100289934]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[Carl]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Korobkin]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Silicon Graphics Computer Systems, 2011 N. Shoreline Blvd., Mountain View, CA]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P248477</person_id>
				<author_profile_id><![CDATA[81100593827]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>3</seq_no>
				<first_name><![CDATA[Rolf]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[van Widenfelt]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Silicon Graphics Computer Systems, 2011 N. Shoreline Blvd., Mountain View, CA]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P140336</person_id>
				<author_profile_id><![CDATA[81100162708]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>4</seq_no>
				<first_name><![CDATA[Jim]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Foran]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Silicon Graphics Computer Systems, 2011 N. Shoreline Blvd., Mountain View, CA]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P221441</person_id>
				<author_profile_id><![CDATA[81100466522]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>5</seq_no>
				<first_name><![CDATA[Paul]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Haeberli]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Silicon Graphics Computer Systems, 2011 N. Shoreline Blvd., Mountain View, CA]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Robert N. Devich and Frederick M. Weinhaus. Image perspective transformations. SPIE, 238, 1980.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122723</ref_obj_id>
				<ref_obj_pid>122718</ref_obj_pid>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Julie O'B. Dorsey, Francois X. Sillion, and Donald P. Greenberg. Design and simulation of opera lighting and projection effects.ln Proceedings of SIGGRAPH'91, pages 41-50,1991.]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_obj_id>325205</ref_obj_id>
				<ref_obj_pid>325334</ref_obj_pid>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Henry Fuchs, Jack Goldfeather, and Jeff P. Hultquist, et al. Fast spheres, shadows, textures, transparencies, and image enhancements in pixels-planes. In Proceedings of SIGGRAPH '85, pages I 1 1-120, 1985.]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_obj_id>97913</ref_obj_id>
				<ref_obj_pid>97879</ref_obj_pid>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[Paul Haeberli and Kurt Akeley. The accumulation buffer: Hardware support for high-quality rendering. In Proceedings of SIGGRAPH '90, pages 309-318, i 990.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[Paul S. Heckbert. Fundamentals of texture mapping and image warping. Master's thesis, UC Berkeley, June 1989.]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[Paul S. Heckbert and Henry E Moreton. Interpolation for polygon texture mapping and shading. In David E Rogers and Rae A. Earnshaw, editors, State of the Art in Computer Graphics: Visualization and Modeling, pages 101-1 I I. Springer- Verlag, 199 i.]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_obj_id>74354</ref_obj_id>
				<ref_obj_pid>74333</ref_obj_pid>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Kazufumi Kaneda, Eihachiro Nakamae, Tomoyuki Nishita, Hideo Tanaka, and Takao Noguchi. Three dimensional terrain modeling and display for environmental assessment. In Proceedings of SIGGRAPH '89, pages 207-214,1989.]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_obj_id>37435</ref_obj_id>
				<ref_obj_pid>37401</ref_obj_pid>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[William T. Reeves, David H. Salesin, and Robert L. Cook. Rendering antialiased shadows with depth maps. In Proceedings of SIGGRAPH '87, pages 283-29 l, 1987.]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Steve Upstill. The RenderMan Companion, pages 371-374. Addison Wesley, 1990.]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_obj_id>807402</ref_obj_id>
				<ref_obj_pid>800248</ref_obj_pid>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[Lance Williams. Casting curved shadows on curved surfaces. In Proceedings of SIGGRAPH "78, pages 270-274, 1978.]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 Computer Graphics, 26,2, July 1992 ? Fast Shadows and Lighting Effects Using Texture Mapping Mark Segal 
Carl Korobkin Rolf van Widenfelt Jim Foran Paul Haeberli Silicon Graphics Computer Systems* Abstract 
Generating images of texture mapped geometry requires projecting surfaces onto a two-dimensional screen. 
If this projection involves perspective, then a division must be performed at each pixel of the projected 
surface in order to correctly calculate texture map coordinates. We show how a simple extension to perspective-comect 
texture mapping can be used to create various lighting effects, These in­clude arbitrary projection of 
two-dimensional images onto geom­etry, realistic spotlights, and generation of shadows using shadow maps[ 
10]. These effects are obtained in real time using hardware that performs correct texture mapping. CR 
Categories and Subject Descriptors: 1.3.3 [Computer Graphics]: Picture/Image Generation; 1.3,7 [Computer 
Graph­ics]: Three-Dimensional Graphics and Realism -colot shading, shadowing, and texture Additional 
Key Words and Phrases: lighting, texturemapping  Introduction Producing an image of a three-dimensional 
scene requires finding the projection of that scene onto a two-dimensional screen, In the case of a scene 
consisting of texture mapped surfaces, this involves not only determining where the projected points 
of the surfaces should appear on the screen, but also which portions of the texture image should be associated 
with the projected points. If the image of the three-dimensional scene is to appear reatistic, then the 
projection from three to two dimensions must be a perspec­tive projection. Typically, a complex scene 
is converted to polygons before projection. The projected vertices of these polygons deter­mine boundary 
edges of projected polygons. Scan conversion uses iteration to enumerate pixels on the screen that are 
covered by each polygon. This iteration in the plane of projection introduces a homogeneous variation 
into the parameters that index the texture of a projected polygon. We call these param­eters ~exture 
coordinates, If the homogeneous variation is ignored in favor of a simpler linear iteration, incorrect 
images are produced 201 1 N. Shoreline Blvd., Mountain View, CA 94(M3 Permission to copy withoutfeeall 
or part of this materialisgranted providedthatthecopieswe notmadeor distributedfor direct commercial 
advan[age. the ACM copyright notice and the title of the publication and its date appear. and notice 
is given that copyingis by permission of the Association for Computing Machinery. To copy utherwise. 
or to republish. requires a fee and/or specific permission. u Li&#38;t Wm&#38;irrt v Figure 1. Viewing 
a projected texture. that can lead to objectionable effects such as texture swimming during scene animation[5]. 
Correct interpolation of texture coor­dinates requires each to be divided by a common denominator for 
each pixel of a projected texture mapped polygon[6]. We examine the general situation in which a texture 
is mapped onto a surface via a projection, after which the surface is projected onto a two dimensional 
viewing screen. ~is is like projecting a slide of some scene onto an arbitrarily oriented surface, which 
is then viewed from some viewpoint (see Figure I). It turns out that handling this situation during texture 
coordinate iteration is essentially no different from the more usual case in which a texture is mapped 
linearly onto a polygon. We use projective re.rtures to simulate spotlights and generate shadows using 
a method that is well-suited to graphics hardware that performs divisions to obtain correct texture coordinates, 
  2 Mathematical Preliminaries To aid in describing the iteration process, we introduce four co­ordinate 
systems. The clip coordinate system is a homogeneous representation of three-dimensional space, with 
z, y, z, and UTco­ordinates. The origin of this coordinate system is the viewpoint. We use the term clip 
coordinate system because it is this system in which clipping is often carried out. The screen coordinate 
system represents the two-dimensional screen with two coordinates. These are obtained from clip coordinates 
by dividing T and y by 711,so that screen coordinates are given by z = xlw and y = ylw (the.$ su­perscript 
indicates screen coordinates). The Iighf coordinate system is a second homogeneous coordinate system 
with coordinates ${, y , Q 1992 ACM-O-8979 1-479-l/92/CF37/0249 $01.50 249 SIGGRAPH 92 Chicaao, Julv 
26-31, 1992 whereQ! = (2I, YI,z;, WI) and Qj = (z!, y~,zj, w$) are the light coordinates of the points 
given by Q 1and Q2 in clip coordinates. We finally obtain k,- Q = Q1/UI AQ{ + BQ\   (x y z w/  f Yt 
~xl,wl +,wl) 7 + L, LightView  w z (texture) (screen) Figure 2. Object geometry in the light and clip 
coordinate systems. .z , and wI; the origin of this system is at the light source. Finally, the texture 
coordinate system corresponds to a texture, which may represent a slide through which the light shines. 
Texture coordi­nates are given by Zt = xl/w and gt = g~/wl (we shall also find a use for .zt = Zt/wi). 
Given (ZS, y ), a point on a scan-converted polygon, our goal is to find its corresponding texture coordinates, 
(Xt, y ). Figure 2 shows a line segment in the clip coordinate system and its projection onto the two-dimensional 
screen. This line segment rep­resents a span between two edges of a polygon. In clip coordinates, the 
endpoints of the line segment are given by QI=(XI, YI, ZI, ~I) and Q2 = (z2, Y2,~2>w2). A point Q along 
the line segment can be written in clip coordinates as Q=(l-t)Q, +tQ2 (1) for some t c IO, l]. In screen 
coordinates, we write the comespond­ing projected point as Q = (1 t )Q; +tsQ; (2) where ~ = Q1/wl arid 
~ = Q2/w2. To find the light coordinates of Q given Q , we must find the value oft corresponding to t 
(in general t # t ). This is accomplished by noting that 1 -t)Q tQ2 (3) s = - )Q /w + Q w = (1-t)w, 
+ twz and solving for t. This is most easily achieved by choosing a and b such that 1 t = a/(a + b) and 
t = b/(a + b); we also choose A and B such that (1 t)= A/(A + 1?)andt = B/(A + B). Equation 3 becomes 
Qs=aQliw~+bQzlwz _ AQ1 +BQ2 (4)(a+b) -Aw, +Bw2 It is easily verified that A = aw2 and B = bwl satisfy 
this equation, allowing us to obtain tand thus Q. Because the relationship between light coordinates 
and clip co­ordinates is affine (linear plus translation), there is a homogeneous matrix A4 that relates 
them: (5) 250 Aw~ + Bw: aQ!lw + bQ~/w (6) a(w~/wl) + b(w~/w ) Equation 6 gives the texture coordinates 
corresponding to a lin­early interpolated point along a line segment in screen coordinates. To obtain 
these coordhates at a pixel, we must linearly interpolate Xi/w, y(lw, and W[lw, and divide at each pixel 
to obtain (For an alternate derivation of this result, see [6].) If WI is constant across a polygon, 
then Equation 7 becomes s/w t/w and t= ,(8) =~ 1/w where we have set s = X1I W1and t = y /wi. Equation 
8 governs the iteration of texture cocdnates that have simply been assigned to polygon vertices. It still 
implies a division for each pixel contained in a polygon. The more general situation of a projected texture 
implied by Equation 7 requires only that the divisor be tu /w instead of I/w. 3 Applications To make 
the various coordinates in the following examples concrete, we introduce one more coordinate system: 
the world coordinate sys­tem. This is the coordinate system in which the three-dimensional model of the 
scene is described. There are thus two transformation matrices of interest: &#38;fc transfomm world coordinates 
to clip coor­dinates, and A41transforms world coordinates to light coordinates. Iteration proceeds across 
projected polygon line segments accord­ing to equation 6 to obtain texture coordinates (d, yt ) for each 
pixel on the screen. 3.1 Slide Projector One application of projective texture mapping consists of viewing 
the projection of a slide or movie on an arbitrary surface[9][2]. In this case, the texture represents 
the slide or movie. We describe a multi-pass drawing algorithm to simulate film projection. Each pass 
entails scan-converting every polygon in the scene. Scan-conversion yields a series of screen points 
and corresponding texture points for each polygon. Associated with each screen point is a color and z-value, 
denoted c and Z, respectively. Associated with each corresponding texture point is a color and z-value, 
denoted Cr and Z,. These values are used to modify corresponding values in a framebuffer of pixels. Each 
pixel, denoted p, also has an associated color and z-value, denoted CPand ZP. A color consists of several 
independent components (e.g. red, green, and blue). Addition or multiplication of two colors indicates 
addition or multiplication of each correspondhg pair of components (each component may be taken to lie 
in the range [0, l]). Computer Graphics, 26,2, July 1992 Assume that ZP is initialized to some large 
value for all p, and that CP is initialized to some fixed ambient scene color for all p. The slide projection 
algorithm consists of three passes; for each scan-converted point in each pass, these actions are performed: 
Pass 1 If z < ZP, then ZP +-z (hialien surface removal) Pass 2 If z = ZP,then CPG CP+ c, (illumination) 
Pass 3 Set en = c .CP (jnal rendering) Pass 1 is a z-buffering step that sets ZP for each pixel. Pass 
2 increases the brightness of each pixel according to the projected spotlight shape; the test ensures 
that portions of the scene visible from the eye point are brightened by the texture image only once (occlusions 
are not considered). The effects of multiple film pro­jections may be incorporated by repeating Pass 
2 several times, modifying ,i ff and the light coordinates appropriate] y on each pass. Pass 3 draws 
the scene, modulating the color of each pixel by the cor­responding color of the projected texture image. 
Effects of standard (i.e. non-projective) texture mapping may be incorporated in this pass. Current Silicon 
Graphics hardware is capable of performing each pass at approximate] y 1@ polygons per second. Figure 
3 shows a slide projected onto a scene. The left image shows the texture map; the right image shows the 
scene illuminated by both ambient light and the projected slide. The projected image may also be made 
to have a particular focal plane by rendering the scene several times and using an accumulation buffer 
as described in [4]. The same configuration can transform an image cast on one pro­jection plane into 
a distinct projection plane. Consider, for instance, a photograph of a building s facade taken from some 
position. The effect of viewing the facade from arbitrary positions can be achieved by projecting the 
photograph back onto the building s facade and then viewing the scene from a different vantage point. 
This ef­fect is useful in walk-throughs or fly-bys; texture mapping can be used to simulate buildings 
and distant scenery viewed from any viewpoint[ I ][7], 3.2 Spotlights A similar technique can be used 
to simulate the effects of spotlight illumination on a scene. In this case the texture represents an 
intensity map of a cross-section of the spotlight s beam. That is, itis as if an opaque screen were placed 
in front of a spotlight and the intensity at each point on the screen recorded. Any conceivable spot 
shape may be accommodated. In addition, distortion effects, such as those attributed to a shield or a 
lens, may be incorporated into the texture map image. Angular attenuation of illumination is incorporated 
into the in­tensity texture map of the spot source. Attenuation due to distance may be approximated by 
applying a function of the depth values z = z /u{ iterated along with the texture coordinates (x , y 
) at each pixel in the image. This method of illuminating a scene with a spotlight is useful for many 
real-time simulation applications, such as aircraft landing lights, directable aircraft taxi lights. 
and automotive headlights. 3.3 Fast, Accurate Shadows Another application of this technique is to produce 
shadows cast from any number of point light sources, We follow the method described by Will iams[ 10]. 
but in a way that exploits available texture mapping hardware. First, an image of the scene is rendered 
from the viewpoint of the light source. The putpose of this rendering is to obtain depth values in light 
coordinates for the scene with hidden surfaces removed. The depth values are the values of zl/wl at each 
pixel in the image. The array of Zt values corresponding to the hidden surface-removed image are then 
placed into a texture map, which will be used as a shadow rnap[ 10][8]. We refer to a value in this texture 
map as Zr. The generated texture map is used in a three-pass rendering pro­cess. This process uses an 
additional framebuffer value OP in the range [0, 1]. The initial conditions we the same as those for 
the slide projector algorithm. Pass 1 If z < ZP, then ZP * z, CP ~ c (hidden suface removal) Pass 2 If 
z, = Zt, then&#38;P -I; else OP -0 (shadow resting) Pass 3 CP + CP + (c modulated by aP ) (jinal rendering) 
Pass 1 produces a hidden surface-removed image of the scene using only ambient illumination. If the two 
values hr tbe comparison in Pass 2 are equal, then the point represented by p is visible from the light 
and so is not in shadow; otherwise, it is in shadow. Pass 3, drawn with full illumination, brightens 
portions of the scene that are not in shadow. In practice, the comparison in Pass 2 is replaced with 
z, > Zt + c, where t is a bias. See [8] for factors governing the selection off. This technique requires 
that the mechanism for setting OP be based on the result of a comparison between a value stored in the 
texture map and the iterated Zt. For accuracy, it also requires that the texture map be capable of representing 
large ZT. Our latest hardware posseses these capabilities, and can perform each of the above passes at 
the rate of at least I@ polygons per second. Correct illumination from multiple colored lights may be 
pro­duced by performing multiple passes. The shadow effect may also be combined with the spotlight effect 
described above, as shown in Figure 4. The left image in this figure is the shadow map. The center image 
is the spotlight intensity map. The right image shows the effects of incorporating both spotlight and 
shadow effects into a scene. This technique differs from the hardware implementation de­scribed in [3]. 
It uses existing texture mapping hardware to create shadows, instead of drawing extruded shadow volumes 
for each polygon in the scene. In addition, percentage closer filtering [8] is easily supported.  4 
Conclusions Projecting a texture image onto a scene from some light source is no more expensive to compute 
than simple texture mapping in which texture coordinates are assinged to polygon vertices. Both require 
a single division per-pixel for each texture coordinate; accounting for the texture projection simply 
modifies the divisor. Viewing a texture projected onto a three-dimensional scene is a useful technique 
for simulating a number of effects, including projecting images, spotlight illumination, and shadows. 
If hardware is available to perform texture mapping and the per-pixel division it requires, then these 
effects can be obtained with no performance penalty.  Acknowledgements Many thanks to Derrick Bums for 
help with the texture coordinate iteration equations. Thanks also to Tom Davis for useful discus­  
  
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134073</article_id>
		<sort_key>253</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>29</seq_no>
		<title><![CDATA[A fast and accurate light reflection model]]></title>
		<page_from>253</page_from>
		<page_to>254</page_to>
		<doi_number>10.1145/133994.134073</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134073</url>
		<categories>
			<primary_category>
				<cat_node>I.3.3</cat_node>
				<descriptor/>
				<type/>
			</primary_category>
			<other_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Animation</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>J.2</cat_node>
				<descriptor>Physics</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Radiosity</descriptor>
				<type>S</type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010405.10010432.10010441</concept_id>
				<concept_desc>CCS->Applied computing->Physical sciences and engineering->Physics</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010372.10010376</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Rendering->Reflectance modeling</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010352</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Animation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010372</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Rendering</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010382</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Image manipulation</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
			<gt>Design</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>P301827</person_id>
				<author_profile_id><![CDATA[81100332285]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Xiao]]></first_name>
				<middle_name><![CDATA[D.]]></middle_name>
				<last_name><![CDATA[He]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Program of Computer Graphics Cornell University, Ithaca, New York]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P220389</person_id>
				<author_profile_id><![CDATA[81100367339]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[Patrick]]></first_name>
				<middle_name><![CDATA[O.]]></middle_name>
				<last_name><![CDATA[Heynen]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Program of Computer Graphics Cornell University, Ithaca, New York]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>PP31092338</person_id>
				<author_profile_id><![CDATA[81332520985]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>3</seq_no>
				<first_name><![CDATA[Richard]]></first_name>
				<middle_name><![CDATA[L.]]></middle_name>
				<last_name><![CDATA[Phillips]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Program of Computer Graphics Cornell University, Ithaca, New York, Los Alamos National Laboratory, Los Alamos, New Mexico]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>PP31097274</person_id>
				<author_profile_id><![CDATA[81332531868]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>4</seq_no>
				<first_name><![CDATA[Kenneth]]></first_name>
				<middle_name><![CDATA[E.]]></middle_name>
				<last_name><![CDATA[Torrance]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Program of Computer Graphics Cornell University, Ithaca, New York]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P63622</person_id>
				<author_profile_id><![CDATA[81100188207]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>5</seq_no>
				<first_name><![CDATA[David]]></first_name>
				<middle_name><![CDATA[H.]]></middle_name>
				<last_name><![CDATA[Salesin]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P68459</person_id>
				<author_profile_id><![CDATA[81100196982]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>6</seq_no>
				<first_name><![CDATA[Donald]]></first_name>
				<middle_name><![CDATA[P.]]></middle_name>
				<last_name><![CDATA[Greenberg]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Program of Computer Graphics Cornell University, Ithaca, New York]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_obj_id>122738</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Xiao D. He, Kenneth E. Torrance, Franqois X. Sillion, and Donald P. Greenberg. A comprehensive physical model for light reflection. Computer Graphics 25(4): 175--86, 1991.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_obj_id>105799</ref_obj_id>
				<ref_obj_pid>105783</ref_obj_pid>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Richard L. Phillips. A general multimedia publishing system, Communications of the ACM 34(7), 1991.]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 ComDuter GraDhics. 26.2. Julv 1992 A Fast and Accurate Light Reflection Model Xiw D. He Patrick O, Heynen 
Richatd L. Phillips Kenneth E, Torrance Da\id H. Sale.sin Donald P. Greenher,q Program of Computer Graphics 
Come]] University Ithaca, New York 14853 *Los Alamos National Laboratory Los Alamos, New Mexico 87545 
 Abstract This multimedia paper elaborates on the comprehensive physically­based light reflection model 
introduced by He et al. [11.To explain the model more fully, the paper gives an overview of the light 
re­flection process at a surfiace, and employs an interactive graphical tool to demonstrate the reflection 
model s directional behavior. To make the model more practical, the paper describes an accurate ap­proximation 
of the reflection model. based on a spline surface, that is much faster to compute. The paper concludes 
with two animated sequences, which demonstrate some features of light reflection that are accounted for 
by the model. The full paper demonstrates the po­tential of interactive multimedia. It is written using 
MediaVlew [2], a system for authoring documents that include graphics, sound, video, and computer animation, 
CR Categories and Subject Descriptors: 1.3.7 [Computer Graph­ics]: Three-Dimensional Graphics and Realism; 
1.3.3 lComputer Graphics]: Picture/Image Generation: J.2 [Physical Sciences and Engineering]: Physics. 
Additional Key Words: reflectance model, multimedia,  Introduction For photorealistic image generation 
it is essential to use a com­prehensive light reflection model that provides a smooth transition from 
specular to diffuse behavior. In addition, to ensure accuracy the model must be physically based, For 
these reasons, a new general light reflection model was pre­sented by He cl a/, at SIGGRAPH 9 I [ 11. 
The model is based on physical optics and describes specular, directional diffuse, and uni­foml diffuse 
reflection off a surface. The reflected light pattern de­pends on wavelength, incidence angle, two surface 
roughness pa­rameters, and the surface refractive index. The model applies to a wide range of materials 
and surface finishes, and has been experi­mentally verified. However. the model also has some disadvantages. 
It contains an in­finite summation term that converges very slowly. In addition, be­cttuse the model 
is complex, it is d~fticult ~o understand. Pcrmissl<m[<)copy without &#38; till <wpart {)( this material 
is grand provided that (he copiesarc nw made or distributed for direct commercial tidvantage. ~heACM 
copyright notice and [he tde of the publication and its date appear. and notice is given that copying 
is by fxrmission of the Assncia(ion for Computing Machinery. To copy otherwlw, or IO republish, requires 
a fce tmd/tw specific permmion, [ [gy~ ACM-()-X979 I-479-I19z/aJ7mss $0150 In this multimedia paper 
we address both of the~e issues. To help ex­plain the light reflection model, the paper gives a graphical 
overview of the light reflection process at a surface, and employs an interactive graphical tool to demonstrate 
the model sdirectional behavior, This tool allows the viewer to observe the effects on the various term 
of the light distribution function as parameters arc changed, To make the model practical, the paper 
describes how the infinite summation term can be closely approximated by a spline surface and stored 
as a small lookup table of control points. This approximation allows very fast computation of the full 
BRDF, as demonstrated by the interactive sessions themselves, Finally. the multimedia paper includes 
twn animation sequences, which demonstrate some features of light reflection that are ztc­countcd for 
by the physically-based model and were not accounted for by previou\ modeli. The full paper was written 
using the MediaView iystem. developed by Richard Phillips [2]. In this extended abstract. we attempt 
to give the flavor of the full multimedia document by using a sequence of illustrations from it\ interactive 
tools and animation. 2 Understanding the physically-based model The bidirectional rctlectance distribution 
funcliorr [BRDF~ depend~ on a number of geometrical and physical parameters [ 11. The ge­ometrical parameters 
include, among other things, the polar angle of incidence H and the solid angle of the incident beam 
cL,,. The physical parameters include the wavelength of the light A as well as some physical parameters 
of the surface its roughness, given byo and T, which specify the height and width of ~mall statisti­cal 
peaks on the surface: and it~ index of refraction it. which ii a function of,\ The full BRDF can be divided 
into three major reflection components specular, directional diffuse, and uniform diffuse which in turn 
can be broken into smaller terms. iuch as Fresnel re­flectivity, effective roughness, and surface ma~king 
and shadowing, Each of these terms can be written m a function of the variou~ ge­ometrical and physical 
pammeter~ of the reflecting sufi~ce and the illuminating light, In the multimedia paper, the reader learns 
uboctt the behitvior of the full BRDF by studying the effecl of these various pammeters on each of the 
model s terms. The user interacts with the model by varying the positions of slider> on the menu shown 
in Figure 2, To vary the index of refraction ri. the user changes the material type (e.g., aluminum is 
~elccted in Figure 2). In addition. by touching 253    
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134075</article_id>
		<sort_key>255</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>30</seq_no>
		<title><![CDATA[Predicting reflectance functions from complex surfaces]]></title>
		<page_from>255</page_from>
		<page_to>264</page_to>
		<doi_number>10.1145/133994.134075</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134075</url>
		<keywords>
			<kw><![CDATA[BRDF]]></kw>
			<kw><![CDATA[Monte Carlo]]></kw>
			<kw><![CDATA[anisotropic reflection]]></kw>
			<kw><![CDATA[spherical harmonics]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Color, shading, shadowing, and texture</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>G.3</cat_node>
				<descriptor>Probabilistic algorithms (including Monte Carlo)</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Curve, surface, solid, and object representations</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Radiosity</descriptor>
				<type>S</type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010399</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Parametric curve and surface models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002950.10003648.10003671</concept_id>
				<concept_desc>CCS->Mathematics of computing->Probability and statistics->Probabilistic algorithms</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010372.10010376</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Rendering->Reflectance modeling</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002950.10003648.10003670.10003677</concept_id>
				<concept_desc>CCS->Mathematics of computing->Probability and statistics->Probabilistic reasoning algorithms->Markov-chain Monte Carlo methods</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010401</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Volumetric models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002950.10003648.10003670.10003682</concept_id>
				<concept_desc>CCS->Mathematics of computing->Probability and statistics->Probabilistic reasoning algorithms->Sequential Monte Carlo methods</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010382</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Image manipulation</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010382.10010384</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Image manipulation->Texturing</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>PP31100375</person_id>
				<author_profile_id><![CDATA[81100345625]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Stephen]]></first_name>
				<middle_name><![CDATA[H.]]></middle_name>
				<last_name><![CDATA[Westin]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Program of Computer Graphics, Cornell University, Ithaca,NewYork]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P131603</person_id>
				<author_profile_id><![CDATA[81100529394]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[James]]></first_name>
				<middle_name><![CDATA[R.]]></middle_name>
				<last_name><![CDATA[Arvo]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Program of Computer Graphics, Cornell University, Ithaca,NewYork]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>PP31097274</person_id>
				<author_profile_id><![CDATA[81332531868]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>3</seq_no>
				<first_name><![CDATA[Kenneth]]></first_name>
				<middle_name><![CDATA[E.]]></middle_name>
				<last_name><![CDATA[Torrance]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Program of Computer Graphics, Cornell University, Ithaca,NewYork]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_obj_id>37434</ref_obj_id>
				<ref_obj_pid>37401</ref_obj_pid>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Cabral, B., Max, N., and Springmeyer, R., Bidirectional reflection functions from surface bump maps. In Proceedings of SIGGRAPH '87(July 27-31, 1987, Anaheim, California), Computer Graphics 21, 4 (July 1990), 273-281.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_obj_id>357293</ref_obj_id>
				<ref_obj_pid>357290</ref_obj_pid>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Cook, R. L, and Torrance, K. E. A reflectance model for computer graphics, ACM Transactions on Graphics 1, 1 (January 1982), 7-24.]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Gouraud, H. Continuous shading for curved surfaces. IEEE Transactions on Computers 20, 6 (June 1971), 623-628.]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[Hecht, E., and Zajac, A. Optics. Addison-Wesley, 1974.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122738</ref_obj_id>
				<ref_obj_pid>122718</ref_obj_pid>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[He, X. D., Torrance, K. E., Sillion, E X., and Greenberg, D. P. A comprehensive physical model for light reflection. In Proceedings of SIGGRAPH '91(July 28-August 2, 1991, Las Vegas, Nevada), Computer Graphics 25, 4 (July 1991), 175- 186.]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_obj_id>808601</ref_obj_id>
				<ref_obj_pid>800031</ref_obj_pid>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[Goral, C. M., Torrance, K. E., Greenberg, D. P., and Battaile, B. Modeling the interaction of light between diffuse surfaces. In Proceedings of SIGGRAPH '84(July 23-27, 1984, Minneapolis, Minnesota), Computer Graphics 18, 3 (July 1984),213-222.]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_obj_id>15902</ref_obj_id>
				<ref_obj_pid>15922</ref_obj_pid>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Kajiya, J. The rendering equation. In Proceedings of SIG- GRAPH '86(August 18-22, 1986, Dallas, Texas), Computer Graphics 20, 4 (August 1986), 143-150.]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_obj_id>325167</ref_obj_id>
				<ref_obj_pid>325165</ref_obj_pid>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[Kajiya, J. Anisotropic reflectance models. In Proceedings of SIGGRAPH '85(July 22-26, 1985, San Francisco, California), Computer Graphics 19, 4 (July 1985), 15-21.]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_obj_id>808594</ref_obj_id>
				<ref_obj_pid>800031</ref_obj_pid>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Kajiya, J., and Von Herzen, B. Ray tracing volume densities. In Proceedings of SIGGRAPH '84(July 23-27, 1984, Minneapolis, Minnesota), Computer Graphics 18, 3 (July 1984), 165-174.]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_obj_id>7050</ref_obj_id>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[Kalos, M, H., and Whitlock, P. A. Monte Carlo Methods. John Wiley &amp; Sons, 1986.]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
			<ref>
				<ref_obj_id>97909</ref_obj_id>
				<ref_obj_pid>97879</ref_obj_pid>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[Poulin, P., and Fournier, A. A model for anisotropic reflection. In Proceedings of SIGGRAPH '90 (August 6-10, 1990, Dallas, Texas), Computer Graphics 24, 4 (August 1990), 273-282.]]></ref_text>
				<ref_id>11</ref_id>
			</ref>
			<ref>
				<ref_obj_id>360839</ref_obj_id>
				<ref_obj_pid>360825</ref_obj_pid>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[Phong, B-T. Illumination for computer generated pictures., Communications of the ACM 18, 6 (June 1975), 311- 317.]]></ref_text>
				<ref_id>12</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122739</ref_obj_id>
				<ref_obj_pid>122718</ref_obj_pid>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[Sillion, E X., Arvo, J., Westin, S. H., and Greenberg, D. P. A global illumination solution for general reflectance distributions. In Proceedings of SIGGRAPH "9i (July 28-August 2, 1991, Las Vegas, Nevada), Computer Graphics 25, 4 (July 1991), t87-196.]]></ref_text>
				<ref_id>13</ref_id>
			</ref>
			<ref>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[Siegel, R., and Howell, J. R. Thermal Radiation Heat Transfer. Hemisphere Publishing, New York, 1981.]]></ref_text>
				<ref_id>14</ref_id>
			</ref>
			<ref>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[Torrance, K. E. and Sparrow, E. M. Theory for offspecular reflection from roughened surfaces. In Journal of the Optical Society of America 57, 9 (September 1967) 1105- 1114.]]></ref_text>
				<ref_id>15</ref_id>
			</ref>
			<ref>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[Torrance, K. E. and Sparrow, E. M. Off-specular peaks in the directional distribution of reflected thermal radiation. In Journal of Heat Transfer (May 1966) 223-230.]]></ref_text>
				<ref_id>16</ref_id>
			</ref>
			<ref>
				<ref_seq_no>17</ref_seq_no>
				<ref_text><![CDATA[Wallace, P. R. Mathematical Analysis of Physical Problems. Dover Publications, Mineola, N. Y. 1984.]]></ref_text>
				<ref_id>17</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378490</ref_obj_id>
				<ref_obj_pid>54852</ref_obj_pid>
				<ref_seq_no>18</ref_seq_no>
				<ref_text><![CDATA[Ward, G. J., Rubinstein, E M. and Clear, R. D. A ray tracing solution for diffuse interreflection. In Proceedings of SIGGRAPH '88 (August 1-5, 1988, Atlanta, Georgia), Computer Graphics 24, 4 (August 1988), 85-92.]]></ref_text>
				<ref_id>18</ref_id>
			</ref>
			<ref>
				<ref_obj_id>358882</ref_obj_id>
				<ref_obj_pid>358876</ref_obj_pid>
				<ref_seq_no>19</ref_seq_no>
				<ref_text><![CDATA[Whitted, T. An improved illumination model for shaded display. In Communications of the ACM 23, 6 (June 1980) 343- 349.]]></ref_text>
				<ref_id>19</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 Predicting Re.ectance Functions from Complex Surfaces Stephen H. Westin James R. Arvo Kenneth E. Torrance 
 Program of Computer Graphics Cornell University Ithaca, NewYork 14853 Abstract We describe a physically-based 
Monte Carlo technique for ap­proximating bidirectional re.ectance distribution functions (BRDFs) for 
a large class of geometries by directly simulating optical scattering. The technique is more general 
than pre­vious analytical models: it removes most restrictions on sur­face microgeometry. Three main 
points are described: a new representation of the BRDF, a Monte Carlo technique to esti­mate the coef.cients 
of the representation, and the means of creating a milliscale BRDF from microscale scattering events. 
These allowthe prediction of scattering from essentially ar­bitrary roughness geometries. The BRDF is 
concisely repre­sented by a matrix of spherical harmonic coef.cients; the ma­trix is directly estimated 
from a geometric optics simulation, enforcing exact reciprocity. The method applies to rough­ness scales 
that are large with respect to the wavelength of light and small with respect to the spatial density 
at which the BRDF is sampled across the surface; examples include brushed metal and textiles. The method 
is validated by com­paring with an existing scattering model and sample images are generated with a physically-based 
global illumination al­gorithm. CR Categories and Subject Descriptors: I.3.7 [Computer Graphics]: Three-Dimensional 
Graphics and Realism. Additional Key Words: spherical harmonics, Monte Carlo, anisotropic re.ection, 
BRDF 1 Introduction Since the earliest days of computer graphics, experimenters have recognized that 
the realism of an image is limited by the sophistication of the model of local light scattering [3, 12]. 
Non-physically-based local lighting models, such as that of Phong [12], although computationally simple, 
exclude many important physical effects and lack the energy consistency needed for global illumination 
calculations. Physically-based models [2, 5, 15] reproduce many effects better, but cannot Permission 
to copy without fee all or part of this material is granted provided that the copies are not made or 
distributed for direct commercial advantage, the ACM copyright notice and the title of the publication 
and its date appear, and notice is given that copying is by permission of the Association for Computing 
Machinery. To copy otherwise, or to republish, requires a fee and/or specific permission. 1000 Geometry 
 Object scale 100 Texture, bump maps 10 Milliscale Texels 1 mm 0.1 BRDF Microscale 0.01 Figure 1: Applicability 
of Techniques model many surfaces, such as those with anisotropic rough­ness. Models that deal with 
anisotropic surfaces [8, 11] fail to assure physical consistency. This paper presents a newmethod of 
creating local scat­tering models. The method has three main components: a concise, general representation 
of the BRDF, a technique to estimate the coef.cients of the representation, and a means of using scattering 
at one scale to create a BRDF for a larger scale. The representation used makes it easy to enforce the 
ba­sic physical property of scattering reciprocity, and its approx­imation does not require discretizing 
scattering directions as in the work of Kajiya [8] and Cabral et al. [1]. The method can predict scattering 
from any geometry that can be ray-traced: polygons, spheres, parametric patches, and even volume densities. 
Previous numerical techniques were limited to height .elds, and analytical methods have been developed 
only for speci.c classes of surface geome­try. The newmethod accurately models both isotropic and anisotropic 
surfaces such as brushed metals, velvet, and wo­ven textiles. Figure 1 shows several representations 
used in realistic ren­dering, along with approximate scale ranges where each is  applicable. At the 
smallest scale (size1 mm), which we call microscale, the BRDF accurately captures the appearance of a 
&#38;#169;1992 ACM-0-89791-479-1/92/007/0255 surface. As individual surface features become larger than 
one pixel, texture maps, bump maps, and texels can be used to showsurface features. At the largest scale, 
object scale, the geometry must be modeled explicitly, for example with poly­gons or parametric patches. 
The applicability of each representation ultimately de­pends on the context: the upper limit of applicable 
scale is determined by the frequency of sampling across a surface, and the lower limit is determined 
by the integration area for each sample; this is often the surface area represented by a pixel. When 
rendering, say, an interior scene, objects as small as a pencil must be modeled at object scale; when 
simulat­ing the viewfrom orbit, however, objects as large as trees and buildings can be modeled within 
the BRDF, so we can think of them as microscale geometry, or microgeometry. The advent of global illumination 
methods (e.g. [6, 18]) has cre­ated another concept of scale: these methods generally use a coarser characterization 
of scattering for indirect illumina­tion, but demand careful attention to energy consistency and physical 
accuracy. The method of this paper is applicable wherever the BRDF is an adequate model of surface geometry. 
It uses an analyt­ical BRDF model for scattering at one scale of roughness, the microscale, simulating 
geometric optical scattering at a larger scale, the milliscale. Milliscale scattering embodies large-scale 
roughness effects (roughness size :wavelength of light, A), and any smooth surface effects (roughness 
size :Aor A) are modeled by the microscale BRDF, which can include wave optics effects. The next three 
sections present the heart of the technique: the BRDF representation, the Monte Carlo estimator, and 
the means of estimating a milliscale BRDF from the microscale description of surface roughness.  2 Wheels 
Within Wheels: Representing the BRDF with Spherical Harmonics A general scattering function for unpolarized 
light is a func­ I tion of four variables, Pbd(8i ,<i,8r ,<r): S2 xS2, where S2 is the unit sphere, 8i 
,<i are the elevation and azimuth angles of incidence, and 8r ,<r are the corresponding angles of re.ec­tion 
(Figure 2). For a BRDF, Pbd is zero whenever 8i or 8r 72. The BRDF can take on highly arbitrary shapes 
[5, 16], so a very general method is needed to represent it. Fortunately, a BRDF z x  is generally 
smooth, making it a good candidate for repre­sentation by smooth orthogonal functions. Previous authors 
have used spherical harmonics to represent scattering func­tions [1, 9, 13], since they form a complete 
basis set of smooth functions over the sphere. Kajiya [9] used spherical harmon­ics to derive an analytical 
scattering function; Cabral et al. [1] and Sillion et al. [13] used them as a numerical approximation 
to the BRDF. The representation used in this paper is an ex­tension of Sillion s technique; it provides 
an accurate, concise embodiment of the general BRDF. 2.1 Overviewof Spherical Harmonics Any square-integrable 
function over the sphere can be exactly represented by an in.nite sum of spherical harmonic basis functions, 
Ylm(8,<), of varying order, l, and degree, m: l f (8,<)=ClmYlm(8,<).(1) l=0 m=-l As with a Fourier 
representation, we can approximate f by truncating the series to a .nite number of terms. For con­venience, 
we organize this .nite collection of basis functions into a vector by the convention of encoding both 
order and degree with a single subscript. Thus n f (8,<) :CkYk(8,<)= C (8,<).(2) k=0 Each coef.cient 
Ck is de.ned by the inner product of f (8,<) with the corresponding spherical harmonic basis function: 
1277 Ck = 1f (8,<)Yk(8,<) sin 8d8d< 0 0 = Yk If). (3) This follows directly from the orthogonality of 
the basis func­tions [17]. 2.2 Representing the BRDF If we .x the incident direction (8i ,<i), the BRDF 
is a func­tion of two variables, (8r ,<r), and the representation in Equa­tion 2 suf.ces. To account 
for variation of the BRDF with in­cident direction, the coef.cient vector Cin Equation 2 can be thought 
of as a function of the incident direction. If a sur­face has isotropic roughness, as assumed in [1] 
and [13], the scattering function Pbd is independent of rotation about the surface normal. In this case, 
Pbd(8i ,<i ,8r ,<r)= Pbd(8i , 0,8r ,<r .<i).(4) Each coef.cient Ck is a function of 8i alone, which 
can be cal­culated for a number of selected values of 8i and interpolated for all 8i [1, 13]. In general, 
however, a BRDF is a function of <i as well as of (8i ,8r ,<r), so a richer representation is needed. 
 2.3 Extension to Anisotropic Surfaces For an anisotropic surface both 8i and <i must be considered, 
and none of the previous representations suf.ces [1, 13]. Each coef.cient Ck in Equation 2 is thus a 
function of 8i and <i: Nomenclature Ck Spherical harmonics coef.cient for basis function Yk CVector of 
coef.cients Ei Incident energy .ux density (irradiance) Er Re.ected energy .ux density Gk Estimator of 
Ck Ii Incident radiance Ir Re.ected radiance  Exact matrix of coef.cients to represent Pbd  Monte 
Carlo approximation of  mjk Element at row j, column k of matrixNb Number of exit rays resulting from 
one incident ray Ni Number of incident ray directions Np Number of sample points on surface of specimen 
p(Oi ,<i ,Or ,<r) Probability density function of scattering from (Oi ,<i)to (Or ,<r) R(Oi ,<i ,Or ,<r) 
Attenuation of a single ray incident from (Oi ,<i) and re.ected to (Or ,<r) Yk(O,<) Spherical harmonics 
basis function YVector of basis functions OElevation angle: O= 0 at surface normal <Azimuth angle: <=0 
at x axis Pbd(Oi ,<i ,Or ,< r) Milliscale bidirectional re.ectance distribution function (BRDF) M Pbd(Oi 
,<i ,Or ,< r) Microscale bidirectional re.ectance distribution function (BRDF) M Ps(Oi ,<i) Microscale 
specular re.ectivity dWi Differential solid angle of incident energy dWr Differential solid angle of 
re.ected energy (a b Inner product of two functions: a(t)b(t)dt ( Expected value of random variable n 
 Pbd(Oi ,<i,Or ,< r) :Ck (Oi ,<i)Yk(Or ,< r).(5) k=0 Each coef.cient function, Ck(Oi ,<i), is de.ned 
by the inner product of Pbd(Oi ,<i ,.,.) with the corresponding spherical har­monic basis function: Ck(Oi 
,<i)= (Pbd Yk re. (6) where the subscript re. denotes integration over the re­.ected hemisphere. Reciprocity 
makes the dependence of Pbd on (Oi ,<i) exactly like its dependence on (Or ,<r). Since spher­ical harmonics 
concisely represent the latter dependence, we also use them to represent the dependence on (Oi ,<i), 
express­ing each coef.cient function in terms of spherical harmonics. Each element of our vector Cof 
coef.cients is nowrepre­ sented in turn by a vector of coef.cients, giving us a matrixto represent the 
BRDF. Each element of the matrix is given by mjk = Yj (Pbd Yk (7) re. in where the subscripts in and 
re. denote integration over the incident and re.ected hemispheres, respectively. Evalua­tion of the 
BRDF becomes NN Pbd(Oi ,<i ,Or ,<r) :Yj(Oi ,<i)mjkYk(Or ,<r) j=0 k=0 = YT (Oi ,<i)Y(Or ,<r),(8) where 
Y(O,<) is the column vector of basis functions evalu­ated at (O,<). 2.4 Reciprocity An important physical 
constraint on the BRDF is reciprocity, which states that Pbd(Oi ,<i ,Or ,< r)= Pbd(Or ,< r ,Oi ,<i) (9) 
 for all angles of incidence and re.ection [14]. If the matrix M is symmetric, then Y T(Oi ,<i)Y(Or ,< 
r)= Y T (Or ,< r)Y(Oi ,<i) (10) and the approximation in Equation 8 satis.es Equation 9. By assuring 
that we compute a symmetric matrix M, we can en­force exact reciprocity; previous approaches [1, 8, 11, 
13] af­forded, at best, approximate reciprocity. 2.5 Storage Reduction and Filtering The matrix M can 
be quite large; tens of thousands of ele­ments are typical. Since our BRDF representation, like that 
of [13], is based on spherical harmonics, we can adapt two tech­niques from that work to reduce the number 
of coef.cients (and corresponding basis functions) needed: the .rst tech­nique causes half the coef.cients 
to vanish, and the second reduces the high-frequency content of the BRDF, reducing the number of coef.cients 
needed to achieve an acceptably accu­rate approximation. Since we deal only with scattering to one hemisphere, 
we can complete the other hemisphere with an arbitrary function. We chose a function that reduces the 
size of the representation: Pbd(Oi ,<i,7-Or ,<r)= -Pbd(Oi ,<i ,Or ,<r); this causes half of the coef.cients 
(those with l + m even in the real form of spherical harmonics) to be zero; they can be omitted from 
the representation, reducing the matrix size by 3 4. To economize further, we represent Pbd cos Oi cos 
Or instead of Pbd; multiplication by cos Oi, together with the completion described above, forces C1 
continuity at the equator and dras­tically reduces ringing. To maintain symmetry of the matrix M, we 
also multiply by cos Or. Representing Pbd cos Oi cos Or assures that Equation 9 is still satis.ed. We 
omit this imple­mentation detail from the following discussion. As with a Fourier representation of a 
function, simply trun­cating all coef.cients with index llmax will cause ringing in the approximation, 
called the Gibbs phenomenon. To re­duce this, we attenuate higher frequencies, as did Cabral et al. [1], 
by progressively reducing the magnitude of coef.­cients with l.lter <l lmax, where l.lter is an empirically­determined 
threshold. The magnitude is reduced according to a half-Gaussian with empirically-determined width. 
 3 Monte Carlo Estimation of the Coef.cient Matrix If we bombard a specimen with incident rays from 
an arbi­trary direction U =(i ,<i), the BRDF can be expressed as O P p(U,V)R(U,V)) bd(U,V)= (11) Ocos 
r where a ray from direction U will scatter into V =(Or ,<r) with a probability density p(U,V), andR(U,V))is 
the mean atten­uation of all rays incident from direction U and scattered in direction V. In order to 
obtain a spherical harmonics coef.cient, we must integrate the product bdYk over the hemisphere. P Ck(U)= 
 Pbd(U,V)Yk (V)dV S2 = gk(U,V)) p(U,V)dV (12) S2 where gk(U,V)= R(U,V) cos Or Yk(V) (13) Unfortunately 
we have no analytical expression for p or R; we can, however, use a Monte Carlo simulation to estimate 
the integral in Equation 12. The integral can be interpreted as the expected value of gk(U,V), where 
V is a random variable with probability density function p(U,V). If we de.ne N 1 Gk(U)= gk(U,Vn) (14) 
N n=1 where Vn are random samples distributed according to p, then the expected value of Gk is Ck(U); 
Gk is said to be an estimator of the integral [10]. The rays departing from the specimen in direction 
V will have mean attenuationR(U,V)); this attenu­  ation must be multiplied by Yk (V)/cos Or to give 
the expected value g for the estimator. This leaves another integration, that with respect to U: mjk 
= Ck(U)Yj (U)dU (15) S2 This integration can also be handled via Monte Carlo, this time as quadrature, 
a discrete approximation to an integral. This is handled similarly, with the estimator N 1 mjk = Cj(Un 
)Yj(Un ) (16) N n=1 where the Un are uniformly distributed over the incident hemisphere. These two sampling 
processes, each approxi­mating an integral in two dimensions, can be combined into one process to approximate 
the four-dimensional integral de­sired. N  1 mjk = gk(Un ,Vn)Yj(Un ) (17) N n=1 where the Un are distributed 
uniformly and the Vn are dis­  tributed according to p.mjk is an unbiased estimator of mjk.  The simulation 
yields, an approximation to the sym­metric matrix M, and does not guarantee symmetry, so reci­procity 
of the BRDF is not guaranteed. We average the upper  triangle and the lower triangle ofto obtain a symmetric 
 matrix 12 (+T) which is used to compute Pbd. The two tri­angles are independent unbiased estimates 
of the BRDF; by averaging them to obtain a symmetric matrix, we also reduce  the variance of our estimate 
of. 4 From Microscale to Milliscale The BRDF can be used to model features ranging from mi­croscale 
to milliscale for visible light, as shown in Figure 1. This section explains howto use microscale scattering 
events to calculate a milliscale BRDF. The section starts with basic BRDF de.nitions, describes the individual 
microscale scatter­ing events, then explains howindividual Monte Carlo events are incorporated into the 
milliscale model to obtain an aggre­gate BRDF. At the microscale, arbitrary re.ection models may be em­ployed, 
including ideal specular, ideal diffuse, and direc­tional diffuse models. One illustrative case is where 
the mi­crogeometry is composed of planar ideal specular surfaces; this is equivalent to geometric optics 
models based on micro­facets, such as the Torrance-Sparrowmodel [15]. We use ray tracing to model scattering 
events, as suggested by Cabral et al. [1]. The ray tracer must be carefully designed to assure physically 
accurate results. Each ray has a certain amount of energy associated with it; microscale re.ection will 
attenuate this energy and perhaps divide it among multiple rays at each bounce. All calculations involve 
energy .ux den­sity until a ray .nally exits the model; then the energy is con­verted to radiance, the 
proper quantity for the BRDF, by di­viding by cos Or. The radiance distribution is averaged over the 
specimen surface to create a milliscale BRDF. Surface normal  Et Specular transmission Figure 3: Local 
Scattering Modes 4.1 Incident Energy and the BRDF We are estimating the BRDF Pbd, which is expressed 
at a given wavelength as dIr(Orr) z<Pbd(Or z<r Oi <i)= (18)zzdEi(Oi z<i) where dIr is the re.ected radiance 
and dEi is the incident en­ergy .ux density, the incident energy per unit time per unit area. This equation 
holds at both micro-and milliscales. It becomes simpler to evaluate if we hold the denominator (in­cident 
energy .ux density) constant and vary the incident an­gles Oi z<i. Then dIr(Orr) z<POOdEi bd(r z<r zi 
z<i)= (19) where dEi is the (constant) incident energy .ux density. Incident radiance Ii is de.ned as 
the incident energy .ux density per unit projected area per unit solid angle dEi Ii = (20) cos idWi O 
Thus dEi(i z<i)= Ii (i z<i) cos idi(21) OOOW The factor cos i converts receiving area to projected area, 
ac- O counting for the dependence of projected surface area on Oi. The method allows different local 
scattering modes, three of which are shown in Figure 3. The next three sections de­scribe howthese modes 
are modeled. 4.2 Specular Re.ection The BRDF at the microscale may contain an ideal specular componentPs. 
Whenever a ray hits such a microfacet, we model the transfer by spawning a ray in the specular direc­tion 
as in classical ray-tracing [19]. The energy .ux density of this ray is determined by the equation  
dEr =s(Oi )dEi (22) P where dEi is the .ux density of the incident ray, Oi is the in­ cident elevation 
with respect to the local facet, andPs is the microscale specular re.ection coef.cient for the facet. 
 4.3 Specular Transmission The method may be used to model microgeometries that in­clude transparent 
materials. Whenever a ray encounters a smooth interface between media of different refractive in­dices, 
we must calculate the energy transfer through the in­terface. Neither energy .ux density nor radiance 
is preserved at the interface [4], since solid angles are altered, but the dis­tribution of transmitted 
rays accounts for this. We also must model any attenuation of the ray as it passes through a trans­parent 
medium; for a uniform medium, the ray is attenuated  by es where s is the path distance and "is an 
extinction co­ef.cient determined by the material. 4.4 Directional-Diffuse Re.ection The most complex 
transfer takes place when a ray strikes a facet that shows directional-diffuse scattering. When a ray 
hits such a facet, we send out n rays to the hemisphere above  the facet and weight them according tobd; 
this serves as a Pdiscrete approximation of scattering according to the ideal­diffuse and directional-diffuse 
parts of the BRDF. The total energy transfer is determined by dEr(Orr)= dIr dWr cos Or = dEiPbd(Oi z<izOr 
z<r) dWr cos Or (23) z< where dEr is the re.ected energy .ux density in a particular direction,Pbd is 
the diffuse part (including directional-diffuse) of the microscale BRDF, and dWr is the solid angle of 
re.ection. The angles (Or z<r) give the re.ection direction with respect to the local facet. We multiply 
by dWr cos Or to convert the radi­  ance given bybd to energy .ux density for the next scattering P 
 event. In our implementation re.ected rays are cast randomly into the hemisphere above the local (microscale) 
surface; they are distributed uniformly over this hemisphere, so each ray represents a solid angle of 
27 dWr = (24) n where 27is the total solid angle of the hemisphere and n is the number of re.ected rays 
shot. 4.5 Integrating Over Milligeometry We have described the possible microscale events of a single 
ray striking a point on the surface, but we must integrate over the specimen to obtain the aggregate 
BRDF. Just as the Monte Carlo integration was extended in Section 3 to accomodate the two dimensions 
of the incident hemisphere, it can be ex­tended further to integrate over a two-dimensional specimen 
surface. We can keep the incident energy .ux density con­stant by keeping both the total incident .ux 
and the receiv­ing surface area constant. We do this by shooting a constant number of rays (energy .ux) 
and by distributing them over a constant surface area. The simplest way to do this is to se­lect a .xed 
region of the surface, as shown in Figure 4, and to distribute the samples uniformly over this region 
at each incident angle. The direction of each ray is determined by the incident angles (Oi z<i) with 
respect to the mean surface; its ori­gin will be calculated so that the ray will strike the notional 
plane of the surface, shown in Figure 4 in red, at the chosen sample point. Figure 4: Target Area The 
surface region chosen should be T large with respect to the lateral geometric features of the surface, 
to assure a good statistical average of large-scale Tscattering; large with respect to the vertical thickness 
of the surface Tgeometry; and a subset of the total surface geometry, since geometry outside the nominal 
surface region will be important at high incident angles. When a ray leaves the specimen area, we update 
the ap­ Mproximate matrixby adding y(U)yT (V)Rjcos Or. This matrix represents the BRDFdbd. We integrate 
over the por­tion of the surface that is visible from the re.ection direction (ir Or), projected onto 
the mean surface.  4.6 Ef.ciency Considerations We can reduce the computation needed to maintain the 
ma­ M trixby holding the incident direction U constant for several re.ected directions V, updating the 
matrix only once for each distinct U. This happens automatically when several ran­domly distributed rays 
are spawned at each intersection, as in directional-diffuse scattering. In addition, we choose sev­eral 
target points on the surface for each U, further amortiz­ing the cost of updating the matrix. Updating 
the matrix then becomes a triple sum NiNpNb M =1 y(Un ) yT(Vml) Rnml (25)NiNpNb cos Or n=1 m=1 l=1 where 
Rnml is the attenuation of a ray from incident direction Un re.ected in direction Vl from target point 
Pm on the sur­face. Ni is the number of incident directions used, Np is the number of sample positions 
across the specimen for each in­cident direction, and Nb is the number of exit rays resulting from a 
single incident ray. This approach reduces the number of evaluations of the spherical harmonics basis 
functions; for NiNpNb samples to update the matrix, y(U) is evaluated only Ni times, while yT (V) is 
evaluated NiNpNb times. The great­est savings, however, comes in matrix adds; we need only perform Ni 
matrix additions; the other updates simply add vectors and require far less computation.  4.7 Convergence 
Measure M Since the exact matrixis symmetric, we can use the asym­metry of our estimate as a measure 
of convergence in approx­imating the true BRDF. We calculate the error Q as M MT Q =(26)   where JJ 
 1 = ij(27) N2 j=1 k=1 where J is the size of the matrix. This is perhaps not as informative as a direct 
estimate of the variance of each coef­.cient, but is much cheaper to compute and tends to decline as 
1, which suggests that it is directly proportional to the N variance.  5 Results We nowshowseveral 
applications of the technique. We ob­tain BRDF s for surfaces textured at milliscale. At the mi­croscale, 
the BRDF can be ideal specular, ideal diffuse, or an analytical BRDF that includes wave optics effects. 
The tech­nique can also be used recursively by using the results of one simulation as the microscale 
BRDF in another simulation. All images shown in this section were generated by Monte Carlo ray tracing; 
the grainy texture of the images is caused by the Monte Carlo integration used to compute global illumi­nation. 
Other global illumination and rendering techniques might have been used, such as that of Sillion et al. 
[13]. We .rst consider a .at Gaussian-rough surface for which, at the microscale, the surface is an ideal 
specular re.ector. We can compare the results of the newmethod with the results of an existing analytical 
model for such a surface [5], thus giving some veri.cation of the newtechnique. 5.1 Initial Veri.cation: 
An Isotropic Surface Wave optics effects were not included, except for the Fresnel coef.cient for each 
microfacet. Re.ection is governed by ge­ometric optics; shadowing and masking effects of the surface 
are included because of the occlusion calculations in the ray tracer. Gaussian height .elds were generated 
by FFT .ltering of white noise, and the resulting points were connected by tri­angles, each of which 
was modeled as a mirror. To integrate over a specimen large compared to the roughness height, an p area 
of 88 millimeters was used. To assure adequate repre­sentation of the surface, a total of 524,288 polygons 
was used. The model was created in four sections of 131,072 polygons, each generated with a different 
random number seed, to rep­resent a square patch of surface 4mm wide. The roughness length parameters 
of the surface were =10m vertically ih and =65m horizontally (Figure 5). The specimen patch thactually 
used was 3.13mm wide in the center of the geomet­ric model; this assured that all incident rays would 
intersect the sides of the patch at least 2away from the notional i plane. Incident ray angles were 
restricted to 88°to keep the effec­tive roughness greater than 460 nm, the shortest wavelength employed. 
This keeps behavior in the regime where geomet­ric optics is valid; were the wavelength to approach the 
size Figure 5: Gaussian Surface of surface features, wave-related effects would begin to affect the 
scattering. Results are plotted as solid lines in Figure 6 for incident angles Oi =0°,30°,45°,60°,75°. 
Dashed lines showresults from the model of He [5], which assumes a Gaus­sian rough surface and allows 
for wave optics effects. The He model is shown in the limit of large surface roughness, (: , where wave 
optics effects should be negligible. The simula­tion agrees quite well with the analytical model for 
re.ection angles less than about 80°; the divergence at greater angles is disturbing, but not very signi.cant 
in terms of energy val­ues. Recall that the BRDF bd gives a radiance value dIr; the Penergy dEr scattered 
in any re.ected direction (Or ,<r)is pro­portional to dIr cos Or, reducing the effect of the error at 
high angles of re.ection. We believe that the error results because we approximate Pbd cos Or. If we 
assume that error in approxi­mating this function is roughly constant over the hemisphere, dividing by 
cos Or to recover Pbd will magnify the error near the horizon (i.e. as Or-2 ).  5.2 Simple Anisotropy 
We can use the method to create an anisotropic millis­cale BRDF by using an isotropic analytical microscale 
BRDF model; we rely on He s analytical model for microgeomet­ric effects, and use the newtechnique to 
model larger-scale anisotropy. Figure 7 shows, at the top, a model of parallel cylinders of slightly 
rough aluminum. In the left side of the .gure, the cylinders are oriented with axes perpendicular to 
the screen; in the right side the axes are parallel to the screen. The bottom half of the .gure shows 
a similar scene, but with two .at plates replacing the arrays of cylinders. Both plates use a BRDF generated 
from parallel cylinders like those in the top half of the .gure. In the left half of the .gure, the axis 
of anisotropy was oriented perpendicular to the screen; in the right half, it is oriented left-right. 
The scattering patterns are similar; when viewed from a distance, the images look the same. The microscale 
BRDF is important for generating the upper images; the milliscale BRDF is used for the lower .gures. 
Note how the surface orientation affects the appearance, revealing the anisotropic behavior of the re.ected 
light. This is further illustrated in 20 15 10 5 0 . r Figure 6: Comparison with Previous Model Figure 
8, where the same object is rendered with two BRDFs for brushed aluminum, one isotropic and one anisotropic. 
Figures 9 and 10 showan aluminum automotive wheel and an aluminum teapot created using this anisotropic 
BRDF. The polishing scratches were oriented as from rotation, about the vertical axis of the teapot and 
about the hub of the wheel. The BRDF energy-consistency of the BRDF, not guaranteed by previous approaches, 
allows an accurate global illumination solution.  Figure 7: Parallel Cylinder Model of Anisotropic Surface 
 Figure 8: Isotropic and Anisotropic Aluminum   5.3 Velvet A more complex microgeometry is that of 
velvet: it consists of many roughly parallel specular .bers extending from a fabric base. This was modeled 
as a forest of narrow cylinders, with the angle of each cylinder perturbed randomly (Figure 11). The 
target area for incident rays is shown at the top of the .bers. The .bers are shown as ideal diffuse 
for clarity; in the BRDF simulation, the .bers were transparent ideal-specular plastic. Whenever a ray 
intersected a .ber, it was either re­.ected (with probability equal to the Fresnel re.ectivity) or transmitted; 
when it intersected the base plane, it was ab­sorbed. Figure 12 shows an image made using the resulting 
BRDF.  5.4 Woven Cloth The method can also be used recursively to model sev­eral scales of roughness; 
this is demonstrated by modelling woven cloth as shown in Figure 1. At the milliscale, the Figure 12: 
Velvet Doughnut   Figure 9: Anisotropic Aluminum Wheel weave pattern of the cloth was modeled as shown 
in Fig­ure 13, and an anisotropic BRDF was used to model the scat­tering from individual .bers in the 
threads. The scattering from the surface of each thread (microgeometry) was mod­eled by the same geometry 
used in Section 5.2, but using a Fresnel re.ectance function to simulate black synthetic .bers. Figure 
14 has three parts: on the left, the cloth microgeometry is shown with an ideal-diffuse BRDF; in the 
center, it is shown with the thread BRDF, and on the right is a magni.ed photo­graph of actual cloth. 
Figure 15 shows a cushion upholstered in black nylon, rendered using the BRDF obtained from this process. 
  6 Conclusion Three main points are described in this paper: a newrepre­sentation of the BRDF, a Monte 
Carlo technique to estimate the coef.cients of the representation, and the means of cre­ating a milliscale 
BRDF from microscale scattering events. These allowthe prediction of scattering for essentially arbi­trary 
geometries. BRDFs for complex surfaces can be simu­lated hierarchically by using the result of one simulation 
in generating the BRDF for the next larger scale. The newrepresentation is concise and well-suited for 
use in rendering and global illumination calculations. The tech­nique of [13] can be easily extended 
to accommodate the new representation. Its ease of evaluation suits it for other global illumination 
methods such as stochastic ray tracing [7, 18] as well. The Monte Carlo integration used here enables 
us to model the scattering of many surfaces which have hitherto been im­possible to model in computer 
graphics, producing accurate models for anisotropic surfaces and surfaces with transparent elements. 
 7 Acknowledgements The authors would like to thank the Hewlett-Packard Com­pany for donating the Apollo 
and HP workstations used in this work. Stephen Westin was supported by a fellowship funded by Ford Motor 
Company. Thanks to Xiao-Dong He for valuable discussions of the physical process of scattering, and to 
Don Greenberg and Roy Hall for careful reading and criticism of the manuscript. Special thanks to Julie 
and Kurk Dorsey and to Harold Zatz for their help in assembling the manuscript. Suzanne Smits assisted 
ably and patiently with the illustrations. Thanks also to Ben Trumbore, Jim Ferwerda, and Hurf Sheldon 
for maintaining an excellent software and hardware environment. Geometric models were graciously provided 
by Sabine Coquillart of INRIA for the cushion in Figures 1 and 15, and by Ford Motor Company Design Staff 
for the wheel in Figure 9.  References [1] Cabral, B., Max, N., and Springmeyer, R., Bidirectional 
re­.ection functions from surface bump maps. In Proceedings of SIGGRAPH 87(July 27-31, 1987, Anaheim, 
California), Computer Graphics 21, 4 (July 1990), 273-281. [2] Cook, R. L, and Torrance, K. E. A re.ectance 
model for computer graphics, ACM Transactions on Graphics 1, 1 (Jan­uary 1982), 7-24. [3] Gouraud, H. 
Continuous shading for curved surfaces. IEEE Transactions on Computers 20, 6 (June 1971), 623-628. [4] 
Hecht, E., and Zajac, A. Optics. Addison-Wesley, 1974. [5] He, X. D., Torrance, K. E., Sillion, F. X., 
and Greenberg, D. P. A comprehensive physical model for light re.ection. In Proceedings of SIGGRAPH 91(July 
28-August 2, 1991, Las Vegas, Nevada), Computer Graphics 25, 4 (July 1991), 175­ 186. [6] Goral, C. 
M., Torrance, K. E., Greenberg, D. P., and Bat­taile, B. Modeling the interaction of light between diffuse 
surfaces. In Proceedings of SIGGRAPH 84(July 23-27, 1984, Minneapolis, Minnesota), Computer Graphics 
18, 3 (July 1984), 213-222. [7] Kajiya, J. The rendering equation. In Proceedings of SIG-GRAPH 86(August 
18-22, 1986, Dallas, Texas), Computer Graphics 20, 4 (August 1986), 143-150. [8] Kajiya, J. Anisotropic 
re.ectance models. In Proceedings of SIGGRAPH 85(July 22-26, 1985, San Francisco, California), Computer 
Graphics 19, 4 (July 1985), 15-21. [9] Kajiya, J., and Von Herzen, B. Ray tracing volume densi­ties. 
In Proceedings of SIGGRAPH 84(July 23-27, 1984, Min­neapolis, Minnesota), Computer Graphics 18, 3 (July 
1984), 165-174. [10] Kalos, M, H., and Whitlock, P. A. Monte Carlo Methods. John Wiley &#38; Sons, 1986. 
[11] Poulin, P., and Fournier, A. A model for anisotropic re.ection. In Proceedings of SIGGRAPH 90 (August 
6-10, 1990, Dallas, Texas), Computer Graphics 24, 4 (August 1990), 273-282. [12] Phong, B-T. Illumination 
for computer generated pic­tures., Communications of the ACM 18, 6 (June 1975), 311­ 317. [13] Sillion, 
F. X., Arvo, J., Westin, S. H., and Greenberg, D. P. A global illumination solution for general re.ectance 
dis­tributions. In Proceedings of SIGGRAPH 91 (July 28-August 2, 1991, Las Vegas, Nevada), Computer Graphics 
25, 4 (July 1991), 187-196. [14] Siegel, R., and Howell, J. R. Thermal Radiation Heat Trans­fer. Hemisphere 
Publishing, NewYork, 1981. [15] Torrance, K. E. and Sparrow, E. M. Theory for off­specular re.ection 
from roughened surfaces. In Journal of the Optical Society of America 57, 9 (September 1967) 1105­1114. 
[16] Torrance, K. E. and Sparrow, E. M. Off-specular peaks in the directional distribution of re.ected 
thermal radiation. In Journal of Heat Transfer (May 1966) 223-230. [17] Wallace, P. R. Mathematical Analysis 
of Physical Problems. Dover Publications, Mineola, N. Y. 1984. [18] Ward, G. J., Rubinstein, F. M. and 
Clear, R. D. A ray tracing solution for diffuse interre.ection. In Proceedings of SIGGRAPH 88 (August 
1-5, 1988, Atlanta, Georgia), Com­puter Graphics 24, 4 (August 1988), 85-92. [19] Whitted, T. An improved 
illumination model for shaded display. In Communications of the ACM 23, 6 (June 1980) 343­ 349.  
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134078</article_id>
		<sort_key>265</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>31</seq_no>
		<title><![CDATA[Measuring and modeling anisotropic reflection]]></title>
		<page_from>265</page_from>
		<page_to>272</page_to>
		<doi_number>10.1145/133994.134078</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134078</url>
		<keywords>
			<kw><![CDATA[Monte Carlo]]></kw>
			<kw><![CDATA[raytracing]]></kw>
			<kw><![CDATA[reflectance]]></kw>
			<kw><![CDATA[shading]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Color, shading, shadowing, and texture</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Raytracing</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Radiosity</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.6.4</cat_node>
				<descriptor></descriptor>
				<type></type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010147.10010341.10010342.10010344</concept_id>
				<concept_desc>CCS->Computing methodologies->Modeling and simulation->Model development and analysis->Model verification and validation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010372.10010376</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Rendering->Reflectance modeling</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010372.10010374</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Rendering->Ray tracing</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010341.10010342</concept_id>
				<concept_desc>CCS->Computing methodologies->Modeling and simulation->Model development and analysis</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010382</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Image manipulation</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010382.10010384</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Image manipulation->Texturing</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>P99980</person_id>
				<author_profile_id><![CDATA[81100633003]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Gregory]]></first_name>
				<middle_name><![CDATA[J.]]></middle_name>
				<last_name><![CDATA[Ward]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Lighting Systems Research Group, Lawrence Berkeley Laboratory]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Beckmann, Petr, Andre Spizzichino, The Scattering of Electromagnetic Waves from Rough Surfaces, Pergamon Press, NY, 1963.]]></ref_text>
				<ref_id>Beckmann63</ref_id>
			</ref>
			<ref>
				<ref_obj_id>563893</ref_obj_id>
				<ref_obj_pid>965141</ref_obj_pid>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Blinn, James F. '*Models of Light Reflection for Computer Synthesized Pictures," Computer Graphics, Vol. I I, No. 2, July 1977.]]></ref_text>
				<ref_id>Blinn77</ref_id>
			</ref>
			<ref>
				<ref_obj_id>37434</ref_obj_id>
				<ref_obj_pid>37402</ref_obj_pid>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Cabral, Brian. Nelson Max, Rebecca Springmeyer, "Bidirectional Reflection from Surface Bump Maps," Computer Graphics, Voi. 21, No. 4, July 1987.]]></ref_text>
				<ref_id>Cabral87</ref_id>
			</ref>
			<ref>
				<ref_obj_id>806819</ref_obj_id>
				<ref_obj_pid>965161</ref_obj_pid>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[Cook, Robert L. Kenneth E. Torrance, "A Reflectance Model for Computer Graphics," Computer Graphics, Vol. 15, No. 3, August 1981.]]></ref_text>
				<ref_id>Cook82</ref_id>
			</ref>
			<ref>
				<ref_obj_id>808590</ref_obj_id>
				<ref_obj_pid>964965</ref_obj_pid>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[Cook, Robert L., Thomas Porter, Loren Carpenter, "Distributed Ray Tracing," Computer Graphics, V ol. 18, No. 3, July 1984.]]></ref_text>
				<ref_id>Cook84</ref_id>
			</ref>
			<ref>
				<ref_obj_id>8927</ref_obj_id>
				<ref_obj_pid>7529</ref_obj_pid>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[Cook, Robert L., "Stochastic Sampling in Computer Graphics," ACM Transactions on Graphics, Vol. 5, No. I, January 1986.]]></ref_text>
				<ref_id>Cook86</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122738</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[He, X., K,E. Torrance, F.X. Sillion, D.P. Greenberg, "A Comprehensive Physical Model for Light Reflection," Computer Graphics, Vol. 25, No, 4. July 1991.]]></ref_text>
				<ref_id>He91</ref_id>
			</ref>
			<ref>
				<ref_obj_id>325167</ref_obj_id>
				<ref_obj_pid>325165</ref_obj_pid>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[Kajiya, James T., "'Anisotropic Reflection Models," Computer Graphics, Vol. 19, No. 3, July 1985.]]></ref_text>
				<ref_id>Kajiya85</ref_id>
			</ref>
			<ref>
				<ref_obj_id>15902</ref_obj_id>
				<ref_obj_pid>15886</ref_obj_pid>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Kajiya, James T., "The Rendering Equation," Computer Graphics, Vol. 20, No. 4, August 1986.]]></ref_text>
				<ref_id>Kajiya86</ref_id>
			</ref>
			<ref>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[Murray-Coleman. J.F., A.M. Smith, "The Automated Measurement of BRDFs and their Application to Luminaire Modeling," Journal of the Illuminating Engineering Society, Winter 1990.]]></ref_text>
				<ref_id>Murray-Coleman90</ref_id>
			</ref>
			<ref>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[Nicodemus. F.E. J.C. Richmond, J.J. Hsia, Geometrical Considerations and Nomenclature for Reflectance, U.S. Dep~ent of Commerce, National Bureau of Standards, October 1977.]]></ref_text>
				<ref_id>Nicodemus77</ref_id>
			</ref>
			<ref>
				<ref_obj_id>360839</ref_obj_id>
				<ref_obj_pid>360825</ref_obj_pid>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[Phong, B., "Illumination for Computer Generated Pictures," Communications of the ACM, Vol. 18, No. 6, June 1975.]]></ref_text>
				<ref_id>Phong75</ref_id>
			</ref>
			<ref>
				<ref_obj_id>97909</ref_obj_id>
				<ref_obj_pid>97880</ref_obj_pid>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[Poulin, Pierre, Alain Fournier, "'A Model for Anisotropic Reflection," Computer Graphics, Vol. 24, No. 4, August 1990.]]></ref_text>
				<ref_id>Poulin90</ref_id>
			</ref>
			<ref>
				<ref_obj_id>539488</ref_obj_id>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[Rubenstein, R.Y., Simulation and the Monte Carlo Method, J. Wiley, New York, 1981.]]></ref_text>
				<ref_id>Rubenstein81</ref_id>
			</ref>
			<ref>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[Sandford. Brian P., David C. Robertson, "Infrared Reflectance Properties of Aircraft Paints," Proceedings IRIS Targets, Backgrounds, and Discrimination, 1985.]]></ref_text>
				<ref_id>Sandford85</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122739</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[Sillion, Francois, James Afro, Donald Greenberg, "A Global Illumination Solution for General Reflectance Distributions," Computer Graphics, Vol. 25, No. 4, July 1991.]]></ref_text>
				<ref_id>Sillion91</ref_id>
			</ref>
			<ref>
				<ref_seq_no>17</ref_seq_no>
				<ref_text><![CDATA[Torrance. K.E. E.M. Sparrow, "Theory for Off-Specular Reflection from Roughened Surfaces," Journal of the Optical Society of America, Vol. 57, No. 9, September 1967.]]></ref_text>
				<ref_id>Torrance67</ref_id>
			</ref>
			<ref>
				<ref_obj_id>358882</ref_obj_id>
				<ref_obj_pid>358876</ref_obj_pid>
				<ref_seq_no>18</ref_seq_no>
				<ref_text><![CDATA[Whirred. Turner, "An improved Illumination Model for Shaded Display," C~mmum'cati~ns of the ACM, Vol. 23, No. 6, June 1980, pp. 343-349.]]></ref_text>
				<ref_id>Whitted80</ref_id>
			</ref>
			<ref>
				<ref_seq_no>19</ref_seq_no>
				<ref_text><![CDATA[Yokoi, Shigeki. Jun-ichiro Toriwaki, "Realistic Expression of Solids with Feeling of Materials," JARECT, Vol. 18, 1988.]]></ref_text>
				<ref_id>Yokoi88</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 Comouter GraDhica. 26.2, July 1992 Measuring and Modeling Anisotropic Reflection Gregory J. Ward Lighting 
Systems Research Group Lawrence Berkeley Laboratory ABSTRACT A new device for measuring the spatial 
reflectancedistributionsof surfaces is introduced, along with a new mathematical model of sniaorropic 
reflectance. The reflectance model presented is both simple and accurate, permitting efficient reflectance 
data reduction rasdreproduction. Tire vali­dity of the model is substantiated with comparisons to complete 
meaarsre­mems of surface reflectance functions gathered with the novel retlectometry device. This new 
device uses imaging technology to capture the entire hemisphem of reflected directions simttkarreously, 
which greatly accelerates the reflectance data gathering process, making it pssible to measure dozens 
of surfaces in the time that it used to take to do one. Example measurements and simulations are shown. 
and a table of fitted parameters for several surfaces is presented. General Terms: algorithms, measurement, 
theory, verification. CR Categories and Descriptors: 1.3.7 Three-dimensionalgraphics and rw#­ism, 1.6.4 
Model validation and analysis. Additional Keywords arsd Phrases: reflectance. Monte Carlo, raytracing, 
shading. 1. Isstroduction Numerousempiricalandtheoreticalmodelsfor the local reflection of light from 
surfaces have been introduced over the past 20 years. Empirical and theoretical models have the same 
goal of reproducing real reflectance func­tions, but the respective approaches are very different. An 
empirical model is simply a formula with adjustable parameters designed to fit a certain class of reflectance 
functions. Little attention is paid to the physical derivation of the model, or the physical significance 
of its parameters. A gmd example of an empirical model is the one developed by Sandford [Ssrtdford85]. 
This is a four parameter model of isotropic reffeztion, where the pararrtetem must be fit to a specific 
set of reflectance measurements. While two of these parameters cormspood roughly to measurable quantities 
such as total reflectance and spectdsrity, the other two parameters have no physical significance and 
are merely shape variables that make the specular lobe of the model more closely match the &#38;rs. In 
contrast to an empirical model, a theoretical model attempts to get closer to the true distribution by 
starting fmm physical theory. A good example of a theoretical model is the one derived recently by He 
et al [He91 ]. This is also a four parameter isotropic model, but afl four parame­ters have some physical 
meaning and can in principle be measured separately from the surface reflectance distribution. In prac­tice, 
however, it is usuaklynecessary to fit even a theoretical model to measurements of reflectance because 
the physical parameters involved are difficult to measure, This js the case in the f-fC-To~ce m~el, since 
measurements of the requisite surface height variance and auto­ Au1hOr $addrsaw I cyclotron Rd., 9.)-3 
I t 1. %kcIcy.CA 94720, E-mail: GJWsrd@lbl.gOv IW2 AcM-()-x9791-479 -l/92 /m7/()265 correlation distance 
variables are impractical for most surfaces. Tlsus, the physical derivation of such a model serves primarily 
to inspire greater confidence. and is not necessarily a practi~al advantage when it comes to fitting 
measured data. As in all scientific disciplines. if the themy does not fit the data, then the theory 
must be discarded, not the data. But where is the data? There is almost no published &#38;ta on surface 
reflectance as a function of angle, and what little data is available is in the form of plane mestsurerrwnts 
of isotropic surfaces with no mtatiortal variance in their reflectance functions. Tbus. we have little 
to compase our reflectance models to, and no real assurance that they are valid T?ris means that we may 
once again be falling back on the if it looks reasonable then it s OK philosophy that has misdirected 
computer graphics so often in the past. Why is the oldest specular model, the one introduced by Phong 
in 1975 [Phong75], still the most widely used to this day? Tlris model is neither theoretically plausible 
nor empirically correct. Any renderings that use the straight Phong model am most likely wrong because 
the model is not physical, and more light may be emitted than is received (for example). Tlte sole virtue 
of the Pbong model is its mathematical simplicity. Simplicity is indispensable in computer graphics. 
Simplicity is what permits fast renderings and hardware implementations. Without it, a reflectance model 
is little more than a novelty, Even a relatively straightfonvard model such as the one developed by Torrance 
and Spar­row [Tome67) and tailored for rendering applications by Blinn [Blinn77] and later Cook [Cook82] 
has been undemtilized in computer graphics due to its moderately complex form. More recent introductions 
by Poulin and Foumier [Poulin90] as well aa He et al [He91 ] are even more complex. what is really needed 
for computer graphics is a simple reflectance model that works reasonably welI for most materials. Our 
goal in this paper is not to present the ultimale mathematical model of reflectance. but to provide a 
simple formula that is physically valid and fits measured reflectance data. Here we will present both 
a new methcd for measuring isolropic and anisotropic refktance distributions and a mathematical model 
that fits these data with both accuracy and simplicity. 2. Definition of the BRDF The interaction of 
light with a surface can be expressed as a single func­tion, called the bidirectioml reflectance distn 
bution function, or BRDF for shorl [Nicodemus77]. This is a function of four angles, two incident and 
two reflested, as well as the wavelength and polarimtion of the incident radiation. For the sake of simplicity, 
we will leave wavelength and plsrization out of our equations, but keep in mind that they we contained 
implicitly in the function pM, which is defined in terms of incident and reflected radiance by the following 
integral: lx xf2 L, (9,.0, )s J J .L,(e,,tIj)PM(O,.Oj;%,0, ) COS9,sinfr( de, d41, (1) 00 where: $ is 
the =imutfral angle measured about the surface normal L, (e, ,$, ) is the reflectedradiance(watts/sreradiart/nteter2) 
L, (ei ,$i ) is the incident radiasxe Phdei TO,S AL) is the BRDF (steradian- ) 265 SIGGRAPH 92 Chicago, 
July 26-31, 1992 The fimction PM is bidirecriorud because the incident and reflected directions can be 
reverzed and the function will return the same value. Tlsk arises tkrm the fact that the physics of light 
is the same mn backwards ~ forwards, which is why light-backwardsray trac­ing works [Whhted80]. 3. Measuring 
the BRDF of a Surface A device for measuring BRDFs is called a grwriorqfectomerer. The usual design for 
such a device incorporates a single photometer that is made to move in relation to a surface sample, 
which itself moves in relation to a light source, afl under the control of a computer. Because BRDFs 
are in general a function of four angles, two incident and two reflcct~ such a device musthavefourdegreesof 
mechanicalfreedomtomeasurethecom­plete timction. This requires substantial complexity in the apparaNS 
and long periods of time to measure a single surface. A typical goniorethxtometer srrangemerrr,designedby 
Murray-Coleman and Smith [Mumsy-Colemrm90], is shown in Figure 1. -rxkrnmo. Figure 1. A conventional 
gonioreflectoroeterwith movable light source and photometer. As art sdtemariveto building such a gonioreflectometer, 
there are severat Iaba in North America where one cart send a surface sample for BRDF characterization. 
For a few hundred dollars, one cats get a three plane measurement of an isotropic materist at four or 
five angles of incidence. \# isosof material has a BRDF that is independent of rotation about the Therefore, 
only one @i direction is sampled.) Unfor­tunately, a comprehensive BRDF measurement of an anisotmpic 
surface typicatly costs a few rhousand dollars. (An anisotropic material reflects light differently at 
different angles of rotation, thus multiple @i dimc­tiorts must be sampled.) Because of the difficulty 
and expense of the BRDF measurements fhemselvcs, only the very richest research PM­grams can afford their 
own data. This data is essential, however, for the correct modeling of surface reflectance. 3.1. An Imaging 
Gonioretlectometer Tbe Lighting Systems Research Group at Lawrence Berkeley Laboratory has developed 
a relatively simple device for measuring BRDFs that uses imaging technology to obtain results more quickly 
and at a lower cost than conventional methods. This irnogirtg goniorejlecrometer has been developed over 
the past three years and represents an important advance towards the more practical characterization 
of BRDFs for lighting simu­lation and computer graphics. It is our hope that other laboratories and research 
institutiona will construct tfilr own versions of this apparatus and thereby make BRDF measurement a 
more common and economical practice. The basic arrangement of the LBL imaging gonioreflectometer is shown 
in 13gute 2t. Tire key optical elements are a half-silvered hemisphere or hemi-ellipsoid and a chargeasupled 
device (CCD) camera with a tisheye lens. Combined, these elements take care of the two degrees of freedom 
handled by a mechanically controlled photometer in a conven­tional gonioreflectometer. Light reflected 
off the sample surface in tA U.S.patentis pcndhg on Ihs imaging gonioWlecbmcter. If grsnred, k ps­ tem 
will restrict other parents on similar devices, but will nol otktwise limit rhe fms availstritity of 
the invention since it was dsvelopcd under Depsnrnem of Erer­ gy funding. ti A - r -- Al ­ c mm c -Y 
.wk Er L Mr.avucd @ 3piulhcrm$phm -J F~re 2. The LBL imaging goniordleztorneter. holder A is collected 
by the hetrtkpherical mirror and reflected back into the fisheye lens and onto the CCD array B. By frxusing 
the lens at one half the hemisphere radus, a near perfect imaging of the reflected angles takes place. 
(See ray diagram in Figure 3.) Because of tMs highly efficient collator arrangement, the light source 
does not have to be very bright to obtain a good measurement, and cart thus be optimized for col­limation 
to get the best possible angular resolution. In our devia, a 3­watt quartz-halogen lamp is used with 
so optically precise parabolic reflector to produce a well collimated beam. White light is preferable 
for photopic measurements, although art array of colored filters may be used to measure the spectral 
dependerw of the BRDF. The herniiphere is half-silvered to allow the light beam to illuminate the sample, 
and so exterior bafffe shields the camera from stray tilation. Tbii unique ~gement of light sousw ~d 
optics allows rctmretlcction (fight reflected back towards the light source) and transmission to be measured 
as well. The incident ei and $i angles are controlled mechanically by pivoting the light source arm at 
point C and the sample holder at point A, respec­tively. In our current prototype, the light source is 
moved by a computer-contmlled motor during &#38;ts collection, and the sample is rotated manually. Because 
the hemisphere of reflected directions is cap­tured in a single image, data collection proceeds quite 
rapidfy and a comptete BRDF can be recorded in a few minutes, including time for manual rotation of the 
sample. 3.2. Calibration and Data Reduetion All measurements are made relative to a standard diffuse 
sample and a background measurement. The background measurement is made with the source on but without 
any sample in fhe holder (using she dark rtmm behind to simulate a black body), and is subtracted from 
the other meas­urements to reduce the effects of stray and ambient light. The standard sample measurement 
is used as a basis for obtaining absolute reflectatwe vahtes using she following simple equation at each 
image poirw where P.-is the total diffuse =fiectmce of the standard sample The ability to measure absolute 
BRDF values directly is an important feature of the imaging gorrioreflectometer. Most other devices rely 
on auxiliary measurements of directional reflectance (ie. total reflectance for  SIGGRAPH 92 Chicago, 
July 26-31, 1992 from surface microstructure [Kajiya85]. However, his approach is not amenable to fitting 
measured reflectance data because the Pararntir space is too large (ie. all possible surface microstnrcturcs) 
and the BRDFs take too long to compute. Poulin and Feurrtiir devcfoped a model based on cylintilcal seratchcs 
that is better suited D%din90]. but their mcdel is reatrictcd to a apeci6c microstructure with cress-sectional 
uniformity, and its evaluation is still somewhat expensive. Our goal is to fit our measured reflectance 
data with fhe simplest empiri­cal fonrtufa that wifl do the job. If we cats develop a model with physi­cally 
meaningful parameters without adding undue complexity, so much the better. 4.1. The Isotropic Gaussian 
Model The Gaussian disaibution has shown up repeatedly in theoretical formul­ations of rcflectarsee [Beckmann63][Torrancc67][Cook82], 
and it arises fmm certain minimal assumptions about the statistics of a surface height function. h is 
usually prceeded by a Frcsnel coefficient and geometrical attenuation factors, and often by an arbitrary 
constant Since the geometric attenuation factors are typical]y difficult to integrate and tend to counteract 
the Fresnel factor anyway, we have replaced all of these coefficients with a single normalization facmr 
that simply insures the distribution will integrate easily and predictably over tie hemisphere. WA. (a 
Jvi$L.fh)=: + .exp[ tan2&#38; a2] p,. 1 (4) +05ei COSer 4rza2 where: pd is the diffuse reflmarsce p, 
is the specular reflectance 6 is the angle bciween veetors ri and ~ shown in Figure 5 a is the standard 
deviation (RMS) of the surface slope notes The p values may have some spectral dependence, and this depen­dence 
may vary as a function of angle so long as pd + p, (the to­tal reflectance) is less than 1. Thus, Fresnel 
effcets may be modeled if desired. 1 The normalization factor, is accurate as long as a is not 4rra2 
much greater than 0.2, when the surface becomes mostly diffuse. The main difference between this isotropic 
Gaussian reflectance model and that of Phong is its physical validity. For example, most Phong implementations 
do not have the necessary bldire-dortal characteristics to constitute a valid BRDF model. It is clear 
by inspection that the above formula is symmetric with respect to its incident and reflected angles. 
Without this symmetry, a BRDF model cannot possibly be phy­sical because the simulated surface reflects 
light differently in one direc­tion than the other, which is forbidden by natural law. Also, without 
proper normalization, a reflectance model drxs not yield eorr-cctenergy balance and thus eamror produce 
physically meaningful results. Even Figure 5. Angles and vectors used in-rctleztion equations. The incident 
light arriv~s along vector d; and is measured or simulat~d in direction d,. The polar angle between the 
half vector ~ and the surface normal ti is &#38; Tlse azimuthal an­gle of h fmm the direction f is @ 
the model inimduced recentty by He et al [Hc91] with its rigorous phy­sical derivation dces not seem 
co pay close enough attention to normali­zation. Specifically, the so-eallcd ambient tcmr in the He-Torrance 
model is added without regard to the overall reflectance of the material, which by nature of the model 
is very difticult to compute. Comparisons were not made in He s papa between the rcflcccarrcemedel and 
abso­lute BRDF measurements (the data was scaled to match the function), thus normalization was not even 
dcmcststmtedempirically. The fact that normalization was not dequatcly treated in He s othcnvise impeccable 
derivation shows just how much normalization is overlooked and rmder­vahred in reflectance modeling. 
The simplicity of the model preacartcd here is what alfows us to incorporate buift-irr normahation and 
has other desirable features as well, such as permitting quick evacuation for data reduction and Monte 
Carlo sampling. 4.2. The Anisotropic (Elliptical) Gaussian Model It is relatively simple to extend the 
Gaussian reflectance model to sur­faces with two perpendicular (uneorrclared) slope distributions, Q 
sad ~. The normalized distribution is as foIlowx Pd PhI@i,$i;er A ) = ~ + exp[-taazb (cos2@/a~+ sin2~r@] 
p,. 1 (5a)dcosei case, 4rraXc+ where: pd is the diffuse reflectance p, is the specular rctlcctance at 
is the standard deviation of the surface slope in the .f direetion c+ is the standard deviation of the 
surface slope in the ~ direction 5 is the mgle between the half vector, ~ and the surface normal. r?. 
@is the azimuth angle of the half vector pmjcctcd into the surface plane. A computationally convenient 
approximation for p~ is: Pd Pfd(ej ,Oi;er.Or)= ~ + 22 ii +~ a= q [[1[1] . (5b) 4+ 4nrL p 2 1 +ivf 
where: sine, cos$r + Sine(cos$~ i ..? = Ilii 11 sine, sin$r + Sine/sim$, k.y = Ilii 11 Coser + Cose, 
 iv? = Ilk 11 IA IIll I = 2 + 2sinersinOi(CO*,COS@i+ Sin$rsi@l) + 2COS8,cOS8i [ 1 For vector calculations, 
the following substitutions are used: ;=d, +ii L&#38; IIhll Coser = d,+ Cosei = (ii.ri where: J, is 
the reflected ray direction (away from surface) ~i is the incident ray direction (away from surface) 
i is a unit veetor in the surface plane ~ is a unit vector in the surface plane perpendicular to f ComrxAer 
Gratrhics, 26, 2, Julv 1992 . Incident (theta, phi) =. (0,0) Incident (theta, phi) = (60,0) 7 - , 6 
6 ,. 5 4 5 4 ,. 3 1 2 2 1 1 0 -80 -60 -40 Theta -20 0 20 (degrees) 40 60 80 c -00 -6o -49 Theta -20 0 
20 (degrees) 4C 60 e> -BC -66 -CC Theta -20 3 20 (degrees) 45 GO 80 Incident (theta, phi) = (0,90) Incident 
(theta, phi) = (30,90) Incident (theta, phi) -(60,90) L n II m -80-60-43-20 c 2C <0 6C BD -80-60-40-2D 
C 20 ,0 60 80 -no-60-40-20 0 10 40 60 80 Theta (degrees) Theta (degrees) Theta (degrees) Figure 6. Measured 
data and elliptical Gaussian fit for unfinishedaluminum. Unfinished aluminum exhibits anisotropy from 
rolling during its manufacture. As in the isotropic case, the normalization of the above anisotropic 
Our simple four parameter model fits well the data we have gathered model is such that the total surface 
reflectance will equal the dMuse from anisotropic surfaces such as varnished wood and unfinished (rolled) 
reflectance coefficient, pd, plus the rough specular or dkctiotral-or brushed metals. Bccatssc of its 
simplicity, it is easy to apply a last dit%se coefficient, p,. The two other model parameters, ax and 
c$, squares error minimization trrcthod to fit a set of pammctcrs to measured represent the standard 
deviation of the surface S1OPCin each of two per-data automatically. Aumtrratic &#38;ta fitting is essential 
to the ccmorrric pendicular directions. Thus, all four of the model s parameters have modeling of surface 
rcflcctarrcefor any significant database of trtarcrials. physical meaning and can &#38; set indepcrrdentlyof 
rttcaautd data to pro-Figure 6 shows art example fit to the BRDF of an unfinished aluminum duce a valid 
rcflcctrutce function. As long as the total reflectance, sample. Although USCfull hcrrsisphcrcof reflected 
data was tncsutu-d ss pd + p,, is less than I and the two a s are not too large, Equation 5 will 21 incident 
angles, it is difficult to visualize the 21 corrcsporrdiig 3­yield a physically valid t-cflectasrcefunction. 
dimcnsiorral ooint rrlots. We therefore mesent here otdv a slice of the data in the i~iden~ plane at 
6 angtes. 1% results m:on (6) lists the The elliptical nature of our model arises from the two perpendicular 
fitted parartretem for this materiat as well as some other example sur­slop distributions, and is apparent 
in the cxpotrcnt of Equation 5a. A faces. similar elliptical reflectance model was develo@ by Ohira 
and described by Yokoi and Toriwaki [Yokoi88], but this model was derived from that of Phong and likewise 
lacks physical meaning. By starting with a valid, normalised function, it is much easier to fit the model 
pasarrretersto physicaJmeasurements as well as orher specifications such as appearance. Computer Graphics, 
26, 2, July 1992 Figure Sa, Sb, SC. Varnished wood comparison. 8a on the left shows a photograph of 
a child s chair. 8b center shows a simulation of the chair using the isotropic Gaussian model given in 
Section 4.1 with a strictly deterministic calculation. (This is similar to the appearance one might obtain 
using a normalized Phong reflectance model.) 8c on the right shows a hybrid deterministic and sto-chastic 
simulation of the chair using the al Gaussian model from Section 4.2. Figure 9. A table scene with amsotropic 
reflectton in metallic and vamtshed wood surfaces. SIGGRAPH 92 Chicago, July 26-31, 1992 The folJowing 
tsbfe gives a short list of msrkes and their eUipficat Gausaian fits. Cofoewas nat measured for anyoftheaur&#38;ea. 
The mataiaf sintheseamdh alfofthetsble arekohofsi c.sothetwoa vafuea are the .samQ turdEquation (4) am 
be used. Mataial rotted brass mued aluminum .1 .21 .04 .09 lightJy brushed shttttinum .15 .19 .088 .13 
varnished plywood .33 .025 .04 .11 enamel tisrished metaJ .25 .047 .080 .096 b nted cardboard box white 
ceramic tie glossy gst?ypaper ivmy computes plastic pJastic laminate .19 .70 .29 .45 .67 .043 .050 .083 
.043 .070 .076 .071 .082 .13 .092 .085 .071 .082 .13 .092 We have aks measured the reflectance functions 
of various trairstedsrsr­ faces. We found the flat Latex paint w tested to be %ry nearfy diffuse, at 
least for incii angles up to 6W. l%ereforq we prcaent only the restdts from our mcasumanems of scsni-gltxs 
and gloss Latex. Otm pi was atwsstd 0.45 ftw both the semi-gloss and the gloss paints. Tlsevrsbrefw p, 
of h sesni-glossIatex was around 0.048 for SU surfaces, and the gloss Latex had a slightly higher am-age 
of 0.059. Although pi changes dramatically with the color of painL the vafue for P. rcmaina fhirlycatatant 
sisrceit is determined bytlseindex ofrefrac­tionofthe pairrt base. lltevattre sfew~an d~areafs ormsffectedby 
paint color, but since they @tend on Useexact microstructure of the painted surface, they vaty with tfw 
apptiion medrod and the rmdesly­ing matea@ as shows in the fottowing two tables. (%,%) for Latex Senli-Gloss, 
p,=o.048 Itcd SP Yed metal I (.037,.064) (.0% .068) (.04: .055) I sheetsock I (.078. .12) (.083. .12) 
(.096. .11) I wood I @97j .24j ~.12$:2q i.ti .26j I (c%,%) for Latex Gloss, P. =0.059 d Ued SP Yed metsf 
I (.037. .063) [.0:. .080) (.03: .054) shhsk (.10, :10) -(.12, :12) . {.10, :10) ­ (.13, .22) (.13, .20) 
(.12, .17) 7. Conclusion We have preaestti an economical new device for measuring BRDFs, and a simple 
reflec~ mcscklthat fits a large class of matesials. The imaging gonioretlectometer presented here is 
a waking prototype, but improvesnenta are newasmy for fhem eammsttemt of grstsing angles and smoothes 
matesials. L*wise, the eflipficalGaussianmodetpresentedis fast and xscurate for rttasty surbxs, but there 
are stiU many materials that do not fit our timcdon. Its conclusion, sdffrougbtJre inidat efforts am 
promising, w hope that this work wifl stimtdate fusltser investigation of empirical absding models. Aftcs 
aU, good science requites both theory and data --one is of littJe use without the other. 8. Ackrtowiedgements 
This work was supporkd its past by a grant from Apple Computer Cor­ prstion, and by the Assktant Seemtary 
for Conasmafion sad Renewable Energy, Office of BuifdisrgTechnologies, Buihiings Equipment Division of 
the U.S. Departmtmt of Energy under Contmct No. DE-AC03­76SFWI098. Ken Turkowski of Apple s Advanced 
Techswlogy Divisiest was joindy responsible foe qesvisicm of thii psojecL Fratxis Rub-Rudy Vesderber 
and Ssm Berman -h gave invsduable mppOrL and Robert Cleas had a direct band in overseeing tbe calibration 
and validation of the camera and rdktaneler e@pmestL Tlt@s also to Stephen Spencer and Kevin Simonof 
Ohio StateUrtivasity for discovwinga problem witJtour origimd retlectastceformula, Anat Grynbcsg participated 
in tk irdtiaf kigss ad consmction of rJSC imaging goniore.tlectometes,and Lisa Stewart made numesous 
equipment moditicafions duringthe dlbration stsge and took most of the BRDF measrsresnentsused its this 
pnpex. Carol Sieges did tJre tole painting on the red and simtdated vessions of the child s Ctti3iS. 
9. References [Beckmsnn63] Beckmsnn. Perr, Andre Spiszichino, The Scarrcring of EIectrornag­netic Waves 
from Rough Sssgfaces, Pergamon Press, NY, 1%3. [Blinn77] Blinn, hares F., Models of Light Reflection 
for Computer Syn­thesized Pictures, Computer Graphics, Vol. t 1, No. 2, July 1977. [Cabrs187] Cabrsl, 
Brian, Nelson Max, Rebecca Springmeyer, Bidirectional Reflection from Surface Bump Maps, Computer Graphics, 
Vol. 21, No. 4, July 1987. [Cook82] Cook. Robert L.. Kenneth E. Torrance, A Reflectance Model for Computer 
Graphics, Compurer Graphics, Vol. 15. No. 3, August 1981. [Cook84] Cook. Rob-retL., Thomas Porter, Loren 
Carpenter, Distributed Ray Tracing, Computer Graphics, Vol. 18, No. 3, July t984. [Cmk86] Cook, Rokctt 
L., Strxhastic %rrrpiing in Computer Graphics, ACM Transocfions on Graphics, VOL 5, No. 1, January 1986. 
[He91] He. X., K.E. Torrance, F.X. Sillion, D.P. Greenberg, A Comprehensive Physical Modet for Light 
Reflection, Computer Graphics, Vol. 25, No. 4. July 1991. [Kajiya85] Kajiya, James T., Anisotropic Reflection 
Models, Compurer Graphics, Vol. 19, No. 3, July 1985. [Kajiya86] Kajiya, James T.. The Rendering Equation, 
Computer Graph­ics, Vol. 20, No, 4, August 1986. [Murray-Coleman90] Murrsy-Coleman, J.F., A.M. Smith, 
The Automshd Measure­ment of BRDFs and their Application to Luminaire Modeling, Journal of the Illuminating 
Engineering Sociery, Winter IWO. [Nicodemus77] Nicodemua. F.E.. J.C. Richmond, J.J. Hsis. Geomerrica/ 
Con. siderarionsand Nomenclaturefor Reflectance, U.S. Department of Commerce, National Bureau of Standards, 
October 1977. [Phong75] Phong, B., Illuminationfor Computer Generated Pictures, Com­munications of the 
ACM, Vol. 18, No. 6, June 1975. [Poulin90] Poutin, Fleece, Alain Foumier, A Model for An isotropic Reflection, 
Computer Graphics, Vol. 24, No. 4, August 1990. [Ruberrstein81] Rubenstein, R.Y., Simulation and the 
Monte Carlo Method, J. Wtley, New York, 1981. [Ssndford85] %ndford, Brian P., David C. Robertson, MYared 
Reflectance Properties of Aircraft Paints, Proceedings IRIS Targets, Back­grounds, and Discrimination, 
1985. [SiUion91 ] SiUion, Fmtrcois, James Arvo, Donald Greenberg, A Global Illumination Solution for 
General Reflectance Distributions, Compmer Graphics, Vol. 25, No. 4, July 199t. [Ton-srr@57] Torrance. 
K.E., E.M. sparrow, Theory for Off-Specular Reflection from Roughened Surfaces, Journal of rhe Oprical 
Socie~ of America, Vol. 57, No. 9, September 1%7. [Whitted80] whirred, Turner, An Impmvd Ithsrninarion 
Model for Shaded Display. Communications of the ACM, Vol. 23, No. 6, June 1980, pp. 343-349. [Yokoi88] 
Yokoi, Shigcki, Jun-ichiro Toriwaki, Realistic Expression of Solids with Feeling of Materials, J,-U/ECT, 
VOI. ]8, 19ss.  
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134080</article_id>
		<sort_key>273</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>32</seq_no>
		<title><![CDATA[An importance-driven radiosity algorithm]]></title>
		<page_from>273</page_from>
		<page_to>282</page_to>
		<doi_number>10.1145/133994.134080</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134080</url>
		<keywords>
			<kw><![CDATA[adaptive meshing]]></kw>
			<kw><![CDATA[adjoint transport equation]]></kw>
			<kw><![CDATA[global illumination]]></kw>
			<kw><![CDATA[hierarchical radiosity]]></kw>
			<kw><![CDATA[importance functions]]></kw>
			<kw><![CDATA[view-dependence]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Radiosity</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Visible line/surface algorithms</descriptor>
				<type>S</type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010147.10010371.10010382</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Image manipulation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010372.10010377</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Rendering->Visibility</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010372.10010376</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Rendering->Reflectance modeling</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>PP31044609</person_id>
				<author_profile_id><![CDATA[81408593457]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Brian]]></first_name>
				<middle_name><![CDATA[E.]]></middle_name>
				<last_name><![CDATA[Smits]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Program of Computer Graphics, Cornell University, Ithaca, NY]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P131603</person_id>
				<author_profile_id><![CDATA[81100529394]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[James]]></first_name>
				<middle_name><![CDATA[R.]]></middle_name>
				<last_name><![CDATA[Arvo]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Program of Computer Graphics, Cornell University, Ithaca, NY]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P63622</person_id>
				<author_profile_id><![CDATA[81100188207]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>3</seq_no>
				<first_name><![CDATA[David]]></first_name>
				<middle_name><![CDATA[H.]]></middle_name>
				<last_name><![CDATA[Salesin]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Program of Computer Graphics, Cornell University, Ithaca, NY]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_obj_id>91416</ref_obj_id>
				<ref_obj_pid>91394</ref_obj_pid>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Airey, John M., John H. Rohlf, and Frederick P. Brooks Jr. Towards image realism with interactive update rates in complex virtual building environments. Computer Graphics (Special Issue on 1990 Symposium on Interactive 3D Graphics) 24(2): 41-50, 1990.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Arvo, James. Backward ray tracing. In the SIGGRAPH '86 "Developments in Ray Tracing" course notes, 1986.]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122724</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Baum, Daniel R., Stephen Mann, Kevin P. Smith, and james M. Winget. Making radiosity usable: automatic preprocessing and meshing techniques for the generation of accurate radiosity solutions. Computer Graphics 25(4): 51--60, 1991.]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_obj_id>97896</ref_obj_id>
				<ref_obj_pid>97880</ref_obj_pid>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[Campbell, III, A. T. and Donald Fussell. Adaptive mesh generation for global diffuse illumination. Computer Graphics 24(4): 155-64, 1990.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122737</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[Chen, Shenchang Eric, Holly E. Rushmeier, Gavin Miller, and Douglass Turner. A progressive multi-pass method for global illumination. Computer Graphics 25(4): 165-74, 1991.]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[Cohen, Michael E, Donald E Greenberg, David S. Immel, and Philip J. Brock. An efficient radiosity approach for realistic image synthesis. IEEE Computer Graphics and Applications 6(2): 26--35, 1986.]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378487</ref_obj_id>
				<ref_obj_pid>378456</ref_obj_pid>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Cohen, Michael E, Shenchang Eric Chen, John R. Wallace, and Donald P. Greenberg. A progressive refinement approach to fast radiosity image generation. Computer Graphics 22(4): 75-84, 1988.]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[Davison, B. Neutron Transport Theory. Oxford University Press, London, 1957.]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122723</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Dorsey, Julie O'B., Franqois X. Sillion, and Donald P. Greenberg. Design and simulation of opera lighting and projection effects. Computer Graphics 25(4): 41-50, 199 I.]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_obj_id>808601</ref_obj_id>
				<ref_obj_pid>964965</ref_obj_pid>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[Goral, Cindy M., Kenneth E. Torrance, Donald P. Greenberg, and Bennett Battaile. Modeling the interaction of light between diffuse surfaces. Computer Graphics 18(3): 213-22, 1984.]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
			<ref>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[Haines, Eric. Ronchamp: a case study for radiosity. In the SIG- GRAPH '91 "Frontiers in Rendering" course notes, ~3:1-28, 1991.]]></ref_text>
				<ref_id>11</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122740</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[Hanrahan, Pat, David Salzman, and Larry Aupperle. A rapid hierarchical radiosity algorithm. Computer Graphics 25(4): 197-206, 199 I.]]></ref_text>
				<ref_id>12</ref_id>
			</ref>
			<ref>
				<ref_obj_id>97895</ref_obj_id>
				<ref_obj_pid>97880</ref_obj_pid>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[Heckbert, Paul S. Adaptive radiosity textures for bidirectional ray tracing. Computer Graphics 24(4): 145-54, 1990.]]></ref_text>
				<ref_id>13</ref_id>
			</ref>
			<ref>
				<ref_obj_id>15902</ref_obj_id>
				<ref_obj_pid>15886</ref_obj_pid>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[Kajiya, J. T. The rendering equation. Computer Graphics 20(4): 143-50, 1986.]]></ref_text>
				<ref_id>14</ref_id>
			</ref>
			<ref>
				<ref_obj_id>7050</ref_obj_id>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[Kalos, M. H., and Paula A. Whitlock. Monte Carlo Methods, Volume I: Basics. J. Wiley, New York, 1986.]]></ref_text>
				<ref_id>15</ref_id>
			</ref>
			<ref>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[Lewins, Jeffery. Importance, The Adjoint Function: The Physical Basis of Variational and Perturbation Theory in Transport and Diffusion Problems, Pergamon Press, New York, 1965.]]></ref_text>
				<ref_id>16</ref_id>
			</ref>
			<ref>
				<ref_obj_id>74368</ref_obj_id>
				<ref_obj_pid>74334</ref_obj_pid>
				<ref_seq_no>17</ref_seq_no>
				<ref_text><![CDATA[Sillion, Francois and Claude Puech. A general two-pass method integrating specular and diffuse reflection. Computer Graphics 23(4): 335-44, 1989.]]></ref_text>
				<ref_id>17</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122739</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>18</ref_seq_no>
				<ref_text><![CDATA[Sillion, Francois X., James R. Arvo, Stephen H. Westin, and Donald E Greenberg. A global illumination solution for general reflectance distributions. Computer Graphics 25(4): 187- 96, 1991.]]></ref_text>
				<ref_id>18</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122725</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>19</ref_seq_no>
				<ref_text><![CDATA[Teller, Seth J. and Carlo H. S6quin. Visibility preprocessing for interactive walkthroughs. Computer Graphics 25(4): 61- 9, 1991.]]></ref_text>
				<ref_id>19</ref_id>
			</ref>
			<ref>
				<ref_obj_id>37438</ref_obj_id>
				<ref_obj_pid>37402</ref_obj_pid>
				<ref_seq_no>20</ref_seq_no>
				<ref_text><![CDATA[Wallace, John R., Michael E Cohen, and Donald P. Greenberg. A two-pass solution to the rendering equation: a synthesis of ray tracing and radiosity methods. Computer Graphics 21(4): 311-20, 1987.]]></ref_text>
				<ref_id>20</ref_id>
			</ref>
			<ref>
				<ref_obj_id>74366</ref_obj_id>
				<ref_obj_pid>74334</ref_obj_pid>
				<ref_seq_no>21</ref_seq_no>
				<ref_text><![CDATA[Wallace, John R., Kells A. Elmquist, Eric A. Haines. A ray tracing algorithm for progressive radiosity. Computer Graphics 23(3): 315-24, 1989.]]></ref_text>
				<ref_id>21</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378490</ref_obj_id>
				<ref_obj_pid>378456</ref_obj_pid>
				<ref_seq_no>22</ref_seq_no>
				<ref_text><![CDATA[Ward, Gregory J., Francis M. Rubenstein, and Robert D. Clear. A ray-tracing solution for diffuse interreflection. Computer Graphics 22(4): 85-92, 1988.]]></ref_text>
				<ref_id>22</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 Computer Graphics, 26, 2, July 1992 * An Importance-Driven Radiosity Algorithm Brian E. Smits James 
R. Ar\w Da~ id H. Sulesin Program of Computer Graphics Cornell University Ithaca, NY 14853 Abstract 
 We present a new radiosi[y algorithm for efficiently computing global solutions with respect to a constrained 
set of views. Radiosi ­ties of directly visible surfaces are computed to high accuracy, while those ot 
surfaces having only an indirect effect are computed to an accuracy commensurate with their contribution. 
The algorithm uses an adaptive subdivision scheme that is guided by the interplay between two closely 
related transport processes: one propagating power from the light sources, and the other propagating 
imporrarwc from the visible surfaces. By simultaneously refining approximate solutions to the dud transport 
equations, computation is signifi­cantly reduced in areas that contribute little to the region of inter­est. 
This approach is very effective for complex environments in which only a small fraction is visible at 
any time. Our statistics show dramatic speedups over the fastest previous radiosity algorithms for diffuse 
environments with details at a wide range of scales. CR Categories and Subject Descriptors: 1.3.7 [Computer 
Graph­ics ]: Three-Dimensional Graphics and Realism. Additional Key Words: importance functions. adaptive 
meshing, hierarchical rddiosity. adjoint transport equation, global illumina­tion, view-dependence. 
Introduction View-independent gtobal mdiosity algorithms have two major draw­backs: they oversolve globally 
and undersolve locally. The algo­rithms oversolve globally in that they attempt to compute radios i­ties 
to a uniform precision throughout the environment-even on surfaces hidden from all useful points of view. 
They undersolve lo­cally in that a single global radiosity solution is seldom adequate under close inspection 
local effects such as shadowing and color bleeding among small objects are often lost when the radiosity 
of the entire environment has to be computed to a uniform precision. Thus, the utiiity of i purely view-independent 
solution diminishes as the environment complexity or the required accuracy increases. To address this 
problem, several adaptive meshing schemes have been devised m increase the level of approximation where 
signifi- Permlssmn to copy without fee all or part of this material is granted provided that the copws 
we not made or chstrtbutcdfor direct commercd advmtugc, the ACM copyright notice and the title of the 
publicatmn and its date appear. and notice IS glvcn that copying is by permwsiorrof the Awocimmn for 
Computing Machinery To copy othcrwt~e. or (u rcpuhliih, requirei a fee and/{)r specific permission. cant 
intensity gradients occur [3. 4. 6]. These algorithms can achieve good results with fewer surface elements. 
For complex environ­ments, however, the cost of creating a fine mesh to capture every illumination detail, 
whether visible or not, may still be far too high. [n practice, radiosity implementations often rely 
on some form of additional intervention by the user in order to handle complex scenes. For example. in 
order to keep the total number of sutiacc elements small, the user may need to supply meshing hint~ based 
on the anticipated set of views. This approach has the advantage ot saving work in areas that are unimportant 
to the final image. How­ever, it also tends to sacrilice global accuracy, as there is no obvious way 
for the user to predict the level of meshing required for distant objects to have their proper effects 
on the visible parts of the scene. The converse of this problem arises during the solution proces~: which 
of the vast number of intemctions in a complex environment are significant enough to evaluate ? Consider, 
for example. comput­ing d radiosity solution for u Iargc building. In principle, light leav­ing a small 
surface on one tloor could reach any other floor by some circuitous path of stairwells and corridors. 
A rddiosity algorithm that accurately computed all such inteructiorts would be highly imprac­tical. Hanrahan, 
Salzman, and Auppcrle [ 12I have recently proposed a brightness-weighted hierarchical radiosity algorithm 
that goes a long way toward resolving this difficulty. The hierarchical algorithm focuses effort on the 
significant energy transfers. quickly approx­imating the insignificant interactions. However, because 
the algo­rithm is still view-independent. it dots more work than necessary in complex environments when 
only a single view or set of views is required. Indeed. it is not difticult [o construct models for which 
even this rapid algorithm is impractically slow. One way to make radiosity practical for complex environments 
is to incorporate a notion of view-dependence. For insumce, we might first use some form of visibility 
preprocessing to determine the sur­faces that arc directly visible [1. 191. To compute the radimities 
of these surfaces, all surfaces contributing energy must be (aken into account. But these contributing 
surface>, in turn, receive en­ergy from sutlaces that arc still further away. However, in general the 
effect of distant interactions v.ill be less important [o the visible scene. In short, to make effective 
use of view-dependence it is nec­essary to consider u// potential interactions among surfidces. but to 
compute each interaction only to an appropriate level of ticcuracy. In this paper, we describe such an 
algorithm: an extension to hier­archical radiosity that relines the interactions contributing the most 
 AcM-t)-x9791-479 -l/92/of)7/0273 $01.so     *j . * E&#38;. Important C Bright~ <­ i .­ 4 E&#38; 
Important Figure 5: Transporting radiosit y and importance in a hierarchy. the quantity ~TAL~ as a close 
approximation to the actual error wTALi. To incorporate this insight into a hierarchical radiosity algorithm 
we begin by considering the interaction between two patches i and j. [n general, computation of the energy 
transfer between any two patches will be approximate, due to the approximations inherent in the dis­crete 
operator L. Let 6,, denote the product [~, AL,j~l 1.The quarr­tity 6,, approximates the error contributed 
by the interaction of patch i and j to the view-dependent function v. By reducing C50over all pairs (i, 
j), we can make the magnitude of the overall error ~TAL~ arbitrarily small. We reduce the error in an 
interaction by subdividing one of the two patches involved and computing new interactions for the refined 
system. The net effect of this refinement is that transfers of radios­ity from bright patches and transfers 
of importance from important patches will generally be treated with greater accuracy at a lower level 
in the hierarchy. Figure 5 illustrates this idea for two patches i andj with high im­portance and high 
radiosity, respectively. The diagram on the top shows a single link from patch i to patch j. The link 
carries radios­ity from i to j, in the direction of the arrow, and importance from j to i, against the 
arrow. Since the effect of these interactions on the error is not great, they take place at a high level 
in the hierarchy. On the other hand, the diagram on the bottom shows the transfer of radiosity from j 
to i and of importance from i to j. These transfers, which have greater potential effect on the error, 
take place at a more refined level of the hierarchy. [n this way the algorithm can put the most work 
into retining the parts of the transport process where the impact of error is greatest. Because of the 
duality of radiosity and importance, the same error criterion I~iALi/~j \ used to refine radiosity can 
be used to refine the importance solution as well. Moreover, since estimates of im­portance are used 
to drive the radiosity solution and vice versa, we need to refine both solutions to the same level of 
accuracy. There­fore, the hierarchical system used for radiosity is also appropriately refined for importance, 
so a single hierarchical system suffices for both. 2.3 Radiosity and importance transport While managing 
radiosity in a hierarchical system is well­understood [6, 12], importance is new and subtly different. 
For com­pleteness, we discuss the equations governing both importance and radiosity here. Until now, 
we have described the linear operator L only as a general matrix. For the radiosity transport equation, 
the operator L can be expressed as follows: L= . (7) L -pnFni pnF.2 . . . 1 pnFn. where p, is the 
rejlectanr-e of patch i, and F,j is the form factor from patch i to patch j [10]. The form factor F,, 
expresses the fraction of power leaving patch that arrives at patch j. The form factor between two unoccluded 
dif­ferential patches di and dj is given by COS@jCOS@ Fdi.dj = =rl JdA1, (8) where 0, and 0, relate 
the normal vectors of di and dj to the vector joining the two patches, r is the distance between the 
patches, and dA, is the differential area of dj. The form factor from a differential patch di to a finite-area 
patch j is given by (9) where A, is the area of patch j. The form factor between two tinite­area patches 
i and j is the average of this quantity over all of patch i: This double integral can be approximated 
by the single-integral for­mulation (9), assuming the two patches are well-separated [ 10]. It is easy 
to check from equation ( 10) that the following reciprocity relationship holds between the form factors 
Fti and F,,: A, F,, = AIF1,. (11) We can rewrite equations (1) and (2) in terms of the radiosity and 
importance arriving at a single patch i from every other patch j to give the familiar radiosity formulation, 
along with an analogous for­mulation for importance: @; = S, + p, ~ @,F,,, (12) Computer Graphics, 26,2, 
July 1992 Q, = R, + ~ p, W,F,,. (13) Since L i~ used for radiosity and L ]is used for importance, the 
two equations differ only in the indices of the reflectance [~and the form Factor F-. We now examine 
how radiosity and importance can be distributed up and down a hierarchical system. Let i be a child patch, 
and / its parent in the ptstch hierdrchy. We will assume that reflectance, m well as emittance of radiosity 
and importance, is constant over every patch. When the patches are well-separated, equations (9) and 
(11 ) imply the following form-factor relationships: F,, x F/,, (14) A, F,, z F,,(15) AI Substituting 
these equations into ( 12) and ( 13) allows us to express the radiosity and importance of a child patch 
in terms of those of its parent, as follows: (17) Thus. mdiosity does not change when pushed down from 
a parent to its children. while importance is distributed according to the pro­portional area of each 
child. We also need to be able 10solve for the radiosity and importance of a parent patch from those 
of its children. To derive these relationships, tirst note that equations (If))and (1I)allow us to express 
the form f;ictors for :i parent patch in terms of those of its children: I F/, = F,,A,, (18) zE {cl (19) 
=D ,El Substituting these equations into ( 12) and ( 13) gives: (20) Thus, radiosities must be averaged 
according to area when pulled up the hierarchy, whereas importances are simply summed.  Algorithm 
The view-dependent radiosity algorithm we describe here is very similar to the brightness-weighted hierarchical 
algorithm proposed by Hanrahan, et uI., with the crucial difference that in the view­dependent algorithm. 
importance as well as radiosity plays a role in refining interactions. The algorithm iteratively computes 
an accurate rddiosity solution for visible patches by refining the interactions between any two patches 
i and j whose estimated error ~~,~,,~, I exceeds a given tolerdnce f. 3.1 Overview The algorithm takes 
as input the initial emittance of radiosity S and importance R for each patch, along with an initial 
set of interac­tions Z among the patches. The set Z contains a link between every pair of patches that 
are not completely occluded from one another. Each link carries radiosity in one direction and importance 
in the other. The set Z can be computed once for each model and stored along with it, The algorithm refines 
the initial set of interactions Z by transform­ing this single-level network into a hierarchy of interactions. 
At each iteration of the outermost loop, the algorithm solves for both radios­ity and importance using 
the current set 1. These solutions, in turn, are used to guide a refinement step, which improves the 
accuracy of the radiosities and importances with respect to a particular view, by adding more links to 
Z. The iteration continues until a preset error tolerance F, is met. The basic algorithm can be described 
in pseudocode as follows: ImportanceDrivenRadiosity (S, R. 1) (6. ~)+(S. R) for [ decreasing from x to 
F, do SolveDualSy.stems( ~. ~, S, R. Z) for each interaction j-i of Z do Re/inelnteraction(j ~ i, 1. 
c) end for end for  The following sections describe the steps of this refinement process in more detail. 
 3.2 Solving for radiosity and importance For a given hierarchical system. ~ and ~ are found by iteratively 
solving two systems of linear equations, Each iteration involves gathering radiosity and shooting importance 
between every linked pair of patches. Radiosity and importance are then distributed up and down the hierarchy 
so that every patch receives the appropriate contributions from its ancestors and descendants. This process 
is re­peated until convergence that is, until the difference between the radiosities and importances 
from one iteration to the next becomes smaller than some tolermrce: SolveDualSvstems (~. ~. S. R. T) 
repeat GatherAndShoot(%, ~. Z) for each top-level patch p do SweepRadiosity(~. S. p. O) SweepImpoflance( 
~. R. p. O) end for until convergence of ~ and ~  Gathering radiosity and shooting importance is implemented 
as fol­lows: ?77 GatherAndShoot(~, ~, ~ -/ -/ (@, w) + (0,0) for each patchi do for each interaction 
j ~ i of T do G;+ 5;+ piFij61 i; i--i; + p,Fv%, end for end for (i, i) + (i , i ) For each interaction 
between two patches j-i, radiosity is gath­ered from j to i, and importance is shot from i to j. Because 
the importance matrix is the transpose of the radiosity matrix, the same matrix entry pi~ti appears in 
both these operations. Here F,, denotes an estimate of the actual form factor Fij. Once radiosity and 
importance have been transferred between linked patches, the two quantities are distributed up and down 
the hierarchy so that every patch receives the appropriate contributions from its parents and children: 
SweepRadiosity(~, S, i, @down) if i is a leaf then f$.~ -Si+ii +@down else Alp+ o for each child i of 
i do x +- SwmpRadiosity(@, S, i , @; + @down) ~up + ~up+x*Ai, /Ai end for end if ;i + $5.~ return @.P 
SweepImpotiance($, R, i, $down) if i is a leaf then ~.p -Ri +~1 + @do.. else @ p+ o for each child i 
of i do x t-(w,+~dwn)*A;# /Ai @.P -+.P + SweepImpo@nce(~, R, i , x) end for endif G, + ?JJUp  return 
@.P The two quantities are distributed in slightly different ways, as dis­cussed in Section 2.3. The 
radiosity @of a child patch i is the sum of its emitted radiosity S,, the radlosity it receives directly, 
and the radiosity of its parent ~d~ . The importance of a child patch i is the sum of its emitted importance 
Ri, the importance it receives directly, and an area-weighted fraction of the importance of its parent 
@down. When pulling radiosity and importance back up the hierarchy the situation is reversed. The radiosity 
of a parent patch is the area­weighted average of the radiosities of its children, whereas its im­portance 
is the sum of the importances of its children. 3.3 Refining the interactions We refine any interactions 
whose estimated error I~jPlFem6j I ex­ceeds the tolerance ~. For F,., we use an upper bound on the error 
in the form factor, computed by taking the difference between up­per and lower bounds H and F,; on the 
actual form factor F,j, ss described in the next section. If the error in the interaction exceeds the 
tolerance c, the interaction is refined by subdividing the patch p with greater area and creating new 
links directly from the children of p to the other patch: RefineInteraction(i -+ i. 1. c) Fem+~ F-!J 
if ~,p;Fe=~, > ~ then SubdivideAndRefine(p, j-i, ~) I -x u {new links created through subdivision} end 
if The procedure SubdivideAndRefine is essentially the same as the refinement routine described by Hanrahan, 
et al.With importance­driven refinement, however, the minimum patch-size criterion that guarantees termination 
is rarely necessary, since the importance of a patch always decreases with its area. 3.4 Estimating 
the form factors We estimate the form factor FiJ from patch i to patch j by takhg a number of samples 
across patch i and averaging the point-to-disk form factors [21 ] over all samples. Care is needed in 
estimating upper and lower bounds on F,,, since the assumptions required by point-to-disk form factors 
may not always hold. We choose samples on both patch i and j and compute double­differential form factors, 
using equation (8). We set the upper sod lower bounds fi and F; to A, max {F~i,~j} and Al min {F~i,dj}. 
re­spectively. These bounds are not necessarily strict if the samples are poorly chosen; however, they 
seem to work well in practice. Note that if any of the double-differential form factors encounters an 
occluding object, then the lower bound F,; is O, and the estimated form-factor error is set to the upper 
bound E. 3.5 Assigning initial importance The vector R determines the initial emitters of importance. 
Different choices of R allow us to use importance in different ways. ~pically, for a single, static view, 
we define an infinitesimal patch for the camera and make it the sole emitter of importance. In thk case, 
we also ensure that an initial link between the camera and the rest of the environment is set up only 
if it falls within the camera s viewing frustum. This choice of R has the same effect as assigning an 
initial importance to each patch according to its visible projected area. Computer Graphics, 26, 2, July 
1992 There is nothing, however, that limits us to a single, static view. For example, importance could 
be used to speed the radiosity solution for an animation or walk-through of an environment by making 
ev­ery patchthat is visible at any time an emitter of importance, Simi­larly, importance could be used 
when the scene is visible from more than a single viewpoint, such as in stereoscopic views or in stage 
design applications [9]. Finally, for some applications it may not be necessary for everything visible 
to be important. For example, perhaps we would like to study a particular object from all angles, such 
as a sculpture in a museum. If we are unconcerned about the environment itself except in how it contributes 
to the illumination of this object, we could make the object itself the sole emitter of importance. Note 
that in all cases, the overall magnitude of R is arbitrary. How­ever, the error tolerance F, must be 
scaled appropriately.  4 Reconstruction and display The algorithm described in this paper addresses 
only the global illu­mination problem i.e., how to determine the radiosities of visible surfaces to within 
a certain accuracy. However, producing an accurate global radiosity solution does not guarantee a high-quality 
picture. Indeed, the reconstruction and dis­play of a radiosity solution is a tricky problem for any 
algorithm that assumes constant radiosities over a patch [11], and a hierwchi ­cal algorithm is no exception. 
Annoying artifacts become apparent if each patch is displayed with a single constartt intensity, as the 
eye is extremely sensitive to such discontinuities. Artifacts due to poor reconstruction are in fact 
even more noticeable for hierarchical algorithms than for standard adaptive subdivision schemes. Since 
constant radiosities are distributed over patches of different sizes at many different levels of the 
hierarchy, the straight­forward approach of pushing constant radiosities down to the leaves and Gouraud-shading 
these smallest elements leaves the boundaries between higher-level patches readily apparent. In order 
to avoid these artifacts, we can take advantage of view­dependence by adding extra meshing to visible 
surfaces as part of the reconstruction process, once the importance-weighted global so­lution has been 
computed. In our implementation, we force subdivi­sion of all visible surfaces down to a fixed projected-area 
threshold, and push all interactions down to these leaves. Displaying these smaller patches with Gouraud 
shading produces results comparable to a standard Gouraud-shaded adaptive subdivi­sion solution. In order 
to eliminate Mach banding and z-buffer ar­tifacts, we use ray casting with a modified form of supersampling. 
For each ray surface intersection, we choose 16 Gaussian-jittered samples in the (u, \ )-coordinates 
of the intersected surface. Tire 16 radiosities from the patches at the bottom of the hierarchy are then 
averaged together to give the intensity of the pixel. 5 Results Figures 6 and 7 show a small maze sitting 
on a table, The images were computed using importance-driven refinement. Figure 6 is flat­shaded to show 
the meshing produced by the algorithm, while Fig­ure 7 is displayed using the reconstruction algorithm 
described in Section 4. Note the color bleeding from the red wall of the maze to the wall behind it. 
This effect is most pronounced on the top of the wall, as the bottom half of the wall is illuminated 
mostly by light reflected from the maze floor. The next pair, Figures 8 and 9, show the same computed 
solution, but displayed from further back. Figure 8 shows the radiosity of each patch, while Figure 9 
depicts the importance of each patch, divided by its area. In the latter image, the visible parts of 
the scene show up very clearly as white because all wavelengths of light emitted from these surfaces 
are equally important to the camera. The other surfaces in the room also have importance, but to a lesser 
degree. The color of each surface gives the fraction of light emitted at a particular wavelength that 
finds its way to the camera. Due to the red and blue walls, red light is more important on the left side 
of the floor and back wall, while blue light is more important on the right. Note how the algorithm has 
done less meshing in areas with little importance. Figures 10 and I I show the radiosity and importance 
of the same solution-displayed from even further back, showing the whole en­vironment. From this vantage 
point, the meshing done on the table is extremely fine. A view-independent algorithm would have great 
dif­ficulty solving the entire environment to such high precision. Note that no meshing at all has taken 
place in the r~m at the lower left, which contains a complex block sculpture, since the importance of 
the room and everything inside it is negligible. Note also that the wall illuminated by the bright light 
in the center does have some importance, and is therefore refined to a certain extent. The impor­tance 
of indirect interactions such as these would be very difficult for a user to anticipate in giving meshing 
hints to a conventional algorithm. Some quantitative measurements of our tests are summarized in Ta­ble 
1. All tests were run on an HP 720, a 55 MIPS machine with 64 megabytes of physical memory. Figures 12 
and 13 compare brightness-weighted refinement (B-only) to brightness-and-importance-weighted refinement 
(W). In running the test, we refined the B-on/y solution as much as possible before running out of physical 
memory. We then ran a B/ algorithm on the same environment until the solution appeared to be at a similar 
or slightly higher level of refinement. For this environment of moderate complexity (1002 initial polygons), 
the B-only solution was 45 times slower, requiring 16 times the total number of patches, and 22 times 
the total number of links. We expect that for environments of greater complexity, the speedups would 
be even more dramatic. We have also tried to compare timings for the more refined solution of Figure 
6 with a B-only solution of comparable accuracy. How­ever, the extraordinary memory requirements for 
a high-accuracy global solution makes this comparison difficult. We let the B-only solution run for about 
40 hours, at which point the virtual memory size was well over 100 megabytes. With 19 times the number 
of patches, 35 times the number of links, and 30 times the number of CPU-minutes as the B/ solution, 
the B-only algorithm still had not achieved a solution close to the same level of accuracy. As an additional 
test, the camera was moved inside the small maze on the table, in the same position with respect to the 
small maze as it was with respect to the large maze in Figure 13. The B/ solution was more accurate than 
B-only and took only 0.5Yc of the time to compute. Figure 6: A view-dependent radiosity solution. Figure 
8: The radiosity solution of Figure 6, seen from further back.  guarantee that this difference will 
always be small. Clustering. A major advantage of using a hierarchical approach is that it reduces the 
total number of interactions between patches from 0(n2) to O(n+rn), where n is the total number of patches 
after subdi­vision, and m is the number of initial, top-level patches. Still, when m is large, which 
is often the case for complex environments, the number of initial interactions maybe too large to be 
practical. In this case, we would like to group patches into higher-level clusters in or­der to reducetheinitial 
interactions.This problemwasmentionedby Hanrahan, cu al. in the description of their brightness-weighted 
hier­archical algorithm; however, resolving this problem becomes even more crucial in an importartce-driven 
algorithm, since the latter is better able to handle complex environments in every other respect. Acknowledgments 
We would like to thank Donald Greenberg for helpful discussions during the development of these ideas, 
and Eric Haines, John Wal­lace and Harold Zatz for reviewing the manuscript. Thanks to Suzanne Smits 
for creating the models, and to Susan Verba for sug­gesting a maze. This work was supported by the NSF 
grant, Inter­active Computer Graphics Input and Display Techniques (CCR­8617880), by the NSF/DARPA Science 
and Technology Center for Computer Graphics and Scientific Visualization (ASC-89202 19), and by generous 
donations of equipment from Hewlett-Packard. Brian Smits is supported by a National Science Foundation 
Gradu­ate Fellowship. References [1] Airey, John M., John H. Rohlf, and Frederick P. Brooks Jr. Towards 
image realism with interactive update rates in com­plex virtual building environments. Computer Graphics 
(Spe­cial Issue on 1990 Symposium on Interactive 3D Graphics) 24(2): 41-50, 1990. [2] Arvo, James. Backward 
ray tracing. In the SIGGRAPH 86 Developments in Ray Tracing course notes, 1986. [3] Baum, Daniel R., 
Stephen Mann, Kevin P. Smith, and James M. Wlnget. Making radiosity usable: automatic preprocessing and 
meshing techniques for the generation of accurate radios­ity solutions. Computer Graphics 25(4): 5140, 
1991. [4] Campbell, 111,A. T. and Donald Fussell. Adaptive mesh gen­eration for global diffuse illumination. 
Computer Graphics 24(4): 155-64, 1990. [5] Chen, Shenchang Eric, Holly E. Rushmeier, Gavin Miller, and 
Douglass Turner. A progressive multi-pass method for global illumination. Computer Graphics 25(4): 165-74, 
1991. [6] Cohen, Michael F., Donald P. Greenberg, David S. Immel, and Philip J. Brock. An efficient radiosity 
approach for realistic image synthesis, IEEE Computer Graphics and Applications 6(2): 26-35, 1986. [7] 
Cohen, Michael F., Shenchang Eric Chen, John R. Wallace, and Donald P. Greenberg. A progressive refinement 
approach to fast radiosity image generation. Computer Graphics 22(4): 75 84, 1988. [8] Davison, B. Neutron 
Transport Theory. Oxford University Press, London, 1957. [9] Dorsey, Julie O B., Fran~ois X. Sillion, 
and Donald P. Green­berg. Design and simula~ion of opera lighting and projection effects. Computer Graphics 
25(4): 4 1 50, 1991. [10] Goral, Cindy M., Kenneth E. Torrance, Donald P. Greenberg, and Bennett Battaile. 
Modeling the interaction of light be­tween diffuse surfaces. Computer Graphics 18(3): 21 3 22, 1984. 
[11] Haines, Enc. Ronchamp: a case study for radiosity. In the SIG-GRAPH 91 Frontiers in Rendering course 
notes, 33:1-28, 1991. [12] Hanrahan, Pat, David Salzman, and Lamy Aupperle. A rapid hierarchical radiosity 
algorithm. Compu/er Graphics 25(4): 197-206, 1991. [13] Heckbert, Paul S. Adaptive radiosity textures 
for bidirectional ray tracing. Computer Graphics 24(4): 145-54, 1990. [14] Kajiya, J. T. The rendering 
equation. Computer Graphics 20(4): 143-50,1986. [15] Kales, M. H., and Paula A. Whitlock. kfonfe Carlo 
~ethods, Volume [: Basics. J. Wiley, New York, 1986. [16] Lewins, Jeffery. importance, The Adjoint Function: 
The Phys­ical Basis of Variational and Perturbation Theory in Transport and Difiusion Problems, Pergamon 
Press, New York, 1965. [17] Sillion, Fran$ois and Claude Puech. A general two-pass method integrating 
specular and diffuse reflection. Computer Graphics 23(4): 33544, 1989. [18] Sillion, Fran$ois X., James 
R. ANO, StephenH. Westin, and Donald P.Greenberg.A global illumination solution for gen­eral reflectance 
distributions. Computer Graphic~ 25(4): 187 96, 1991. [ 19] Teller, Seth J. and Carlo H. S6quin. Vkibility 
preprocessing for interactive walkthroughs. Compufer Graphics 25(4): 61­9, 1991. [20] Wallace, John R., 
Michael F. Cohen, and Donald P. Greenberg. A two-pass solution to the rendering equation a synthesis 
of ray tracing and radiosity methods. Computer Graphics 2 I(4): 311-20, 1987. [21] Wallace, John R., 
Kens A. Elmquist, Eric A. Haines. A ray tracing algorithm for progressive radiosity. Computer Graph­ics 
23(3): 315-24, 1989. [22] Ward, Gregory J., Francis M. Rubertstein, and Robert D. Clear. A ray-tracing 
solution for diffuse interreflection. Computer Graphics 22(4): 85 92, 1988. 
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134082</article_id>
		<sort_key>283</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>33</seq_no>
		<title><![CDATA[Illumination from curved reflectors]]></title>
		<page_from>283</page_from>
		<page_to>291</page_to>
		<doi_number>10.1145/133994.134082</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134082</url>
		<keywords>
			<kw><![CDATA[automatic differentiation]]></kw>
			<kw><![CDATA[caustics]]></kw>
			<kw><![CDATA[differential geometry]]></kw>
			<kw><![CDATA[geometrical optics]]></kw>
			<kw><![CDATA[global illumination]]></kw>
			<kw><![CDATA[interval arithmetic]]></kw>
			<kw><![CDATA[ray tracing]]></kw>
			<kw><![CDATA[wavefronts]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Raytracing</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Geometric algorithms, languages, and systems</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Radiosity</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.3</cat_node>
				<descriptor></descriptor>
				<type></type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010372.10010376</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Rendering->Reflectance modeling</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010372</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Rendering</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003752.10010061</concept_id>
				<concept_desc>CCS->Theory of computation->Randomness, geometry and discrete structures</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010382</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Image manipulation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010372.10010374</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Rendering->Ray tracing</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>PP31038868</person_id>
				<author_profile_id><![CDATA[81100360165]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Don]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Mitchell]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[AT&T Bell Laboratories]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>PP15033698</person_id>
				<author_profile_id><![CDATA[81100482576]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[Pat]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Hanrahan]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Princeton University]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Appel, A. Some techniques for shading machine renderings of solids. AFIPS 1968 Spring Joint Computer Conf. 32 (1968), 37-45.]]></ref_text>
				<ref_id>Appel68</ref_id>
			</ref>
			<ref>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Arvo, J. Backward ray tracing. Developments in Ray Tracing SIGGRAPH Course Notes, 12 (1986).]]></ref_text>
				<ref_id>Arvo86</ref_id>
			</ref>
			<ref>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Berry, M. V., Upstill, C., Catastrophe Optics: Morphologies of Caustics and their Diffraction Patterns, Progress in Optics XVIII, (1980), 259- 346.]]></ref_text>
				<ref_id>Berry80</ref_id>
			</ref>
			<ref>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[Born, M. and Wolf, E., Principles of Optics. Pergamon, 1980.]]></ref_text>
				<ref_id>Born80</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122737</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[Chen, S. E., Rushmeier, H. E., Miller, G., Turner, D., A Progressive Multi-Pass Method for Global Illumination Computer Graphics 25, 4 (1991), 165-174.]]></ref_text>
				<ref_id>Chen91</ref_id>
			</ref>
			<ref>
				<ref_obj_id>806801</ref_obj_id>
				<ref_obj_pid>965161</ref_obj_pid>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[Dill, John C., An Application of Color Graphics to the Display of Surface Curvature Computer Graphics 15, 3 (1981), 153-161.]]></ref_text>
				<ref_id>Dill81</ref_id>
			</ref>
			<ref>
				<ref_obj_id>807453</ref_obj_id>
				<ref_obj_pid>965103</ref_obj_pid>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Forrest, A. R., On the Rendering of StLrfaces. Computer Graphics 13, 2 (1979), 253-259.]]></ref_text>
				<ref_id>Forrest79</ref_id>
			</ref>
			<ref>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[Gullstrand, A. Die reelle optische Abbildung. Sv. Vetensk. Handl. 41, (1906), 1-119.]]></ref_text>
				<ref_id>Gullstrand06</ref_id>
			</ref>
			<ref>
				<ref_obj_id>97895</ref_obj_id>
				<ref_obj_pid>97880</ref_obj_pid>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Heckbert, P. Adaptive Radiosity Textures for Bidrectional Ray Tracing. Computer Graphics, 24, 4 (August 1990), 145-154.]]></ref_text>
				<ref_id>Heckbert90</ref_id>
			</ref>
			<ref>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[Kneisly, J. A. III, Local curvature of wavefronts in an optical system. J. Opt. Soc. Amer. 54, (1964), 229-235.]]></ref_text>
				<ref_id>Kneisly64</ref_id>
			</ref>
			<ref>
				<ref_obj_id>93276</ref_obj_id>
				<ref_obj_pid>93267</ref_obj_pid>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[Mitchell, D. P. Robust ray intersection with interval arithmetic. Graphics Interface 90, (May 1990) 68-74.]]></ref_text>
				<ref_id>Mitchell90</ref_id>
			</ref>
			<ref>
				<ref_obj_id>1098639</ref_obj_id>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[Moore, R. E., Methods and applications of interval analysis. SIAM, 1979.]]></ref_text>
				<ref_id>Moore79</ref_id>
			</ref>
			<ref>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[Murdur, S. P., Koparkar, P. A., Interval methods for processing geometric objects. IEEE Computer Graphics and Applications, 4,2 (February 1984), 7-17.]]></ref_text>
				<ref_id>Murdur84</ref_id>
			</ref>
			<ref>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[Rail, Louis B., Automatic Differentiation: Techniques and Applications. Springer-Verlag, 1981.]]></ref_text>
				<ref_id>Rall81</ref_id>
			</ref>
			<ref>
				<ref_obj_id>37408</ref_obj_id>
				<ref_obj_pid>37402</ref_obj_pid>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[Shinya, M., Takahashi, T, Naito, S. Principles and applications of pencil tracing. Computer Graphics, 21, 4 (July 1987), 45-54.]]></ref_text>
				<ref_id>Shinya87</ref_id>
			</ref>
			<ref>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[Shinya, M., Saito, T., Takahashi, T. Rendering techniques for transparent objects. Proc. Graphics Interface "89, (1989) 173-182.]]></ref_text>
				<ref_id>Shinya89</ref_id>
			</ref>
			<ref>
				<ref_obj_id>93316</ref_obj_id>
				<ref_obj_pid>93267</ref_obj_pid>
				<ref_seq_no>17</ref_seq_no>
				<ref_text><![CDATA[Shirley, P. A ray tracing method for illumination calculation in diffuse-specular scenes. Proc. Graphics Interface '90, (1990) 205-212.]]></ref_text>
				<ref_id>Shirley90</ref_id>
			</ref>
			<ref>
				<ref_obj_id>74368</ref_obj_id>
				<ref_obj_pid>74334</ref_obj_pid>
				<ref_seq_no>18</ref_seq_no>
				<ref_text><![CDATA[Sillion, F., Puech, C., A General Two-Pass Method Integrating Specular and Diffuse Reflection. Computer Graphics 23, 3 (1989), 335-344.]]></ref_text>
				<ref_id>Sillion89</ref_id>
			</ref>
			<ref>
				<ref_seq_no>19</ref_seq_no>
				<ref_text><![CDATA[Sparrow, E. J., Eckert, E. R. G., Jonsson, V. K., An Enclosure Theory for Radiative Exchange Between Specularly and Diffusely Reflecting Surfaces. Journal of Heat Transfer 84C,4, (1962).]]></ref_text>
				<ref_id>Sparrow62</ref_id>
			</ref>
			<ref>
				<ref_seq_no>20</ref_seq_no>
				<ref_text><![CDATA[Stavroudis, O. N. The Optics of Rays, Wavefronts, and Caustics, Academic, 1972.]]></ref_text>
				<ref_id>Stavroudis72</ref_id>
			</ref>
			<ref>
				<ref_seq_no>21</ref_seq_no>
				<ref_text><![CDATA[Struik, Dirk J., Lectures on Classical Differential Geometry 2nd. Edition, Dover Publications, New York, 1961.]]></ref_text>
				<ref_id>Struik61</ref_id>
			</ref>
			<ref>
				<ref_obj_id>325233</ref_obj_id>
				<ref_obj_pid>325165</ref_obj_pid>
				<ref_seq_no>22</ref_seq_no>
				<ref_text><![CDATA[Toth, D. L. On ray tracing parametric surfaces. Computer Graphics, 19, 3 (July 1985), 171-179.]]></ref_text>
				<ref_id>Toth85</ref_id>
			</ref>
			<ref>
				<ref_obj_id>37438</ref_obj_id>
				<ref_obj_pid>37402</ref_obj_pid>
				<ref_seq_no>23</ref_seq_no>
				<ref_text><![CDATA[Wallace, J., Cohen, M. F., Greenberg, D. P., A Two-Pass Solution to the Rendering Equation: A Synthesis of Radiosity and Ray Tracing Methods. Computer Graphics 21, 4, (1987), 311-320.]]></ref_text>
				<ref_id>Wallace87</ref_id>
			</ref>
			<ref>
				<ref_obj_id>97920</ref_obj_id>
				<ref_obj_pid>97880</ref_obj_pid>
				<ref_seq_no>24</ref_seq_no>
				<ref_text><![CDATA[Watt, M. Light-water interaction using backward beam tracing. Computer Graphics, 24, 4 (August 1990) 377-385.]]></ref_text>
				<ref_id>Watt90</ref_id>
			</ref>
			<ref>
				<ref_obj_id>358882</ref_obj_id>
				<ref_obj_pid>358876</ref_obj_pid>
				<ref_seq_no>25</ref_seq_no>
				<ref_text><![CDATA[Whitted, T. An improved illumination model for shaded display. Comm. ACM, 23, 6 (June 1980), 343-349.]]></ref_text>
				<ref_id>Whitted80</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 Illumination from Curved Reflectors Don Mitchell ? Pat Hanrahan $ t AT&#38;T Bell Laboratories ~ t 
Princeton University Abstract A technique is presented to compute the refkted illumination from curved 
mirror surfaces onto other surfaces. In accordance with Fermat s principle, this is equivalent to fiiding 
extremal paths from the light source to the visible surface via the mirrors. Once pathways of illumination 
are found, h-radiance is computed from the Gaussian curvature of the geometrical wavefront. Tech­niques 
from optics, differential geometry and interval analysis are applied to this problem in global illumination. 
CR Categories and Subject Descriptions: 1.3.3 [ Computer Graphics ]: Picture/Image Generation; 1.3.7 
[ Computer Graphics ]: Three-Dimensional Graphics and Realism General Terms: Algorithms Additional Keywords 
and Phrases: Automatic Differentiation, Caustics, Differential Geometry, Geometrical Optics, Global Illu­mination, 
Interval Arithmetic, Ray Tracing, Wavefionts 1. Introduction Ray tracing provides a straightforward 
means for synthesizing realistic images on the computer. A scene is fwst modeled, usu­ally by a collection 
of implicit or parametric surfaces. For each point in an image, a visual ray is traced from the eye into 
the scene. The visible (i.e., closest) surface intersection is found by geometrical and numericsd methods, 
and the radiance at that visi­ble point is calculated according to some shading model. Whitted s shading 
model extends the notion of visibility by simu­lating refhxting and refracting surfaces [Whitted80]. 
A visual ray that encounters a reflective surface is bounced off and continues in the direction of reflection 
(see Figure 1). Eventually, it will encounter a non-reflecting surface, and the shading crdculation is 
performed, Permission to copy without fee all or part of this material is granted provided that the copies 
are not made or distributed for direct commercial advantage, the ACM copyright notice and the title of 
the publication and its date appear, and notice is given that copying is by permission of the Aswciation 
for Computing Machinery. To copy othenviw, or to republish, requires a fee and/or specific permission. 
Reflector s P Figure 1. Reflected Visual Rays This model simulates the effect of seeing the scene reflected 
in a mirror or refkted through glass, but it does not extend the notion of illumination. Once a visual 
ray arrives at a point p, the shading calculation is liited to the dirtxt component of illumination­just 
the effect of light traveling directly from the light ats. Shad­ing occurs in two steps, fmt the irradiance 
at p is computed, and next the reflected radianw in the direction of the visual ray is determined, baaed 
on the bidirectional reflectance of the surface. Reflector s .. Eye .. .. x . .,,Light Ray .. . . Visusd 
Ray D /. ,. . .. . P Figure 2. Reflected Illumination Figure 2 illustrates a much more difficult task; 
to illuminate a vis­ible point with reflected light. There are two problems involved. I?te first is fmdirtg 
the proper direction (or directions) irt which to cast light rays, so that they arrive at the visible 
point p. The sec­ond problem is to compute the proper irradiartce, given that the light may reflect off 
a csuved surface and rmverge or diverge. 283 01992 ACM-O-89791-479-1/92/007/0283 $01.50 SIGGRAPH 92 
Chicago, July 26-31, 1992 Two approaches have been used previously to simulate specularly reflected and 
refracted illumination. If the reflectors and refrac­tors are polyhedral, illumination can be computed 
by backward beam tracing [Shinya87, Shinya89, Watt90]. For each face of a reflector visible from the 
light source, the subtended solid angle is traced outward until it reaches a non-specular surface, where 
radiant power is deposited. For curved specuhu surfaces, backward ray tracing (also called light-ray 
or illumination-ray tracing) provides an approximate solution [Arvo86, Heckbert90, Shirley90]. In this 
method, rays are cast stochastically from the light source, like individual photons, reflecting through 
the scene until striking a non-specular surface. Shirley has produced some of the most impressive photorealistic 
images to date with this method (e.g., Figure 7 in [Shirley90]). The primary d~lculties with backward 
ray tracing involve sampling and estimating the distribution of radiant power (irradiance). Illumination 
rays arrive at their final destinations in a nonuniform pattern; and if they gave us samples of imdisnce, 
we would have some difficulty with nonuniform interpolation. However, the problem is worse, because illumination 
rays just give samples of radiant power. We must estimate the distribution of radiant power from photon 
locations and density. This prob­lem has been discussed by Heckbert [Heckbert90]. Chen et al. [Chen91] 
describe a nice resampling method, but even this method is fraught with difflcukiea. This is a troublesome 
prob­lem which has not been eampletely solved. The method we pro­pose will compute irradiance values 
at locations of our choosing, and thus avoids both of these problems. 2. Geometrical Optics The shading 
models of image synthesis are baaed on the princi­ples of geometrical optics, where wave-like behavior 
of light is assumed to occur only on an invisibly small scale. In this scheme, light emitted from some 
point in some direction travels along a curve or ray C(t) through space. We define the oplbxl pa~h length 
from one point on a ray to another as the geometric path length weighted by the refractive index of the 
media S(l) = ~cq d; A surface of constant S (relative to some source point) is called a geometrical 
wavefiont, which is always perpendicular to the light rays passing through it [Born80]. In homogeneous 
media, light rays are rectilinear; and if there are regions of constant refractive index separated by 
smooth bound­aries, then rays will travel along piecewise straight paths­reflecting or refracting at 
boundaries. In a medium with smoothly varying refractive index, rays would be curved. In all of these 
settings, Ferrnd s Principle is obeyed, which stipulates that light travels along paths of stationary 
optical length, That is, the optical path length is a 10CSImaximum or local minimum with respect to any 
smafl variation in the path. Given a stationary path, the important question is how much light propagates 
along it. In optics, intensify, 1, is defined to be the radiant power per wavefront area at any point 
along a ray. The irradiance of a surface is then E = I cm8, where (3 is the angle between the ray and 
the surface normal. In the case of duect illu­mination from a point source, rays emanate radially, and 
the wavefronts are spherical. At a distance d, the wavefront intensity is simply 1 = P/(4nd2 ), where 
P is the total power of the source, However, once the ray has reflected off a curved surface, the shape 
of the wavefront is no longer as simple. . ..­ -­ ---­ --­ ---­ --..- ­ -- fl ----­ _ . f2 --\-._.._ 
-­---­ _ D ray -­ wavefront Figure 3, Wavefront and Principle Radii Figure 3 illustrates the general 
situation in the neighborhood of a point on a rectilinear ray. A plane containing the ray will inter­sect 
the wavefront on a curve with some radius of curvature. From elementary differential geometry, we know 
there will be some orientation of the plane giving a curve with maximum radius of curvature r,, and another 
orientation wilf give a mini­mum radius r2. Furthermore, the planes associated with these principle radii 
of curvature will rdways be orthogonal. The circles of curvature are centered at points f, and f2, on 
the ray. Let UM be an element of area on this wavefront. All the rays passing through dA will intersect 
some subsequent wavefiont in an area &#38;i . Let de, and d(lz be the elements of angle subtended at 
the centers of curvature by these areas. By consemation of energy, we know the following intensity law 
must hold true rlr2d(31de2 r, rz I d = z=Ir;r~deld(lz r; r; This shows the important fact that the 
intensity along the ray is proportional to the Gaussian curvature of the wavefront 1/(r, r2 ).  3. 
Fermat Paths A f~st step in computing the reflected illumination, as pictured in Figure 2, would be to 
find the stationary paths from the point s to p. Ingeneral, this would be a difficult problem of variational 
cal­culus; but in the case we are considering, it reduces to a simple optimization problem. Figure 2 
pictures a one-bounce path from the light s to p via a reflection at x. The total optical path length 
is a simple function of x. d(x)=-+- If the mirror surface is defined implicitly by g(x) = O, then the 
optimization of d(x) subject to the contraint that all points lie on g can be accomplished by the method 
of .bgrange multipliers. This will give a system of four equations in four variables. Vd(x) + kVg(x)) 
= O g(x) = o The solutions of these non-linear equations will yield paths of locally extremal length. 
Recall from analytic geometry that the loci of points whose sum of distanms to two points is constant 
form an ellipsoid. Varying the total distance yields a family of confocal ellipsoids whose foci are s 
and p. Recall also that the gradient of an implicit function evaluated on a surface is in the direction 
of the normal to the surface. Thus, the system of equations produced by the method of Lagrange multipliers 
have the simple geometric interpretation that the extiemal points must not only lie on the implicit surface 
g, but also that the ellipspid, and the surface must be tangent at those points (see Figure 4). Therefore, 
we seek those ellipsoids in the family of confocsd ellipsoids that are tangent to the surface. Figure 
4. Osculating Ellipsoid If the light is at infiiity, we cars use a simpler formula for optical path 
length. d(x) = +(p X)2 (s.x) where in this case s is a unit vector in the direction of the light source. 
The surfaces of varying d define a family of confocal paraboloids about the visible point p. The extrema 
paths are where these paraboloids are tangent to the surface. The case of one-bounce refraction is similar 
to reflection. If the tight and the visible point are on different sides of a smooth boundary between 
two transparent mediz the optical path length becomes: d(x) =q1~+q2~ where q, and q z are the respective 
refractive indices. Surfaces of constant d are confocal Carresian ovaIs. A Cartesian oval has the appearance 
of an egg-shaped ellipsoid and is a quartic surface. The mathematics of these surfaces are discussed 
in [Stravroudis72]. If the curved mirror is defined by a parametric surface x(u,v), then the tangency 
conditions are equivalent to stating that the parametric derivatives of the surface are perpendicular 
to the normal of the eUipsoid. xU(u, v) Vd(u, v) = O xV(u, v). Vd(u, v) = O where x. and x, are the 
derivatives in the u and v directions, respectively, and d(u, v) is the distance function evaluated at 
points on the surface, This leads to a system of two equations in two unknowns. In this paper, we will 
focus on the problem of the implicitly defined refkting surface. Such surfaces are harder to deal with 
because they require a higher dimensional system of equations. However, they are typically easier to 
ray trace. The more general case of paths with N Imunces can be formulated as a system of 4N equations. 
XO = s and XN+, = p; however, only x, through x~ are variables in the optimization problem. The total 
optical path length for multiple reflections is then: N d(x~, . ..xN +.)= ~~, (X, X,+,)2 i=o The implicit 
mirror surfaces are denoted by g, (xi ) = O, and the so the system of equations to be solved are (for 
i from 1 to N): V,d(xo, . .x N+,) +k, v;g, (xt) = o g,(x,) = o Computer Graphics, 26,2, July 1992 The 
gradient equations represent the condition that an ellipsoid with foci at x,. , and x, + , must kiss 
the mirror surface g; (x, ) = O. Notice that the V,d containsonly three terms, and hence the system of 
4N equations is sparse. There exist marry special purpose methods for solving the above systems of equations 
for particular classes of surfaces. For example, finding the ellipsoid tangent to a plane or to a sphere 
is ve~ easy. In Section 5, however, we present numerical methods based on interval techniques that work 
for general implicit surfaces. Once a path is determined, it is still necessary to check that no intervening 
surface blocks light traveling rdong it. This is easily done with the ray tracing occlusion tests. This 
is just the obvious generrdization of Appel s shadow-probe method [Appe168].  4. Wavefront Tracing Once 
a path from the light source to the receiver has been deter­mined, the intensity of the incoming ray 
must be computed. As was discussed in Section 2, the intensity at a point along a ray path is proportional 
to the Gaussian curvature of the wavefront associated with that point. This intensity law suggests an 
algo­rithm where we keep track of the Gaussian curvature as the ray interacts with surfaces on its way 
to the receiver. The implemen­tation requires (i) tools to analyze the differential geometry of wavefronts 
and surfaces, and (ii) functions that tmuwform the wavefront as it is transferred through homogeneous 
media and as it reflects and refracts from a surface. Methods for performing (i) are derived from classical 
differential geometry (For example [Struik61]); methods for performing (ii) are derived from classical 
geometrical optics (For example [Stavroudis72]). More details (particularly the derivations) of the results 
used this section are available in the quoted references. The local properties of a surface can be derived 
by computing its derivatives in different directions. A unit tangent in a direction dx is equal to *=LQ 
ds where dsz =dx.dx is the differential arc length. Differentiating t again yields dt = K n+Kg(nxt) ds 
The normal curvature SC. is the component of curvature in the direction . . dt dx dn dx.dn Knin. .__. 
= _ ds ds ds dxdx where we use the fact that tn = O and hence t n = -t, n . In the remainder of this 
paper whenever curvature is mentioned it will mean the normal curvature. For this reason from this point 
on the subscript n will be dropped. The curvature is defined for aU directions tangent to the surface. 
The radius of curvature, which is equal to the reciprocal of curva­ture, is the radius of the osculating 
circle attached to a curve cre­ated by cutting the surface with a normal plane, that is, a plane containing 
n and t. Note that if a plane cuts the surface in a con­vex curve, the cumature will be negative, whereas 
if the curve is concave, the curvature will be posilive. A classic result in differ­ential geometry is 
that the curvature attains a minimum and a maximum value along two perpendicular directions calted the 
lines of curvdure, or principal directions. These extrem% or principal curvatures, are denoted by K, 
and Kj. The Gaussian  The equations of transfer are simplest: Ku Ku = 1 -dKU K, Kv = l d&#38; where 
d is the distance the wavefront moves. Noting that K = 1/r, where r is the radius of curvature, these 
equations also can be written in the form: 11 =_ r. rU d 11 = r, t-, -d which simply states that the 
radius of curvature of the waveffont changes by an amount equal to the distance travelled. Remember that 
for a converging wavefront the radius of curvature is positive. Inspecting the above equations, we note 
that when a converging wavefront moves a distance equal to original radius of curvature, the denominator 
goes to O, and hence the intensity goes to infin­ ity. These positions of extremely high intensity are 
the caustics of the wavefront. The equations for refraction and reflection are more complicated and involve 
the following three steps: 1) Recall the equations giving the directions of the reflected and refracted 
ray: ~(r) = ~(l)+2c05~ ~(.) n( ) = q n( )+y n( )  (t) and n(~) me the nomds to fie irlCl- In these equations 
n dent wavefront and surface, respectively; n(r) and n( ) are the norrnrds to the reflected and transmitted 
(refracted) wavefronts. q is the ratio of the indices of refraction in the two media, q, /q ~, and ~ 
= qcosi + car (i is the angle of incidence and / is the angle of refraction) [Stavroudis72]. 2) The direction 
u = n( ) xn( ) is tartgent troth to the incident wavefront and to the surface (since it is perpendicular 
to both normals). The curvatures of the incident wavefront in the direction u can be computed by rotating 
the principal curvatures using the angle between u and the line of curva­tures and Euler s Formula. The 
curvatures of the surface in this direction can be computed using the curvature ten­sor of the surface. 
3) The curvatures of the new wavefronts can be computed by taking the directional derivatives of n( ) 
and n( ) in the direction u. These derivatives can be computed directly from the formulae for the refkzted 
and refracted vectors and the directional derivatives of the normals on the inci­dent wavefront and the 
surface. This calculation can be found on pp. 149-157 of [Stavroudis72]; only the results are stated 
here. For reflection: K:) = K:) +2cosiK$) K((J = _ K(:)_ 2K(9 K( ) = K( ) +(2/COSi)K:) v Remember that 
the cumature of a plane is O. Therefore, the cur­vatures of an outgoing wavefront refkted horn a planar 
surface will be the same as the incoming wavefront (the fact the K~ switches sign is a result of the 
change in orientation of the coordi­nate system due to the reflection). This is as expected, since a 
perfectly reflected wave does not change its shape. Note also that a planar wavefront incident onto a 
reflecting surface essentially inherits the curvature of the surface. Thus if the surface is con­vex, 
the reflected wavefront will be diverging; whereas if the sur­face is concave, the wavefront will be 
converging, eventually forming a caustic. Once we know the cunatures of the outgoing wavefront in the 
u direction, we can compute the directions of principal curvatures using Euler s Formul% converting to 
our canonical wavefront rep­resentation. This process is then repeated for the next surface that the 
wavefront is incident upm. The outgoing intensity of reflected and refracted light should also k multiplied 
by the corresponding Fresnel coefficients to account for the changes in the magnitudes of reflected vs. 
refracted light as a function of the angle of incidence.  5. Numerical Techniques Solving systems of 
nonlinear equations like the ones in section 3 can be a diftlcuh numerical problem; and in graphics, 
there is a desire to include a diverse selection of implicit surfaces g(x) = O. The combination of two 
interesting techniques make this practical: automatic differentiation and interval arithmetic.  5.1. 
Automatic Differentiation Imagine that we want to evaluate a function ~(xo ) at some point and also the 
derivative ~X(xO). We could symbolically differenti­ate J but this can result in a large expression that 
is computation­ally expensive to evaluate. We could compute a finitedifference approximation to the derivative, 
but this yields por numerical accuracy. An alternative is to compute with pairs of numbers representing 
values of ~ and j, at a pint [Rrd181]. For constant ~ = c, this pair will be (c, O), and for~ = x, the 
value/derivative pair is sim­ply (XO,1). Starting from there, a formula for~ can be evaluated by performing 
operations on these pairs of numbers. The pairs are combined according to familiar rules of differentiation, 
such as the following rules for multiplication and square root: (8(XO), I?x(xo)) * (f(xo), f.(xo)) + 
(go, g(xo)j-x(xo) + f(~o)gx(~o)) 4U(XO) . fx(xo)) Ux)(xo) ~ + (~), 2~) This method can be easily extended 
to evaluate partial derivatives with respect to different variables. It also can be extended to simultaneously 
compute higher order derivatives. 287 SIGGRAPH 92 Chicaao, July 26-31, 1992 5.2. Interval Arithmetic 
An alternative system of arithmetic can be defined, based on interval numbers. A number of powerfuf numerical 
techniques are based on interval arithmetic [Moore79], and some of these techniques have been applied 
to problems in computer graphics [Murdur84,Toth85,Mitchel190]. An interval number corresponds to a range 
of real values and can be represented by a pair of numlwrs [a, b], the lower and upper bounds of the 
interval. Given intervaf numbers X and Y, we would like to compute interval values of expressions such 
as X + Y or function values ~(X). Ideally, these values should be exact bounds, the range of lowest to 
highest values of ~(x) for all x E X. Often it is not possible to find the exact bound, but it may still 
be very useful to know an interval value guaranteed to contain the exact bound. It is straightforward 
to define interval extensions of basic arithmetic operations: [a,b] +[c,d] =[a+c,b+d] (la) [a)b] -[c,d] 
= [a -d,b-c] (lb) [a,b] * [c,d] = [min(ac,ad,bc,bd), (lC) max(ac, ad, bc, bd)] andif O d [c, d] [a,b] 
/ [c,d] = [a,b] x [1/d,l/c] (Id) Given a rational function r(x), the natural interval afension can be 
defined by evaluating the expression r(X) for an intervaf argument X = [xO, xl ] and using the interval-mithmetic 
operations in (l). Interval extensions of familiar functions like cosine or square root can also be defined 
and included in expressions. The resulting interval value of r(X) is guaranteed to contain the exact 
bound of the real-valued r(x) over the interval X. The tightness of the bound may depend on how r(X) 
is expressed. For example, intervaf arithmetic is subdistributive: X(l + Z) c XY + XZ. One of the most 
important properties of the natural interval extension is inclusion monotoniciiy: X c X, implies r(X 
) ~ r(X) This means that as the interval X becomes more narrow, the interval r(X) will converge to its 
real restriction. 5.3. Solving Nonlinear Systems A robust and generaf method of solving nonlinear systems 
com­bines automatic differentiation with interval arithmetic. Suppose we aze attempting to solve a system 
of N equations in N unknowns, f(x) = O. Ordinary Newton s method does not pro­vide a reliable way to 
locate every solution within a given region, but interval extensions have been developed which do [Moore79]. 
The most straightforward interval Newton s method is the sequence beginning with some interval vector 
X ~: X~+l = N(X~) nXl where N(X) = m(X) -[F (X) ]-l~(m(X)) Here, m(X) is m ordinary vector made up of 
midpoint values of the X components, and F ( X )-1 is the interval Jacobian of the system of equations 
at X. The intersection N(X~ ) n X~ con­strains the new intervaf to be within the originaf and is a common 
precaution against effects of finite-precision machine arithmetic. A problem with Newton-step operator 
N(X ) is that it involves the inversion of an interval matrix. Krawczyk developed an alternative Newton-like 
method using an operator which is cheaper to compute. This operator only requires inversion of an ordinary 
(non-interval) matrix: K(X) = m(X) -[m(F (X))]-lf(m( X)) + (l-[m(F (X))]-l F (X) ](X m(X)) Moore and 
others have proven a number of theorems about the convergence of these Newton-like methods which are 
used to construct a sound method for isolating and refiiing solution esti­mates [Moore79,Ralf8 1]. Theorem 
1 (Nonexistence I) ~0 # F(X), there is no soh.dion of f(x) = o inx. Theorem2 (Nonexistence II) ff K(X) 
n X = 0, (here are no roots in X. Theorem 3 (Convergence). If K(X) G X and 111-[m(F (X))]-l F (X)ll <1 
, there is a unique root in X and a number of iterative methods will converge to it. The algorithm for 
fiiding all solutions is then quite simple. Given an interval X, these three theorems are automatically 
tested. The interval is discarded if it is known to have no solutions within it. Some Newton-like iterative 
method is applied if Theorem 3 guarantees convergence. Otherwise, the interval is subdNided and the procedure 
applied recursively. Subdivision must terminate when the limits of machine-arithmetic are reached (i.e., 
when the width of X is less than some E=). In our problem of reflected illumination, the systems given 
in Section 3 must be solved. Since the equations involve Vg and Vd, the interval Newton method will require 
values of the second derivatives of g and d. The process of finding solutions must begin with an initial 
intervaf value for the variables x, y,z,l. The frost three dimensions are initialized to a box tightly 
enclosing the impficit surface g( x) = O. Reflector s ,.. m .. ,.. ... ,., ..  x ,::. ... ., .. ... 
., .. P Figure 5. Back-Facing Reflection Points As Figure 5 shows, we wish to exclude points on the 
mirror where the osculating elfipsoid touches a back-facing surface, since the body of the mirror itself 
would block the light s paths. These points are eliminated automatically by choosing the initial k interval 
to be [O, km]. This will only allow points where the mirror s normal points in the opposite direction 
of the normaf on the osculating ellipsoid. A nice property of the interval root­fmding methods is that 
they do not expend resources searching outside the initial interval, so no time is wasted on back-facing 
reflection points. It s important to note that more than one stationary path may exist from a given p 
to the light source. Figure 6 shows the paths at a series of points in a two-dimensional scene. Rays 
from the fight (in the upper right) to the surface are omitted to avoid chstterirsg the image. Regions 
containing one path and a region containing three paths are separated by a caustic surface. In the regions 
containing three stationszy paths, notice that the middle pathway is a local maximum. A common misconception 
is that Fermat s principle requires paths to be of minimum length. Figure 6. Examples of Stationary Paths 
of Illumination 6. Implementing Multiple Extensions of a Function Our ray tracer can accept an expression 
for an implicit surface in a simple symbolic form, and then construct and solve the system of equations 
described above. To accomplish this, expressions g(x) are represented by sequences of codes for a push-down 
stack machine. For example, the function for a unit sphere, g(x) =x*+ y2+z* l=o, is defined as: Bytecode 
sphere[] = { LDX, SQR, LDY, SQR, LDZ, SQR, ADD, ADD, NUM, 1.0, SUB, RET, ); The LDX instruction pushes 
the value of x onto the stack. ADD pops two vafues and pushes the sum, etc. A slightly more inter­esting 
surface, shaped like a rounded cube with the faces dented inward, is given by this quartic formul~ g(x) 
=x4+y4+z4 x* y* Z2 =0, is defined as: Bytecode cuboid[] = { LDX,SQR,SQR, LDY,SQR,SQR, LDZ,SQR,SQR, ADD,ADD, 
LDX,SQR,LDY,SQR,LDZ, SQR,ADD,ADD, SUB, RET, } These stack-machine codes are evaluated by a collection 
of six stack-machine interpreters in the ray tracer. Each of these inter­preters takes a code sequence 
and argument x. The frost group of interpreters operate on real numbers. The sim­plest interpreter evaluates 
the code with ordimuy floating-point arithmetic and returns the scalar value g(x). This stack machine 
is used primarily during root refinement by ordinary Newton s method (when the interval methods have 
proven convergence within an interval). A second stack machine used automatic dif­ferentiation to compute 
g(x) and a corresponding value of Vg. This is used primarily to find surface normal vectors for the shad­ing 
calculation. A third machine computes the Hessian, and is used irr wavefront-curvature calculations. 
The second group of interpreters operate on intervals. A fust machine in this group computes an interval 
extension of g and an interval extension of the directional derivative ag/af along a ray. This stack 
machine is used by the ray/surface intersection routines as described in [Mitchel190]. A second machine 
computes inter­val extensions of g and its gradient Vg, and a third machine com­putes these as well as 
an interval extension of the Hessian matrix for g. These two machines are used to compute the Krawczyk 
operator (8) during the root isolation phase. ,,. . .. ..... . . , , ::, ... ... ., . ... . ,. ..: .. 
, . ..., .. .. .. .,. . . Figure 7. Spot Diagram of Rays Reflected off Cuboid 7. Results A basic ray 
tracer augmented with the reflection-illumination techniques described above was implemented in 3400 
lines of C code. Two 512x5 12 images were rendered of a reflective copper-colored cuboid defined by: 
g(x)=xq+yg+zq xz-yz Z2=(I This surface is a good test of our method, because it has regions of concave, 
convex, and saddle-shaped curvature. The light source is a point at infinity behind the viewer and slightly 
to their right. In Plate 2, the wavefront intensity is not used, so the brightness of the reflection 
is simply a function of how many vir­tual light sources illuminate each visible point. Plate 3 is the 
same image, using the intensity laws develo~d in Section 4. Note that some reflections seen in Plate 
2 have vanished because they make an insignificant contribution to the intensity. Interest­ing skucture 
in the reflection includes the bright focal point blow the concave side and the bright edges of the caustic 
structure-a singularity in intensity that occurs at the boundaries between regions having different numbers 
of virtual lights. These plates (as well as Figure 6) further demonstrate that the table top is divided 
into distinct regions according to how many virtual lights (i.e, stationary paths to the light source) 
me present.   Graphics hterfizce 90, (1990) 205-212. [Sillion89] Sillion, F., Puech, C., A General 
TWO-PSSS Method Integrating Specular and Diffuse Reflec­tion. Computer Graphics 23,3 (1989), 335-344. 
[Sparrow62] Sparrow, E. J., Eck@ E. R. G., Jonsson, V. K., An Enclosure Theory for Radiative Exchange 
Between Specularly and Diffusely Reflecting Surfaces. Journal of Heat Tran@er 84C,4, (1962). [Stavroudis72] 
Stavroudis, O. N. The Optics oj_ Rays, Wavefionts,and Caustics,Academic, 1972. [Struik61] Struik, Dirk 
J., Lectures on Classical Differential Geometry 2nd. Edition, Dover Publications, New York 1961. [Toth85] 
Toth, D. L. On ray tracing parametric surfaces. Computer Graphics, 19,3 (July 1985), 171-179. ~sllace87] 
Waflsce, J., Cohen, M. F., Greenberg, D. P., A Two-Pass Solution to the Ren&#38;nng Equation: A Synthesis 
of Rsdiosity and Ray Tracing Methods. Computer Grqohics 21,4, (1987),311-320. ~att90] Wa~ M. Light-water 
interaction using backward beam tmacing. Cornpuer Graphics, 24,4 (August 1990) 377-385. ~hitted80] Whitted, 
T. An improved ilfuminstion model for shaded display. Conrrn. ACM, 23, 6 (June 1980), 343-349. [Ap@68] 
[Arvo86] [Berry80] [Born80] [Chen91] [Dil181] [Fomest79] [GuMrsnd06] [Heckbert90] [Kneisly64] [Mitchel190] 
[Moore79] [Murdur84] [Ral181 ] [Shinya87] [Shinya89] [Shirley90] gradient map [Berry80]. Producing mathematical 
visualizations of such functions would be extremely interesting to mathematical physicists. 9. References 
Appel, A. Some techniques for shading machine renderings of so fids. AFIPS I %8 Spring Joint Computer 
Cd 32 (1968), 3745. Arvo, J. Backward ray !racing. Developments in Ray Tracing SIGGRAPH Course Notes, 
12 (1986). Berry, M. V., Upstill, C., Catastrophe Optics: Morphologies of Caustics and their Diffraction 
Patterns, Progress in Op/ics XVIII, (1980), 259­ 346. Born, M. and Wolf, E., Principles of Optics. Pergamon, 
1980. Chen, S. E., Rushrneier, H. E., Miller, G., Turner, D., A progressive Multi-Pass Method for Global 
Illumination Cornptier Grqphics 25, 4 (1991), 165-174. Dill, John C., An Application of Color Graphics 
to the Display of Surface Curvature Cornpuler Graphics 15,3 (1981), 153-161. Forrest A. R., On the Rendering 
of Surfaces. Cornpuler Graphics 13,2 (1979), 253-2S9. Gullstrand, A. Die reelle optische Abbildung. Sv. 
Vetensk. Hand. 41, (1906), 1-119. Heckbe@ P. Adaptive Radiosity Textures for Bidrectionaf Ray Tracing. 
Computer Graphics, 24,4 (August 1990), 145-154. Kneisly, J. A. III, Local curvature of wavefronts in 
an optical system. J. Opt. Sot. Amer. 54, (1964), 229-235. Mitchell, D. P. Robust ray intersection with 
interval arithmetic. Graphics Interfdce 90, (May 1990) 68-74. Moore, R. E., Methods and applicatwns of 
interval analysis. SIAM, 1979. Murdur, S. P., Koparksr, P. A., Intervaf methods for processing geometric 
objects. IEEE Computer Graphics and Applications, 4,2 (February 1984), 7-17. Rail, Louis B., Automatic 
Diffwentiation: Techniques and Applications. Springer-Verlag, 1981. Shiny% M., Takahashi, T, Nsito, S. 
Principles and applications of pencil tracing. Computer Graphics, 21,4 (July 1987), 45-54. Shinya, M., 
Ssito, T., Tskahashi, T. Rendering techniques for transparent objects. Proc. Graphics Interfwe 89, (1989) 
173-182. Shirley, P. A ray tracing method for illumination calculation in diffuse-specular scenes. Proc. 
 
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134083</article_id>
		<sort_key>293</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>34</seq_no>
		<title><![CDATA[Interactive spacetime control for animation]]></title>
		<page_from>293</page_from>
		<page_to>302</page_to>
		<doi_number>10.1145/133994.134083</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134083</url>
		<keywords>
			<kw><![CDATA[animation]]></kw>
			<kw><![CDATA[spacetime]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Animation</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>G.1.2</cat_node>
				<descriptor>Spline and piecewise polynomial approximation</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Curve, surface, solid, and object representations</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.6</cat_node>
				<descriptor>Interaction techniques</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>G.1.6</cat_node>
				<descriptor></descriptor>
				<type></type>
			</other_category>
			<other_category>
				<cat_node>I.6.3</cat_node>
				<descriptor></descriptor>
				<type></type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010399</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Parametric curve and surface models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010341</concept_id>
				<concept_desc>CCS->Computing methodologies->Modeling and simulation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003120.10003121.10003125.10010391</concept_id>
				<concept_desc>CCS->Human-centered computing->Human computer interaction (HCI)->Interaction devices->Graphics input devices</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010387</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Graphics systems and interfaces</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002950.10003714.10003715.10003720</concept_id>
				<concept_desc>CCS->Mathematics of computing->Mathematical analysis->Numerical analysis->Computations on polynomials</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010401</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Volumetric models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003752.10003809.10003716</concept_id>
				<concept_desc>CCS->Theory of computation->Design and analysis of algorithms->Mathematical optimization</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002950.10003714.10003716</concept_id>
				<concept_desc>CCS->Mathematics of computing->Mathematical analysis->Mathematical optimization</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002950.10003714.10003736.10003737</concept_id>
				<concept_desc>CCS->Mathematics of computing->Mathematical analysis->Functional analysis->Approximation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010352</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Animation</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
			<gt>Design</gt>
			<gt>Human Factors</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>PP79028452</person_id>
				<author_profile_id><![CDATA[81406592138]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Michael]]></first_name>
				<middle_name><![CDATA[F.]]></middle_name>
				<last_name><![CDATA[Cohen]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Department of Computer Science, University of Utah, Salt Lake City, Utah]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[ARMSTRONG, B., AND GREEN, M. The dynamics of articulated rigid bodies for purposes of animation. In Proceedings of Graphics Interface (May 1986), Computer Graphics Society, pp. 407-415.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_obj_id>74356</ref_obj_id>
				<ref_obj_pid>74334</ref_obj_pid>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[BARAFF, D. Analytical models for dynamic simulation of non-penetrating rigid bodies. A CM Computer Graphics ~3, 3 (July 1989), 223-232.]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_obj_id>26962</ref_obj_id>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[BARTELS, R. H., BEATTY, J. C., AND BARSKY, B. A. An Introduction to Splines .for Use in Computer Graphics and Geometric Modeling. Morgan Kaui!mann, 1979.]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378509</ref_obj_id>
				<ref_obj_pid>54852</ref_obj_pid>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[BARZEL, R., AND BARR, A. H. A modeling system based on dynamic constraints. In Proceedings of SIG- GRAPH'88 (Atlanta, Georgia, August 1-5, 1988) (August 1988), ACM, pp. 179-188.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[BOEHM, W. Inserting new knots into b-spline curves. IPC Business Press 1~, 4 (July 1980), 199-201.]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378531</ref_obj_id>
				<ref_obj_pid>54852</ref_obj_pid>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[BROTMAN, L. S., AND NETRAVALI, A. N. Motion interpolation by optimal control. In Proceedings of SIG. GRAPH'88 (Atlanta, Georgia, August 1-5, 1988) (Aug. 1988), vol. 22, ACM, pp. 309-315.]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_obj_id>74357</ref_obj_id>
				<ref_obj_pid>74334</ref_obj_pid>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[BRUDERLn~, A., AND CALVERT, T. Goal-directed, dynamic animation of human walking. A CM Computer Graphics ~3, 3 (July 1989), 233-422.]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[CHAR, B. W., GEDDES, K. O., GONNET, G. H., MON- AGAN, M. B., AND WATT, S. M. MAPLE Reference Mqnualj_Fiflh edition. Waterloo Maple Publishing, Waterloo, Ontario, 1988.]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[COHEN, E., LYCHE, T., AND RIESENFELD, R. Discrete b-splines and subdivision techniques in computeraided geometric design and computer graphics. Computer Graphics and Image Processing 15, 2 (October 1980), 87-111.]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_obj_id>534661</ref_obj_id>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[CRAIG, J. J. Introduction to Robotics. Addison-Wesley, Reading, MA, 1986.]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
			<ref>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[DRISKILL, H. Symbolic kinematic and dynamic equations of motion. LISP code (1990).]]></ref_text>
				<ref_id>11</ref_id>
			</ref>
			<ref>
				<ref_obj_id>578513</ref_obj_id>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[FAux, I., Ar~) PRATT, M. Computational Geometry for Design and Manufacture. Ellis Horwood Limited, 1979.]]></ref_text>
				<ref_id>12</ref_id>
			</ref>
			<ref>
				<ref_obj_id>39857</ref_obj_id>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[FLETCHER, R. Practical Methods of Optimization, Vol. i and ~. John Wiley and Sons, 1980.]]></ref_text>
				<ref_id>13</ref_id>
			</ref>
			<ref>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[GmL, P. E., AND MURRAY, W. Numerical Methods}or Constrained Optimization. Academic Press, 1974.]]></ref_text>
				<ref_id>14</ref_id>
			</ref>
			<ref>
				<ref_obj_id>31465</ref_obj_id>
				<ref_obj_pid>31462</ref_obj_pid>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[GIRARD, M. Interactive design of 3d computeranimated legged animal motion. IEEE Computer Graphics and Applications 7, 6 (June 1987), 39-51.]]></ref_text>
				<ref_id>15</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378530</ref_obj_id>
				<ref_obj_pid>54852</ref_obj_pid>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[HAHN, J. Realistic animation of rigid bodies. In Proceedings of SIGGRAPH'88 (Atlanta, Georgia, August 1-5, 1988) (August 1988), ACM, pp.299-308.]]></ref_text>
				<ref_id>16</ref_id>
			</ref>
			<ref>
				<ref_seq_no>17</ref_seq_no>
				<ref_text><![CDATA[HIMMELI3LAU, D. M. Applied Nonlinear Programming. McGraw-Hill, New York, 1972.]]></ref_text>
				<ref_id>17</ref_id>
			</ref>
			<ref>
				<ref_obj_id>37428</ref_obj_id>
				<ref_obj_pid>37401</ref_obj_pid>
				<ref_seq_no>18</ref_seq_no>
				<ref_text><![CDATA[ISAACS, P. M., ANt) Com~N, M. F. Controlling dynamic simulation with kinematic constraints, behavior functions, and inverse dynamics. In Proceedings of SIG- GRAPH'87 (Anaheim, California, July ~7-31, 1987) (July 1987), ACM, pp. 215-224.]]></ref_text>
				<ref_id>18</ref_id>
			</ref>
			<ref>
				<ref_seq_no>19</ref_seq_no>
				<ref_text><![CDATA[ISAACS, P. M., AND COHEN, M. F. Mixed methods for kinematic constraints in dynamic figure animation. The Visual Computer $ (1988).]]></ref_text>
				<ref_id>19</ref_id>
			</ref>
			<ref>
				<ref_seq_no>20</ref_seq_no>
				<ref_text><![CDATA[KOREIN, J. U., AND BADLER, N. I. Techniques for generating goal-directed motion of articulated structures. IEEE Computer Graphics and Applications $, 6 (Nov. 1982), 71-8~.]]></ref_text>
				<ref_id>20</ref_id>
			</ref>
			<ref>
				<ref_obj_id>97907</ref_obj_id>
				<ref_obj_pid>97879</ref_obj_pid>
				<ref_seq_no>21</ref_seq_no>
				<ref_text><![CDATA[LE~., P., WEI, S., ZHAO, J., AND BADLER, N. I. Strength guided motion. In Proceedings of SIG- GRAPH'90 (Dallas, Texas, August 6-10, 1990) (August 1990), ACM, pp. 253-262.]]></ref_text>
				<ref_id>21</ref_id>
			</ref>
			<ref>
				<ref_obj_id>4132</ref_obj_id>
				<ref_seq_no>22</ref_seq_no>
				<ref_text><![CDATA[MAGNENAT-THALMANN, AND THALMANN. Computer Animation: Theory and Practice. Springer Verlag, 1985.]]></ref_text>
				<ref_id>22</ref_id>
			</ref>
			<ref>
				<ref_obj_id>97882</ref_obj_id>
				<ref_obj_pid>97879</ref_obj_pid>
				<ref_seq_no>23</ref_seq_no>
				<ref_text><![CDATA[McKENNA, M., AND ZEt,TZEP., D. Dynamic simulation of autonomous legged locomotion. In Proceedings of SIGGRAPH'90 (Dallas, Texas, August 6-10, 1990) (August 1990), ACM, pp. 29-38.]]></ref_text>
				<ref_id>23</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378508</ref_obj_id>
				<ref_obj_pid>54852</ref_obj_pid>
				<ref_seq_no>24</ref_seq_no>
				<ref_text><![CDATA[MILLER, G. S. P. The motion dynamics of snakes and worms. In Proceedings o.f SIGGRAPH'88 (Atlanta, Georgia, August 1-5, 1988)(August 1988), ACM, pp. 169-173.]]></ref_text>
				<ref_id>24</ref_id>
			</ref>
			<ref>
				<ref_obj_id>4159</ref_obj_id>
				<ref_seq_no>25</ref_seq_no>
				<ref_text><![CDATA[MORTENSON, M. E. Geometric Modeling. John Wiley and Sons, New York, 1985.]]></ref_text>
				<ref_id>25</ref_id>
			</ref>
			<ref>
				<ref_seq_no>26</ref_seq_no>
				<ref_text><![CDATA[PAPALAMBROS, P. Y., AND WILDE, D. J. Principles .of Optimal Design. Cambridge University Press, Cambridge, England, 1988.]]></ref_text>
				<ref_id>26</ref_id>
			</ref>
			<ref>
				<ref_obj_id>74355</ref_obj_id>
				<ref_obj_pid>74333</ref_obj_pid>
				<ref_seq_no>27</ref_seq_no>
				<ref_text><![CDATA[PENTLAND, A., AND WILLIAMS, J. Good vibrations: Modal dynamics for graphics and animatioIt. In Proceedings of SIGGRAPH'89 (Boston, Mass., July 31- Aug ~, 1989) (July 1989), ACM, pp. 215-222.]]></ref_text>
				<ref_id>27</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122756</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>28</ref_seq_no>
				<ref_text><![CDATA[PHILLmS, C. B., AND BADLER, N. I. Interactive behaviors for bipedal articulated figures, vol. 25, ACM, pp. 359-362.]]></ref_text>
				<ref_id>28</ref_id>
			</ref>
			<ref>
				<ref_obj_id>91452</ref_obj_id>
				<ref_obj_pid>91385</ref_obj_pid>
				<ref_seq_no>29</ref_seq_no>
				<ref_text><![CDATA[PHILLIPS, C. B., ZHAO, J., AND BADLER, N. 1. Interact!ve real-time articulated figure manipulation using multiple kinematic constraints. In Proceedings of Symposium on Interactive 3D Graphics (Snowbird, Utah, March, 1990) (Mar. 1990), vol. 24, ACM, pp. 245-250.]]></ref_text>
				<ref_id>29</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378524</ref_obj_id>
				<ref_obj_pid>54852</ref_obj_pid>
				<ref_seq_no>30</ref_seq_no>
				<ref_text><![CDATA[PLAIT, J., AND BAR_R, A. H. Constraint methods for flexible models. In Proceedings of SIGGRAPH'88 (Atlanta, Georgia, August 1-5, 1988)(August 1988), ACM, pp. 279-288.]]></ref_text>
				<ref_id>30</ref_id>
			</ref>
			<ref>
				<ref_obj_id>6771</ref_obj_id>
				<ref_seq_no>31</ref_seq_no>
				<ref_text><![CDATA[PRESS, W. H., AND Ft, ANNERY, B. Numerical Recipes: The Art of Scientific Computing. Cambridge University Press, 1986.]]></ref_text>
				<ref_id>31</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122755</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>32</ref_seq_no>
				<ref_text><![CDATA[RAmERT, M. H., AND HODGnUS, J. K. Animation of dynamic legged locomotion, siggraph91 J, 25 (1991), 349-358.]]></ref_text>
				<ref_id>32</ref_id>
			</ref>
			<ref>
				<ref_obj_id>97904</ref_obj_id>
				<ref_obj_pid>97879</ref_obj_pid>
				<ref_seq_no>33</ref_seq_no>
				<ref_text><![CDATA[VAN DE PANNE, M., F~, E., AND VRANESIC, Z. Reusable motion synthesis using state-space controllers. In Proceedings of SIGGRAPH'90 (Dallas, Texas, August 6-10, 1990) (August 1990), ACM, pp. 225-234.]]></ref_text>
				<ref_id>33</ref_id>
			</ref>
			<ref>
				<ref_obj_id>31463</ref_obj_id>
				<ref_obj_pid>31462</ref_obj_pid>
				<ref_seq_no>34</ref_seq_no>
				<ref_text><![CDATA[WILHELMS, J. Using dynamic analysis for realistic animation of articulated bodies. IEEE Computer Graphics and Applications 7, 6 (June 1987), 12-27.]]></ref_text>
				<ref_id>34</ref_id>
			</ref>
			<ref>
				<ref_obj_id>37429</ref_obj_id>
				<ref_obj_pid>37402</ref_obj_pid>
				<ref_seq_no>35</ref_seq_no>
				<ref_text><![CDATA[WITKIN, A., FLEISCHER, K., AND BARR, A. Energy constraints on parameterized models. In Proceedings of SIGGRAPH'87 (Anaheim, California, July 27-31, 1987) (July 1987), vol. 21, ACM, pp. 225-232.]]></ref_text>
				<ref_id>35</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378507</ref_obj_id>
				<ref_obj_pid>54852</ref_obj_pid>
				<ref_seq_no>36</ref_seq_no>
				<ref_text><![CDATA[WlTKIN, A., AND KASS, M. Spacetime constraints. In Proceedings of SIGGRAPH'88 (Atlanta, Georgia, August 1-5, 1988) (July 1988), ACM, pp. 159-168.]]></ref_text>
				<ref_id>36</ref_id>
			</ref>
			<ref>
				<ref_obj_id>565650</ref_obj_id>
				<ref_obj_pid>97879</ref_obj_pid>
				<ref_seq_no>37</ref_seq_no>
				<ref_text><![CDATA[WITKtN, A., AND WELCH, W. Fast animation and control of nonrigid structures. In Proceedings of SIG- GRAPH'90 (Dallas, Texas, August 6-10, 1990) (August 1990), ACM, pp. 243-252.]]></ref_text>
				<ref_id>37</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 Computer Graphics, 26,2, July 1992 Interactive Spacetime Control for Animation Michael F. Cohen* Department 
of Computer Science University of Utah Salt Lake City, Utah 84112 Abstract This paper describes new 
techniques to design physically based, goal directed motion of synthetic creatures. More specifically, 
it concentrates on developing an interactive framework for specifying constraints and objectives for 
the motion, and for guiding the numericrd solution of the opti­mization problem thus defined. The ability 
to define, modify and guide constrained space­time problems is provided through an interactive user inter­face. 
Innovations that are introduced include, (1) the subdi­vision of spacetime into discrete pieces, or Spacetime 
Win­dows, over which subproblems can be formulated and solved, (2) the use of cubic B-spline approximation 
techniques to de­fine a C2 function for the creature s time dependent degrees of freedom, (3) the use 
of both symbolic and numerical pro­cesses to construct and solve the constrained optimization problem, 
and (4) the ability to specify inequality and condi­tional constraints. Creatures, in the context of 
this work, consist of rigid links connected by joints defining a set of generalized degrees of freedom. 
Hybrid symbolic and numeric techniques to solve the resulting complex constrained optimization problems 
are made possible by the special structure of physically based models of such creatures, and by the recent 
development of symbolic algebraic languages. A graphical user interface pro­cess handles communication 
between the user and two other processes; one devoted to symbolic differentiation and ma­nipulation of 
the constraints and objectives, and one that performs the iterative numerical solution of the optimiza­tion 
problem. The user interface itself provides both high and low level definition of, interaction with, 
and inspection of, the optimization process and the resulting animation. Implementation issues and experiments 
with the Spacetime Windows system are discussed, CR Categories: 1.3.7: [Computer Graphics] Three-Dimensional 
Graphics and Realism; 1.6.3 [Simulation and Modeling] Applications; G.].6 [Constrained Optimization] 
Additional Keywords: Animation, Design, Spacetime. * Current Address: Dept. of Computer Science, Princeton 
University, 35 Olden St, Princeton, NJ 08544 Permission [n copy withcwl fee ill or part nf this material 
is granted provided that the copies are nnt made or distributed for direct commercial advantage. the 
ACM copyright rmice and the title of the publication and Its date appear. and notice is given that copying 
is by permission of tbe Assocmtion for Computing Machinery. Tn copy nthcrwisc. tw to republlsh, requires 
a fee and/or specific Permission. 1 Introduction Computers have been used to assist in the creation 
of an­imated sequences for more than a decade, yet the result­ing animation still cannot reproduce the 
lifelike qualities imparted to creatures through traditional hand animation. There has been some success 
in creating realistic motion of inanimate objects such as chains and machines by simulating physical 
laws. The lifelike motion of animate creatures is, however, driven both by physics and by internal motivations 
(or actuated s@ems 32 ~&#38;:~~,5t};gsc~~~t~ncaptured by a direct application oL./ The goal of this research 
is to provide actively design the motion of simulated pears correct, and satisfies goals and user. Thus 
the laws of physics provide on the motion rather than the primary ulation. The motion of the creatures 
user guided optimization process that the ability to inter­creatures which ap objectives set by the possible 
constraints driving force for sim­is derived through a minimizes an objec­ tive function subject to physical 
and other user-defined con­straints. The use of spacetime constraints and optima~ con­trol introduced 
to computer animation by Witkin and Kass 36 and Brotman and Netravali 6] is enhanced and embed-Lle into 
an interactive framewor !c. Interactive constraint and objective definition, symbolic and numerical optimization 
capabilities, and graphical feedback are provided in the Spacetime Windows system. The Space­time Windows 
system consists of three separate processes, a graphical user interface, a symbolic manipulation process, 
and a spacetime numerical optimization system. Animations are designed in an iterative fashion through 
the creation and manipulation of symbolic constraints and objectives, provid­ing sketches of the proposed 
animation, and by focusing the optimization on subsets (windows) of spacetime during the numerical optimization 
process. The remainder of the paper is organized as follows. After a brief review of computer animation 
methods, the Space­ time Windows system and its implementation are described. This is followed by some 
example animation segments, and a discussion of areas for future research. 2 Previous Work in Computer 
Animation In the past decade, two main approaches have evolved for creating motion of synthetic figures. 
The first approach recreates and enhances the kinematic tools used by tradi­tional animators to relieve 
some of the tedious and time consuming tasks of hand animation. The second path simu­lates the physical 
laws that govern motion in the real world. Although each of the two methodologies has produced some 
ACM-( )-89791 -479 -l/92/(N)7/(1293 $01.50 beautiful computer generated motion, they both have serious 
limitations. Traditional animation methods provide great control to the artist, but do not provide any 
tools for auto­matically creating realistic motion. Dynamic simulation, on the other hand, generates 
physically correct motion (within limits) but it does not provide sufficient control for an artist or 
scientist to create desired motion 22]. More recent work, and the focus of the work reported i ere, has 
concentrated on adding control within a dynamic framework. 2.1 Kinematics and Dynamics Not surprisingly, 
the most successful computer animation to date has relied heavily on the abilities of the animator. Films 
such as Tony de Peltrie and LUXO Jr brought creatures convincingly to life. The primary role of the compnter 
was to render images and perform interpolation tasks, thus allowing the artist/animator to concentrate 
explicitly on the creation of key frames. A more powerful technique involves the use of inverse kinematics 
permitting direct specification of end point positions (e.g., a hand or foot) [15; 20; 29; 28]. Dynamics 
hss been the focus of the work of a number of re­searchers attempting to automatically generate realistic 
mo­tion [1; 2; 4; 16; 18; 19; 21; 24; 23; 27; 34]. The motion of chains, waves, spacecraft, automobiles 
and other inanimate objects has been successfully simulated. The reason for this success is the objects 
response to ezternal forces in accor­dance with physical principles. The objects are, however, not under 
the control of the animator after initial conditions are specified. How to return some level of control 
to the animator is one of the most difficult issues in dynamic simulation. In [18; 19], constraints are 
included to allow the concurrent exphcit con­trol of some degrees of freedom while sJlowing others to 
react in a correct dynamic fashion. Witkin and Welch take this concept one step further and generate 
kinematic constraints from higher level control specifications and apply them to non-rigid bodies 37]. 
Wilhelms explores similar directions for adding contro \ within a dynamic system [34], but does not include 
goal directed motion in an integrated fashion. 2.2 Constraints and Control Various types and levels of 
control have been added to dy­namic systems to achieve control over the motion of simu­lated creatures. 
Bruderlin and Calvert [7] create convincing walklng motion of human figures through the use of a hybrid 
hierarchical control process that incorporates an approxi­mate dynamic model. Raibert and his colleagues 
produce running motion of a variety of simulated (and real) crea­tures [32]. Control algorithms are used 
to regulate speed, gait, and to maintain balance. This control is exerted at each time interval based 
on the current state of the creature. Motion sequences are then created as in dynamic systems by integrating 
forward through time. Each of these systems has been extremely successful over their limited domain of 
ap­plicability y. Ading constraints to modeling systems is not new and has resulted in animation sequences. 
Barr and others use con­straints to construct static assemblies of rigid bodies, e.g., a cable tower 
[35; 4; 30]. The process of solving the constraints leads to a series of configurations for the constrained 
objects, thus creating an animation as a byproduct of the solution process.  2.3 Spacetime Constraints 
and Control In contrast to systems that simulate motion by stepping for­ward through time, animation 
design involves planning en­tire sequences of motion w a single unit. Scenes are designed to have particular 
events occur at specified times. Thus, one would like a system that provides control over the total an­imation 
while incorporating dynamics principles. Witkin and Kass describe a spacetime constraint system [36] 
in which constraints and objectives are defined over .Space­time, referring to the set of all forces 
and positions of all of a creature s degrees of freedom (DOF) from the begin­ning to the end of an animation 
sequence. Brotman and Netravali [6] achieved a similar resnlt through the use of Op­timal Control methodologies. 
In each case, the animation is derived through an optimization of the objective subject to the constraints. 
This integration of user-defined constraints and physical constraints answers many of the difficulties 
of earlier systems. The work reported in these papers demonstrates impressive results, but suffers from 
a number of restrictions. The first restriction is that the complexity growth of.t,he problem lim­its 
the length of animation sequences. The second restriction is that creatures must have full knowledge 
of the future to optimize their actions. This is not dksimilar to the first re­striction, in that all 
the motion is based on a single set of con­straints and a single objective. The non-interactive nature 
of the specification and, more importantly, the numericaJ pro­cess also make it difficult to integrate 
these techniques into an animation design system. In addition, given the highly non-linear nature of 
the constraints and objectives, the avail­able numerical methods often do not converge to acceptable 
solutions. 3 Spacetime Windows The Spacetime Windows system, described below, includes a number of features 
designed to remove the restrictions of ear­lier systems and to enable the use of spacetime constraints 
in an interactive framework. The ability to interactively spec­ify and modify constraints and objectives, 
and to define and iterate on solutions to subproblems provides the animator with tools to examine and 
thns guide the optimization pro­cess. The sensitivity of highly non-linear constrained opti­mization 
to starting values and solution algorithms can thus be controlled to a great extent by the user. Given 
visual and numeric feedback about the progress of the convergence towards a desired solution, the user 
is able to add new con­straints, raise or lower the weight of previous constraints, or modify intermediate 
solutions. This is followed by further iterations until the animation is deemed satisfactory by the user. 
The ill-defined design process is thus left largely in the control of the animator. A primary concept 
used to realize these goaJs is the abil­ity to focus attention on overlapping pieces of spacetime, or 
spacetime windows. A window is defined over a subset of the creature s degrees of freedom, and across 
a subset of the time from the beginning to the end of the animation. Then! an iterative optimization 
process is run to find a set of functions of the DOF across the window, that minimize an objective while 
maintaining a set of weighted constraints. The solu­tion for each spacetime window represents a partial 
solution of the entire animation. The solutions within windows are combined through continuity conditions 
with the spacetime outside of the window, and by overlapping subsequent win­dows in space and time. Spacetime 
windows also provide the facility to refine specific intervaJs of time or the motion of specific DOF. 
This approach addresses problems inherent in Witkin and Kass work. First, computational complexity is 
mitigated since each window represents an independent subproblem. In addition to keeping the iteration 
times of the optimiza­tion to a few seconds, the subproblem defined across a space­ Computer Graphics, 
26, 2, July 1992 (a) (b) Figure 1: Cat and Mouse time window is generally more numerically stable, produc­ing 
more robust convergence towards a solution. The use of spacetime windows also provides the semantics 
to simulate creatures with a limited knowledge of the future. For exam­ple, if a simulated cat is constrained 
to catch a mouse with minimum energy, in a full spacetime optimization, the cat would optimize its actions 
by simply moving in a straight line to where the mouse will be and then waiting for it to run into its 
mouth (Figure la). By optimizing over individ­ual smaller spacetime windows overlapping in time, the 
cat s path is only influenced by local regions in spacetime (Figure 1b), resulting in a more realistic 
chasing action. 3.1 System Overview An overview of the Spacetime Windows system is given in Figure 2. 
Three separate processes communicate via stan­dard UNIX pipes and thus may reside on separate processors 
across a network. The graphical user interface (GUI) is writ­ten in C++ on top of X-windows/MOTIF. The 
user interface handles all communication between the user and the sys­tem and between processes, thus 
performing synchronization responsibilities. A symbolic manipulation process (SYM) is written on top 
of the symbolic algebra package, Maple [8]. SYM is responsible for symbolic simplification of the differential 
equations that describe the constraints and ob­jective. It is also responsible for symbolic differentiation 
of these equations with respect to the DOF. The spacetime op­timization system (SOS) parses the symbolic 
equations and their derivatives, evaluates the expressions at specific points in time, performs optimization 
steps and graphically reports results. Spacetime Windows System UdzR   I SYM symbolic Spsatime Pmczsdng 
Optimization I (Maple) 0kmLm USER Figure 2: The Spacetime Windows System Figure 3: Spacetime 3.2 Spacetime 
Spacetime refers to the set of all DOF over the entire an­imation sequence. In the context of figure 
animation, the space in spacetime refers to the DOF, or generalized co­ordinates that define a creature 
s position, e.g., the global position X, Y, Z) of the creature in space, or the angle of an elbow or 
!(nee. The value of each DOF varies across time and is thus represented as a function of time, t (Figure 
3). The set of DOF functions, (or simply DOF), will be denoted by X, with reference to a particular DOF 
as X,. Constraints or the objective imposed on the DOF may be any second order differential function 
of the DOF, C(X, X, X, t) and are thus differential junctional (differential functions of functions). 
The set of constraints are denoted C, with a particular con­straint Ci, and the objective, R. Constraints 
may be expressions that should be true at a par­ticular point in time, (e.g., the ball should be at a 
particular position at a particular time), or may express a relation­ship that should be true at all 
time or over a limited range of times, (e.g., the force on the ball in the vertical direc­tion plus the 
force of gravity equals its vertical acceleration). Constraints that exist over time are dkcretized 
in time into a set of constraint instances, C, with a particular instance Ci,l, now a function of scalar 
values for the DOF and their first two derivatives at specific times. Similarly, the DOF functions, are 
approximated from a set of dkcrete cent rol points, S, that at a particular iteration have values. S1.. 
The optimization rmoblem can then be ,~. . appro~mated as finding a set of values for S that minimize 
R subject to the constraint instances, C. 3.3 B-Spline Approximation For the numerical evaluation of 
the constraints and the OL jective it is necessary to evaluate the DOF and their first two derivatives 
at specific points in time. First and second derivatives of the constraint instances with respect to 
the control points must also be evaluated for the numerical op­timization. For these values to be defined 
at all times the X must be at least C2. Earlier work relied on the use of finite difference techniques 
for the derivatives [36], but these are well defined only at the discrete time values used in the discretization. 
Here, cubic B-spline curves [3] have been cho­sen to represent the DOF. Uniform cubic B-spline curves 
are approximated by a set of control points that are blended to­gether by a set of cubic B-spline blendlng 
functions. The blending functions in turn are derived from a set of knot values over the parameter of 
time. The B-splhe curve is then defined by: N1+2 1= 2 where the B-splines, Bj, are non-zero over four 
spans be­tween knot values, and SJ,l are the values of the jth DOF S control points. Issues such as how 
to deal with end condi­tions, and much greater detail on this topic can be found in tbe extensive literature 
on B-splines [12; 3; 25]. The time derivatives of the DOF, XJ (t), are obtained from the time derivatives 
of the B-spline: 1=-2 1= -2 The derivatives of the DOF with respect to the control point are simply 
the B-spline itself and zero: ax,(t)LYx, (t) ~ = B/(t) and y  f3sj,l Finally, the derivatives of the 
constraint instances (or ob­jective integrand with respect to the control points can be found with the 
c1 ain rule: The partial derivatives of the constraints with respect to the DOF are solved analytically 
in SYM, and evaluated numer­ically for each instance of the constraint. The derivatives of the DOF with 
respect to the control points are independent of the value of the control points themselves, and are 
thus only a function of time and the knot vector. The fact that B-splines are non-zero over a limited 
range of parameter (i.e., time) values creates a desired locality be­tween changes in control point values 
and the shape of the 2% resulting curve. This leads to a sparse Hessian matrix used in the numerical 
stage of the optimization. Particular DOF with rapidly changing values over a particular region can be 
refined [5; 9]. 3.4 Constraints and Objective Two classes of constraints are those provided directly 
by the user, and those derived from a physical description of the creature and its environment. A typical 
user constraint may be that the toot must be in a particular position at a par­ticular time, or that 
a hand and bail must coincide during a specified time interval. Constraints can also be specified as 
inequality constraints, or as conditional constraints (i.e., enforced only during times when some condition 
is met). Physical constraints arise from the equations of motion for a particular creature. The simplest 
example is that of a point mass for which a direct application of Newton s second law applies. Constraints 
may take the form of any second order differential equation of the DOF. They may contain references to 
constants that can be set and changed by the user during the animation design process. Constraints them­selves 
can also be added, deleted or modified. Equations of motion for the linkages are automatically derived 
through a lisp code [11] from a Denavit-Hartenberg description of the linkage [10]. The lisp code generates 
the symbolic equations of motion through a Newton-Euler formulation, that results in equating generalized 
forces and torques with differential expressions of the DOF. These forces become symbols for the corresponding 
expressions and can then be used as subex­pressions in other constraints and the objective. The objective 
is defined as a sum of integrals of the squares of sub-objectives. Sub-object ives are simply expressions 
with the same syntax ss those for constraints. For example, if one wants to minimize the torque at the 
elbow, the expression for the torque is added to the set of sub-objectives. 3.5 Subexpressions Forces 
are eliminated as explicit DOF (ad thus the corre­sponding control points are not required) by symbolic 
sub­stitution of the force s subexpression for all references to the force in any constraint or sub-objective. 
This symbolic solu­tion for the physical constraints eliminates a large number of constraint instances 
that were required in previous work to hold the value of a force equal to its corresponding differ­ential 
expression. In addition to subexpressions for forces derived from the equations of motion, user defined 
sub expressions are of rest 7 utility. For example, the location of an end-effecter e. ., 7 the hand 
at the end of an arm, (HandX, HandY, HandZ ) can be specified as a set of subexpressions derived from 
the Denavit-Hartenberg notation. These can then be used to hold the ball in the hand, HandXIO, 7 1 13X[0, 
7 1, (and likewise for HandY and HandZ). The use of subex­pressions simplifies the numerical optimization 
problem by reducing both the number of DOF and constraint instances. Derivatives of expressions containing 
subexpressions are gen­erated symbolically with the chain rule. 3.6 Non-linear Constrained Optimization 
General non-linear constrained optimization remains an un­solved problem [17; 13; 14; 26; 31]. The procedures 
that are currently used to solve general optimization problems are often described as an art . The art 
of selecting appropriate algorithms, starting values, and parameters of the numeri­cal process relies 
on experience and an understanding of the Computer Graphics, 26,2, July 1992 problem being solved. The 
animator s understanding of the desired motion, plus an intuitive understanding of what de­fines correct 
motion is brought to use through interactive monitoring and guidance of the numerical process. The user 
interface to the iterative process is discussed in section 4. 3.6.1 Minimization of the Lagrangian It 
is easily shown that in the case of an unconstrained mini­mization problem, a local minimum will occur 
only at points where all partial derivatives of the objective with respect to the control points vanish. 
Similarly, in the constrained prob­lem, the gradient of the objective must be equal to some linear combination 
of the constraint gradients for the so­lution to represent a constrained minimum. This leads to the formulation 
of the Langrangian of the constrained prob­lem, that represents an equivalent unconstrained problem, 
and can thus be minimized using methods for unconstrained problems. (liven the objectiv~, R, and the 
set of constraint instances, C ,, with control points, S, the Lagrangian is given by: L(S, A) = R(S) 
+ ~ A, C,(S) where the A, are referred to as Lagrange multipliers and correspond roughly to the influence 
of the constraints on the objective. Just w the unconstrained problem has a mininum when all partial 
derivatives are zero, the augmented problem also has a minimum when all partial derivatives of L with 
respect to the SJ and A, are zero. Given n control points and m constraint instances, a set of n + m 
homogeneous equations can be formed by taking the partial derivatives of L with respect to each of the 
elements of S and of 2, and setting them equal to zero. It should be noted that the partial derivatives 
of L with respect to the Lagrange multipliers are simply the constraints themselves, and thus setting 
them equal to zero solves the constraints implicitly. 3.6.2 Sequential Quadratic Programming By applying 
a combination of Lagrange s method and New­ton s method to the constrained objective, one can formulate 
a sequence of quadratic subproblems that lead towards a so­lution to the constrained optimization. To 
understand the method, we begin with the gradient of the Lagrangian at a local optimum (S., A,): VL(S*, 
A*) = o that must be zero as stated in the previous section. Consider a sequence of iterations beginning 
with an initial guess for S and the multipliers, ,1, (S., Ao), (the subscripts, k, are used here to indicate 
the iteration number. ) Expand­ ing the (k + l) t iteration into a first order Taylor series around the 
kth iteration and setting it equal to zero results in: = vLr + v2~k(~Sk,~Ak)T = O where: v~, L v?~L = 
v*R+ ~TV2C VCT v*L= v,~L v;~L ][ Vc o1 [ Using Newton s method, one can now construct a lin­earized 
system around the current guess for the animation, and equate the Hessian of the Lagrangian times a step, 
(6 Sk, ~~k), with the gradient of the Lagrangian. or since~~k = ~A+l ~k, one can solve fO1changes in 
state S, and directly for the next set of Lagrange multipliers, ~k+l : This defines a sequence of quadratic 
subproblems, thus the name Sequential Quadratic Programming, also known as Lagrange-Newton equations. 
Each step performs a mini­ mization of the Lagrangian subject to a linearized set of constraints. 3.6.3 
Linear Equation Solution and Line Search Each of the terms of the Hessian and the gradient in the above 
formulation is determined once analytically through symbolic differentiation of the constraints and the 
objective. Numeric values are then derived from the current guess for the control points and Lagrange 
multipliers. The B-spline formulation for the DOF ensures the sparsity of the Hessian of the Lagrangian. 
Finally, a solution of the Linearized sys­tem of equations above is obtained using a conjugate gra­dient 
method for sparse systems [31]. If the above linear system is rephrased simply as V* L . dS = vL, then 
the conjugate gradient process itself solves for tfS by performing a least squares minimization of (v2L 
. dS + vL)2, Problems may arise if the current guess is far from the solu­tion and the constraints are 
highly non-linear. A final modi­fication to the above procedure uses the solution for ask as a step direction 
and seeks a scalar, ~A that minimizes a merit function along a line Sk + ak~sk [26]. The merit function 
is taken to be a weighted sum of the constraint violations and the objective function. 4 User Interaction 
with the Optimization Process The graphical user interfaee is designed to provide control over constraint 
and objective specifications, and the pro ress and inspection of the optimization process. The GUI ? 
Fig­ure 4) is implemented with X-Windows/MOTIF and thus can be run on a variety of workstations. The 
interface is layed out in the following seven blocks of interaction wid­gets (from top to bottom) 1. 
Menu Bar: controls 1/0 such as input files to SYM, or output of numerical values for visual inspection. 
 2. Degrees Of Freedom: permits creation and inspection of DOF, the setting of DOF parameters such as 
bounds on the values, and inclusion and exclusion of specific DOF from the current spacetime window. 
Individual DOF motion curves (timelines) can be fi{terecfor shaken to help move a solution towards or 
away from local minima. Display of the DOF value, and its first or second derivative through time is 
also supported as an introspection tool into the optimization process. 3. Equations: permits creation, 
and modification of con­straints, objectives, and sub-expressions. This includes the definition and modification 
of the expression itself, the weighting of constraints and objectives, setting of the time scope of equations 
and displaying the equation values as a function of time.   play of DO F function values has been found 
very useful to confirm motion, and to understand the effects of such op­erations m filtering, shaking, 
and key framing. Display of expression values over time provides a rapid means to-exam­ine constraint 
violations, and suggest changing the wei ht of particular constraints and objectives when desired. #he 
most important visual feedback for the animation designer is the animation itself resulting from each 
successive iteration. 5 Results A series of experiments have been conducted with the Space­time Windows 
system. They include animating a variety of simple creatures ranging from a 2D point mass to jumping 
and ball throwing linkages. The simpler creatures provide a didactic format to understand the internal 
numerical fea­tures, while the more complex figures provide a better format for discussing the w.er interface 
and how an animator might use the system in a real setting. Experiments with an arm and ball and a planar 
acrobat are described below. ( ~omputationa.1 times given consist of both system and user time, and include 
the formulation of the Lagrangian prob­lem, matrix solution, and line search minimization. All tests 
were run on an IBM RS6000 model 530 workstation, with 48 Mb RAM. 5.1 Three-Link Arm and a Ball A three-link 
arm with a fixed shoulder position was an­imated, The arm s motion was confined to the plane, thus three 
generalized spatial DOF define its position, SHO(ILDER, ELBOW, and WRIST. Associated forces in this case 
consist of the torques exerted at each joint. The addition of a ball (point mass) adds two more spatial 
DOF and ,associated forces. Throwing a Ball Animating an arm throwing a ball requires a variety of con­straint 
and objective choices. Physical constraints make the ball fly in a natural way i.e., obey physical laws). 
Other constraints hold the ball in ti e hand until released and spec­ify a goal point for the ball to 
fly to. The free-flight and ball­iu-hand constraints must overlap in time by a short span (0.1 sec.), 
otherwise the ball could stay with the hand and simply jump to a new position to begin its flight. A 
short overlap in the time extent of the constraints creates a short interval when the hand must move 
along the parabolic path of natu­ral free flight as it releases the ball. Two further constraint sets 
(one for each DOF) specify the starting and ending po­sitions and velocity of the arm. Objectives that 
were used include minimizing the torques at the joints and the related, simpler objective without inertial 
force terms. Animating such a sequence with the Spacetime Windows system illustrates many of the features 
previously described. Windows, refinement, and key frames were used in combina­tion to achieve a desired 
animation. Given a single space­time window over the animation span with the constraints and objective 
described above and a starting position with the hand stretched out, the optimization quickly converged 
to an underhand toss in which the arm raises from the speci­fied downward hanging starting position, 
and flicks the wrist to toss the ball to its goal (Figure 5 a). Aside from minor discrepancies between 
the ball and hand position specified by subexpressions), all the constraints were met. b owever, although 
this may have represented a local minimum in the complex space of all possible ball throws, it may not 
have represented the animator s intention. Influence of Keyframes: Setting a few keyframes that roughly 
approximate an overhand throw caused the anima- Computer Graphics, 26, 2, July 1992 tion to converge 
to an overhand toss instead (Figure 5 b . This integration of a simple sketching system greatly ai d 
s the optimization search. A quite different result again was obtained by simply changing the X value 
of the goal point for the throw leading to a more rigorous overhand throw (Figure 5 c). The full animation 
resulted in 70 constraint instances and 135 control points, with iterations taking ap proximately 13 
seconds. Windows and Refinement: Although the ball was con­strained to be in the hand until rele=e, the 
ball was not held tightly in the hand, particularly near the time of release. This was in part due to 
the fact that the hand position was a function of three generalized coordinates, while the ball was a 
function of two global coordinates. In general, there will not be a set of control points for the joint 
angles and ball position that exactly satisfy the constraint for the ball to be in the hand. Creating 
a smaller spacetime window around the time of release and refining the B-splirte curve for the ball position 
quickly pulled the ball into a tighter agreement with the hand position. Finally, by removing all the 
DOF except the ball position from the spacetime window, very fast iterations further refined this process. 
  5.2 A Basketball Player A more complex creature W= created by adding a movable base to the arm above. 
The base was given three DOF, to move in the XZ plane, and rotate above the vertical axis. Thus the arm 
as a whole could move about the ground plane and rotate to throw the ball anywhere in the three dimen­sions 
(a third DOF for the ball was added). A similar set of experiments was conducted with this new creature. 
The variations of throws was now greater. For example, it would settle into a throw in which it would 
twist the base rapidly to throw sideways, rather than turn and then throw straight. The use of a few 
key frames wordd push the solution to one that was desired. Playing Catch with Itselfi A final sequence 
that was animated included the creature throwing the ball towards a goal point, then moving quickly to 
get in position to catch its own throw, and finally to throw the ball into a basket (Fig­ures 6,8). The 
catch required a similar set of overlapping constraints to have the hand move with the ball s trajec­tory 
for a short stretch before the ball was free to follow the hand s motion. The complete sequence included 
a series of spacetime windows and refinements. The full spacetime took approximately 20 seconds per iteration. 
As before, smafler spacetime windows were useful to tighten the animation par­ticularly at the time of 
the throw and catch.  5.3 Acrobat A final creature w= constructed of two links with four DOF, the two 
rotations at the FOOT and WAIST and two spa­tial motion DOF, X and Y to allow rigid body motion in the 
vertical plane. This creature is similar to the jumping Luxo lamp of the work in [36; 33]. Animations 
were cre­ated to simulate a series of jumps, In this cixiie, jumping was specified in much the same way 
as throwing a ball was defined. The foot was constrained to stay in fixed positions for short time intervals. 
Physically based free flight was re­quired during the inbetween intervals, but also overlapping each 
fixed position interval by 0.1 seconds. This insured that the body gained upward momentum to carry it 
into flight and brought itself to rest at the end of the jumps by continu­ing the motion of the creature 
s center of gravity for a short interval after landing. As in the case of the throw, multiple very different 
solutions formed in local minima of the con­strained objective. Key framed motion sketches moved the 
solutions between them. (a) (b) (c) Figure 5: Throwing a Ball (a) (b) (c) Figure 6: A Basketball Player 
 Figure 7: An Acrobat  References [20] KoRErN, J. U:, AND BADLER, N. I. Techniques for gen­ [1] [2] 
[3] [4] [5] [6] [7] [8] [9] [10] [11] [12] [13] [14] [15] [16] [17] [18] [19] ARMSTRONG, B., AND GREEN, 
M. The dynamics of articulated rigid bodies for purposes of animation. In Proceedings of Graphics Inter/ace 
(May 1986), Com­puter Graphics Society, pp. 407 415. BARAFF, D. Analytical models for dynamic simula­tion 
of non-penetrating rigid bodies. ACM Computer Graphics 29, 3 (July 1989), 223-232. BARTELS, R. H., BEATTY, 
J. C., AND BARSKY, B. A. An Introduction to S lines for Use in Corn uter Gra h­hits and Geometric ~odeling. 
Morgan Kar$mann, 19%. BARZEL, R., AND BARR, A. H. A modeling system based on dynamic constraints. In 
Proceedings of SIG- GRAPH 88 (Atlanta, Georgia, August 1-5, 1988) (Au­gust 1988), ACM, pp. 179-188. BOEHM, 
W. Inserting new knots into b-spline curves. IPC Business Press J,$?,4 (July 1980), 199-201. BROTMAN, 
L. S., AND NETRAVALI, A. N. Motion in­terpolation by optimal control. In Proceedings of SIG-GRA PH 88 
(Atlanta, Georgia, August 1-5, 1988) (Aug. 1988), vol. 22, ACM, pp. 309-315. BRUDERLIN, A., AND CALVERT, 
T. Goal-directed, dy­namic animation of human wzJking. ACM Computer Graphics 23, 3 (July 1989), 233-422. 
CHAR, B. W., GEDDES, K. O., GONNET, G. H., MON-AGAN, M. B., AND WATT, S. M. MAPLE Reference Manual Fijth 
edition. Waterloo Maple Publishing, Wa­terloo, bntario, 1988. COHEN, E., LYCHE, T., AND RIESENFELD, R. 
Dis­ c~ete b-splines.and subdivision techniques in ~omputer­mded geometric design and computer graphics. 
Com­puter Graphics and Image Processing 14, 2 (October 1980), 87-111. CRAIG, J. J. Introduction to Robotics. 
Addison-Wesley, Reading, MA, 1986. DRISKILL, H. Symbolic kinematic and dynamic equ~ tions of motion. 
LISP code (1990). FAUX, 1., AND PRATT, M. Computational Geometry ~9;9Design and Manufacture. Ellis Horwood 
Limited, FLETCHER, R. Practical Methods oj Optimization, Vol. 1 and 2. John Wiley and Sons, 1980. GILL, 
P. E., AND MURRAY, W. Numerical Methods jor Constrained Optimization. Academic Press, 1974. GIRARD, M. 
Interactive design of 3d computer­ animated legged animal motion. IEEE Computer Graphics and Applications 
7, 6 (June 1987), 39-51. HAHN, J. Realistic animation of rigid bodies. In Pro­ ceedings of SIGGRA PH 
88 (Atlanta, Georgia, August 1-5, 1988) (August 1988), ACM, pp. 299-308. HIMMELBLAU, D. M. Applied Nonlinear 
Programming. McGraw-Hill, New York, 1972. ISAACS, OP. M., AND COHEN, M. F. Controlling dy ­ namlg slmulati.on 
with kinematic constraints, behavior functions, and reverse dynamics. In Proceedings of SIG-GRAPH 87 
(Anaheim, California, July ,27-31, 1987) (Ju]y 1987), ACM, pp. 215-224. ISAACS, P. M., AND COHEN, M. 
F. Mixed methods for kinematic constraints in dynamic figure animation. The Visual Computer 4 (1988). 
erating goal-directed motion of articulated structures. IEEE Computer Gmphics and Applications 2, 6 (Nov. 
1982), 71-81. [21] LEE, P., WEL S., ZHAO, J., AND BADLER, N. I. Strength guided motion. In Proceedings 
oj SIG-GRAPH 90 (Dallas, Texas, August 6-10, 1990) (Au­gust 1990), ACM, pp. 253-262. [22] MAGNENAT-THALMANN, 
AND THALMANN. Computer ~9ni5mation: Theory and Practice. Springer Verlag, [23] MC KENNA, M., AND ZELTZER, 
D. Dynamic simula­tion of autonomous legged locomotion. In Proceedings of SIG GRAPH 90 (Dallas, Texas, 
August 6 1 O, 1990) (August 1990), ACM, pp. 29-38. [24] MILLER, G. S. P. The motion dynamics of snakes 
and worms. In Proceedings oj SIG GRA PH 88 (A tlont a, Geoqia, August 1-5, 1988) (August 1988), ACM, 
pp. 169-173. [25] MORTENSON, M. E. Geometric Modeling. John Wiley and Sons, New York, 1985. (26] PAPALAMBROS, 
P. Y., AND WILDE, D. J. Principles oj Optimal Design. Cambridge University Press, Cam­bridge, England, 
1988. [27] PENTLAND, A., AND WILLIAMS, J. Good vibrations: Modal dynamics for graphics and animation. 
In Pro­ceedings of SIGGRAPH 89 (Boston, Mass., July 31 Aug 4, 1989) (July 19S9), ACM, Pp. 215-222. [28] 
PHILLIPS,C. B., ANDBADLER,N. I. Interactive be­ haviors for bipedal articulated figures. vol. 25, ACM, 
pp. 359-362. [29] PHILLIPS, C. B., ZHAO, J., AND BADLER, N. 1. inter­ active real-time articulated figure 
manipulation using multiple kinematic constraints. In Proceedings oj Sym­posium on Interactive SD Graphics 
(Snowbird, Utah, March, 1990) (Mar. 1990), vol. 24, ACM, pp. 245-250. [30] PLATT, J., AND BARR, A. H. 
Constraint methods for flexible models. In Proceedings of SIGGRAPH 88 (Atlanta, Georgia, August 1-5, 
1988) (August 1988), ACM, pp. 279-288. [31] PRESS, W. H., AND FLANNERY, B. Numerical Recipes: The Art 
of Scientific Computing. Cambridge UniverSit y Press, 1986. [32] RAJEIERT,M. H., AND HODGINS, J. K. Animation 
of dynamic legged locomotion. siggraph91 4, 25 (1991), 349-358. [33] VAN DE PANNE, M., FIUME, E., AND 
VRANESXC, Z. Rensable motion synthesis using state-space controllers. In Proceedings of SIGGRA PH 90 
(Daiias, Texas, Au­gust 6-10, 1990) (August 1990), ACM, pp. 225-234. [34] WILHELMS, J. Using dynamic 
analysis for realistic ani­mation of articulated bodies. IEEE Computer Graphics and Applications 7, 6 
(June 1987), 12 27. [35] WITKIN, A., FLEISCHER, K., AND BARR, A. Energy constraints on parameterized 
models. In Proceedings oj SIG GRAPH 87 (Anaheim, California, July 27 31, 1987) (July 1987), vol. 21, 
ACM, pp. 225-232. [36] WITKIN, A., AND KASS, M. Spacetime constraints. In Proceedings of SIG GRAPH 88 
(Atlanta, Georgia, Au­gust 1-5, 1988) (July 1988), ACM, pp. 159-168. [37] WITKIN, A., AND WELCH, W. Fast 
animation and control of nonrigid structures. In Proceedings of SIG-GRAPH 90 (Dallas, Tezas, August 6-10, 
1990) (Au­gust 1990), ACM, pp. 243-252.   
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134084</article_id>
		<sort_key>303</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>35</seq_no>
		<title><![CDATA[Dynamic simulation of non-penetrating flexible bodies]]></title>
		<page_from>303</page_from>
		<page_to>308</page_to>
		<doi_number>10.1145/133994.134084</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134084</url>
		<categories>
			<primary_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Animation</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Curve, surface, solid, and object representations</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>G.1.2</cat_node>
				<descriptor></descriptor>
				<type></type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010399</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Parametric curve and surface models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003752.10003809.10003636</concept_id>
				<concept_desc>CCS->Theory of computation->Design and analysis of algorithms->Approximation algorithms analysis</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010401</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Volumetric models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002950.10003714.10003736.10003737</concept_id>
				<concept_desc>CCS->Mathematics of computing->Mathematical analysis->Functional analysis->Approximation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010352</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Animation</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
			<gt>Design</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>PP39038146</person_id>
				<author_profile_id><![CDATA[81100334025]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[David]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Baraff]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Program of Computer Graphics Cornell University Ithaca, NY]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P18516</person_id>
				<author_profile_id><![CDATA[81100295587]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[Andrew]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Witkin]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[School of Computer Science, Carnegie Mellon University, Pittsburgh, PA]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_obj_id>74356</ref_obj_id>
				<ref_obj_pid>74334</ref_obj_pid>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[D. Baraff. Analytical methods for dynamic simulation of nonpenetrating rigid bodies. In Computer Graphics (Proc. SIG- GRAPH), volume 23, pages 223-232. ACM, July 1989.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_obj_id>97881</ref_obj_id>
				<ref_obj_pid>97880</ref_obj_pid>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[D. Baraff. Curved surfaces and coherence for non-penetrating rigid body simulation. In Computer Graphics (Proc. SIG- GRAPH), volume 24, pages 19-28. ACM, August 1990.]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_obj_id>165682</ref_obj_id>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[D. Baraff. Dynamic Simulation of Non-penetrating Rigid Bodies. PhD thesis, Cornell University, May 1992.]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_obj_id>1096889</ref_obj_id>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[J.E. Dennis, Jr. and R.B. Schnabel. Numerical Methods for Unconstrained Optimization and Nonlinear Equations. Prentice Hall, Inc., 1983.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[C. Lanczos. The Variational Principles of Mechanics. Dover Publications, Inc., 1970.]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_obj_id>74355</ref_obj_id>
				<ref_obj_pid>74334</ref_obj_pid>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[A. Pentland and J. Williams. Good vibrations: Modal dynamics for graphics and animation. In Computer Graphics (Proc. SIGGRAPH), volume 23, pages 215-222. ACM, July 1989.]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[W.H. Press, B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling. Numerical Recipes. Cambridge University Press, 1986.]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378522</ref_obj_id>
				<ref_obj_pid>54852</ref_obj_pid>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[D. Terzopoulos and K. Fleischer. Modeling inelastic deformation: Viscoelasticity, plasticity, fracture. In Computer Graphics (Proc. SIGGRAPH), volume 22, pages 269-278. ACM, August 1988.]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_obj_id>565650</ref_obj_id>
				<ref_obj_pid>97879</ref_obj_pid>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[A. Witkin and W. Welch. Fast animation and control of nonrigid structures. In Computer Graphics (Proc. SIGGRAPH), volume 24, pages 243-252. ACM, August 1990.]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 Computer Graphics, 26, 2, JUIV1992 Dynamic Simulation of Non-penetrating Flexible Bodies Datid Barufl 
Program of Computer Graphics Cornell University Ithaca, NY 14853 Abstract A model for the dynamic simulation 
of flexible bodies subject to non-penetration constraints is presented. Flexible bodies are de­ scribed 
in terms of global deformations of a rest shape. The dynam­ ical behavior of these bodies that most closely 
matches the behavior of ideal continuum bodies is derived, and subsumes the results of earl ier Lagrangian 
dynamics-based models. The dynamics derived for the flexible-body model allows the unification of previous 
work on flexible body simulation and previous work on non-penetrating rigid body simulation. The non-penetration 
constraints for a system of bodies that contact at multiple points are maintained by analyt­ ically calculated 
contact forces. An implementation for first-and second-order polynomially deformable bodies is described. 
The simulation of second-order or higher deformations currently in­ volves a polyhedral boundary approximation 
for collision detection purposes, 1. Introduction In this paper we present a new formulation for the 
dynamics of flexible bodies that covers collisions and continuous contact as well as free motion. The 
model, which draws on the flexible-body model proposed by Witkin and Welch[9] and on the analytical contact 
force model for rigid bodies presented by Bara~ 1,2], centers on the idea that flexible body simulation 
can be greatly simplified through the introduction of a suitable geometric approximation. By restricting 
the body s changes of shape to those that can be represented by a global parametric deformation, we solve 
two problems that plague conventional local formulations: tirst, the dimensionality of the simulation 
is reduced, and second, the severe numerical problems to which local interactions can give rise are eliminated. 
Because it is restricted by the geometric approximation, the flex­ible body s behavior generally exhibits 
error when compared to the behavior of an ideal continuum body under like conditions. Whether this approximation 
error is acceptable depends on factors such as the materials and forces being modeled, and the purpose 
of the simulation. In any case, once an approximation has been adopted it is clearly desirable to minimize 
the resulting error. Our formulation is derived from the criterion of minimal approx­imation error. Following 
a brief discussion of local models and the problems they introduce, we will review the global model of 
Wkkin and Welch, and show that their formulation for free body motion is in fact the minimal error solution. 
Then we will consider the prob­lem of collision-response for flexible bodies. Collisions between Permission[o 
copywithoutfcc all or part of this material is granted provided that the copies are not made or distributed 
for direct commercial advantage, the ACM copyright notice and the litle of the publicatimr and its date 
appear, and notice is given that copying is by permission of the Association fnr Computing Machinery. 
To copy otherwise, or 10 rcpubiish, requwcs a fee and/or specific permission. Andrew Witkin School of 
Computer Science Carnegie Mellon University Pittsburgh, PA 15213 rigid bodies are generally modeled 
as instantaneous events through the use of impulses. [n the case of flexible bodies, this would be inappropriate, 
since we are interested in seeing them compress and rebound. The minimal error criterion leads us to 
a two-phase model in which an initial impulse prevents inter-penetration, followed by a non-impulsive 
phase of continuous contact in which the body compresses due to its own momentum, then rebounds due to 
the buildup of internal strain energy. Finally, we extend Baraff s ana­lytic contact force model to flexible 
bodies, discuss implementation issues for polynomial deformations, and present simulation results. 1.1 
Local models and the problem of stiffness Traditional models for flexible bodies. including finite difference, 
finite element, and mass-and-spring lattice models, approximate the deviation of a continuum body from 
its rest shape in terms of dis­ placements at a finite number of points called nodal poinl.r. Given a 
sufficient density of nodal points, these formulations can represent essentially any deformation. AI 
the other end of the spectrum, continuum bodies whose deformations are considered small enough to k neglected 
can be approximated as rigid bodies, which are free only to translate and rotate. Obviously, the rigid 
body formulation cannot be applied to bodies whose deformation we do not wanr to neglect, This is unfortu­nate 
because nodal formulations tend to give rise to stiff differen­tial equations which are difficult to 
solve numerically. The basic problem is that nodal formulations model global phenomena for example, acceleration 
of the whole body due to a point force only via local interactions among adjacent nodes. The compression 
waves that translate these local interactions into large-scale effects involve deformations that are 
generally far too small and fast to play a significant role in computer animation, the more so as the 
mechanical stiffness of the flexible body is increased. Even so, if ordinary numerical methods are used, 
it is these high-speed effects rather than the phenomena of primary interest that dictate the size of 
the time steps, with potentially disastrous effects on performance[7j. Where it applies, the rigid body 
approximation sweeps these prob­lems away by eliminating local interactions altogether: the only degrees 
of freedom a rigid body has are the global ones that govern its position and orientation. Modeling of 
flexible body collisions and contact raises additional problems for the nodal formulation. In particular, 
collisions are difficult to handle because they usually involve extremely large tran­sient forces and 
accelerations which, like any others, must operate strictly through local interactions. Hence the usual 
stiffness problem is exacerbated, Things are made still worse if penalty methods[ 1,3] (another local 
model) are used to enforce non-penetration con­straints, since these introduce stiffness problems of 
their own. (.)IW2 ACM-O-89791-479-1/92/(1)7/0303 $01.50 303 SIGGRAPH 92 Chicaao, JUIY26-31, 1992 1.2 
Global models Witkin and Welch[9] present a flexible-body model that repre­sents a compromise between 
the extremes of the nodal and rigid formulations. Changes in the body s shape are approximated neither 
by nodal displacements nor by rigid body transforrnations, but by global deformations that apply a parametric 
space wa@ to all points in the body. This global formulation constrains the range of deformations that 
the body can undergo to those that can be represented by the chosen deformation function. However, because 
the shape parameters are global in their effect, the stiffness problems due to local interactions are 
eliminated, as in the rigid case. In a dif­ferent flexible-body formulation, Pentland and Williams[6] 
achieve much the same goal by linearizing the dynamic model, then using modal analysis to eliminate high-frequency 
vibrations. We prefer the formulation used in Wltkin and Welch primarily because, as we will see in the 
next section, it minimizes the error due to the geo­metric approximation, whereas the consequences of 
the dynamics­based approximations of Pentland and Williams are more difficult to assess. 1.3 Collision 
and contact Bara~ 1,2] presents an analytical method for computing contact forces between corrtigurations 
of rigid bodies. Contact forces are computed by solving simultaneous equations that reflect all of the 
forces acting on all of the bodies. Thus, an external force acting on one body has an immediate effect 
on any contacting bodies. The formulation of the contact forces as a global problem eliminates the stiffness 
problems encountered by the penalty method for contact forces. To complete our global formulation, we 
will adapt this method to deal with flexible bodies.  2. Global Deformations In this section, we will 
define the basic global formulation for flexible bodies used throughout this paper. As stated in the 
introduc­tion, rather than describe the shape of a deformed body in terms of some number of nodal points, 
a body s shape is described in terms of a global deformation function D4, where q is a vector of parameters 
that controls the deformation. The function Dq maps Rs onto itsel~ Dq describes the deformed shape of 
a body by mapping each point p of the body s rest shape to the point D, (p). 2.1 The dynamics of global 
deformations Our goal in deriving the dynamical behavior of our flexible-body model is to relate the 
forces acting on a body to the acceleration of the control parameters q, in a generalization of the familiar 
equation ~ = ma. That is, given the control parameters q, and the first derivative cj, we want to express 
ij in terms of q, ~, and any forces acting on the body. We want the motion prescribed by this ~ to have 
the minimum possible deviation from the motion of an ideal continuum body. The expression for ~ derived 
in this paper that minimizes the deviation matches the expression derived by the earlier work of Witkin 
and Welch[9] using Lagrangian dynamics; thus, we show that the Lagrangian dynamics formulation satisfies 
our minimal approximation error criterion. The model of collision­response derived in section 3.2 is 
also based on a minimum error criterion. In the derivations in this paper, bodies are parameterized by 
a coordinate p in body space, which ranges over some fixed volume. The density of the body at any point 
p in body space is denoted as p(p). If we let q([) describe the stale of the body as a function of time, 
then at time t, Dg(,) specifies how the body is mapped from body space into world space. Specifically, 
at time t the deformed body has density p(p) at the world space point D,(,) (p). In an ideal continuum 
body, the acceleration at any point is given by the standard equation $ = ma. An ideal continuum body 
is therefore completely unconstrained in its motion, and can be de­ formed into any arbitrary shape, 
by appropriate forces. In contrast, global deformations represent a constraint, limiting the allowable 
deformations, and thus the motion, of a body. Because of this constraint, the acceleration a of a point 
with mass m, in response to a force,,f~ will not in general satisfy a = f/m. The best we can do is to 
mmlmize the deviation of the actual acceleration a, from the ideal acceleration f/m, To measure the total 
acceleration deviation for the entire body, we will integrate the acceleration deviation at each point 
over the entire volume of the body. Let the net force in world space acting on a body be described as 
a vector-valued function f(p) over the body. The force function f includes external forces such as gravity, 
internal forces due to deformation, and forces due to contact. If we let a(p) denote the acceleration 
at each point of the body, then a(p) would be ideal if it always satisfied a@) = f(p)/p@), or equivalently, 
ati) ~(p) /P(P) = 0.W will measure the net acceleration error E from this ideal acceleration for the 
entire body by writing where p ranges over the volume of the body in world space. The deviation is mass-weighted, 
since the error contributed by an accel­ eration deviation in some region of the body should grow linearly 
with the density in that region. Using E, we can relate the accelera­ tion of the control parameters 
to the net force function ~ by requiring that q be chosen so as to minimize E. However, the error E detirred 
by equation ( 1) is the same as a quantity named by Gauss as the constraint of a system. Gauss formulated 
a principle called the principle of least constraiw that asserts that the motion of a system subject 
to constraints always minimizes the constraint , namely equation ( I). The principle of least constraint 
yields the same result for constrained motion as is given by Lagrange s equation of motion[5]; thus, 
our notion of motion satisfying a minimal error criterion is equivalent to treating bodies as mechanical 
systems and defining their motion in terms of the very well known Lagrangian dynamics. 2.2 Linear deformations 
The previous section describes the dynamics when the deforma­ tion function Dg,,) is arbitrary. For the 
remainder of this paper, we will limit ourselves to deformations Dqf,~(p) that depend linearly on q, 
but may vary non-linearly with respect to p. Rather than describe the state in terms of a vector q(t), 
we will switch notation and define the state as a matrix R([); correspondingly, D~[,) denotes the defor­mation 
function specitied by R(r). The fact that the deformation D~lr) is linear with respect to l?(t) means 
that 11~(,~must have the form D,(,)(p) = R(r)Z(p) (2) where Z(p) is a vector-valued function that does 
not depend on ei­ther r, or R. This restriction greatly simplifies some of the dynamics equations, while 
still allowing much latitude in the choice of the deformation function D. Note the Z(p) need not be a 
linear function ofp. A deformation that is quadratic in the undeformed coordinates could be specified 
by z(p) = [p:, p;. p:. p\p\, p\p:, p\ P:, Pt. P\. P=! IIr (3) with R(r) a 3 x 10 matrix, Clearly, polynomial 
deformations of any order can be expressed in terms of deformations that are linear with respect to the 
state. Second-order polynomial deformations in particular are fairly liberal in terms of the allowable 
deformations of a body. Section 4 will discuss the details of implementing first­and second-order polynomial 
deformation functions. Computer Graohics, 26.2. .Julv 1992 From the previous section, we know ~hat we 
can use Lagrangian dynamics to relate ~(r) to R(I), k(f). and the force ,f (p) with mini­mal error. Witkin 
and Welch[Y] derive the relation R(J) = Q(f)M 1 (4) where M is a constant square matrix und Q(r) is a 
matrix of the generalized net force acting on the body. The matrix M is delined by M. /)(/ ))Z(/))z(/)) 
 (/1 (5) / which yields a square matrix of size H, where H is the dimension of the column vector Z(p). 
Additionally. M is both symmetric and positive definite. The matrix Q(t) has dimension 3 x n. Generalized 
force Q is related to force in R7 as follows: ti force ~ in R] acting on the point D~(,~(p) in world 
space yields the matrix of generalized force jZ(p) . Note that both ,f and Z(p) are column vectors. so 
that the outer product ,fZ(p ) yields a 3 x ~]matrix. For bodies with a complicated rest shape, the 
integral of equa­ tion (S) is difticult to calculate analytically. Since M is constant bowever. it can 
be calculated off-line of the simulation process by numerical techniques: currently. we use Monte-Carlo 
integration to precompute M. Thus. all that is required to simulate the motion of these flexible bodies 
is tbe solution of equation (4). This is done by converting equation (4) (o the coupled first-order ordinary 
differential equation (6) Tbe remaining lask is to evaluate the generalized force Q( I), which subsumes 
ex[emal forces, internal forces, and any contact forces acting on the body. External forces are by definition 
forces that are known to us at time /. such as gravity, or viscous damping. In the next section, we show 
how internal forces due to deformation may be calculated, Section 3 discusses the computation of tbe 
contact forces included in Q(f). 2.3 Potential energy functions of linear deformations The internal 
forces that act to restore a flexible body to its rest shape are specitied in terms of the derivative 
tN /8R of a potential energy function V[9]. For most physical bodies. potential energy functions can 
be described in terms of the me[ri( tensor of a body. (Internal damping forces are calculated similarly 
in terms of the metric tensor and its time derivative, ) For affine deformations, the metric tensor (and 
its time derivative), at any instant of time, are constant over the volume of a body: thus, evaluating 
integrals of the metric tensor over the body volume is trivial. However, for non­affine deformations, 
the metric tensor can vary over the volume of a body: if the body s shape is complex, the integrals needed 
to compute t)t /dR can be difficult to evaluate. Our choices are to either calculate the integrals analytically, 
or use a numerical approximation. For polynomial deformations, integrals involving the metric tensor 
can be expressed as a linear combination of integrals that are independent of R((). These inte­grals 
are weighted by functions of R(t) and summed to compute W I?)R. Internal damping forces are computed 
similarly as a linear combination of precomputed integrals, weighted by functions of both R(I) and ~(f). 
However, even for tbe second-order polynomial deformations we have implemented. the necessary expansion 
of precalculated integmls is quite large. An alternate technique is to simply approximate the integrals 
by evaluating the integrand at some finite number of points scattered throughout the body. This has the 
virtue of being trivial to implement, and may also be more general in dealing with complex energy functions 
that allow for (0) (b) 1 Figure 1: (a) Non-penetration is enforced by preventing only the four contacting 
vertices from moving below the plane. (b) The entire lower rim oft he cylinder must be prevented from 
moving below the plane. plasticity or fracmre[8 ]. For second-order polynomial deforma­tions, a small 
number of sample points (on the order of fifty) yields adequate results.  3. Non-penetration Constraints 
The derivation for the contact forces between flexible bodies that prevent inter-penetration closely 
parallels the derivation of contact forces between rigid bodies in Baraff[ 1,2]. The most notable dif­ference 
arises when considering collision> between bodies, and is detailed in section 3.2. 3.1 Contact geometry 
restrictions In considering contact between bodies, we will make the as­sumption that contact between 
bodies can be described in terms of finitely many contact points. That is. we will restrict ourselves 
to contigumtions in which inter-penetration can be prevented globally by enforcing a finite number of 
local constraints. As an example, consider figure 1, If all the bodies involved are rigid, then in figure 
la, inter-penetration is prevented globally between the cube and the plane by enforcing the four local 
constminti that each vertex of the cube in contact with the plane remain on or above the plane, However, 
to prevent the cylinder in figure Ib from dipping below the plane and inter-penetrating, while still 
allowing it to tip over arbitrarily, we must constrain eu(h of the infinitely many boundary points on 
the lower cylinder to remain on or ahove the plane. Thus, we do not allow contiguratiom such as figure 
Ib. For bodies whose deformations are aftine functions of the material co­ordinates (as well as rigid 
bodies), polyhedral contact regions are allowed (figure 2a). However, for till other deformations, configu­rations 
such as tigure Ia cannot be allowed, A deformation which caused the contact face of tbe cube to curve 
could result in inter­penetration even if the vertices of the Pace were prevented from inter­penetrating 
the plane (figure ?b). Section 4.2 describes a geomet­ric polyhedral boundary di~cretizalion that permits 
the simulation of configurations with one-or two-dimensional polygonal contact regions when arbitrary 
deformation functions we allowed. This ap­proximation is somewhat unsatisfactory; a non-discretized method 
for dealing with situations like figure 2b would be preferable. 3.2 Colliding contact Having described 
the geometry of contact, we can now consider the dynamics of contact. When bodies initially come into 
contact at a point p, , we say a collision has occurred. In order to maintain tbe non-penetration constmint 
between the two bodies, at least one SIGGRAPH 92 Chicago, July 26-31, 1992 (a) (b) rest linear non-linear 
shape deformation deformation Figure 2: (a) Affine deformations allow polyhedral contact re­gions, because 
inter-penetration can be prevented with finitely many local constraints. (b) For non-linear deformations, 
pre­venting the vertices from moving below the plane does not nec­essarily prevent inter-penetration. 
of the two contact surfaces must undergo a velocity discontinuity at the contact point. Otherwise, some 
amount of inter-penetration would occur in the vicinity of the contact point. Since rigid bodies cannot 
deform at all, in the case of a collision between two rigid bodies, every point on the rigid body ex~riences 
a velocity discon­tinuity. This implies an abrupt change in momentum, which can only be accomplished 
by an impulse. Collisions can be quantified in terms of the energy lost: a collision cart be completely 
elastic, meaning no energy is lost, or completely inelastic, meaning that the kinetic energy of both 
bodies is completely dissipated (measured with respect to a center of mass coordinate system). For rigid 
body collisions, this energy loss is instantaneous. Immediately after a collision, bodies bounce apart 
with a velocity that depends on the elasticity of the collision. In contrast, the collision process for 
flexible bodies takes some non-zero amount of time. During that time, the colliding bodies remain in 
contact with each other. To derive a collision-response model for our flexible bodies, we will use a 
variational principle. To motivate such a derivation, let us consider the case of a one­dimensional rod 
colliding with a fixed obstacle. The rod is dis­cretized into n mass points. Since this example is one-dimensional, 
each mass point may undergo displacement either left or right. The mass points are numbered left to right, 
from I to n (figure 3). When the first mass point collides with the fixed obstacle, its velocity must 
discontinuously change to zero, to prevent inter­penetration. However, the velocity of the other mass 
points of the rod are unchanged. In particular, as the second mass point continues with its original 
velocity, the distance between the first and second mass point decreases. As this distance decreases, 
an internal force acts to repel the two mass points. This has the effect of deaccelerating the second 
mass point, which means that the distance between the second and third mass point decreases; clearly, 
this effect propagates throughout the entire rod. While this is happening, the fixed obstacle has been 
exerting a (non-impulsive) contact force on the first mass point, to prevent the repulsive internal force 
from accelerating the first mass point leftwards. After some finite period of contact, the internal forces 
cause the rod to bounce away from the obstacle. If there is no damping, the only energy lost will be 
due to the dissipation of the kinetic energy of the first mass point. However, in the limit as n goes 
to infinity, the mass of this point, and thus its initial kinetic energy, both go to zero. Even though 
a velocity discontinuity occurs (at the left end of the bar), the actual change in momentum is zero, 
and thus no energy is lost. If we wish to model collisions with some amount of inelasticity, we must 
impose damping forces on the body that dissipate energy during the collision. The collision-response 
model for our constrained flexible bodies is based on this analysis. As in the rigid body case, we will 
need 1 23 ... n   1------­ impulse contact force + contact ~ Fieure 3: A discretized rod collides 
with an immovable obstacle. Miss 1 s velocity changes instantaneously to zero upon impact­ing the obstacle. 
As mass 2 approaches mass 1, an internal force between the two acts, pushing mass 1 Ieftwards. A contact 
force acts rightwards on mass 1 to prevent inter-penetration. to apply an impulse at the contact point 
to prevent immediate inter­penetration. This means that some kinetic energy must be lost, and we cannot 
attain a perfectly elastic collision. This is a consequence of limiting the allowable deformations of 
the body. After the im­pulse has been applied, the bodies will no longer be colliding, and a non-impulsive 
force (described in the next section) will act at the contact point to prevent inter-penetration. 1 As 
in section 2.1, we use an error measure to compare the collision-response of our flexible-body model 
with the collision­response of an ideal continuum body. To measure the net collision­response, we generalize 
equation ( 1) to obtain a new error measure E given by P E =+ P(P)lAV(P)12dV (7) 1 where Av(p) is the 
change in velocity in response to art impulse. For art ideal continuum body, Av@) is zero everywhere 
except at the point of collision and E is zero. For our flexible-body model, E measures the deviation 
between the actual change in velocity, Av(p), and the ideal change in velocity, which is zero. The correct 
instantaneous change AR(r) in the state velocity ~(r) is the one which minimizes E , subject to the kinematic 
constraints of the collision. From the description of the collision in figure 3, it seems intuitive that 
the correct course of action is to apply art impulse between two collidlng bodies at the point of contact, 
such that they just come to rest (relative to each other) at the contact point. In the absence of friction, 
the impulse should act normal to the contact surfaces. A standard constrained-minimization principle 
applied to equation (7) shows that the change in velocity AR(t) from such an impulse is in fact exactly 
the A~(I) which minimizes E , subject to the kinematic constraints of the collision. The actual computation 
of the impulse is trivial. For simplicity, let us consider a collision between a flexible body A and 
art immov­able, unreformable obstacle B with a well defined surface normal at the contact point p,.. 
The vector ri denotes the outwards pointing 1In general, the energy loss can be decreased by altering 
the deformation function D so that it allows the body more degrees of freedom. The limiting case, when 
D can represent any deformation, is the same as the limiting case for the discretized bar of figure 3 
when n goes to infinity. Obviously, neither case can be simulated without an infinite amount of computation. 
Computer Gra~hics. 26, 2, Julv 1992 Figure 4: lmcsact between a flexible body A and an immovable undeformabi~ 
body B. unit surtace normal of B at the contact point p, (figure 4). The generalization to the case 
when B is an ordinary rigid or deformable body is straightforward. As is the case for generalized forces, 
an impulse f in R3 acting on a body at the point D~(,) (p) produces a generld[ized impulse Q = fZ(p)7. 
A flexible body s state veloeity ~(f) changes discontinuously to ~(r) + QM -1 when subject to a generalized 
impulse Q. To calculate tbe required impulse, let p, = DR(,) (p). We know that the impulse occurs at 
p,, and has direction h for a frictionless impact. Thus. we can express the impulse as hi, where A is 
an unknown scalar. The velocity of the contact point on the moving body before the collision is $DRII)(P) 
= ~(f).z(P). (8) After the collision. the velocity of the contact point is (~(f) + QM- )Z(p). Since body 
B is fixed, the veloeity of the contact point in the i direction after the collision must be zero; that 
is, we require ri . (i(r) + QM-))Z(p) = O. (9) Substituting Q = (hi )Z(p) J. we have the constraint i. 
+ )Z(p) = o  (k(() Ariz(p)7M- (lo) which yields  ri . k(l)z(p) ri. i(r)z(p) (11) A= n. riz(p)rl -lz(p)= 
Z(p)rlw-lz(p) since i has unit length. Since M is positive definite, the denom­inator of equation (11 
) is non-zero and positive. Moreover, since ti . ~(f)Z(p) is the initial approach speed in the normal 
direction (which is negative), A is positive as one would expect from figure 4. For collisions involving 
more than one contact point, the collisions at the contact point can be considered as a sequence of collisions, 
slightly staggered in time. If collisions involving multiple contact points are modeled as occurring 
simultaneously, the approach taken by Baraff[ 1] can be used. 3.3 Resting contact The derivation for 
the resting contact forces between flexible bodies is almost the same as the derivation for resting contact 
forces between rigid bodies. The non-penetration constraints for rigid bodies described in Baraff[2] 
are restricted to handle situations with only finitely many contact points, as described in section 3.1. 
Since we are restricted to situations in which inter-penetration can be prevented by considering only 
finitely many contact points, we can index the contact points from I to n. At each contact point between 
two bodies A and B, we will write down a constraint of the form i,(f{)) 20 (12) where ~,(f) is a measure 
of the separation between A and Binthe normal direction at time ~. Since ~,(r) is a spatial measure, 
~,(f) measures the relative normal acceleration between A and B. In particular, if ~, ([o) < 0, then 
the bodies are accelerating so as to inter-penetrate at the ith contact point. Conversely, if ~,(to) 
> 0, then the bodies are accelerating apart, and contact will be broken at the ith contact point immediately 
after time ro. If ~, (ro) = O, then contact is not broken at the ith contact point. Thus. to prevent 
inter-penetration, we must enforce equation ( I 2). The relation ~,(r) ~ O is maintained at each contact 
point by a time-varying contact force, acting normal to the contact surface. As in the case of colliding 
contact, we need to calculate the magni­tudes of these contact forces. Because ~, (fo ) measures acceleration, 
~, (to) depends linearly upon all the forces acting on bodies A and B. The contact force at each contact 
point is required to be repulsive and conservative; that is, it must not add energy to the system of 
bodies. Since the normal force at one contact may affect the accel­eration of one or both of the bodies 
at another contact, satisfying ~,(r) ~ O at all of the contact points involves satisfying a system of 
simultaneous linear inequalities. The constraint that the contact forces act conservatively can be expressed 
in terms of a quadratic constraint on the contact forces. Contact forces satisfying these constraints 
can be computed by quadratic programming 1,2]. Exactly the same formulation is used to prevent inter-penetration 
between flexible bodies. Tlte expression derived for ~, (10) in Bara~2 I requires the spatial and [emporal 
derivatives of functions describing the contact surfaces. Suppose we express the unde­formed rest sha~ 
of our contact surface in body space in terms of a real-valued function F(I(p); that is, a point ph in 
body space is on the undeformed surface if and only if ~O(j% ) = 0. Then the deformed contact surface 
at time / consists of those points p in world space for which F(P11) = F@;(:)(P)) = 0. (13) Deriving 
expressions for the various derivatives of F(j, I) neces­sary to symbolically evaluate ~, (10) becomes 
mostly an exercise in applying the chain rule of calculus. For any deformation function D~f,)(p) = R([) 
Z(P), i,(h) is a linear function of i(h)), so ~,(ro) depends linearly upon the contact forces. The contact 
forces can be extended to include friction as described by Baraff13]. 4. Implementing Polynomial Deformations 
We have implemented flexible bodies for the cases of first-and second-order polynomial deformations. 
There is no difficulty in performing simulations that involve bodies with a mix of differ­ing deformation 
functions. Simulations can also mix rigid and deformable bodies. In this section, we will discuss a number 
of implementation details. 4.1 Collision detection Currently, our bodies are limited to unions of convex 
primitives, where a primitive is either a polyhedron or a convex closed curved surface. When deformations 
are limited to first-order deformations, convexity is conserved under deformation, Thus, the collision 
de­tection method described in Baraff12] can be used without alter­ation. Additionally, when flexible 
bodies are determined to contact at some point p, in world space, it is necessary to compute p, in tbe 
body space of both of the bodies: that is, D~(~)(p, ) must be computed for each body. This is trivial 
for first-order deformations since fl~(,) is simply an affine transformation whose inverse is easily 
computed.    
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134085</article_id>
		<sort_key>309</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>36</seq_no>
		<title><![CDATA[Dynamic deformation of solid primitives with constraints]]></title>
		<page_from>309</page_from>
		<page_to>312</page_to>
		<doi_number>10.1145/133994.134085</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134085</url>
		<keywords>
			<kw><![CDATA[constraints]]></kw>
			<kw><![CDATA[deformable models]]></kw>
			<kw><![CDATA[finite elements]]></kw>
			<kw><![CDATA[physics-based modeling and animation]]></kw>
			<kw><![CDATA[solid primitives]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Animation</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Curve, surface, solid, and object representations</descriptor>
				<type>S</type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010401</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Volumetric models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010399</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Parametric curve and surface models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010352</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Animation</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>PP39080447</person_id>
				<author_profile_id><![CDATA[81100429042]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Dimitri]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Metaxas]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Department of Computer Science, University of Toronto, Toronto, Ontario, M5S 1A4]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>PP14109166</person_id>
				<author_profile_id><![CDATA[81100294834]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[Demetri]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Terzopoulos]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Department of Computer Science, University of Toronto, Toronto, Ontario, M5S 1A4, Fellow, Canadian Institute for Advanced Research]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Barr, A., (1981) "Superquadrica and angle preserving transformations," IEEE Computer Graphics and Applications, 1(1), 11- 23.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_obj_id>808573</ref_obj_id>
				<ref_obj_pid>964965</ref_obj_pid>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Barr, A., (1984) "Global and local deformations of solid primitives," Computer Graphics, 18(3), 21-30.]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378509</ref_obj_id>
				<ref_obj_pid>378456</ref_obj_pid>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Bar~el, R., and Barr, A., (1988) "A modeling system based on dynamic constraints," Computer Graphics, 22(4), 179-188.]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[Baumgarte, J., (1972) "Stabilization of constraints and integrals of motion in dynamical systems," Comp. Meth. in Appi. Mech. and Eng., 1, 1-16.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_obj_id>74803</ref_obj_id>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[Hoffmann, C.M., (1989) Geometric and solid modeling, Morgan- Kaufmann, Polo Alto.]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_obj_id>22977</ref_obj_id>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[Kardestuncer, H.,York--(ed'.)' (1987) Finite element handbook, McGraw-Hill, New]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_obj_id>628483</ref_obj_id>
				<ref_obj_pid>628302</ref_obj_pid>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Metaxas, D., and Terzopoulos, D., (1992) "Shape and nonrigid motion estimation from synthesis." IEEE Transactions on Pattern Analysis and Machsne Intelligence, to appear.]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_obj_id>74355</ref_obj_id>
				<ref_obj_pid>74334</ref_obj_pid>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[Pentland,A., and Williams, J., (1989) "Good vibrations: Modal dynamics forgraphics and an,mation," Computer Graphics, 2a(3), 21s-222]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_obj_id>76524</ref_obj_id>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Plait, J., (1989) "Constraint methods for neural networks and computer graphics," PhD Thesis, Dept. of Computer Science, California Institute of Technology, Pasadena, CA (Caltech-CS- T1~89-07).]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122745</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[Sclaroff, S., and Pentland, A., (1991) "Generalized implicit functions for computer graphics," Computer Graphics, 25(4), 247- 250.]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
			<ref>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[Shabana, A., (1989) Dynamics of multibody systems, Wiley, New York.]]></ref_text>
				<ref_id>11</ref_id>
			</ref>
			<ref>
				<ref_obj_id>15903</ref_obj_id>
				<ref_obj_pid>15886</ref_obj_pid>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[Sederberg, T.W., and Parry, S.R., (1989) "Free-form deformation of solid geometric primitives," Computer Graphics, 20(4), 151- 160.]]></ref_text>
				<ref_id>12</ref_id>
			</ref>
			<ref>
				<ref_obj_id>117760</ref_obj_id>
				<ref_obj_pid>117754</ref_obj_pid>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[Terzopoulos, D., and Metaxas, D., (1991) "Dynamic 3D models with local and global deformations: Deformable superquadrics." IEEE Transactions on Pattern Analysis and Machine Intelligence, 13(7), 703-713.]]></ref_text>
				<ref_id>13</ref_id>
			</ref>
			<ref>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[Terzopoulos, D., and Fleischer, K., (1988) "Deformable models," The Visual Computer, 4(6), 306-331.]]></ref_text>
				<ref_id>14</ref_id>
			</ref>
			<ref>
				<ref_obj_id>617444</ref_obj_id>
				<ref_obj_pid>616002</ref_obj_pid>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[Terzopoulos. D., and Witkin A. (1988) "Physically-based roodels with rigid and deformal~ie. ~omponents,' IEI~E Computer Graphics and Applications, 8(6), 41-51.]]></ref_text>
				<ref_id>15</ref_id>
			</ref>
			<ref>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[Witkin, A., and Welch, W., (1990) "Fast animation and control of nonrigid structures," Computer Graphics, 24(3), 243-252.]]></ref_text>
				<ref_id>16</ref_id>
			</ref>
			<ref>
				<ref_obj_id>37429</ref_obj_id>
				<ref_obj_pid>37402</ref_obj_pid>
				<ref_seq_no>17</ref_seq_no>
				<ref_text><![CDATA[Witkin, A., Fleischer, K., and Barr, A., (1987) "Energy constraints on parameterized models," Computer Graphics, 21(4), 225-232.]]></ref_text>
				<ref_id>17</ref_id>
			</ref>
			<ref>
				<ref_seq_no>18</ref_seq_no>
				<ref_text><![CDATA[Wittenburg, J., (1977) Dynamics of systems of rigid bodies, Tubner, Stuttgart.]]></ref_text>
				<ref_id>18</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 z Computer Graphics, 26,2, July 1992 Dynamic Deformation of Solid Primitives with Constraints Dimitri 
Metaxas and Demetri Terzopoulosl Department of Computer Science, University of Toronto, Toronto, Ontario, 
M5S 1A4 Keywords: Physics-Based Modeling and Animation, De­formable Models, Constraints, solid Primitives, 
Finite Ele­ ments Abstract: This paper develops a systematic approach to deriving dynamic models from 
pammetrically dejined solid primitives, g!obal geometric deformations and local jinite­element deformations. 
Even though their kinematics is styl­ized by the particular solid primitive used, the models behave in 
a physically correct way with prescribed mass distributions and elasticities. We also propose eficient 
constraint meth­ods jor connecting these new dynamic primitives together to make articulated models. 
Our techniques make it possible to build and animate constrained, nonrigid, unibody or multi­body objects 
in simulatedphysical environments at interactive rates. Introduction The graphics literature is replete 
with solid object repre­sentations. Unfortunately, it is not particularly easy to synthesize realistic 
animation through direct application of the geometric representations of solid modeling [5], and the 
problems are exacerbated when animate objects can deform. Physics-based animation has begun to overcome 
some of the difficulties. We propose a systematic approach for creating dynamic solid models capable 
of realistic physical behaviors start­ing from common solid primitives such as spheres, cylinders, cones, 
or superquadrics. Such primitives can deform cine­matically in simple ways; for example, a cylinder deforms 
as its radius or length is changed. To gain additional model­ing power we allow the primitives to undergo 
parameterized global deformations (bends, tapers, twists, shears, etc. ) of the sort proposed in [2], 
To further enhance the geometric flexibility, we permit local free-form deformations. Our local deformations 
are similar in spirit to the FFDs of [12], but rather than being ambient space warps [12, 10], they are 
in­corporated directly into the solid primitive as finite element shape functions. Through the application 
of Lagrangian mechanics and the finite element method our models inherit generalized coordi­nates that 
comprise the geometric parameters of the solid primitive, the global and local deformation parameters, 
and the six degrees of freedom of rigid-body motion. Lagrange equations govern the dynamics, dictating 
the evolution of the generalized coordinates in response to forces. Thus our mod­els exhibit correct 
mechanical behaviors and their various ge­ometric parameters assume well-defined physical meanings 1Fellow, 
Canad]an Institute for Advanced Research E-mail addresses dm@cs toronto.edu; dt~cs.toronto,edu Permiwmn 
to c{)py wi(hout I&#38; till or part of this material IS granted pmkided that the copiei are not rnwle 
or distributed for direct commercvtil advwmigc, the ACM copyright m)tict! and the t]tle of the puhllca[mn 
and iti date appear, wxl rroticc IS g!vcn that copying IS by permission (1I !hc Amocwtwn I{w Ctm~putlng 
Mtich!nery To copy othcrw Iw. {Irt{) repuhli~h, requires s kc and/or specific pcrmissi,m Figure 1: Interaction 
with deformable superquadrics. in relation to prescribed mass distributions, elasticities, and energy 
dissipation rates. For example, Fig. 1 shows several deformable su­ perquadrics. A superellipsoid [1] 
is deforming in response to the traction from a linear spring attached to its surface and pulled interactively. 
In general, the models are abstract viscoelastic solids. It is possible, for instance, to mold a su­persphere 
into any of the deformable superquadrics shown in the figure, not only through manual parameter adjustment 
but, more interestingly, by applying forces. A distinguishing feature of our approach is that it marries 
the parameterized and free-form modeling paradigms within a single physical model. Roughly speaking, 
we successfully combine locally deformable models [14, 9] with globally de­formable models [8, 16]. More 
precisely, the method applies generally across all geometric primitives and deformations, so long as 
their equations are differentiable. The coupling of rigid-body and deformation dynamics is similar to 
that de­scribed in [15], but our formulation accommodates global de­formations defined by fully nonlinear 
parametric equations. Hence, our models are more general than the restrictive, lin­early deformable ones 
in [16] and quadratically deformable ones in [8, 10]. Our dynamic deformable models raise interesting 
chai­lenges related to the application of constraints to construct composite models and control animation. 
We describe a method for computing generalized constraint forces between our models which is based on 
Baumgarte s constraint stabi­lization technique [4, 18]. As in [17, 3], our algorithm may be used to 
assemble complex objects satisfying constraints from initially mispositioned and misshaped parts, and 
it enables us to construct and animate articulated objects composed of rigid or nonrigid components, 
The remainder of this paper describes our general formu­lation and presents some results. Space limitations 
preclude a complete elaboration of the mathematics. We refer the reader to [13, 7] for further details. 
 , 199? ACM-(1-X9791-479-I W21H)7 0309 $(1I .50 w) SIGGRAPH 92 Chicago, July 26-31, 1992 Modd fonmtioru 
 z Figure 2: Geometry of deformable model. Geometry Consider a solid model whose intrinsic (material) 
coordi­ nates are u = (U, v,w). Referring to Fig. 2, X(U, t) = (SI (u, t), ZZ(U, t), ZS(U, i))T, where 
T denotes transposition, gives the positions of points on the model relative to the fixed reference frame 
0. We can write x=c+Rp, (1) where p(u, t) denotes the positions of points relative to the noninertial, 
model-centered frame 4 whose inst ant aneous po­sition is c(t) and orientation relative to @ is given 
by the rot ation matrix R(t)., We further express p=s+d, (2) the sum of a reference shape S(U, t)and 
a displacement func­tion d(u, t). We define the reference shape as s= T(e(u; al, az,...); bl, bZ)...). 
(3) Here, a geometric primitive e, defined parametrically in u and parametenzed by the variables ai, 
is subjected to the global de~ormation T which depends on the parameters bi. Although generally nonlinear, 
e and T are assumed to be differentiable (so that we may compute the Jacobkn of s) and T may be a composite 
sequence of primitive deforma­tion functions. We define the vector of global deformation parameters q~=(al, 
az, . . .. bl. bZ)T. .)T. (4) Next, we express the displacement as a linear combination of basis functions 
bi (u). The basis functions can be local or global; however, finite element shape functions [6] are the 
naturaJ choice for representing local deformations d = Sq&#38; (5) Here S is a shape matrix whose entries 
are the shape func­tions and qd=(..., ql)T..)T (6) is the vector of local deformation parameters. Typic-ally, 
fi­nite elements have nodes at their vertices, and the parameter qi denotes a displacement vector associated 
with node i of the model. In [13, 7] we provide the formulas for a superquadric el­lipsoid e with tapering, 
bending, shearing, and twisting de­~fimations (see also [2]). 3 Kinematics and Dynamics To convert the 
above geometric representation into a physi­cal model that responds dynamically to forces, we first con­sider 
the kinematics implied by the geometry and then intro­duce mass, damping, and elasticity into the model 
to derive its mechanics. The velocity of points on the model is given by, x=c+Rp+Rp=c+Bfl+ ti+Rsq&#38; 
(7) where 4 = (.. ., Oi, ,. .)T is a vector of rotations coordinates and B G [... ~(RP)/~@i . . .]. NOW, 
s G [Zk/~qs]q. G Jq$, where J is the Jacobian of the reference shape with respect to the global deformation 
parameter vector. We can therefore write the model kinematics compactly as x=c+R(s+d)= h(q), (8) x=[IBRJRS]q=Lq, 
(9) where q=(q:>q:, q:, q:)T1 (lo) with q= = c and qe = O serving as the vector of generalized coordinates 
for the dynamic model. To specify the dynamics, we introduce a mass distribution p(u) over the model 
and assume that the material is subject to frictional damping. We also assume that the material may deform 
elastically or viscoelastically [14]. From Lagrangian mechanics we obtain order-second equations of motion 
which take the form M~+Dq+Kq=gq+fq. (11) The mass matrix M = ~ pLTL du. The stiffness ma­trix K may 
be obtsined from a deformation strain energy (qTKq)/2. The Raleigh damping matrix D = IYM + PK. The generalized 
inertial forces gq = ~ pLTLq du include generalized centrifugal, Coriolis, and transverse forces due 
to the dynamic coupling between qO, q., and qd. Finally, fq = LTf are generalized external forces associated 
with the components of q, where f(u, t)is the force distribution ap­plied to the model. See [13, 7] for 
explicit formulas for the above matrices and vectors. 4 Constrained Nonrigid Motion We can extend (11) 
to account for the motions of compo~ ite models with interconnected deformable parts. Shabana [11] describes 
the well-known Lagrange multiplier method for multibody objects. We form a composite generalized co­ordinate 
vector q and force vectors gq and fq for an n-part model by concatenating the ql, gqi, and fqi associated 
with each part ia l,..., n. Similarly, the composite matrices M, D, and K for the n-part model are block 
diagonal matri­ces with submatrices Mi, Di, and Ki, respectively, for each part i. The method solves 
the composite equations of mo­tion Ma + Dq + Kq = gq + fq -C~A The generalized constraint forces fgc 
= C~A acting on the parts stem from the holonomic constraint equations C(q, t) = o; (12) i.e., C = [C~, 
C~, ..., C~]T expresses k constraints among the n parts of the model. The term C~ is the transpose of 
the constraint Jacobian matrix and A =(A~,..., A~)T isa vector of Lagrange multipliers that must be determined. 
To obtain an equal number of equations and unknowns, we differentiate (12) twice with respect to time, 
yielding 7 = cq~ = Ctt (Cqq)qq 2cqtq. (13) Computer Graphics, 26,2, July 1992 We obtain the augmented 
equations of motion collisions are implemented using reaction constraints [9] be­tween multiple deformable 
bodies. Fig. 4 shows the construction and animation of a minimal­ist dragonfly from its deformable body 
parts (Fig. 4(a) ) and 4 [: %q[N=[-Dq-K;+gq+ fql 4) point-to-point constraints. The dragonfly self-assembles 
[17, In principle, these equations tial conditions q(0) and q(0) C(q(0), O) = O. At each time with known 
q and ~, and then t+ At to obtain q and q (e.g., may be integrated from ini­satisfying C(q(0), O) = O 
and step, we solve (14) for ~and ~ we integrate ~ and ~ from tto using the simple Euler method ~(~+At) 
= ~(~) + At ~(t); q(t+@ = ~(~) + At ~(t+@). There are two practical problems in applying (14) to an­imation. 
First, the various parameters of the parts may not be set initially so that the constraints are satisfied 
(i.e., C(q, O) # O). Second, even if the constraints may be satisfied at a given time step of the animation 
(i.e., C(q, t) = O), they may not be satisfied at the next time step (i.e., C(q, t+ At) #O) because of 
numerical errors, etc. The constraint stabilization method of Baumgarte [4, 18] remedies these problems. 
The constraint equation C = O is replaced in (14) by the damped second-order equation C + 2rxC + @2C 
= O, where w and /3 are stabilization fac­ tors. This replaces the lower entry of the vector on the rhs 
of (14) to y 2aC /32C. Fast stabilization means choosing ~ = o to obtain the critically damped solution 
C(q, O)e-a which, for given a, has the quickest asymptotic decay to­wards constraint satisfaction C = 
O. Baumgarte constraint stabilization and its variations are also applied in [3, 9, 16]. The Lagrange 
multiplier method is very general, but it is potentially expensive for our deformable models since the 
matrix in (14) is large. We have devised a fast specialized method to solve for the unknown constraint 
forces fg= arising from point-to-point constraints. The method involves the solution of a linear system 
whose size is on the order of the number of constraints, which is usually small. In this sense, it is 
similar to the dynamic constraint technique of 3], but \it is suitable for nonrigid parts. The details 
are in [7 . 5 Animation Examples The partitioning of complex nonrigid behavior into rigid­body motions, 
global deformations, and local deformations leads to numerically well-conditioned discrete equations 
and stable simulation algorithms based on explicit numerical in­tegration methods. We represent the rotation 
component of the models using quaternions, which facilitates the inte­gration of qe. We do not assemble 
and factorize a finite element stiffness matrix as is common practice in finite el­ement analysis, but 
instead compute Kqd efficiently in an element-by-element fashion. For greater efficiency, we can lump 
masses to obtain a diagonal M, and we may assume mass-proportional damping, i.e. D = VM where v is the 
damping coefficient [6]. The following animation examples involve deformable su­ perquadric primitives 
that interact with one another and their simulated physical environments through point-to­ point constraints, 
collisions, gravity, and friction against im­ penetrable surfaces. To attain frames per second (on an 
SGI mented dynamic shells where stricted to a membrane surface mass density p(u) = O for O ~ surface 
of the model into linear the details). animation rates of several 4D-35TG), we have imple­the material 
domain is re­ u = (u, v, 1) and the interior w < 1. We triangulate the elastic elements (see [13] for 
Fig. 3 shows several frames from an animation of multiple balloon pendulums suspended in gravity by inextensible 
strings. The simulation starts from the initial configuration shown in Fig. 3(a), and the balloons swing, 
collide, and de­form until the kinetic energy is dissipated. The inelsstic 3] and it works, inasmuch 
as internal forces open and flap the wings (Fig. 4(b)). An impenetrable plane appears out of nowhere 
and swats the dragonfly in the rear (Fig. 4(c)). The body parts deform in response to the blow, but they 
remain joined by the constraints (Fig. 4(d)). Fig. 5 illustrates the self-assembly and animation of 
a snowman. Twelve point-t~point constraints assemble and hold the deformable superquadric body parts 
together (Fig. 5(a-b)). When gravity is turned on, the assem­bled snowman drops to the impenetrable floor 
and locc­motes along a prespecified path through controlled bouncing (Fig. 5(b-d)). Fig. 6 illustrates 
a simple circus stunt, in which two de­formable superquadric balls interact with a pivoting spring­board 
mounted on immobile planes. The simulation starts from Fig. 6(a) with the yellow ball dropping downward. 
Fig. 6(b) shows the motion tracks. The figures have demonstrated a rather sophisticated fam­ily of parameterized 
models~eformable superquadrics with global twisting, bending, tapering, and shearing deforma­tions, and 
local membrane deformations. We emphasize in closing, however, that our approach is generally applicable 
to a wide variety of parameterized models, global deformations, and finite element basis functions. References 
[1] Barr, A., (1981) (Superquadrics and angle preserving transfor­mations, IEEE Computer Graph:cs and 
Appkcataons, l(l), 11­ 23. [2] Barr, A., ( 1984) Global and local deformations of solid primi­tives, 
Computer Graph:cs, 1S(3), 21 30. [3] Bamel, R., and Barr, A., ( 1988) (A modeling system based on dynamic 
constraints) Computer Graphical 22(4), 179-188. [4] Baumgarte, J., ( 1972) Stabilization of motion in 
dynamical systems, and Eng., 1, 1-16. [5] Hoffmann, C. M., 19d9) Geometrtc Kemfmann, Palo Lto. [6] Kardestuncer, 
H., (cd.), (1987) McGraw Hill, New York. [7] Metaxas, D., and Temopoulos, D., of constraints and inte 
rals Comp. A4eth. in Appi. .&#38;h. and solid modeltng, Morgan­  F~ntte element handbook, 1992) Shape 
and nonrigid motion estimation from synthesis ~EEE 2hnsact%on$ On PrIt­ tern Anaiysis and Mach:ne Intelligence, 
to appear. [8] Pentlapd, A., and W,illiams, J., (19f39) Good vibrations: Modal dynamics for graph]cs 
and ammat]on, Computer Graphics, 23(3), 215 222. [9] Platt, J., (1989) Constraint methods for neural 
networks and PhD Thesis, Dept. of Computer Science, ;;j: ;~ = ornla nst]tute of Technology, Pasadena, 
CA (Caltech-CS- Cali [10] Sclaroff, S., and Pentland, A., (1991) (Generalized implicit func­tions for 
computer graphics, Computer Graph:cs, 25(4), 247­ 250. [11] Shabana, A., (19S9) Dynamics of muft:body 
systems, Wiley, New York. [12] Sederberg, T. W., and Parry, S. R., (1989) Free-form deformation of solid 
geometric primitives, Computer Graphtca, 20(4), 151­ 160. [13] Terzopoulos, D., and Metaxas,, D., (1991) 
Dynamic 3D models with local and global deformations: Deformable superquadrics IEEE Transactions on 
Pattern Analysis and Machtne Intel~:­.,.aence. 13(7),,. 703 713. [14] Terzopoulos, D., and Fleischer, 
K., ( 1988) Deformable models, The Visual Computer, 4(6), 306-331. [15] Terzopoulosl D., and Witkin, 
A., (198S) Ph sicall -based mod­els with rigid and deformable components ~ IE~E Computer Graph:cs and 
Appl:cattons, S(6), 41 51. [16] Witkinl A., and Welch, W., (1 990) Fast animation and control of nonrigid 
structures, Computer [17] Witkin, A., Flelscher, K., and straints on parameterized models, 225-232. 
[18] Wittenburg, J., (1977) Dynam:cs Tubner, Stuttgart. Graphtcs, 24(3), 243 252. Barr, A., (1987) Energy 
con­ Computer Graphtcs, 21(4), of systems of r:g:d bod:es, 311  SIGGRAPH 92 Chicago, July 26-31, 1992 
(b) (cl Cd) Figure 3: Balloon multi-pendulum. Initial state (a). Swinging and colliding (b-d). (cl Cd) 
 Figure 5: Yellow snowman. Self-assembly (a). Hopping (b-d) (a, (b) Figure 6: Balls and springboard. 
Initial state (a). Motion tracks (b).  
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134086</article_id>
		<sort_key>313</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>37</seq_no>
		<title><![CDATA[Smooth interpolation of orientations with angular velocity constraints using quaternions]]></title>
		<page_from>313</page_from>
		<page_to>320</page_to>
		<doi_number>10.1145/133994.134086</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134086</url>
		<categories>
			<primary_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Animation</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>G.1.1</cat_node>
				<descriptor>Spline and piecewise polynomial interpolation</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>G.1.4</cat_node>
				<descriptor>Finite difference methods</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>G.1.6</cat_node>
				<descriptor></descriptor>
				<type></type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10002950.10003714.10003715.10003718</concept_id>
				<concept_desc>CCS->Mathematics of computing->Mathematical analysis->Numerical analysis->Computations in finite fields</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003752.10003809.10003716</concept_id>
				<concept_desc>CCS->Theory of computation->Design and analysis of algorithms->Mathematical optimization</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002950.10003714.10003716</concept_id>
				<concept_desc>CCS->Mathematics of computing->Mathematical analysis->Mathematical optimization</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002950.10003648.10003649.10003657.10003659</concept_id>
				<concept_desc>CCS->Mathematics of computing->Probability and statistics->Probabilistic representations->Nonparametric representations->Spline models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002950.10003714.10003715.10003724</concept_id>
				<concept_desc>CCS->Mathematics of computing->Mathematical analysis->Numerical analysis->Numerical differentiation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002950.10003714.10003715.10003722</concept_id>
				<concept_desc>CCS->Mathematics of computing->Mathematical analysis->Numerical analysis->Interpolation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010352</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Animation</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>PP14034821</person_id>
				<author_profile_id><![CDATA[81100070192]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Alan]]></first_name>
				<middle_name><![CDATA[H.]]></middle_name>
				<last_name><![CDATA[Barr]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[California Institute of Technology]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P28732</person_id>
				<author_profile_id><![CDATA[81100456871]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[Bena]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Currin]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[California Institute of Technology]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P269860</person_id>
				<author_profile_id><![CDATA[81537121456]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>3</seq_no>
				<first_name><![CDATA[Steven]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Gabriel]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Sage Design]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>PP40024462</person_id>
				<author_profile_id><![CDATA[81100166298]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>4</seq_no>
				<first_name><![CDATA[John]]></first_name>
				<middle_name><![CDATA[F.]]></middle_name>
				<last_name><![CDATA[Hughes]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Brown University]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_obj_id>35072</ref_obj_id>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[R. Bartels, J. Beatty, and B. Barsky. An Introduction to Splines for Use in Computer Graphics and Geometric Modeling. Morgan Kaufmann, Los Angeles, 1987.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[S. Gabriel and J. Kajiya. Spline interpolation in curved space. In "State of the Art Image Synthesis," Course notes for SIGGRAPH '85, 1985.]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[W. R. Hamilton. Lectures on Quaternions. Hodges and Smith, Dublin, 1853.]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_obj_id>808575</ref_obj_id>
				<ref_obj_pid>964965</ref_obj_pid>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[D. Kochanek and R. Bartels. Interpolating splines with local tension, continuity, and bias control. Computer Graphics, 18(3):33-41, July 1984.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[R. S. Millrnan and G. D. Parker. Elements of Differential Geometry. Prentice-Hall, Englewood Cliffs, NJ, 1977.]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[B. A. Murtagh and M. A. Saunder. MINOS 5.0 user's guide. Technical Report SOL 83-20, Dept. of Operations Research, Stanford University, 1983.]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Ltd Numerical Algorithms Group. NAG Fortran library routine document, 1988.]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378524</ref_obj_id>
				<ref_obj_pid>378456</ref_obj_pid>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[J. Platt. Constraint methods for flexible models. Computer Graphics, 22(4):279-288, July 1988.]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_obj_id>42249</ref_obj_id>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[W.H. Press, B.P. Flannery, S.A. Teukolskym, and W.T. Vetterling. Numerical Recipes in C.. Cambridge Univ. Press, Cambridge, England, 1988.]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_obj_id>325242</ref_obj_id>
				<ref_obj_pid>325165</ref_obj_pid>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[K. Shoemake. Animating rotation with quaternion curves. Computer Graphics, 19(3):245-254, July 1985.]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
			<ref>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[M. Spivak. A Comprehensive Introduction to Differential Geometry. Publish or Perish, Inc., Boston, 1970.]]></ref_text>
				<ref_id>11</ref_id>
			</ref>
			<ref>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[D. Zwillinger. Handbook of Differential Equations. Academic Press, San" Diego, 1989.]]></ref_text>
				<ref_id>12</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 Computer Graphics, 26,2, July 1992 i? Smooth Interpolation of Orientations with Angular Velocity Constraints 
using Quaternions Alan H. Barrt, Bena Currint, Steven Gabrieltt, John F. Hughesttt California Institute 
of Technology Sage Designtt Brown Universityttt Abstract ing spline paths on curved manifolds, and applied 
their results to quaternion paths. In this paper we present methods to smoothly inter­polate orientations, 
given N rotational keyframesof an object along a trajectory. The methods allow the user to impose constraints 
on the rotational path, such as the angular velocity at the endpoints of the trajectory. We convert the 
rotations to quaternions, and then spline in that non-Euclidean space. Analogous to the mathematical 
foundations of flat-space spline curves, we minimize the net tangential acceleration of the quaternion 
path. We replace the flat-space quantities with curved-space quantities, and numerically solve the resulting 
equation with finite difference and optimiza­ \ I tion methods. I 1I Introduction The problem of using 
spline curves to smoothly in-\ \ terpolate mathematical quantities in flat Euclidean \ \ spaces is 
a well-studied problem in computer graph-\ q %2 q.-l ics [BARTELS ET AL 87], [KOCHANEK&#38;BARTELS 84]. 
\\ .: \.\,..: , Many quantities important to computer graphics, how­ Q==q  ever, such as rotations, 
lie in non-Euclidean spaces. In ,.. .. .. , ; .:-. ...  1985, a method to interpolate rotations using 
quater- ,, \ nion curves was presented to the computer graph-:/ ics community [SHOEMAKE 85]; beyond this, 
there 2? has been relatively little work in computer graphics -hoe to smoothly interpolate quantities 
in non-Euclidean, Figure 1. The interpolation problem we solve: curved spaces [GABRIEL&#38;KAJIYA 85]. 
In that paper, Given K keyframe quaternions, (capital) Q , : = 1, Kajiya and Gabriel developed a foundation 
for an in­ 2, ..., K, at keyframe times t, = p, h, what are the n opti­ trinsic differential geometric 
formulation for comput­ mal interpolated quaternions q(p), p= 1,2, ....n at equally spaced times rP = 
h (p 1), that pass through the keyframe Perrnission 10 copy without fee all or part of [his material 
is granted provided thal the copies are not made or distributed for direct quaternions? q(p) = Qi and 
t,= TP,when p = p,. Option­commercial advantage. the ACM copyrigh( notice and the title of Ihe ally, 
find the n rotations (plus two extra key frame rotations) publication and its date appear. and notice 
is given that copying is by first when given angular velocities w and W1wt of the first and permission 
of [he Awtxial!on for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or 
specific permission. last rotation along the path. p ]y)~ ACM-()-89791-479-1/92/007/031 3 $01.50 3[3 
Splining in non-Euclidean Spaces This paper presents a simpler version of the Gabriel/Kajiya approach 
to splining on arbitrary mani­folds, Our approach uses extrinsic coordinates and con­straints (rather 
than intrinsic methods, Christoffel sym­bols and coordinate patches), and generalizes to other manifolds 
that are embedded in Euclidean space.1 The problem of computing spline curves on curved manifolds is 
of increasing importance to computer graphics, and we predict many future generalizations. There are 
several reasons why someone would choose to use our interpolation techniques: . The paths we generate 
through rotation space are very smooth. . Our techniques allow the user to specify arbitrar­ily large 
initial and final angular velocities of a rotating body; by assigning large angular veloci­ties, a user 
can make an object tumble several full turns between successive keypoints, . It is fairly easy to add 
additional constraints. . The techniques generalize to interpolations of other quantities in non-Euclidean 
spaces.  The techniques are fast enough to experiment with, taking a few minutes per interpolation. 
Of course, we cannot claim to have solved all problems of interpolating rotations and orientations. Through 
our choice of representation, we will have the classic advantages and disadvantages of using unit quaternions 
to represent rotations.2 Also implicit in our approach is the assumption that the geometry of the space 
of orientations has a certain homogeneity, and that we can mathematically specify all of the constraints 
that we wish to apply.3 We find a path that minimizes a measure of net bending. We implement this, however, 
using a finite difference technique, so that we end up with a sequence of points on the path, rather 
than a continuous path. To produce a continuous path, we use Shoemakers slerping to interpolate between 
these points. In section 2, we provide a brief discussion of quater­nions, and present intuitive mathematical 
background to motivate the differences between interpolating in flat space and curved spaces; in section 
3 we sketch the over­all algorithm; in section 4 we present the constrained 1whitney~s origin~ embedding 
theorem tells us that every M dimensional manifold can be embedded in a 2 M + 1 dimensional Euclidean 
space. 2The m~n ~vatage is that quaternion constraints we sim­ ple to enforce (constructing a four dimensional 
unit vector); the main disadvantage is double representation: there are two unit quaternions that represent 
each rotation. 3For ~wbling bodies this is reasonable, but it is not completely true for camera orientations: 
certain orientation (ones with no tilt around line of sight of the camera) are far preferable to others. 
We would need to determine the appropriate constraints to minimize the net tilting. optimization problem; 
section 5 speaks briefly about numerical derivatives on manifolds; section 6 presents methods to solve 
the problem, while section 7 presents our results,  2 Mathematical Background Shoemakers paper on quaternions 
provides a good in­troduction to the mathematics of quaternions and their relationship to rotations. 
For our results, we need three basic facts-about quaternions: . The set of unit-length quaternions (i.e., 
expres­sions of the form q= a+ bi+ cj+ dlcwith az+ b2+c2+d2 = 1) corresponds to the unit 3-sphere in 
4-dimensions. The quaternion a+ bi+ cj+ dk cor­responds to the point (a, b, c, d). The same quater­ 
nion is denoted by q= ~, where s = a and () v = (h, c,d). . There is a natural map that takes a unit 
quater­nion and produces a rotation: the quaternion a+ bi+cj +dlt corresponds to a rotation of 2 cos-l(a) 
about the axis (b, c, d) in 3-space. If (b,c,d) = (O,O,O) the rotation angle is 2 Cos- (zkl) = O, and 
the rotation is the identity. . The map from unit quaternions to rotations is 2­  to-1. For every rotation, 
two quaternions, +q and q, lying at antipodal ends of a hypersphere, cor­respond to it. Advantages of 
quaternions. There are several rea­sons to use quaternions to describe rotations. First, the quaternion 
space has the same local topology and geom­etry as the set of rotations (this is not true of the space 
of Euler angles, for example, but is true of the 3 x 3 orthog­onal matrices of determinant 1). Second, 
the number of coordinates used in describing a quaternion is small (4 numbers, in contrast to the 9 in 
a 3 x 3 matrix). Third, the number of constraints on these coordinates is small: the only constraint 
on a quaternion representing a ro­tation is that it have unit length; a 3 x 3 matrix must satisfy six 
equations to represent a rotation. Finally, the extrinsic equations for quaternions turn out to be fairly 
simple. Disadvantages of quaternions. The main disadvan­tage of using quaternions is that their 2-to-1 
nature ne­cessit ates a preprocessing step, to choose whether the plus or minus keyframe quaternion is 
the appropriate one to use. Euclidean and non-Euclidean-space splines. Since the 3-sphere is a non-Euclidean 
space, we discuss inter­polation methods for Euclidean spaces, and then mo­tivate and describe a generalization 
to non-Euclidean spaces. We will informally refer to them as flat spaces and curved spaces respectively. 
2.1 Flat-space interpolation The Hermite formulation expresses a spline curve as a parametric cubic 
curve ~(t) that starts and ends at two given points4, T(O) = PO and v(1) = P1, and haa given velocities 
there, i.e., ~ (0) = R and ~ (l) = RI. Given these boundary conditions (i.e., PO, P1, Il , and RI), we 
can find a unique cubic path that satisfies them. But why is a cubic the right curve to use? One answer 
is given by reformulating the problem to ask Among all curves starting at PO with velocity RO and ending 
at P1 with velocity R1, what curve bends the least? We approximate the least square measure of curvature 
by minimizing the net squared length of the acceleration vector, ~ . Thus we seek to minimize 1 E= -y 
(t) -y (t)dt (1) /o over all paths ~ that satisfy the boundary conditions. The Euler-Lagrange equations 
[ZWILLINGER 89] pro­vide a necessary condition for v to be a minimum. Writ­ing out these conditions gives 
T = O, which means that each component of ~(t) must be a cubic function oft, A physical implementation 
of splines in a flat space. The word spline originally referred to a thin strip of wood or metal that 
was constrained by pins to form smooth curves for drafting or shipbuild­ing. For drafting, the pins were 
placed onto a flat sur­face; for shipbuilding, rigid posts were inserted into the earth, and wooden flexible 
planks were threaded be­tween them. In each case, the splines flexed to meet the positional constraints 
imposed by the pins or posts. The spline took on curved shapes in its attempt to achieve a low-energy 
state, governed by equation (1). 2.2 Flat space splines versus curved­space splines. We would like to 
carry out an analogous computation in a curved space: we define a bending measure of a curve, and then 
determine which curves minimize the measure. Unfortunately, the ordinary second derivative of a path 
is no longer the right way to measure net bending. We can understand this by considering the problems 
that arise even for surfaces in 3-space. If ~ is a path on a surface M in 3-space, then 7 can be thought 
of as a path in 3-space as well. As such, at each time tthe path has a velocity vector -+(t)and an acceleration 
vector ~ (t).Because 7 lies within the 4We use superscripts to indicate different vectom, and sub­scripts 
to denote z, y, z, etc components of vectors. Computer Graphics, 26,2, July 1992 surface, its velocity 
vector will always be tangent to the surface. Its acceleration vector, however, does not have to lie 
within the surface. It is likely to have components normal to the surface, as well aa components tangential 
to the surface. In Figure 2 we see a pair of curves on a surface. The midpoint of the upper curve has 
an acceleration vector a that points both out from the surface and up a little. We see that the acceleration 
vector a is not parallel to the surface normal IV; the non-~ part of vector a (the tangential acce/eratton 
or covariant accelemtion) is labeled Sin the drawing. The acceleration vector of the lower curve actually 
coincides with the normal vector to the surface, and hence its tangential acceleration is zero. I Figure 
2. Two curves on a curved surface. The upper curve has an acceleration vector a, that does not lie in 
the surface. The vector N is the normal vector to the surface, along the path. The tangential part of 
the acceleration is the vector S = a \ N (described in section 2.3). The lower curve s acceleration is 
parallel to N, hence it has zero tangential acceleration. A physical analogy. Imagine driving in a small 
circle in a hilly region. You feel two sorts of acceleration: you bounce up and down in your seat as 
you go over bumps, and you are pushed against your car door because you are turning in a tight circle. 
The first is acceleration in the direction normal to the surface of the earth; the second is the tangential 
acceleration. Note that if you want to take a drive, any path you take is likely to have some net tangential 
acceleration. But to make the trip as comfortable as possible, minimizing tangential acceleration is 
desirable. Normal acceleration is inevitable. By contrast, the normal component of the acceleration is 
a necessary evil. Imagine trying to get from one place on a sphere to an­other in a way that minimizes 
total acceleration. If you travel along a great circle at a constant speed, the only acceleration will 
be normal. If you try to adjust your path so that you undergo no acceleration, you will have to be traveling 
in a straight line in 3-space, and hence will have to leave the surface of the sphere. This gets rid 
of the normal acceleration, but at the cost of violating the requirement that -y be a path on the surface. 
 Another physical example. Let us consider making a physical spline onto a spherical globe. Instead of 
placing pins into a flat drafting surface, we push the pins into the globe itself. We thread a semi-rigid 
elaatic strip through the pins, making sure that the strip stays on the globe while being constrained 
by the pins. Since the strip needs to stay on the globe, we do not penalize it for bending to stay on 
the globe. These examples motivate why we do not penalize acceleration normal to the surface, while penalizing 
ac­celeration within the surface, for constructing splines on curved surfaces. In generalizing Equation 
1 to curved spaces, Kaji ya and Gabriel therefore replaced the squared length of the acceleration vector 
with the squared length of the tangential acceleration. This is the starting point for our solution: 
we will seek a path in quaternion space, i.e., a path on the unit 3-sphere in 4-space, that minimizes 
the total squared tangential acceleration. 2.3 A formula for tangential accelera­tion Given two n dimensional 
vectors a and b, we wish to project away and remove all portions of b found in vec­tor a. The notation 
we use for this is a \ b (read as vector a without vector b). By definition, a\ b=a ab, such that (a\ 
b). b=O .. (a ~b) hich mpl es hat o = (b. b) If the surface M is a unit sphere, then the unit nor­mal 
at the point (a, b, c) is (a, b, c). So for a path ~ on the unit sphere, the total acceleration at time 
t is ~ (t); its normal vector is ~(t) itself, and the tangential acceleration S(t) is given by s(t) = 
-f (t) \ ~(t), For other applications, the formula for tangential accel­eration of a curve on an arbitrary 
implicitly defined surface f(z) = Ois S(t) = ~ (t) \ N, where N = Vf.  316 2.4 Physical meaning of paths 
on the quaternion sphere We have already noted that each unit quaternion corre­sponds to a rotation. 
If we think of this rotation acting on a rigid body in a home coordinate system, then we can say that 
each quaternion corresponds to an orienta­tion of the rigid body. Therefore a path in the quater­nion 
sphere represents a continuously changing orienta­tion. The derivative of the path at a particular instant 
represents the rate of change of orientation of the body, essentially its angrdur velocity. Thus to specify 
the end­points and end tangents of a quaternion curve means to specify the initial and final orientations 
of a rigid body and its angular velocities at those points.  3 Algorithm Description We provide a sketch 
of the overall algorithm in figure 3, using the curved-space results of the previous sections. In the 
subsequent few sections, we develop the math­ematics for step 2. The implementation for step 2 is found 
in section 6. 1. Preprocess orientations into key frame quaternions, Qi as shoun in Appendix A 2. Use 
constrained optiraization techniques as described in section 6 to compute quaternions interpolated between 
the keyframes. 3. Optionally slerp between the interpolated quaternions to get a cent inuous represent 
at ion. 4. Convert the quaternions back into rotation matrices (or other desired form) .  Figure 3. 
The steps of the algorithm. 4 Mathematical Formulations In this section, for our constrained optimization 
prob­lem, we consider some of the merits of using a contin­uous derivative versus using discrete derivatives. 
Ulti­mately we will choose the discrete approach, because it is simpler. The reader should not infer 
that continu­ous approaches are not worthy of further investigation, however. Computer Graphics, 26, 
2, July 1992 4.1 Continuous derivative approach The problem statement for the continuous version with­out 
angular velocity constraints is: given K keyframe quaternions, Ql, Q2, . ~, QK, at times tl, tz, . . 
.. t~, what is the unit quaternion curve -y(t) of minimal net least square tangential acceleration that 
passes through the points? We are looking for the unknown (four dimensional) unit magnitude quaternion 
function ~(t) which mini­mizes t, the net square magnitude of the tangential ac­celeration. Without loss 
of generalit y,5 we stipulate that tl = O. Thus we minimize &#38;= ~*K l#(t) \ -f(t)[2 dt / subject to 
the constraints boundary values : V(ti) = Qi, i = 1,2,..., K. magnitudes : 17(t)l = 1, 0 ~ t ~ tK The 
boundary value constraints ensure that the quaternion path passes through the key frame quater­nions; 
the unit magnitude constraint keeps the quater­nion on the unit 3-sphere. tK and O are the (prescribed) 
values of tat the endpoints of the quaternion path. This constrained optimization problem is a calcu­lus 
of variations problem, which produces an Euler-Lagrange ordinary differential equation formulation with 
constraints [ZWILLINGER]. It is an extrinsic form of the Gabriel/Kajiya equation. The authors have de­ 
rived this equation, but feel it would needlessly clutter the presentation. The approach involves the 
solution of a K-point ODE boundary value problem with con­straints; we leave the pursuit of this approach 
as future work, 4.2 Discrete derivative approach If we do not wish to solve K-point boundary value 
prob­lems, we can make discrete approximations to convert the calculus of variations problem into a calculus 
prob­lem. Instead of solving for an unknown function 7(t), we solve for n fixed quaternions q@J,p= 1,2, 
....n. We retain the constraints that each q@ ) is a (four dimen­sional) unit vector, and that the appropriate 
q(p ls coin­cide with our key frame quaternions Qi, i= 1,2, .... K. We replace the continuous derivatives 
~(t) in the &#38; equation with a numerical approximation, shown in section 4.3; we denote the discrete 
derivative approxi­mation with (q@)) , and compute them from the q@)s. In addition, we replace the integral 
with a discrete ap­proximation, the sum of about n equally spaced values, times the stepsize, h = tK/(n 
1). 5The reader can shift the arguments of the function to reduce a tl # O problem to a tl = O problem. 
Thus, we minimize the function Pu..x E(q) = h ~ (q(p)) \ q(p) 2 P=Pmin subject to the constraints that 
boundary values : ~(P!) = Q , inl,z,...,K magnitudes: lq(p)l = 1, p= 1,2, . . ..n. The p: are those values 
ofp where we wish the inter­polated quaternions q@J to coincide with the keyframe quaternions Qi. Pl=l, 
andl-k=n;prnin=l or2 and pmax =n or n 1. They are chosen so that (q(p) ) can be computed in each term 
in the sum. (This is equivalent to having a weighting factor in the sum).  4.3 Discrete second derivatives 
A simple discrete version of the second derivative is the three-point formula: 2q(P) + q(P-l) (q(p) ),, 
= @ +l) h2 We now have a calculus problem: find the n quaternions q@ 1that minimize the scalar function 
f?(q) subject to the above constraints. Without the angular velocity constraints we let pmin = 2 and 
pmaX= n 1.  4.4 Angular velocity constraints Sometimes, we may wish to stipulate that angular veloc­ities 
Ufirst and UIMt apply to the first and last rotations along the path. We can stipulate that the angular 
velocity is constant over the time interval h< t<0 and t~ <t< tK+ h. We reduce the problem with angu­lar 
velocity constraints into the previous case, creating new quaternions and new constraints q(o) = QO and 
q(~+l) = QK+l. TO compute QO, let Wfirst w= O= hlw{ w = w/lwl Qo = c:f3@/2) QI sln(O/2) d () To compute 
QK+l, let Wlast w= 0= hlwl d= w/{wl c0s(8/2) QK@+l = sin(O/2) &#38; () Thus, the method involving angular 
velocity con­straints is merely a renumbered version of the previous method. We let pmin = 1 and p~ax 
= n, to add the two points. These points are the two smaller dots in figure 8.  5 Numerical derivatives 
on the 3-sphere There are three problems that typically arise when using numerical methods to approximate 
derivatives on a mani­fold. First, some derivative formulas are not centered they approximate the derivative, 
but not at the specified point. Secondly, there is a numerictai accuracy problem numerical approximations 
of the derivative typically will not lie in the tangent plane. Finally, there can be an aliasing problem, 
particularly for paths which circumnavigate the sphere or travel in tight loops. The aliasing problem 
greatly accentu­ates the numerical accuracy problem. We compute our numerical derivatives using the centered 
three point formula for the second derivative shown in sec­tion 4.3. To solve the aliasing problem, we 
must choose n, the number of samples of g(p) to be large enough so that aliesing effects are not significant. 
To reduce &#38;s­ing, we suggest maintaining enough interpolation points so that adjacent q(p)s do not 
travel more than +1/4 way around the sphere, which can be tested via the condition # J . g(PtlJ >0. )?OI 
inst ante, between antipodal keyframe quaternions, two or more intervening interpolation points are needed. 
For the angular velocity constraint, a similar condition suggests maintaining lelc ~/2. This implies 
that we need n > # Idl t~., steps, where [dl is the magnitude of the larger of the two angular velocities. 
 6 Implementing the discrete derivative method The most reliable way to implement the algorithm, whether 
or not angular velocity constraints are used, is to use a con­strained optimization package for sparse 
systems, such as the MINOS package [MURTAGH8ZSAUNDEHS83]. Any method whichsolvesforthe q(p)can be used,aalongasit 
minimizes E(q), subject to the constraints. By using first and second derivatives of the energy function 
E(q), you can speed up the solutions significantly. An advantage of thm approach is that the packaged 
al­gorithms implement a robust convergence test, to determine when the optimal solution is found. 6.1 
Augmented Lagrangian constraints If the implementer does not wish to use prepackaged algo­rithms, a practical 
approach is to implement a variation of the Lagrangian methods in [PLAIT 88], using first-derivative 
information. (We leave the implementation of faster meth­ods, with quadraticconvergence,as future work.) 
First, you need the constraint function which keeps the p-th quaternion on the unit sphere Then construct 
a total energy J (q) by adding the constraint and penalty terms P=Pmi. (r) and take its derivative with 
respect to ql and with respect to A, If r c ~min + l,pma= -1], the above equation is valid. If r = pmin 
-1, only the r + 1 term applies and the others are deleted; if r = Pmi., the r+ 1 and r terms apply, 
but the first term is deleted; if r = p~a, + 1, only the first term applies, while if r = Pm,,, the first 
three terms apply. Then, set up the differential equations d (r) s -&#38;F(q), r#pi ~qp  z ~ (r)=o Zqt 
 =pi -gA, = +gr(q) and set up appropriate initial conditions: q:) (0) = Q) r=pl, i=l,..., K, lz0,1,2,3. 
q\r) (0) = interpolated values between the Q&#38;, either flat-space or results from previous runs with 
smaller numbers of points. Better initial con­ditions significantly improve the speed of this method 
Ap=l Numerically solve the differential equations with an au­tomatic stepsize method (such as Adarns 
method), until you reach sufficiently constant values. This heuristic stop condition is why we advocate 
using packaged optirniiation algorithms, which have robust stop conditions. It is recommended that the 
program be structured so that output from a smaller number of interpolated points can be used to set 
up the initial conditions for a run with a larger number of interpolated points.c 6you cm &#38;o trmfom 
the variables in the differential equ­tion via s= 1+ 1/(0 -1), essentially scaling the right hand side 
by 1/(1 -u ). The solution will then be found at u = 1, rather than at s = co; you can iterate, numerically 
integrating the trans­formed differential equation repeatedly from O to 0.999 until the termination condition 
is reached. Results In the following figures, we show quaternion points visualized in three dimensions: 
we chose quaternions with the k com-ponent set to zero. Internally, of course, the implementation is 
fully four dimensional. We implemented augmented La-grangian constraints, as well as a prepackaged version. 
The two methods agreed within the prescribed tolerances. I 1 Figure 4a. Two keyframe rotations, without 
angular velocity constraints (shown as dots) on the interpolated path. Figure 4b. The corresponding rotational 
path of the object. The two yellow objects are the two keyframe rotations, while the green images are 
the interpolated values. For clarity, we draw only a subset of the interpolated values. Figure 5a. We 
go half-way around the quaternion sphere for the same initial and final rotation, by choosing the antipo 
da1 point, -Q . We rotate more fully around in space. Comwter Graphics, 26, 2, July 1992 Figure 6a. 
Here we specify asymmetric angular velocity con-straints, doubling until the path goes around the sphere. 
Figure 6b. The object rotates twice around. Figure 7a. Here we have seven keyframe quaternion points; 
there are 199 interpolated points. Figure 7b. The seven keyframe rotations are clearly visible. Figure 
5b. The rotational path of the object in 5a. Figure 8. Symmetric angular velocity constraints are applied 
to the same endpoints in 4a. Note the two extra points, Q and Q1 +r, drawn with smaller dots off of the 
curve. Notes. In the figures, the keyfrarne quaternions are drawn with larger dots, while the keyframe 
quaternions from the angular velocity constraints are drawn with smaller dots. Note the qualitative similarity 
with flat-space splines. The banana rotates more in figure 5b than in 4b, due to the antipodal representation 
of the left rotation. Since the algo­rithm finds local mtilma, a different solution with a ditTerent 
number of loops might turn out to be the absolute minimum. The method, for large numbers of points, prefers 
good ini­tial conditions, such as those produced by the algorithm with fewer points. For figures 7a and 
7b, 32 interpolation points are used in each interval, for a total of 199 points. The schedule of increasing 
points in each interval was 5 ~ 8 ~ 16 * 32. The total computation time on an HP 700 was less than four 
minutes.  Conclusions We have presented a new technique terpolate rotations using quaternions. uses 
an extrinsic version of Kajiya and minimization to characterize a spline nion 3-sphere; such splines 
are natural of splines in Euclidean space, and to smoothly in- The method Gabriel s bend­ in the quater­ 
generalizations are particularly amenable to solution on the 3-sphere. We use a numeri­cal method to 
determine several points between the key orient ations; Shoemakers slerping can be applied to the points; 
the resulting splines are smooth, and have the desirable property that they pass through their control 
points exactly. Our preliminary results are favorable, but there is much that can still be done to improve 
on this tech­nique. We believe that splining in curved spaces will be of increasing importance to computer 
graphics, and predict many future generalizations. Acknowledgements The authors wish to thank Mark Montague, 
John Sny­der, David Laidlaw, and Jeff Goldsmith at the Cal­tech graphics lab, as well as the Siggraph 
review­ers, for numerous helpful suggestions. The banana database is a generative model made by John 
Snyder and Jed Lengyel. This research was supported by the NSF/DARPA STC for Computer Graphics and Scien­tific 
Visualization, and by grants from HP, IBM, DEC and NCR to the university laboratories. References [1] 
R. Bartels, J. Beatty, and B. Barsky. An intro­duction to Sphnes for Use in Computer Graphics and Geometrr 
cModeling. Morgan Kaufmann, Los Angeles, 1987. [2] S. Gabriel and J. Kajiya. Spline interpolation in 
curved space. In State of the Art Image Synthe­sis, Course notes for SIGGRAPH 85, 1985. [3] W. R. Hamilton. 
Lectures on Quaternions. Hodges and Smith, Dublin, 1853. [4] D. Kochanek and R. Bartels. Interpolating 
splines with local tension, continuity, and bias control. Computer Graphics, 18(3):33-41, July 1984. 
[5] R. S. Millman and G. D. Parker. Elements of Diflerentiai Geometry. Prentice-Hall, Englewood Cliffs, 
NJ, 1977. [6] B. A. Murtagh and M. A. Saunder. MINOS 5.(I user s guide. Technical Report SOL 83-20, Dept. 
of Operations Research, Stanford University, 1983. [7] Ltd Numerical Algorithms Group. NAG Fortran library 
routine document, 1988. [8] J. Platt. Constraint methods for flexible models. Computer Graphics, 22(4):279-288, 
July 1988. [9] W.H. Press, B.P. Flannery, S.A. Teukolskym, and W .T. Vetterling. Numericai Recipes in 
C... Cam­bridge Univ. Press, Cambridge, England, 1988. [10] K. Shoemake. Animating rotation with quaternion 
curves. Computer Graphics, 19(3):245-254, July 1985. [11] M. Spivak. A C omprehensiue Introduction to 
Dif­ferential Geometry. Publish or Perish, Inc., Boston, 1970. [12] D, Zwillinger. Handbook of Differential 
Equations. Academic Press, San Diego, 1989. Appendix A: Preprocessing Step to Cre­ate Spin First, convert 
the K rotation matrices into K quater­nions (see Shoemakeor other quaternionreferencefor details). Then 
choose the desiredspinningbehavior of the objects between the quaternions. Sometimes, the object isdesiredtoundergoanodd 
numberoffullspins around on an interval(usually once). These will be the odd intervals (and the other 
intervals are regarded as even , which usually do not spin around). Mu]­tiplying a quaternion by 1 does 
not change the ori­entation it represents, but it does change whether or not an even or odd number of 
full-spins around the ob­ject takea place. The dot product of adjacent keyframe quaternions should be 
greater than or equal to zero for the even intervals, and less than zero for the odd ones. Multiply the 
quaternion by by 1 to change the interval from one state to the other. 
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134087</article_id>
		<sort_key>321</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>38</seq_no>
		<title><![CDATA[CONDOR: constraint-based dataflow]]></title>
		<page_from>321</page_from>
		<page_to>330</page_to>
		<doi_number>10.1145/133994.134087</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134087</url>
		<keywords>
			<kw><![CDATA[constraints]]></kw>
			<kw><![CDATA[dataflow]]></kw>
			<kw><![CDATA[graphical programming]]></kw>
			<kw><![CDATA[optimization]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>C.1.3</cat_node>
				<descriptor>Data-flow architectures</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>I.3.6</cat_node>
				<descriptor>Interaction techniques</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>D.2.2</cat_node>
				<descriptor>User interfaces</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>D.3.4</cat_node>
				<descriptor>Compilers</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>D.3.2</cat_node>
				<descriptor>C++</descriptor>
				<type>P</type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010147.10010371.10010387</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Graphics systems and interfaces</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003120.10003121.10003125.10010391</concept_id>
				<concept_desc>CCS->Human-centered computing->Human computer interaction (HCI)->Interaction devices->Graphics input devices</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10011007.10011006.10011066.10011069</concept_id>
				<concept_desc>CCS->Software and its engineering->Software notations and tools->Development frameworks and environments->Integrated and visual development environments</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10011007.10011006.10011041</concept_id>
				<concept_desc>CCS->Software and its engineering->Software notations and tools->Compilers</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10011007.10011006.10011008.10011009</concept_id>
				<concept_desc>CCS->Software and its engineering->Software notations and tools->General programming languages->Language types</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010520.10010521.10010542.10010545</concept_id>
				<concept_desc>CCS->Computer systems organization->Architectures->Other architectures->Data flow architectures</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Languages</gt>
			<gt>Performance</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>PP39032842</person_id>
				<author_profile_id><![CDATA[81100215003]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Michael]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Kass]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Apple Computer, Advanced Technology Group, 20525 Mariani Ave., Cupertino, CA]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Davis, A. and Keller, R., "Data flow Program Graphs," IEEE Computer, Feb. 1982, p. 26-24 I]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378494</ref_obj_id>
				<ref_obj_pid>54852</ref_obj_pid>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Haeberli, P., "ConMan: A Visual Programming Language for Interactive Graphics," Proc. of Siggraph "88, p. 103-111.]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_obj_id>102331</ref_obj_id>
				<ref_obj_pid>102313</ref_obj_pid>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Fleischer, K. and Witkin, A., "A Modeling Testbed," Proc. of Graphics Interface "88, Edmonton, Alberta, 1988]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_obj_id>325247</ref_obj_id>
				<ref_obj_pid>325165</ref_obj_pid>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[Perlin, K. "An Image Synthesizer," Computer Graphics 19 (3) Proc. Siggraph '85, 1985 p. 287-296.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[Alefeld, G. and Herzberger, J, "Introduction To Interval Computations," Academic Press, 1983.]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_obj_id>37429</ref_obj_id>
				<ref_obj_pid>37401</ref_obj_pid>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[Witkin, A, Fleischer, K., and Barr, A., "Energy Constraints On Parameterized Models," Proc. Siggraph '87, Anaheim, California, 1987.]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378507</ref_obj_id>
				<ref_obj_pid>54852</ref_obj_pid>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Witkin, A. and Kass, M., "Spacetime Constraints," Proc. Siggraph '88, p. 159-168.]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_obj_id>134024</ref_obj_id>
				<ref_obj_pid>133994</ref_obj_pid>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[Snyder, J., "'Interval Analysis for Computer Graphics," Proc. Siggraph '92.]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_obj_id>134027</ref_obj_id>
				<ref_obj_pid>133994</ref_obj_pid>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Duff, T., "Interval Arithmetic and Recursive Subdivision for Implicit Functions and Constructive Solid Geometry,'" Proc. Siggraph '92.]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_obj_id>134082</ref_obj_id>
				<ref_obj_pid>133994</ref_obj_pid>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[Mitchel, D. and Hanrahan, P.,"lllumination from Curved Reflectors," Proc. Siggraph '92.]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
			<ref>
				<ref_obj_id>48029</ref_obj_id>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[Wolfram, S., Mathematica: A System for Doing Mathematics by Computer, Addison-Wesley, Redwood City, California, 1988.]]></ref_text>
				<ref_id>11</ref_id>
			</ref>
			<ref>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[Gill, E., Murray, W. and Wright, M., Practical Optimization, Academic Press, New York, 1981.]]></ref_text>
				<ref_id>12</ref_id>
			</ref>
			<ref>
				<ref_obj_id>808573</ref_obj_id>
				<ref_obj_pid>800031</ref_obj_pid>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[Ban-, A., "Global and local deformations of solid primitives,'" Proc. Siggraph '84 p. 21-29.]]></ref_text>
				<ref_id>13</ref_id>
			</ref>
			<ref>
				<ref_obj_id>62100</ref_obj_id>
				<ref_obj_pid>62083</ref_obj_pid>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[Ingalls, D. et al, "Fabrik: A Visual Programming Environment," Proc. OOPSLA "88, September 25-30, 1988, p. 176-190.]]></ref_text>
				<ref_id>14</ref_id>
			</ref>
			<ref>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[Pangaro, P., Steinberg, S., Davis, J. and McCann, B., "EOM: a Graphically Scripted, Simulation-Based Animation System," Architecture Machine Group, Massachusetts Institute of Technology, August 1977.]]></ref_text>
				<ref_id>15</ref_id>
			</ref>
			<ref>
				<ref_obj_id>808602</ref_obj_id>
				<ref_obj_pid>800031</ref_obj_pid>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[Cook, R., "Shade Trees," Proc. Siggraph '84, p. 223-230, 1984.]]></ref_text>
				<ref_id>16</ref_id>
			</ref>
			<ref>
				<ref_obj_id>97910</ref_obj_id>
				<ref_obj_pid>97879</ref_obj_pid>
				<ref_seq_no>17</ref_seq_no>
				<ref_text><![CDATA[Abram, G., and Whitted, T., "Building Block Shaders," Proc. Siggraph '90, 1990,p. 283-288.]]></ref_text>
				<ref_id>17</ref_id>
			</ref>
			<ref>
				<ref_obj_id>33425</ref_obj_id>
				<ref_seq_no>18</ref_seq_no>
				<ref_text><![CDATA[Steele, G. et. al., Common Lisp the Language, Digital Press, Bedford, Massachusetts, 1984.]]></ref_text>
				<ref_id>18</ref_id>
			</ref>
			<ref>
				<ref_seq_no>19</ref_seq_no>
				<ref_text><![CDATA[Linton, M., Calder, P., and Vlissides, J., "The Design and Implementation of InterViews," Proceedings of the USENIX C++ Workshop,, November 1987.]]></ref_text>
				<ref_id>19</ref_id>
			</ref>
			<ref>
				<ref_obj_id>356498</ref_obj_id>
				<ref_obj_pid>356502</ref_obj_pid>
				<ref_seq_no>20</ref_seq_no>
				<ref_text><![CDATA[Sherman, A., Algorithm 533: "NSPIV, A Fortran Subroutine for Sparse Gaussian Elimination With Partial Pivoting," ACM TOMS, Vol. 4, No. 4, December, 1978, p. 391-398.]]></ref_text>
				<ref_id>20</ref_id>
			</ref>
			<ref>
				<ref_seq_no>21</ref_seq_no>
				<ref_text><![CDATA[Press, W. et. al., Numerical Recipes, Cambridge University Press, Cambridge, England, 1986]]></ref_text>
				<ref_id>21</ref_id>
			</ref>
			<ref>
				<ref_obj_id>155322</ref_obj_id>
				<ref_obj_pid>155294</ref_obj_pid>
				<ref_seq_no>22</ref_seq_no>
				<ref_text><![CDATA[Gleicher, M, and Kass, M, "An Interval Refinement Technique for Surface Intersection," Graphics Interface '92, to appear.]]></ref_text>
				<ref_id>22</ref_id>
			</ref>
			<ref>
				<ref_obj_id>37415</ref_obj_id>
				<ref_obj_pid>37402</ref_obj_pid>
				<ref_seq_no>23</ref_seq_no>
				<ref_text><![CDATA[Von Herzen, B. and Ban., A., "'Accurate Triangulations of Deformed, Intersecting Surfaces," Computer Graphics 21 (4) Proc. Siggraph '87, 1987 p. 103-110.]]></ref_text>
				<ref_id>23</ref_id>
			</ref>
			<ref>
				<ref_obj_id>97883</ref_obj_id>
				<ref_obj_pid>97880</ref_obj_pid>
				<ref_seq_no>24</ref_seq_no>
				<ref_text><![CDATA[Von Herzen, B., Barr, A., and Zatz, H., "Geometric Collisions for Time-Dependent Parametric Surfaces," Computer Graphics 24 (4) Proc. Siggraph "90, 1990 p. 39 - 48.]]></ref_text>
				<ref_id>24</ref_id>
			</ref>
			<ref>
				<ref_obj_id>97906</ref_obj_id>
				<ref_obj_pid>97879</ref_obj_pid>
				<ref_seq_no>25</ref_seq_no>
				<ref_text><![CDATA[Williams, L., "Performance-Driven Facial Animation," Proc. Siggraph "90, 1990, p. 235-242.]]></ref_text>
				<ref_id>25</ref_id>
			</ref>
			<ref>
				<ref_seq_no>26</ref_seq_no>
				<ref_text><![CDATA[Lowe, D., "Solving for the Parameters of Object Models from Image Descriptions," Proc. Image Understanding Workshop, April 1980, p. 121-127.]]></ref_text>
				<ref_id>26</ref_id>
			</ref>
			<ref>
				<ref_seq_no>27</ref_seq_no>
				<ref_text><![CDATA[Gennery, D., "'Stero Camera Calibration," Proc. image Understanding Workshop, April 1980, p. 201-208.]]></ref_text>
				<ref_id>27</ref_id>
			</ref>
			<ref>
				<ref_seq_no>28</ref_seq_no>
				<ref_text><![CDATA[Kass, M., Witkin, A., and Terzopoulos, D., "Snakes: Active Contour Models," International Journal of Computer Vision, 1988, p. 321-331]]></ref_text>
				<ref_id>28</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 z Computer Graphics, 26, 2, July 1992 CONDOR: Constraint-Based Dataflow Michael Kass Apple Computer 
Advanced Technology Group 20525 Mariani Ave., ABSTRACT CONDOR is an interactive constraint-based dataflow 
programming environment which is particularly suited to prob­lems that arise in computer graphics. In 
addition to traditional dataflow functions, CONDOR dataflow elements can perform ef­ficient derivative 
evaluation and interval arithmetic. As a result, CONDOR is able to support constraints, dynamics, surface 
trim­ming, collision testing, and a variety of other computations which are difficult or impossible to 
implement in traditional dataflow systems. CONDOR includes a graphical interface in which mathematical 
functions are represented as boxes with vector or scalar inputs and outputs. The functions can be composed 
by interactively connecting together their inputs and outputs, CON-DOR performance is sufficiently fast 
to make it suitable for creat­ing shaders, parametric surfaces, and complex constrained mod­els. Keywords: 
Optimization, Dataflow, Constraints, Graphical Pro­gramming.  L INTRODUCTION CONDOR ~straints ~namics 
Qbjects and J&#38;elationships) is an experimental interactive dataflow programming environment particularly 
suited to computer graphics problems. It consists of three parts. The first is a compiler which turns 
textual specifica­ tions of mathematical functions into efficient C++ implementations of corresponding 
dataflow elements. The sec­ ond is a graphical user interface which allows these functions to be interactively 
composed and manipulated to express complex mathematical relationships. The third is a set of utilities 
which perform specialized operations on dataflow networks such as optimization. surface trimming and 
rendering, Together, they form a powerful tool for exploring a wide range of computations that arise 
in computer graphics. Dataflow architectures II have some well known weaknesses which have limited their 
use for general computation. Among other things, flow of control is usually awkward if not impossible 
to express. and operations with side effects can pose severe diffi- Perrmssiun to cnpy without fee all 
or par( of (his material M grwrted provided tha[ the copies are not made or distributed for direct commercial 
advamage. the ACM copyright notice wrd the title nf the publlcatmn and Its date appear. and notice ]s 
given that copying M by permission of the Asweiation for Computing Machinery. To copy ntherwise, (v m 
rcpuhllsh. requires a fee and/or spcific permission. Cupertino, CA 95014 ct.tlties because the order 
of evaluation is hard to specify. Nonetheless, dataflow architectures have been widely used in computer 
graphics (e.g. [1 ~]) largely because a wide variety of important computer graphics problems can be easily 
cast in data­flow form. Most shaders, for examplefA), are easily put in data­flow form because they rarely 
use side effects or intricate flow of control. Parametric surfaces and spatial deformations are also 
very suitable for dataflow representation because they are usually expressed by pure mathematical mappings 
from one space to another. The standard graphics pipeline found in many work­stations consists of a series 
of operations which are easily ex­pressed in dataflow form. For computer graphics, an important limitation 
of traditional dataflow systems is that they often fail to provide sufficient metadata, particu lady 
information about how an output depends on inputs. CONDOR addresses this limitation by providing two 
valuable and unusual types of metadata which greatly expand its range of usefulness. The first is sparse 
derivative information and the second is interval information. CONDOR can rapidly de­termine which inputs 
an outpu( port depends on, and what its de­rivatives are with respect to those inputs. In addition, if 
bounds are placed on the inputs, CONDOR can evaluate a bound on the output using interval arithmetics]. 
The availability of metadata makes it possible to implement a number of efficient numerical algorithms 
within CONDOR and apply them to a variety of computer graphics problems. Tbe derivative evaluation has 
been designed to be suitable for optimization and the solution of ordinary and partial differential equations. 
The interval arithmetic has been designed for surface intersection and trimming calculations, as well 
as ray-surface intersections, tessellation of implicit surfaces and problems which require guaranteed 
root finding. Thus far, the most extensive use of CONDOR s derivative evaluation has been in optimization. 
Problems suitable for optimization arise very frequently in the course of computer­graphics modeling 
and animation, so having a computer graphics systems with built-in optimization capabilities can be of 
great value. An important set of optimization problems in computer graphics involve inverse problems 
such as computing the joint angles necessary to place the foot of a figure on tbe ground (in­verse kinematics). 
Some involve real-world data, such as the problem of computing the camera parameters for live video from 
tbe positions of a few reference points. Many are geometrical in nature and involve some type of shape 
optimization or constraint solving[6). A very difficult set arises from trying to create physi­cally-based 
character animationlT1. The most extensive use of CONDOR s interval arithmetic capability has been to 
compute intersection points of parametric c! 19y2 321 AcM-o-8979i-479-l/92/m7/0321 $01.50 surfaces 
for use in trimming operations. Interval arithmetic makes it possible to provide strong guarantees about 
the intersection points of extremely general parametric surfaces. There is no need to be limited to piecewise 
tensor product rational polynomials or some other set of primitives. Interval arithmetic can directly 
handle trigonometric functions and many other transcendental. Avariety of recent graphics algorithms 
make use of interval techniques (e.g. [8; 9; 10] ). The compiler built for CONDOR automatically generates 
code necessary for computing the derivative and interval arith­metic metadata. In addition, it generates 
very efficient code for the basic dataflow function evaluation. Experience with CON-DOR has made it clear 
that this, even apart from the metadata, is a valuable capability. By wiring together dataflow elements 
in CONDOR, functions can be constructed and modified interactively, yet they can be evaluated very efficiently. 
Example of the use of this capability in CONDOR include interactively creating and modifying parametric 
surfaces, warping images, and constructing surface shaders for rendering purposes. Section 11. details 
the motivation and design goals of CONDOR and a general outline of how they were addressed. Section III. 
compares and contrasts CONDOR with prior work in light of those goals. Next, sections IV. through VII. 
discuss the details of the compiler, the function and metadata evaluation, the user interface, and the 
utilities. Finally section VIII. goes through a series of examples showing the ordinary dataflow capa­bilities 
of CONDOR as well as those based on its optimization and interval arithmetic metadata.  Il. APPROACH 
CONDOR was primarily intended as an interactive research test­bed for computer graphics modeling, animation 
and rendering. Its main design goal was to approach the performance of hand­crafted code while providing 
an interactive programming environment to explore a wide variety of computer graphics com­putations. 
The idea was to create an exploratory system with per­formance sufficient for practicaI problems, so 
there would rarely be a need to re-implement CONDOR computations with special purpose code to achieve 
satisfactory performance. The performance requirements for CONDOR dictated the use of a very efficient 
programming language supporting high speed floating point calculation. This effectively ruled out lan­guages 
such as Lisp and Smalltalk for the function and metadata evaluation despite their merits for supporting 
ease of modifica­tion. In the end, C++ was chosen as the language for the run-time system because it 
allowed careful control of performance while providhtg the amenities of an object-oriented language. 
In order to provide most of the flexibility of an interpreter while limiting the associated speed penalty, 
CONDOR relies on dynamic composition of compiled functions to compute dataflow outputs and metadata. 
Each dataflow element is associated with compiled functions which compute its output, its interval bounds 
and its derivatives. CONDOR uses a compiler to generate these functions to avoid the labor and potential 
for error inherent in cre­ating them by hand. In some cases, the compiler can create code which is more 
efficient than code written by hand because of its symbolic mathematics, exhaustive common-subexpression 
elimi­nation and loop unwinding. When dataflow elements are wired together, CONDOR cre­ates an expression 
tree which is used to control function and metadata evaluation. Storage is pre-allocated for intermediate 
results, so the tree can be traversed with minimum overhead. When computing the dataflow function or 
its interval bounds, evaluation consists of little more than a series of calls to compiled functions 
given by a set of pointers in the expression tree. As long as a dataflow element does substantial computation 
inside its compiled function, the overhead in following pointers in the ex­pression tree is a small part 
of the total running time. Evaluation of derivative information is somewhat different from the other 
evaluations. There are two general approaches available for computing derivatives of dataflow elements: 
nu­merical and symbolic differentiation. Numerical differentiation is much easier to code, but the results 
are less reliable than symbolic differentiation because the function has to be evaluated at nearby points. 
If the points are too far apart, the derivative estimate is poor. If the points are too close, numerical 
precision may limit the accuracy of the result. In addition, numerical differentiation can waste time 
evaluating derivatives which are always zero, but symbolic differentiation methods can detect such cases 
and there­by achieve important efficiency gains. For these reasons, CON-DOR computes first derivatives 
of dataflow elements using compiled functions that evaluate their symbolic derivatives. First derivatives 
of expression trees are computed using the chain rule. Since the chain rule becomes somewhat unwieldy 
for second de­rivatives, CONDOR relies on numerical second derivatives calcu­lated from symbolic first 
derivatives. This appears to be a good compromise. The symbolic first derivatives provide most of the 
valuable information about sparsity and the numerical second de­rivatives keep the complexity of the 
entire system to a manage­ able level. The CONDOR compiler takes mathematical descriptions of dataflow 
elements and creates the set of functions necessary to support function and metadata evaluation. The 
compiler is writ­ten in Lisp and uses Mathematical 1]] to do the required symbolic differentiation and 
simplification. The output of the compiler is very efficient, streamlined C++ code which is linked in 
with the CONDOR application. Note that neither Lisp nor Mathematical is called at run time. They are 
used only to generate C++ code. At run-time, all the code is C++, so the run-time speed is unaffected 
by the performance of either Lisp or Mathematical. While thk odd assortment of programming languages 
may seem a little baroque, 1 each language is used in the domain for which it was designed: C++ for speed, 
Mathematical for symbolic mathematics, and Lisp for traversing and manipulating lists. Connecting together 
dataflow elements into expression trees requires some kind of interface: CONDOR provides an object oriented 
C++ interface for programs and a graphical user interface. While it is probably possible to build similar 
capabilities into an interactive textual interface, the direct manip­ulation of the graphical interface 
lends an intangible satisfying el­ement to the use of the system and makes certain types of opera­tions 
particularly easy. In the user interface, dataflow elements are depicted by rectangles, so the the dataflow 
elements have come to be known as function blocks. Having used the graphical interface to specify a dataflow 
computation, the user can interactively invoke several utilities which operate on these functions. One 
of the most useful of these is the optimizer. With the efficient derivative evaluation supplied by CONDOR, 
any of a wide variety of optimization algorithms can be used. The one currently implemented is a Newton 
s meth­od with step-size control[ 12]. The gradient and sparse Hessian matrix provide a local quadratic 
approximation to the objective function. Based on this information, the optimizer computes a minimum 
of the quadratic approximation (safeguarded with step­size control) by using sparse LU decomposition 
and then moves towards the minimum. After each step, it re-evaluates the gradi­ent and Hessian to construct 
a new quadratic approximation to the objective function. Iteration continues until some termination condition 
is met. The CONDOR graphical user interface provides special mechanisms for the user to specify that 
a given dataflow function is to represent a parametric curve, surface, or shader. These curves and surfaces 
can be rendered interactively with a Z-buffer, or tesselated and written out to files in formats suitable 
for other renderers. In addition, parametric surfaces can be trimmed against each other using the interval 
bounds. 1. It is. Computer Graphics, 26,2, July 1992 CONDOR is u system still under active development. 
The basic function and metadata evaluation has been stable for some time, but new utilities and features 
are constantly being added. Building the new utilities into CONDOR means that -they immediately benefit 
from the efficient function and metadata evaluation. the graphical user interface and the interactive 
visual­ization capabilities of the system,  Ill. PRIOR WORK In terms of motivation and general approach, 
CONDOR is most properly viewed as an evolutionary descendent of the math com­piler described in 171 combined 
with some of the modeling capa­bilities of [tl. The design of CONDOR benefits enormously from experience 
with each of these systems, Like the math compiler described in 17], CONDOR solves optimization problems 
posed graphically by wiring together visu­isl representations of mathematical functions, Evolutionary 
im­provements in CONDOR include the use of a direct L-U matrix solver instead of a conjugate gradient 
solver and a different meth­od of handling sparse matrices which avoids a long pre-process­ing step before 
commencing optimization. The direct matrix so­lution and the fact that it is written in C++ instead of 
Lisp gives CONDOR substantially better performance. For banded systems, the direc[ matrix solution is 
the difference between O(n) and O(nA2) computation, [n addition, CONDOR s graphical interface provides 
a >ariety of improvements such as the ability to change tirbitraily between vector and scalar representations, 
to create dataflow elements with variable numbers of inputs, and to create hierarchies of dataflow elements. 
More significantly, CONDOR adds interval arithmetic to the metadata and combines optimiza­tion with integrated 
modeling and visualization capabilities. Like the modeling testbed described in [~], CONDOR pro­vides 
facilities which allow a user to specify deformed parametric surfaces graphically is I. Unlike the testbed, 
the same type of graphical programming can be used in CONDOR to specify shad­ing calculations and motion 
paths as well, The uniformity of rep­resentation in CONDOR makes it possible, for example, to optimize 
and thereby constrain any parameter which appears in the computation, whether related to rendering, modeling, 
or ani­mation path. The graphical interface of CONDOR has many similarities with other graphical programming 
environments such as Fabnkl i.1], ConManLql and even the early animation system EOMI [s] From a system-level 
perspective, the chief differences have to do with CONDOR s metadata capabilities. In addition, Fabrik 
suffers in performance because it is written in Smalltalk, while ConMan s performance is limited for 
small-grain computations by the speed of UNIX pipes. The value of flexible yet high-performance calculations 
for shading has been well established since Cook s work on shade treesl lb]. Since then. there have been 
a \ariety of attempts to cre­ate rapid interactive environments for constructing shaders. Abram and Whitted 
describe a graphical programming system[l 71 designed for just such a purpose. While CONDOR has not been 
specitlcally (ailored to the demands of constructing shade trees, it does have substantial capabilities 
in this regard, and it derives a great deal of additional power from being able to use the same operations 
and graphical language to express geometry, con­straints, motion and shading.  IV. CONDOR COMPILER The 
CONDOR compiler is designed to convert concise mathe­matical descriptions of function blocks into definitions 
of very ef­ficient C++ objects that compute the functions and associated metadata. Thecompiler isimplemented 
in Common Lisp[]tt] and runs on Silicon Graphic s4D workstations. ltusesa Unix pipe in­[erface to Mathematica 
inorder to compute symbolic derivatives. The compiler parses the Mathematical output into a Lisp list 
which represents an expression tree. Before doing final code generation, the compiler does exhaustive 
common-subexpression elimination by putting the expression tree and all its subexpres­sions in a hash 
table. Any expression entered into the hash table more than once is flagged as a common subexpression. 
Common subexpressions which occur only inside of a single larger com­mon subexpression are eliminated. 
The remaining common­sttbexpressions are used to generate assignment statements which precede the evaluation 
of the function or its derivatives. The following is an example of the definition used for a cubic Catmull-Rom 
spline. (defoplimize :name CRSpline :initially (string-append MAT= ({-1,3,-3,1},{2,-5,4,-1},(-1,0,1,0),(0,2,0,0))/2; 
U=(UA3,UA2,U,1 ); P = (a,b,c,d); Y = U.MATF). :inputs (hJlIal IblIclIdl) :outputs ((IYI Y) (IYuI DIY,u~)(lYuul 
D[D[Y,u],u] ))) The argument following initially in the definition is a string sent to Mathematical 
before evaluating anything else. The syntax is a strange mixture of Lisp and Mathematical, but it specifies 
that the inputs to the function box are the spline parameter u and the four knot points a,b,c and d, 
while the outputs are the position Y of the spline, its derivative Yu with respect to the spline parameter 
u, and its second derivative Yuu. From this definition, the com­piler generates a C++ class definition, 
a constructor, a structure describing the number and names of the inputs and outputs, a function to compute 
the value of each of the outputs, an interval arithmetic function, and a function for each output that 
computes the gradient of the output with respect to each of the inputs. The full output of the compiler 
from this definition amounts to 134 lines of C++ code. While the full output is too long to reproduce 
here, the following is the part of the compiler output which com­putes the gradient of Yu with respect 
to the inputs u, a, b, c and d. void CRSplineDerivl(Real in, Real out)1 Real u, a, b, c, d; u = in[O]; 
a = in[l]; b = in[2]; c = m[3]; d = in[4]; { Real comsubl: comsubl =u u: out[O]=b (-5+Wu)+d (-l +3u)+a 
(2-3 u)+c (4-9 u); out[l] =2 u+comsubl -3/2-lr2; out[2]= -5 u + comaubl 9/2; out[3]= 4%+comsubl -9/2+ 
1/2; out[4]= -u + comsubl 3/2; }) Note that the compiler effective] y unwinds the implied loops in the 
matrix multiplication because everything is reduced to a single expression tree. Also note that thezeros 
inthe matrix drop outofthe expression due to the symbolic algebra --this isanop­timiza[ion that programmers 
are unlikely to do by hand. In addition to generating the C++ code for the new object, the compiler modifies 
the make file for the application, adds the new object to the application menu and adds the new objeet 
toa table, so it can be saved andretneved. All that remainsin order to be able to use the new object 
is to compile and link the application. In future, some form of dynamic linking will be used, but at 
present, the entire application has to be relinked.  V. FUNCTION AND METADATA EVALUATION CONDOR uses 
a function evaluation scheme based on a dataflow model [i]. Values can be regarded as flowing from inputs 
of func­tion boxes to their outputs and then propagating to connected inputs. For efficiency considerations, 
CONDOR uses a Pull version of dataflow evaluation with caching. If a function block is asked to evaluate 
its output, it first evaluates all of its inputs, then evaluates the appropriate function of its inputs 
and passes on the value. This should be contrasted with the Push model in which changed input values 
automatically propagate through the tree. The result of the Pull model is a depth-first evaluation of 
the expression tree. To prevent excess function evaluations, each function block caches the last set 
of output values it has comput­ed and can return them without further computation if its inputs have 
not changed. Anytime a value is changed in the network, a cache-invalidate signal is Pushed through the 
graph, informing affected function-blocks that they will have to recompute their outputs the next time 
they are evaluated. Cache-invalidate sig­nals need not be propagated past function blocks with caches 
that are already invalid. This method of pulling values with caching appears to prevent unnecessary function 
evaluations in most cases of interest. It prevents, for example, excess matrix multiplies when rendering 
models of standard articulated figures. The cach­es end up implementing the storage traditionally implemented 
in a transformation matrix stack. Interval calculations are done with a small modification of the basic 
function evaluation where all the inputs and outputs are replaced with intervals. Using C++ overloading, 
ordinary mathe­matical functions are extended to interval arguments. For example the operator + is overloaded 
so that if x is the interval (xrnirr, xrnux) and y is the interval (ynin, yrrux) then x+y evalu­ates 
to the interval (.wnin+ymin, xnmx+yrnux). The interval function for each operator has the property that 
if the inputs of the ordinary function lie within the input intervals, then the outputs of the ordinary 
function must lie within the output intervals, Interval functions are composed and cached in exactly 
the same way as ordinary functions. Like the ordinary and interval-function evaluation, derivative evaluation 
is performed by depth-first pulling. Before it can start, a table of all changeable input variables is 
constructed. Each function block in turn is asked to supply a list of its inputs which are neither frozen 
nor connected to the output of another function block. These are given global indices and constitute 
the state variables of the optimization or differential equation. Once state variables have been identified, 
the basic deriva­tive operation provided by CONDOR is the evaluation of the gra­dient of any output. 
For efficiency, CONDOR uses a sparse rep­resentation of gradient vectors, maintaining a linked list of 
the non-zero components. Derivatives within a function block are evaluated using code generated by the 
compiler, and these deriva­tives are composed recursively using the chain rule. Second derivatives are 
estimated from first derivatives by fi­nite-differencing. When a complete sparse Hessian matrix is needed, 
it is constructed from the sparse gradients by finite-dif­ferencing and is represented by a data structure 
containing a list of the non-zero elements of each row. Function blocks which numerically integrate their 
inputs evaluate the sparse Hessian for each element of the sum and add them together, This frequently 
results in a banded or otherwise regular pattern of sparsity. The visualization function boxes work somewhat 
differently from the others because they inherently involve the side effect of displaying someth~ng on 
the screen. When the Draw or Ren­der command is executed, the visualization boxes pull the required data 
through the dataflow diagram and display the re­sults. The Circle box, for example, pulls its radius 
and position through the dataflow tree and then displays a corresponding circle in the visualization 
window when the Draw command is exe­cuted. Parametriccurvesandsurfacesrequireaslightlydifferent treatment. 
In CONDOR, they are represented with split nodes -­one which generates the parameters, and one which 
accepts the position and possibly color of a curve or surface point. When asked to Draw or Render, the 
split nodes do a series of evalu­ations through the dataflow tree to tesselate and display the curve 
or surface. To evahrate each point on the curve or surface, they set the parameters (pushing a cache-invalidate 
signal) and then pull the position and/or color information through the tree. W. CONDOR USER INTERFACE 
CONDOR provides a graphical user interface designed in the Macintosh tradition of pull-down menus, noun-verb 
interac­tion and direct manipulation. To facilitate its use with both high­performance graphics srrpercomputers 
and personal computers, the user interface was built using Interviews 19],a portable, pub­lic domain, 
C++ object-oriented user-interface toolkit using X­windows. InterViews was ported to use the Macintosh 
Toolbox when running on Macintoshes and the Silicon Graphics GL when running on Silicon Graphics workstations. 
The resulting performance is acceptable on both high-end Apple Macintosh computers and SGI IRIS 4D graphics 
workstations. In addition, a native Macintosh implementation of most of the CONDOR func­tionality has 
been embedded in Graphite, an experimental modeler in use in the Apple Computer Advanced Technology Group. 
Fig. 1 shows a sample screen-image of CONDOR in use. The user has created and wired together five adder 
and multiplier function blocks to specify a simple optimization problem. New boxes are selected from 
the menus and wired together by clicking and dragging. Each function block appears with its inputs on 
the bottom and its outputs on the top. Computed values flow from the output of one function box to the 
input of another along connections displayed as splines. Any input which is not connected to the output 
of another box contains a numeric value which the user can set. During the course of an optimization 
or a differential equation, the values can be changed unless the user freezes them by selecting the inputs 
and then choosing the Freeze command from the edit menu. Frozen inputs are displayed in blue and are 
regarded as constants for optimization and differential equations. A function to be optimized can be 
selected by picking an output and choosing the Minimize command from the Edit menu. Any output selected 
for minimization is drawn in green. For convenience, several outputs can be selected for minimiza­tion 
at once. As far as the optimizer is concerned, this means that the objective function is the sum of the 
outputs that have been se­lected. Fig. 2 shows a small subset of the different boxes that CONDOR supports. 
Additional boxes can be created very easily with the compiler. Inputs or outputs Iabelled with numbers 
in brackets are vectors. Creating a connection between a vector input and a vector output connects each 
component together, The user interface does not allow connections between inputs and out­puts of different 
vector lengths. No distinction is made between scalars and vectors of length one. Note the adder box 
at the bot­tom of the figure. Adders and many other function boxes can be created with vector inputs 
of any length. This adder has its sec­ond input displayed as a sequence of three scalars (bO, bl, and 
b2) because the user selected the second input and chose the To Scalar command from the Edit menu. All 
vector inputs and outputs can be freely changed back and forth to scalars for conve­nience. The box Iabelled 
CRSpline is the Catmull-Rom spline defined in section IV. The Dot box is a dot product which is available 
with variable numbers of inputs. The Circle, Curve and Surf boxes are special boxes for visu­alization 
or rendering purposes. When the Draw command is Computer Graphics, 26,2, July 1992 executed, the Circle 
box draws a circle in a separate drawing window at the position given by its vector x input with a radius 
given by its r input. The Curve object is used to draw a paramet­ric curve in the drawing window. It 
is represented visually by two blocks, one which generates values of the parameter u and one which accepts 
position values. To specify a curve, the user wires up a diagram which computes x as a function of u. 
Para­metric surfaces are handled similarly with the Surf object except that one block generates u, v 
values while the other block accepts positions in three dimensions and an associated color. Surf ob­jects 
are tessela[ed, Gouraud shaded and Z-buffered when drawn. The Time box outputs a special global value 
which is controlled by the VCR buttons just below the menu bar. Combined with the visualization capabilities 
of the drawing ob-Jeers. it provides a means of creating animation. When the VCR play button > is pressed, 
CONDOR displays an animation by sequentially changing the value of the time variable and drawing the 
results. Complex scenes can be computed frame by frame and written to tiles or directly to single-frame 
animation equip­ment by using the Animate command. The Mouse box outputs the position and button state 
of the mouse. This is particularly useful when CONDOR k h a contin­uous optimization or display loop. 
As (he mouse is moved, the objective function can be changed interactively, In addition, if CONDOR is 
told to minimize the product of an objective func­tion and a mouse button, then the mouse button effectively 
turns the objective function on and off. The Compound box is used for creating hierarchies of boxes. 
In order to use this facility, the user creates a compound box, opens it up and creates input and output 
boxes. Any series of other boxes can be connected between the inputs and outputs. When the compound box 
is closed, it appears again as a single box with the corresponding inputs and outputs. For convenience, 
it can be relabeled with a more meaningful name. The Wire box is used to send a value from one part of 
a diagram to another without a connecting spline. Some have sug­gested that a better name would be Wireless. 
It is designed to mimic the convention for connecting signals across long distances in electrical circuit 
diagrams by naming them at both ends. Wires can be given labels which denote the values they carry. Binders 
are function boxes which simulate the parameter binding that occurs when subroutines are called in conventional 
computer languages. They save certain inputs of other boxes, change them to new values, evaluate the 
outputs and then restore the original input values, Their main value is that they allow arbitrary portions 
of a diagram to be used for multiple purposes. The binder in the diagram computes the value of the Yu 
output of the CRSpline box with only the b input changed. The Selector box contains a potentially very 
long vector of values. Its outputs a,h, c and d are a sequence of values taken from the vector starting 
at an index given by the integer portion of the time input. For the selector shown in the figure, the 
values themselves are vectors of length five, The r output of the Selector computes the fractional portion 
of the time input. Selector boxes are particularly useful for supplying spiine knots and neighborhoods 
of samples for finite-difference problems. CONDOR supplies a collection of other general function blocks 
and a large set of problem-specific blocks which are easily constructed with the compiler. The collection 
is a rapidly expanding moving target as can be expected with an experimental system. Compiler definitions 
for some of the other function blocks used in the examples can be found in Appendix 1.  VII. CONDOR 
UTILITIES set of utilities which perform useful operations on functions spec­ified by the dataflow diagrams. 
The utilities make widespread use of the function and metadata evaluation supplied by CON-DOR, The CONDOR 
optimizer is the utility responsible for com­puting the solutions of optimization problems posed with 
the user interface. Given the state vector, the gradient and the Hessian matrix, a variety of optimization 
methods are possible[ i~], The currently implemented optimizer uses Newton s method with stepsize control. 
[n order to solve the required linear system, the optimizer uses a public domain sparse LU decomposition 
algorithm from the ACM collected algorithmslml. The CONDOR optimizer attempts to converge to the nearest 
local minimum from any given starting point. It does not do global op­timization. The user has to pick 
a suitable starting point for the optimization and cast the problem in such a way that the nearest local 
minimum will be of value. The CONDOR ODE solver is in an early stage of develop­ment, providing an explicit 
Runge Kutta integrator and an implic­it Euler integratorfz t 1. Since it has not yet been fully integrated 
into the user interface, its use has been limited so far. ODES of physical systems with energy functions 
are the easiest to handle because their energy functions can be specified the same way as objective functions 
for optimization. General dissipation terms require extensions to the interface which have not yet been 
com­pleted, PDEs are currently handled in CONDOR by using the finite difference or finite element method 
to express a residual. The re­sidual is then squared and minimized with the optimizer. If the optimizer 
reduces the residual to zero, the PDE is solved, Sometime in the future, a solver aimed directly at PDEs 
may be added. The CONDOR surface trimmer uses interval arithmetic to find intersection points between 
two parametric surfaces. For any u, t, rectangle on a parametric surface, interval arithmetic provides 
a guaranteed 3D axis-aligned bounding box. It can be thought of as providing a mapping [(urnitr, umu-r), 
(vrnin, vrrru-r)]--> [(.xmin, xmux), (ymin, ymax), (zrnirr, roux)]. To compute intersection points, the 
surface trimmer begins by finding the bounding boxes corresponding to the whole parameter spaces of the 
two surfaces. If the bounding boxes do not intersect, then the surfaces do not intersect and the algorithm 
terminates. If the bounding boxes do intersect, both of the parameter spaces are subdivided in quadtrees. 
As the parameter-space regions are subdivided, their bounding boxes get smaller and smalter. In regions 
where the bounding boxes from the two surfaces overlap, the algorithm subdivides until the bounding boxes 
are smaller than a tolerance. The algorithm can then provide a set of points where the surfaces are guaranteed 
to intersect within a tolermrce. and connected regions of parameter space in which the trimming curve 
might lie. The surface trimmer connects the intersection points into a trimming curve and triangulates 
the parameter-space region in such a way that pieces from the two parameter spaces can be joined without 
cracks. Details of the algorithm can be found in122]. Other utilities based on interval arithmetic are 
planned. The CONDOR interval arithmetic capability makes it particularly suited to geometric problems 
where point sampling gives insuffi­cient information, In triangulating parametric or implicit surfac­es, 
for example, interval arithmetic provides a way to guarantee that small features are not missed. Similarly, 
interval arithmetic can provide direct guaranteed ray-object intersections for analytic surfaces. Other 
have used Lipschitz bounds for similar purposesln; MI, but in most cases, interval arithmetic provides 
a suitable alternative. Dataflow function composition is useful in many contexts, but it has important 
limitations for general purpose programming. Recognizing these limitations, CONDOR provides an expanding 
  constraints on these hypothesized values and let the optimizer solve for them. There are two selectors 
which contain data for the optimiza­tion, The first, Iabelled XYZ Se], holds the positions of the points 
in the reference frame on the piece of cardboard. The sec­ond, Iabelled UV SeI, holds the positions of 
the observed points on the camera screen. The data in both of these selectors is fro­zen because it is 
given in the problem specification. This is de­noted in the diagram by the blue color of the selector 
outputs. The boxes lahelled Viewing Xform compute the transformation of the known 3D points given the 
hypothesized camera parame­ters. The points transformed into 2D are then subtracted from the measured 
2D points and the result squared by the Eq2d function block. The TOpt box sums the result over the four 
points, The TOpt box achieves its minimum value of zero if and only if the hypothesized transformation 
of the 3D points brings them into the measured 2D positions. There is one further constraint on the problem 
which is that the rotation matrix should be orthogonal. This is handled bv the 0rtho3d function block 
which commstes the func(ion 1A AT -112 which vanishes if and only if the matrix is orthogonal. When given 
a starting point without an incorrect reflection, CONDOR solves the problem of Fig, 4tonearly three digits 
ac­curacy in (wentytothit-ty Newton iterations, each taking substan­tially less than asecondon a Personal 
IRIS. Asstated, this prob-Iem involves a 13 by 13 full Hessian matrix and some difficult non-linearities 
due to the perspective projection, Given that, the performance is fairly reasonable, There are much more 
efficent ways of solving the same problem which involve much smaller matrices (e.g. using quaternions 
for the rotation) --this wascho­sen for pedagogical purposes. Fig.5a shows an example based on a variational 
problem: the minimization of the energy of a natural spline. The selector box contains a se[of 100samplesof 
a curve in the plane, Suc­cessive points along that curve are used to approximate the sec­ond derivative 
by the formuladxx = (a+b-2c)/hA2. The dot box computes the dot product of the second derivative approximation 
with itself. This yields the sum of the squares of the second deri\ati\esof thexandyc omponentof thecurve, 
The TOptbox computes the integral of this quantity overtime, the parameter of the curve. The user has 
frozen five points in the selector box with particular values input by hand. The result is aspeciticationof 
the first-principle from which splines are typically derived. It is well known that the solution of this 
optimization involves piece­wise cubics whose coefficients can be computed from a banded Iinear system, 
Faced with this problem, CONDOR constructs a related banded linear system fortheraw optimization problem. 
It solves the system in a fraction of a second on a Silicon Graphics Personal IRIS and requires only 
a few itemtions for convergence. The function boxes on the right half of Fig. 5aconcem the generation 
of the drawing. The five Circle blocks display the knot points while the Curve boxes draw the curve. 
The box la-belled Binder isa Binder function box which points to one of theoutput so ftheSelectorbox 
asa function of time. This allows thedravingw tdoptimization functions to beappliedto the same set of 
data. The optimization of Fig. 5a is interesting, but the answer ex­ists in closed form. Such is not 
the case for the closely related optimization of Fig. 5b, In addition to the standard bending ener­gy 
of a natural spline, CONDOR has been asked to minimize the integral alongthecurve ofa//r-repulsion force 
Iocatedat a point given byan Identity boxlabelled Repulsor. This time thesolu­tion can no longer be expressed 
as a piecewise cubic, but CONDOR still solves it in a fraction of a second using a similar, but different 
banded matrix, The ability to experiment rapidly with a variety of curve and surface optimization may 
well pro­duce important new classes of functions for computer-aided geometrictil design. Theoptimization 
of Fig. 5bisciosely related to some valuable computations in computer visionlzsl. Computer Graphics, 
26,2, July 1992 Fig.6 shows CONDOR applied to a spacetime constraint problem(T). Inthisproblem, reattempt 
tocompute a physically valid motion for a damped spring which is constrained to he at two different places 
at two different points in time. If the two constrained points were at the very beginning, then this 
problem could be solved by integrating the differential equation with a standard ODEsolver[2]). ht this 
case, however, they areapproxi­matelyone fourth and one half of the way into the motion, so the problem 
ismosteasily posed as an optimization. In Fig. 6a, the displacement of the damped spring is represented 
by a set of sam­ples, and the constraints are expressed in terms of finite differences. In Fig.6b, the 
displacements are represented by a Catmull-Rom spline curve --effectively using the finite element method. 
Both minimize the integral along the curve of (F-ma)2. At the minimum, F=ma everywhere along the curve. 
Both examples converge in a matter of seconds to the same answer, Fig. 6a with one hundred samples on 
the curve, and Fig. 6b with twenty-five spline segments. Fig. 7 is an example of CONDOR being used to 
create a shade tree and connect it to a parametric surface. Roughly speak­ing, the left side of the dataflow 
diagram is responsible for mod­eling and the right side for shading, The u and v parameters of the surface 
go into a Torus node which computes the positions, tangents and normals of the torus. The torus is then 
twisted by sending its positions and normals through a Barrt t31 Twist transformation and translated 
by sending the points through an adder. On the right side of the diagram, the u and v parameters are 
first remapped using a sinusoidal function of v (the PtoR function block computes a polar to rectangular 
coordinate trans­form) and then sent to an Image function block. The Image func­tion block takes in a 
point on an RGB image and outputs a biiin­early interpolated color vector. The resulting color is used 
by the Phong box which relies on the transformed normals from the twist transformation. The picture was 
tesselated into 50,000 tri­angles and displayed in less than 10 seconds on a Personal IRIS, Quite complex 
shaders and geometry can be constructed at inter­active speed. Fig. 8 shows a simple example using the 
interval-arithmetic based surface trimming algorithm implemented inside CONDOR[221, Two intersecting 
spheres have been trimmed against each other, leaving a sphere with a bite taken out. Fig. 8a shows the 
result of trimming with a fine subdivision, While a very similar image could have been created using 
ray tracing with CSG, this image was created by triangulating both surfaces. Fig, 8b shows the result 
with a much coarser subdivision which makes it more evident that the surfaces are triangulated. The triangulations 
were computed by recursively subdividing the parameter spaces of the two spheres and testing for intersections 
with interval arithmetic. The algorithm first does a breadth-first subdivision of the parameter spaces 
and then finds a series of points on the intersection curves by depth-first subdivision. The points are 
linked together into trimming curves and then the connected regions of the parameter spaces are triangulated. 
The triangulations of the two pieces share all vertices along the trimming curve, so no cracking can 
arise. Fig. 8C shows the quadtree subdivision of parameter space used to compute and triangulate the 
trimmed regions.  IX. CONCLUSION CONDOR was designed to provide a high-performance ex­ploratory environment 
for a variety of computer graphics computations. Despite being a fairly general tool, its perfor­mance 
is good enough to make it practical for problems of sub­stantial complexity. For example, it achieves 
linear-time asymp­totic performance on an important class of optimization problems that involve curves 
or functions of time. For geometry and ren­dering calculations, the efficiency of the compiler and the 
function composition make it a powerful interactive tool. The ability to combine these capabilities in 
a uniform dataflow repre­sentation means that geometry, rendering and animation compu­tations can influence 
each other. This is in contrast to most com­puter graphics software in which modeling, renderirr~ and 
anima­tion are regarded as very separate computations.  Acknowledgements Special thanks to Andrew Witkin 
for his role in developing some of the problems which motivated CONDOR and many of the ideas for solving 
them. Thanks to Pete Litwinowicz and Roger Spreen for porting InterViews and helping debug prob­lems. 
Roger Spreen also implemented the linear system code used by CONDOR and helped with an early version 
of the user interface. Michael Gleicher implemented the interval arithmetic operator overloading and 
the trimming code. Steven Rubin wrote the Macintosh modeler Graphite and ported the function and metadata 
evaluation of CONDOR to run within Graphite. Thanks to Lance Williams, Larry Tesler and Frank Ludolph 
for helpful advice and suggestions. Thanks to Frank Crow, Rick Le Faivre, Dave Nagel and the Advanced 
Technology Group at Apple Com­puter for supporting this work. Trademarks: MacintoshisatrademarkofAppleComputerInc. 
Mathe­maticalis a trademark of Wolfram Research Inc. UNIX is a trademark of AT&#38;T, IRIS is a trademark 
of Silicon Graphics Inc. APPENDIX 1 The following are compiler definitions of some of the function boxes 
used in the examples. (defoptimize :name ViewingXform :inputs ((lrotl:dims(3 3)) (Itransl:dims(3)) 1s1(Irefl:dims(3))) 
:initially (string-append srow= (s,s,1}; Mat= {srow,srow,srow,srow) Append[rot,trans]; OutVac= Append[ref,l].Mat 
) :outputa (((IouII:dims(2)) {OutVec[[l]VOutVac[[3]], 0utVec[[2]~OutVec[[3]] ) ))) (defoptimize :name 
Torus :inputs (lalIblIulIvl) :initially (string-append P= {(a+ b Coa[u 2 Pi])COS[V 2 F7], -(a+b Cos[u 
2 Pi])Sin[v 2 Pi], bSin[u 2 Pi]); TU= D[P,u]; Tv= D[P,v]; C= Croas~u,Tv];q Norm= Divide[C,(Sqrf[C.C])~ 
) :outputs (((IXI:dims(3)) P) ((ITuI:dims(3)) TuQ) ((ITvI:dims(3)) Tv ) ((INI:dims (3)) Norm ))) (defopfimize 
:name Twist :inputs ((lpi :dims(3))(Inl:dims(3)) Ikl) :inifially (stringappersd x= p[[l]];y=p[[2]]:z=p[[3]]; 
newp= (X,ZSin[kx]+y Coa[kX],ZCos[kx]-y Sin[kx]); Jac = (D[newp,p[[l]]],D[newp,p[[2]]], D[newp,p[[3]]]);m 
newn= TrigReduce~ranspose[lnverseflrigRaduce[Jac]]]].n") :outputs (((lpl:dims(3)) Yrewp ) ((lnl :dims 
(3)) newn ))) [1] Davis, A. and Keller, R., Data flow Program Graphs, IEEE Compurer, Feb. 1982,p. 26-241 
[2] Haeberli, P., ConMan: A Visual Programming Language for hr­teractive Graphics; Proc. of Siggraph 
88, p. 103-111. [3] Fleischer, K. and Witkin, A., A Modeling Testbed, Prwc. of Graphics Inte@ace 88, 
Edmonton, Alberta, 1988 [4] Perlin, K. An Image Synthesizer, Compurer Graphics 19 (3) Proc. Siggraph 
85, 1985 p. 287-296. [5] Alefeld, G. and Herzberger, J, Introduction To Interval Computa­tions, Academic 
Press, 1983. [6] Witkin, A, Fleiscber, K., and Barr, A,, Energy Constraints On Pa­rametrized Models, 
Proc. Siggraph 87, Anaheim, California, 1987. [7] Witkin, A. and Kass, M,, %pacetime Constraints, Proc. 
Siggraph 88, p. 159-168. [8] Snyder, J., Interval Analysis for Comp~ter Graphics, Proc. Sig­graph 92. 
[9] Duff, T,, Interval Arithmetic and Recursive Subdivision for im­plicit Functions and Constructive 
Solid Geometry, Proc, Sig­graph 92. [10] Mitchel, D. and Hanrahan, P., Illuminationfrom Curved Reflec­tors, 
Proc. Siggraph 92. [II] Wolfram, S., Mathernatica: A Sysfem for Doing Mathematics by Computer, Addison-Wesley, 
Redwood City, California, 1988. [12] GI1l, E., Murray, W. and Wright, M., Practical Optimization, Aca­demic 
Press, New York, 1981. [t3] Barr, A., Globat and local deformations of solid primitives, Proc, Siggraph 
84p, 21-29. [14] Irrgalls,D. et al, Fabrik: A Visual Programming Environment, Proe. 00PSLA 88, September 
25-30, 1988, p. 176-190. [15] Pangaro, P., Steinberg, S., Davis, J. and McCann, B., EOM: a Graphically 
Scripted, Simulation-Based Animation System, Ar­chitecture Machine Group, Massachusetts Institute of 
Technology, August 1977. [16] Cook, R., Shade Trees, Proc. Siggraph 84, p. 223-230, 1984. [17] Abram, 
G., and Whitted, T., Building Block Shaders, Proc. Sig­~raph 90, 1990,p. 283-288. [18] Steele, G. et. 
al., CommonLisp ~he Language, Digital Press, Bed­ford, Massachusetts, 1984. [19] Linton, M., Calder, 
P,, and Vlissides, J., The Design and Imple­mentation of InterViews, Proceedings of the USEN[X C+ + Workshop,, 
November 1987. [20] Sherman, A., Algorithm 533: NSPIV, A Fortran Subroutine for Sparse Gaussian Elimination 
With Partial Pivoting, ACM TOMS, Vol. 4, No. 4, December, 1978,p, 391-398. [21] Press, W. et. al., Numericaf 
Recipes, Cambridge University Press, Cambridge, England, 1986 [22] Gleicher, M, and Kass, M, An Interval 
Refinement Technique for Surface Intersection, Graphics Interface 92, to appear. [23] Von Herzen, B. 
and Barr, A., Accurate Triangulations of De­formed, Intersecting Surfaces, Computer Graphics 21 (4) Proc. 
Siggraph 87, 1987p. 103-110. [24] Von Herzen, B., Barr, A., and Zatz, H., Geometric Collisions for Time-Dependent 
Parametric Surfaces, Compurer Graphics 24 (4) Proc. Siggraph 90, 1990p. 39-48, [25] Williams, L,, Perforrnance-Driven 
Facial Animation, Proc. Sig­graph 90, 1990, p. 235-242. [26] Lowe, D., Solving for the Parameters of 
Object Models from Image Descriptions, Proc. image Understanding Workshop, April 1980, p. 121-127. [27] 
Gennery, D., Stero Camera Calibration, Proc. Image f/nder­srandirrg Workshop, April 1980,p. 201-208. 
[28] Kass, M., Witkin, A., and Terzopoulos, D., Snakes: Active Con­tour Models, Inrernatimsa[ Journal 
of Compu/er Vision, 1988, p, 321-331  Fig. 7: CONDOR used for rendering and modeling a twisted torus. 
Fig. 8: Two spheres trimmed against each other. (a) Fine tesselation. (b) Coarse tesselation. Fig. SC: 
Parametric subdivision corresponding to the coa  
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134088</article_id>
		<sort_key>331</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>39</seq_no>
		<title><![CDATA[Through-the-lens camera control]]></title>
		<page_from>331</page_from>
		<page_to>340</page_to>
		<doi_number>10.1145/133994.134088</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134088</url>
		<keywords>
			<kw><![CDATA[camera control]]></kw>
			<kw><![CDATA[constrained optimization]]></kw>
			<kw><![CDATA[interaction techniques]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.6</cat_node>
				<descriptor>Interaction techniques</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>F.2.1</cat_node>
				<descriptor>Computations on matrices</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>G.1.6</cat_node>
				<descriptor>Constrained optimization</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>H.5.2</cat_node>
				<descriptor>Interaction styles (e.g., commands, menus, forms, direct manipulation)</descriptor>
				<type>S</type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10003120.10003121.10003124</concept_id>
				<concept_desc>CCS->Human-centered computing->Human computer interaction (HCI)->Interaction paradigms</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002950.10003714.10003716</concept_id>
				<concept_desc>CCS->Mathematics of computing->Mathematical analysis->Mathematical optimization</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10002950.10003714.10003715.10003719</concept_id>
				<concept_desc>CCS->Mathematics of computing->Mathematical analysis->Numerical analysis->Computations on matrices</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003752.10003809.10003716</concept_id>
				<concept_desc>CCS->Theory of computation->Design and analysis of algorithms->Mathematical optimization</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010387</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Graphics systems and interfaces</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003120.10003121.10003125.10010391</concept_id>
				<concept_desc>CCS->Human-centered computing->Human computer interaction (HCI)->Interaction devices->Graphics input devices</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
			<gt>Human Factors</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>PP39038559</person_id>
				<author_profile_id><![CDATA[81100342764]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Michael]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Gleicher]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[School of Computer Science, Carnegie Mellon University, Pittsburgh, PA]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P18516</person_id>
				<author_profile_id><![CDATA[81100295587]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[Andrew]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Witkin]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[School of Computer Science, Carnegie Mellon University, Pittsburgh, PA]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_obj_id>319132</ref_obj_id>
				<ref_obj_pid>319120</ref_obj_pid>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Norman Badler, Kamran Manoocherhri, and David Baraff. Multi-dimentional input techniques and articulated figure positioning by multiple constraints. In Proceedings of the 1986 Workshop on Interactive 3d Graphics, pages 151- 170, October 1986.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378509</ref_obj_id>
				<ref_obj_pid>378456</ref_obj_pid>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Ronen Barzel and Alan H. Bart. A modeling system based on dynamic constaints. Computer Graphics, 22:179-188, 1988. Proceedings SIGGRAPH '88.]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_obj_id>617421</ref_obj_id>
				<ref_obj_pid>616000</ref_obj_pid>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Jim Blinn. Where am I? What am I looking at? IEEE Computer Graphics and Applications, pages 76--81, July 1988.]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_obj_id>319122</ref_obj_id>
				<ref_obj_pid>319120</ref_obj_pid>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[Frederick Brooks. Walkthough- a dynamic graphics environment for simulating virtual buildings. In Proceedings of the 1986 Workshop on Interactive 3d Graphics, pages 9-22, October 1986.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378497</ref_obj_id>
				<ref_obj_pid>378456</ref_obj_pid>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[Michael Chen, S. Joy Mountford, and Abigail Sellen. A study in interactive 3d rotation using 2d input devices. Computer Graphics, 22(4): 121-130, August 1988. Proceedings SIGGRAPH '88.]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_obj_id>51684</ref_obj_id>
				<ref_obj_pid>51683</ref_obj_pid>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[PHIGS+ Committee. Phigs+ functional description, revision 3.0. Computer Graphics, 22(3):125-215, 1988.]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_obj_id>147166</ref_obj_id>
				<ref_obj_pid>147156</ref_obj_pid>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Steven Drucker, Tinsley Gaylean, and David Zeltzer. CIN- EMA: a system for procedural camera movements. In Proceedings of the 1992 Symposium on Interactive Computer Graphics, pages 67-70, 1992.]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_obj_id>39857</ref_obj_id>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[Roger Fletcher. Practical Methods of Optimization. John Wiley and Sons, 1987.]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Sundaram Ganapathy. Decomposition of transformation matrices for robot vision. In International Conference on Robotics, pages 130-139, March 1984.]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[Donald Gennery. Stereo-camera calibration. In Proc. DARPA Image Understanding Workshop, pages 101-107, 1979.]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
			<ref>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[Phillip Gill, Walter Murray, and Margret Wright. Practical Optimization. Academic Press, New York, NY, 1981.]]></ref_text>
				<ref_id>11</ref_id>
			</ref>
			<ref>
				<ref_obj_id>143074</ref_obj_id>
				<ref_obj_pid>142750</ref_obj_pid>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[Michael Gleicher. Briar- a constraint-based drawing program. in CHI '92 Formal Video Program, 1992. SIG- GRAPH video review, in press.]]></ref_text>
				<ref_id>12</ref_id>
			</ref>
			<ref>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[Michael Gleicher and Andrew Witkin. Differential manipulation. Graphics Interface, pages 61--67, June 1991.]]></ref_text>
				<ref_id>13</ref_id>
			</ref>
			<ref>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[Michael Gleicher and Andrew Witkin. Snap together mathematics. In Edwin Blake and Peter Weisskirchen, editors, Advances in Object Oriented Graphics 1: Proceedings of the 1990 Eurographics Workshop on Object Oriented Graphics. Springer Verlag, 1991. Also appears as CMU School of Computer Science Technical Report CMU-CS- 90-164.]]></ref_text>
				<ref_id>14</ref_id>
			</ref>
			<ref>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[David Lowe. Solving for the parameters of object models from image descriptions, In Proc. DARPA Image Understanding Workshop, pages 121-127, 1980.]]></ref_text>
				<ref_id>15</ref_id>
			</ref>
			<ref>
				<ref_obj_id>97898</ref_obj_id>
				<ref_obj_pid>97880</ref_obj_pid>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[Jock Mackinlay, Stuart Card, and George Robertson. Rapid controlled movement through a virtual 3d workspace. Computer Graphics, 24(4):171-176, August 1990.]]></ref_text>
				<ref_id>16</ref_id>
			</ref>
			<ref>
				<ref_seq_no>17</ref_seq_no>
				<ref_text><![CDATA[Chris McGlone. Automated image-map registration using active contour models and photogrammetric techniques. In Proceedings of the SPIE, Volume 1070, January 1989.]]></ref_text>
				<ref_id>17</ref_id>
			</ref>
			<ref>
				<ref_seq_no>18</ref_seq_no>
				<ref_text><![CDATA[Francis H. Moffitt. Photogrammetry. International Textbook Company, 1959.]]></ref_text>
				<ref_id>18</ref_id>
			</ref>
			<ref>
				<ref_obj_id>378524</ref_obj_id>
				<ref_obj_pid>378456</ref_obj_pid>
				<ref_seq_no>19</ref_seq_no>
				<ref_text><![CDATA[John Platt and Alan Bart. Constraint methods for flexible models. Computer Graphics, 22:279-288, 1988. Proceedings SIGGRAPH '88.]]></ref_text>
				<ref_id>19</ref_id>
			</ref>
			<ref>
				<ref_seq_no>20</ref_seq_no>
				<ref_text><![CDATA[William Press, Brian Flannery, Saul Teukolsky, and William Vetterling. Numerical Recipes in C. Cambridge University Press, Cambridge, England, 1986.]]></ref_text>
				<ref_id>20</ref_id>
			</ref>
			<ref>
				<ref_seq_no>21</ref_seq_no>
				<ref_text><![CDATA[K. Schwidefsky. An Outline of Photogrammetry. Pitman Publishing Corporation, first english edition, 1959.]]></ref_text>
				<ref_id>21</ref_id>
			</ref>
			<ref>
				<ref_obj_id>325242</ref_obj_id>
				<ref_obj_pid>325165</ref_obj_pid>
				<ref_seq_no>22</ref_seq_no>
				<ref_text><![CDATA[Ken Shoemake. Animating rotations with quatemion curves. Computer Graphics, 19(3):245-254, July 1985.]]></ref_text>
				<ref_id>22</ref_id>
			</ref>
			<ref>
				<ref_obj_id>147196</ref_obj_id>
				<ref_obj_pid>147156</ref_obj_pid>
				<ref_seq_no>23</ref_seq_no>
				<ref_text><![CDATA[Mark Surles. Interactive modeling enhanced with constraints and physics - with applications in molecular modeling. In Proceedings of the 1992 Symposium on Interactive Computer Graphics, pages 175-182, March 1992.]]></ref_text>
				<ref_id>23</ref_id>
			</ref>
			<ref>
				<ref_seq_no>24</ref_seq_no>
				<ref_text><![CDATA[Konstantinos Tarabamis, Roger Tsai, and Peter Allen. Automated senor planning for robotic vision tasks. In Proceedings of th 1991 IEEE International Conference on Robotics and Automation, pages 76--82, April 1991.]]></ref_text>
				<ref_id>24</ref_id>
			</ref>
			<ref>
				<ref_obj_id>139852</ref_obj_id>
				<ref_obj_pid>139834</ref_obj_pid>
				<ref_seq_no>25</ref_seq_no>
				<ref_text><![CDATA[Russell Turner, Francis Balaguer, Enrico Gobbetti, and Daniel Thalmann. Physically-based interactive camera motion using 3d input devices. In N. M. Patrikalakis, editor, Scientific Visualiztion of Physical Phenomena: Proceedings of CG International 1991, pages 135-145~ Tokyo, 1991. Springer-Verlag.]]></ref_text>
				<ref_id>25</ref_id>
			</ref>
			<ref>
				<ref_obj_id>91442</ref_obj_id>
				<ref_obj_pid>91394</ref_obj_pid>
				<ref_seq_no>26</ref_seq_no>
				<ref_text><![CDATA[Colin Ware and Steven Osborne. Exploration of virtual camera control in virtual three dimensional environments. Computer Graphics, 24(2):175-184, March 1990. Proceedings 1990 Symposium on Interactive 3D Graphics.]]></ref_text>
				<ref_id>26</ref_id>
			</ref>
			<ref>
				<ref_seq_no>27</ref_seq_no>
				<ref_text><![CDATA[William Welch, Michael Gleicher, and Andrew Witkin. Manipulating surfaces differentially. In Proceedings, Compugraphics '91, September 1991. Also appears as CMU School of Computer Science Technical Report CMU-CS- 91-175.]]></ref_text>
				<ref_id>27</ref_id>
			</ref>
			<ref>
				<ref_obj_id>37429</ref_obj_id>
				<ref_obj_pid>37402</ref_obj_pid>
				<ref_seq_no>28</ref_seq_no>
				<ref_text><![CDATA[Andrew Witkin, Kurt Fleischer, and Alan Ban-. Energy constraints on parameterized models. Computer Graphics, 21 (4):225--232, July 1987.]]></ref_text>
				<ref_id>28</ref_id>
			</ref>
			<ref>
				<ref_obj_id>91400</ref_obj_id>
				<ref_obj_pid>91394</ref_obj_pid>
				<ref_seq_no>29</ref_seq_no>
				<ref_text><![CDATA[Andrew Witkin, Michael Gleicher, and William Welch. Interactive dynamics. Computer Graphics, 24(2): 11-21, March 1990. Proceedings 1990 Symposium on Interactive 3D Graphics.]]></ref_text>
				<ref_id>29</ref_id>
			</ref>
			<ref>
				<ref_seq_no>30</ref_seq_no>
				<ref_text><![CDATA[Andrew Witkin, Michael Kass, Demetri Terzopoulos, and Kurt Fleischer. Physically based modeling for vision and graphics. In Proc. DARPA Image Understanding Workshop, pages 254-278, 1988.]]></ref_text>
				<ref_id>30</ref_id>
			</ref>
			<ref>
				<ref_obj_id>565650</ref_obj_id>
				<ref_obj_pid>97879</ref_obj_pid>
				<ref_seq_no>31</ref_seq_no>
				<ref_text><![CDATA[Andrew Witkin and William Welch. Fast animation and control of non-rigid structures. Computer Graphics, 24(4):243-252, August 1990. Proceedings SIGGRAPH '90.]]></ref_text>
				<ref_id>31</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 Comuuter Graohies, 26,2, JIJIV1992 Through-the-Lens Camera Control Michael Gleicher artd Andrew Witkin 
School of Computer Science Carnegie Mellon Pittsburgh, {gleicher lwitkin} Abstract In this paper we 
introduce through-the-lens camera con­trol, a body of techniques that permit a user to manipulate a virtual 
camera by controlling and constraining features in the image seen through its lens. Rather than solving 
for camera parameters directly, constrained optimization is used to compute their time derivatives based 
on desired changes in user-defined controls. This effectively permits new controls to be defined independent 
of the underlying parameterization. The controls can also serve as con­straints, maintaining their values 
as others are changed. We describe the techniques in general and work through a detailed example of a 
specific camera model. Our im­plementation demonstrates a gallery of useful controls and constraints 
and provides some examples of how these may be used in composing images and animations. Keywords: camera 
control, constrained optimization, interaction techniques Introduction Camera placement and control 
play an important role in image composition and computer animation. Conse­quently, considerable effort 
has been devoted to the devel­opment of computer graphics camera models. Most cam­era formulations are 
built on a common unded ying model for perspective projection under which any 3-D view is fully specified 
by giving the center of projection, the view plane, and the clipping volume. Within this framework, camera 
models differ in the way the view specification is parameterized. Not all formulations are equivalent 
some allow arbitrary viewing geometries, while others impose restrictions. Even so, alternative models 
can be viewed to Perrmssinn tn cnpy without fee all or port of this material is granted provided that 
the copies are not made or distributed for direct cnmmerciat advantage, the ACM copyright notice and 
the title of the puhlicalmn and IIS date appr, and notice M given that cupyirrg is by permission nf the 
Awmiatmn for Computing Machinery. To copy other wtsc,or to repuhliih. requires a fee imd/or specific 
permission. (( WY2 ACM-O-8979 [-479-1/92/007/033 I $01.50 University PA flcs.cmu.edu a great degree 
as alternative slicings of the same projective pie. How important is the choice of the camera model s 
pa­rametenzation? Very important, if the parameters are to serve directly as the controls for interaction 
and key frame interpolation. For example, the popular LOOKAT­/LOOKFROM/VUPparameterizationmakes it easy 
to hold a world-spacepoint centered in the image as the camera moves without tilting. To do the same 
by man­uall y controlling generic translation/rotationparameters would be ail but hopeless in practice, 
although possible in principle. The difficulty with using camera parameters directly as controls is that 
no single parameterization can be ex­pected to serve all needs. For example, sometimes it is more convenient 
to express camera orientation in terms of azimuth, elevation and tilt, or in terms of a direction vector. 
These particular alternatives are common enough to be standardly available, but others are not. A good 
example involves the problem, addressed by Jim Blinn[3] of portraying a spacecraft flying by a planet. 
Blinn de­rives several special-purpose transformations that allow the image-space positions of the spacecraft 
and planet to be specified and solves for the camera position. The need for this kind of specialized 
control arises frequently, but we would rather not face the prospect of deriving and coding specialized 
transformations each time they do. In short, camera models are inflexible. To change the controls, one 
must either select a different pre-existing model or derive and implement a new one. If this in­flexibility 
could be removed, the effort devoted to camera control could be reduced and the quality of the result 
en­hanced. In this paper, we present a body of techniques, which we call through-the-lens camera control, 
that offer a general solution to this problem. Instead of a fixed set, the user is given a palette of 
interactive image-space and world­space controls that can be applied on the fly, in any combination. 
For example, the image-space position of an arbitray world-space point can be controlled by inter­active 
dragging, or pinned while other points are moved. Image-space distances, sizes, and directions can also 
be .. controlled. Points can be constrained to remain within the image or within a specified sub-region. 
These and other image-space controls can be freely combined with direct world-space controls on camera 
position and orientation. The set of controls is extensible, with a general procedure for adding new 
ones. Using through-the-lens control, the spacecraft/phmet problem, and others of its kind, could be 
solved imme­diately and interactively: a point on the planet would be grabbed, dragged to its target 
location, then left pinned at that image point. The spacecraft would be similarly posi­tioned and pimed. 
Residual degrees of freedom could be fixed by dragging additional points, or manipulating the camera 
in world space, while both image points mnained nailed. All the while, the required camera motions would 
be computed automatically at interactive speed. The principal technical obstacle to achieving this kind 
of control lies in the nonlinearity of the relationship between the desired controls and the underlying 
view specification. No general guaranteed procedure exists for solving non­linear algebraic systems; 
in fact there may often exist no solution, or many. The direct approach solving numer­ically for the 
camera parameters given the controls-is therefore unlikely to succeed. The key to our approach is that 
we instead formulate the problem differentially-solving for the lime derivatives of the camera parameters, 
given the time derivatives of the controls. For example, a point is dragged by specifying its velocity 
from moment to moment, rather than giving a final target position. When the camera is under interactive 
control, it falls to the user interface to convert user actions, such as pointer motions, into suitable 
velocity signals. In keyframe control, the velocity is calculated by takhg the time derivative of the 
interpolating function. The use of differential control does not allow us to directly position the camera 
in global leaps, but instead provides a robust and accurate means of translating continuous adjustments 
of the controls into continuous motions of the camera. We are primarily interested in interactive control 
by grabbing and dragging, for which continuous motion is desirable, and with low-level camera control 
for animation, for which continuous motion is sufficient. We formulate the problem of computing time 
deriva­tives of camera parameters as a simple constrained op­timization. Once the derivatives have been 
computed, using them to update the camera s state over time reduces to the standard problem of solving 
a first-order ordinary differential equation from an initial value, for which good numerical methods 
abound (see Press et. a~. [20] for a good practical introduction.) An interesting feature of through-the-lens 
control is the new role in which it places the camera parameterization. Although we retain a fixed underlying 
camera model, the model s parameters no longer bear the burden of serving as use~-level controls. In 
fact, the parameters maybe com­pletely hidden from the user. This leaves us free to choose a camera model 
on the basis of numerical well-behavedness and implementation convenience. Our preferred formula­tion, 
based on quatemion rotations, is a case in point: it is a very poor model by conventional criteria, since 
the four components of the quatemion would be exceedingly diffi­cult to control directly. Yet it provides 
an ideaI substrate for through-the-lens control because it allows free came­ra rotations without singularities 
or other artifacts. We avoid the well-known difficulties involved with interpo­lating quatemions for 
animation[22] by interpolating the controls instead. The remainder of the paper is organized as follows: 
Fol­lowing a discussion of related work, we develop the ma­chinery of through-the-lens control in terms 
of a generic camera model, starting with the problem of controlling the image-space velocity of a single 
point, then generalizing to the full solution. We then present complete through­the-lens equations for 
our simple quatemion-based cam­era model. We describe our implementation and present examples, then conclude 
with a discussion of future work. 2 Related Work As we noted in Section 1, standard computer graphics 
cam­era models are based on specialized transformations that specify the view as a function of parameters 
that are useful for interactive, procedural, or keyframed control. Earlier we discussed the standard 
LOOKAT/LOOKFROM model. An example of a more general viewing model currently in wide use is the PHIGS+ 
model[6]. In addition, a vari­ety of special-purpose models such as Blinn s spacecraft flyby transformations 
[3] have been developed. Issues involved in using the LOOKAT/LOOKFROM model to navigate virtual spaces 
are considered by [16]. In [7], the LOOKAT/LOOKFROM model is embedded in a proce­dural language for specifying 
camera motions. Much of the work on interactive camera placement in computer graphics has been concerned 
with direct con­trol of the camera s position and orientation. The prob­lem of developing intuitive controls 
for 3-D rotations is a difficult one[5], particularly when the input device is twe-dimensional. Several 
researchers have addressed the problem through the use of use of 3-D interfaces, inchtd­ing six degree-of-freedom 
pointing devices[26, 25, 1] and more specialized devices such as steerable treadmills[4]. Problems involving 
the recovery of camera parame­ters from image measurements have been addressed in photogrammetryl, computer 
vision, and robotics. All of these are concerned with the recovery of parameter val­ues, rather than 
time derivatives. Algebraic solutions to specific problems of this kind are given in [18] and [9], while 
numerical solutions are discussed in [15, 10, 17]. In [24], constrained optimization is employed to position 
a Also see chapter 6 of [21] for amazing mechanical solutions to photogrammetry problems. real camera, 
mounted on a robot arm, for the purpose of object recognition. Factors considered in the optimization 
include depth of field, occlusion, and image resolution. Optimization techniques have been applied to 
the re­lated problem of object placement in computer graphics. In [1] articulated figures are posed using 
penalty meth­ods to meet positional goals. In [28], similar methods are employed for general object placement 
and control. The use of these methods for camera placement in animation is described in [30]. The differential 
control methods employed in this paper are formally more closely allied to the methods of con­strained 
dynamic simulation described in [29,2, 19,31,23] than to the positional optimization methods cited above. 
Some of the issues involved in adapting these methods to differential kinematic control are addressed 
in [13], while [27] considers their application to the design of free form surfaces, and [12] illustrates 
their use in a constraint-based drawing program. The Machinery In this section we introduce the basic 
mechanisms that support through-the-lens control, employing a simple con­strained optimization formulation. 
Assuming that we have chosen a camera model to provide the fixed, underlying parameterization, we solve 
for the time derivatives of the parameters such that their mean squared deviation from a desired value 
is minimized, subject to the constraints imposed by the image-space controls. Setting the default values 
to zero yields a solution that minimizes the mean squared rate of change of camera parameters. Non-zero 
values can be used to support interactive dragging subject to the constraints imposed by other controls. 
We begin by giving the relationship between a world­space point and its image-space counterpart, which 
we express in terms of a generic camera model. A specific quatemion-based model will be fully described 
in section 4. We give the coordinates of an image point p as p = h(Vx), (1) where x is the world-space 
point that projects to p, V is a homogeneous matrix representing the combined pro­jection and viewing 
transformations, and h is a function that converts homogeneous coordinates into 2-D image coordinates, 
defined by h(x)= ;,: . ,,. [1 where the X, s are components of homogeneous point x. The matrix V is 
some (for now unspecified) function of the camera model parameters, which we denote by a length-n vector 
q. In practice, V would usually be computed as the product of several matrices, each a function of one 
or more of the parameters. Computer Graphics, 26,2, July 1992 3.1 Camera motions and image point velocities. 
Assuming for now that the world space point x is fixed, the image point p is entirely a function of the 
camera parameters q. This is a nonlinear relationship because h is nonlinear, as in general is V (q). 
We obtain the expression for the image velocity p by applying the chain rule: 8(VX) . p = h (Vx) (2) 
aq ()where h (x) is the matrix representing the derivative of h(x), given by q is the time derivative 
of q, and tl(Vx)/~q is the 4 x n matrix representing the derivative of the transformed point Vx with 
respect to q, We differentiate the point Vx rather than the matrix V to avoid differentiating a matrix 
with respect to a vector, which would give rise to a rank-3 tensor. In section 4, we give an example 
of how this derivative matrix can be computed. For notational compactness we will define the 2 x n matrix 
a(vx) J = h (Vx) (4) i?q so that p = Jq. (5) Notice that equation 5 gives p as a Iinear function of q, 
even though p is a nonlinear function of q.  3.2 Controiiing a singie point Having obtained p as a function 
of q, we next consider the problem of controlling a single image point, i.e. solv­ing for a value of 
q that makes the image point assume a given velocity p = po. In practice the value for p. might be supplied 
by the user interface or might indicate the velocity on a keyframed motion path. Although the relation 
between p and q is linear, we cannot simply solve p. = Jq for q unless matrix J is square and of full 
rank, which in general it will not be. The singularity of the matrix J reflects the fact that many distinct 
camera motions can cause a single point to move in the same way. One way to solve the problem might be 
to require the user to control enough points or other features to yield a square matrix. We choose a 
different option that offers far more flexibility: subject to the constraint that p = po, we minimize 
the magnitude of q s deviation from a specified value qo. Letting = O imposes a qO criterion of minimal 
change in the camera parameters. As we shall see later, the ability to choose other values makes it possible, 
for example, to drag image points and other features subject to the hard constraints. 333 The problem 
we now wish to solve is: ~inimize ~ = (q -40) (4 -40) ,ub@ctto@ _ p, = ~ 2 (6) To qualify as a constrained 
minimum, q must satisfy sev­eral conditions. First, of course, the constraint must be met, i.e. p. = 
Jq. At an unconstrained minimum, we would require that the gradient d13/dq vanish. Instead, we require 
that it point in a dkction in which displacements are prohibhed by the constraints. This condition is 
expressed by requiring that dE/d~ =~ q. = JTA, for some value of the 2-vector J of Lagrange multipliers. 
This equation simply states that the gradient of E must be a linear combination of the gradients of the 
constraints. Combining the two conditions gives JJTA = P(I Jqo, (7) which is a matrix equation to be 
solved for A. Then the camera parameter derivatives are given by q = q. +JTA (8) Finally, we must use 
the computed value of q to update the camera state q, a standard initial value problem. See Press et. 
al. [20] for a discussion of the issues and a good assortment of numerical methods for ordinary differential 
equations. The very simplest method, Euler s method, employs the update formula q(t + At) = q(t)+ Atq(t). 
 Although easy to implement, Euler s method is notoriously unstable and inaccurate. Use it at your own 
risk! In the interactive loop of through-the-lens control, drawing and input are interleaved with solver 
steps. 3.3 General quadratic objective functions The restricted form of the objective function given 
in equa­tion 6 is often adequate, but can cause problems: when the controls do not fully determine the 
camera s state, the task of accounting for the remaining degrees of freedom falls to the objective function. 
For example, if the camera is able to respond to the motion of a controlled point by a com­bination of 
tracking and panning, the objective function determines how much of each will take place. Because the 
error norm of equation 6 is the Euclidean distance in the camera s parameter space, rather than being 
intrinsic to the world-space camera motion, the behavior depends in a somewhat haphazard way on the choice 
of camera parameterization, tid could even depend, for example, on the choice of linear and angular units 
of measure! To allow such behavior to be controlled in a more ratio­nal way we make a reasonably straightforward 
generaliza­tion, allowing E to be any quadratic function of q, having 334 the form E=~qMq+b. q+c, where 
M is a marnx, typically symmetric and positive­ definite, b is a vector, and c is a scalar, none of them 
depending on q. Since E is quadratic, the problem remains linear, although the matrix equation to be 
solved becomes a bit more complex. The gradient of E becomes dE  =Mq+b. ~ Denoting the inverse of 
M by W = M- , equation 7 assumes the form P(I = JWJTA JWb. (9) It is also possible to solve for A without 
obtaining the explicit inverse for M by forming a larger linear system (see [8].) Under this general 
linear/quadratic formulation, the camera s response to controls can be decoupled from the parameterization, 
for instance by letting M be a mass ma­trix for the camera[l 3,29, 31]. 3.4 Muitipie Points and Other 
Functions Controlling more than one point involves a simple exten­sion to the foregoing derivation. The 
matrix J depends on x, so each point being controlled yields a distinct version of equation 5. We combine 
the m equations into a sin­gle one by concatenating the derivative matrices to form a 2m x n matrix, 
and concatenating the image velocities to form a 2m-long vector. From that point on, the derivation proceeds 
as above, to the solution of equation 7 for A, which is now also a vector of length 2m. In addition to 
controlling image points directly, we would like to control functions of one or more points, such as 
image distance or orientation. In fact, to mix image­space and world-space controls we may want to control 
other functions of q that do not involve the image at all, such as object-to-camera distance. Conceptually, 
this is not a difficult generalization to make: in equation 5, we simply interpret p not as a literal 
point, but as the vector of quantities we wish to control. Matrix J must then give the derivative of 
each controlled quantity with respect to each camera parameter. In practice, performing the derivative 
evaluations, indexing and other bookkeeping, etc., can be­come quite complex. See [14, 29] for general-purpose 
schemes that facilitate the handling of this kind of matrix­assembly problem. Although our own implementations 
are based on such a scheme, the camera control problem is sufficiently restricted in scope that this 
certainly is not necessary. Many through-the-lens controls, such as point-to-point distance, can be expressed 
as fi,mctions of several image points positions. The labor involved in implementing such controls can 
be greatly reduced through through the use of the chain rule. For instance, consider a scalar Computer 
Graphics, 26,2, July 1992 function of two image points ~( pl, p2 ). The derivative of ~ with respect 
to q is d.. af dj J1 + Jz,  fi dp, 13pj where J I and J2 are the derivative matrices for p] and pz, 
computed according to equation 4. The code that evaluates J for image points need only be implemented 
once. Thereafter, just derivatives with respect to image points need be treated anew for each control. 
These tend to be simple, and as an added advantage, they are independent of the choice of the underlying 
camera parametenzation. 3.5 Constrained Dragging and Soft Controls When controls are added dynamically 
by the user, it is en­tirely possible for inconsistencies to arise, either because the degrees of control 
exceed the camera s degrees of free­dom, or because some controls are in conflict, e.g. trying to move 
one point in two directions. These problems can be handled gracefully by employing a least-squares method 
to solve the matrix equation see for example the conju­gate gradient solver described in [20] s0 that 
the error due to the inconsistency is distributed uniformly over the controls, in a least-squares sense. 
Although the least-squares solution avoids disaster when conflicts arise, we have found that it is very 
helpful to permit the user to drag points and other features sub­ject to the constraints imposed by existing 
controls, so that conflicts can never arise. We achieve this behavior by in­corporating the dragged point 
s desired behavior into the objective function, rather than using a hard constraint to control it. The 
constrained optimization solution then re­solves any conflicts strictly in favor of the hard constraints. 
Thus, for example, a point whose range of motion is re­stricted by the controls will move freely up to 
the limit of its travel, but no further. A simple way to implement such soft controls is to specify the 
desired camera motion q. according to the formula qo ==k, J~(p. p), (lo) where k, is a constant and 
pC is the position of the cur­sor in image coordinates. Using this value to drive the system is similar 
to attaching a rubber band between pC and p, inducing camera motion that causes p to chase p.. Inserting 
this value of qo into equation 7 minimizes the mean squared difference between q and qo, subject to the 
constraints. Soft controls can be implemented more accurately, at the expense of greater complexity, 
by min­imizing the squared difference between p and a desired value po, subject to the constraints. To 
express this objec­tive function, the general form given in equation 9 must be used. A greatly simplified 
though much less powerful version of through-the-lens control is obtained by using soft con­trols only. 
Then, the constrained optimization of equation 6 collapses into an unconstrained optimization. For exam­ple, 
an image point could be dragged by using equation 10 directly to determine q. 3.6 Position Feedback 
So far, we have cast the problem in terms of velocity con­trol. The velocity signals that drive the control 
process may come from several sources. For example, during interactive dragging of a controlled image 
point, the ve­locity may represent an estimate of mouse velocity. In key framing, the velocity represents 
the derivative of a known trajectory curve po( t ). In both cases, position as well as velocity information 
is available. This extra infor­mation can be used to greatly improve tracking accuracy by preventing 
error accumulation and drift as velocity is integrated over time. We do this by the addition of a simple 
linear feedback term to our initial statement of the control requirement: P= Po kf(p po). where kj 
is a feedback constant, and p. is the desired position for p at the current time. When p is on target, 
the feedback term vanishes, but if positional error exists, the velocity is biased in a direction that 
reduces the error. The feedback term carries straight through the derivation, leading to the following 
modified form for equation 7: JJTA =Po+k, (PI) p) Jq . (11)  3.7 Tracking a moving point Until now, 
we have assumed that the world-space point x is stationary. A small generalization makes it possible 
to accurately track a moving point. In key frame animation, for example, this would allow moving points 
on objects to be tracked automatically. To make the generalization, we assume that the world-space point 
moves according to a known function x(t). In practice, we need only know the point s cument position 
x and velocity x. Since x now depends on time, an additional term appears in equation 2, the chain-rule 
expression for p, accounting for the part of x s image velocity due to the motion of x itselfi 8(VX) 
p = h (Vx) q+h (Vx)Vx(12) tiq As before, the extra term carries through, adding an addi­tional correction 
factor to the right hand side of equation 7, yielding JJT} = p.+ kf(po p) h (Vx)Vx J~o. (13) This 
formulation makes it possible to control the image­space motion of a point independently of its world-space 
motion. If the image point is pinned, the camera will move as necessary to maintain its position. Both 
the image point and the world point can be key framed independently: the camera will move as required 
to achieve the desired image motion, regardless of the world-space motion of the point. 335   4 A Quaternion 
Camera Having developed the through-the-lens equations in generic form, itremains to fill inthe blanks. 
Intheequa­tions of the last section, the camera transformation was described in terms of an anonymous 
matrix V depending on an anonymous parameter vector q. To proceed, we must say what the function V(q) 
actually is. Then we must formulate the equations that are required to evaluate the image point derivative 
matrix J. If we limit ourselves to image-space controls that can be expressed purely as functions of 
point positions, then the matrices V and J tell us everything we need to know about the camera. As we 
noted in section 1, through-the-lens control hides the underlying camera parametenzation from the user, 
so that most of the criteria by which a conventional camera model would be judged do not apply. The model 
we present in this section is unusual in that a quatemion is used to represent the camera s orientation; 
we choose it because of the quatemion s ability to represent arbitrary rotations free of singularities 
and other artifacts. The equations of section 3 are compatible with any camera model. If you prefer another 
one, the derivation in this section can still serve as a template for the general procedure. 4.1 The 
Wew Matrix Our model employs a translation to specify the Lookfrom point and a quatemion to specify orientation. 
The view matrix V called for by equation 1 is given by the matrix product V = P(f) T(tz. ty. tz)Q(gw, 
gz, gv+qz)t (14) where P is a matrix for perspective projection with focal length ~, T is the matrix 
for translation by [tZ, ty, tZ], and Q isa quaternion rotation matrix, performing the rotation specified 
by the quatemion q, with scalar part q~ and vector part [q.. qv, q. ]. The camera parameter vector q 
is the length-8 vector formed by concatenating the transformation parameters, [?, tz, tv, tZ, qw, 9Z, 
gut9. . 1 The perspective matrix is a simple one, placing the focal point at the ongin and the image 
plane at distance ~ from the origin along the z-axis, lying parallel to the q-plane: 10 00 P=::;:.  
ool/fo H  The translation matrix is the standard one: [loot. Olotu T(tz, tv,t.) =  Ooltz 10001 
The quatemion rotation matrix is a bit more complex. The 336 form given in [22], ~ _qy2 *Z2 1 9. 9V 
9Wf?z Q=2 9W9Y+ 4.92 0 [ (15) assumes that the quatemion has unit magnitude, i.e. that Otherwise, 
Q is not a pure rotation, and shapes will be dis­torted. This constraint on Iql means that the camera 
has only seven true degrees of freedom. To enforce the con­straint, it is not sufficient simply to normalize 
Q between iterations: in that case, the derivative matrix wouldn t know about the constraint, and the 
control solution would be incorrect. While it would be possible to add the constraint, in differential 
form, to the control solution, there is a much simpler alternative: in place of equation 15, we express 
Q in a form that incorporates the normal­ization, so that quatemions q and aq specify the same transformation, 
for any scalar o. Under this scheme, we must still normalize q from time to time to prevent the accumulation 
of numerical errors. The modified version of Q is most simply expressed as the product Q.= +Q, where 
 [yz -q,z -9*2 q,q,+qwllz q.qz -%9, 01 1 !#_qz2_qz29W9Z qwq. + qyqz o %% Q=2 !# q=z 9Y2 o %0% + 9.9. 
9Y9Z 9W9. y 000 I 4.2 Evaluating J Employing the notation of section 3, the image coordinates corresponding 
to world point x are given by p= h(Vx) = h(PQnTx), The rows of J are formed by differentiating this 
expression with respect to each camera parameter in turn. To perform the differentiations, we note that 
each camera parameter influences exactly one matrix in the chain. Therefore, using the rule for differentiation 
of a product, the deriva­tive of the chain with respect to a parameter is another chain, obtained by 
replacing the appropriate matrix by its element-by-element derivative. Thus, for example, avx  = P~Qux, 
  at. . and we obtain the row of J corresponding to t=from ap = h (Vx)~, a. z  where h (Vx) is as 
defined in equation 2, and where 0001 0000 0000 0000 1 Differentiating each matrix with respect to each 
parameter on which it depends yields eight matrices in all. The matrix for dT/i)tr is given above-the 
other two derivatives of T arelikewise trivial. The derivative of P with respect to its only parameter, 
j, is 00 00 dP 00 (1o ~= 00 00 o 0 1/f~ o [1 The four derivatives of Q. may be expressed compactly 
as and To evaluate J, we need only implement functions that calculate each of these eight derivative 
matrices, along with the function that calculates h (x). Standard ma­trix/vector operations are then 
used to produce the eight rows of J. Implementation and Examples We have implemented through-the-lens 
control as part of a multi-view, direct manipulation testbed. The program is written in C++ on a Silicon 
Graphics Iris workstation and uses a toolkit which permits rapid evaluation of dynami­cally composed 
functions and their derivatives 14]. All of the examples in this paper can be specified interactively 
and run at interactive rates on a Silicon Graphics IRIS 4D/210 GTX. We have experimented with a wide 
variety of through­the-lens controls including the position of a point on the screen, the distance between 
two points on the screen, . the orientation of two points in the image, the ratio between two screen 
space distances. Computer Graphics, 26, 2, July 1992 All can be interactively specified and connected 
to ver­tices in the scene, can be made into hard or soft controls, can serve as constraints, and can 
be key framed. Controls that do not have an obvious geometric method for direct manipulation, such as 
the last three on the list, can be connected to sliders. The architecture of our system makes it easy 
to define new types of controls, although this must be done at com­pile time. Unlike finding new transforms, 
which entails solving systems of non-linear equations, defining new con­trols is easy to automate in 
a general and guaranteed man­ ner since the only required mathematical manipulation is differentiation. 
We have built automatic code generation tools that facilitate defining new types of controls. By adding 
the ability to place boundaries on the values of a control, we have been able to create several interesting 
through-the-lens features in our system, such as . bounding a point within a region of the image, . 
ensuring that an object does not become larger or smaller than a certain size,  . preventing an object 
from becoming too much bigger or smaller than another. We use an active set technique[ I I]to extend 
the methods of section 3 to provide the capability of inequality constraints. These through-the-lens 
controls work in concert with a variety of world-space controls. Because a camera is a first class object 
in our system, these controls can be applied to them as well as other objects in the scene. Multiple 
win­dows with cameras dynamically assigned to them make it easy to use world and image space controls 
together in composing an image. Building on top of a general purpose facility for com­posing derivatives 
permits our implementation to exercise the full generality of the methods in section 3 by allowing us 
to solve simultaneously for camera and object parame­ters. Through-the-lens controls can therefore affect 
other objects in addition to the camera. Although removing the restriction that x does not depend on 
q does not require any change to the techniques presented, the pragmatic issues that arise in including 
parameters of objects other than the camera in q are beyond the scope of this paper. These issues are 
discussed in [14, 13, 29]. They %rmit a uni­fied approach to controlling and constraining all objects, 
including cameras. When the state vector includes objects besides the cam­era, through-the-lens controls 
provide a way to couple the camera and scene objects. If a point on an object is pinned to a particular 
place in the image, as the object moves the camera will also change to maintain the constraint. Changing 
the camera will similarly alter the object. If the camera is locked in place, the object is restricted 
to locations where its image satisfies the through-the-lens requirements. Adjusting a through-the-lens 
control can cause both the camera and the scene objects to change,   and Michael Kass for providing 
some references, Steven Drttcker and Tinsley Gaylean for helping renew our in­terest in camera placement, 
and Will Welch for providing caffeine and conversation. References [1] Norman Badler, Kamran Manoocherhti, 
and David Baraff. Multi-dimentiomd input techniques and articulated figure positioning bymtrltiple constrairtts. 
In proceedingsof the 1986 Workshopon Interactive3d Graphics,pages 151­170, October 1986. [2] Ronen Barzel 
and Alan H. Barr. A modeling system based on dynamic constants. Computer Graphics, 2L 179-188, 1988. 
Proceedings SIGGRAPH 88. [3] Jim Blinn. Where am I? What am I looking at? IEEE Computer Graphics and 
Applications, pages 76-81, July 1988. [4] Frederick Brooks. Walkthough -a dynamic graphics en­vironment 
for simulating virtual buildings. In Proceedings of the 1986 Workshop on Interactive 3d Graphics, pages 
9-22, October 1986. [5] Michael Chen, S. Joy Mountford, and Abigail Sellen. A study in interactive 3d 
rotation using 2d input devices. Com­puter Graphics, 22(4): 121 130, August 1988. Proceedings SIGGRAPH 
88. [6] PHIGS+ Committee. Phigs+ functional description, revi­sion 3.0. computer Graphics, 22(3): 125 
215, 1988. [7] Steven Drucker, Tinsley Gaylean, and David Zeltzer. CIN-EMA: a system for procedural camera 
movements. In Pro­ ceedings of the 1992 Symposium on Interactive Computer Graphics, pages 67-70, 1992. 
[8] Roger Fletcher. Practical Methods of Optimization. John Wiley and Sons, 1987. [9] Sundaram Ganapathy. 
Decomposition of transformation matrices for robot vision. In international Conference on Robotics, pages 
13&#38;l 39, March 1984. [10] Donald Gennery. Stereo-camera calibration. In Proc. DARPA Image Understanding 
Workshop, pages 101-107, 1979. [11] Phillip Gill, Walter Murray, and Margret Wright. Practical Optimization. 
Academic Press, New York, NY, 1981. [12] Michael Gleicher. Briar -a constraint-based drawing pro­gram 
In CHI 92 Formal Video Program, 1992. SIG-GRAPH video review, in press. [13] Michael Gleicher and Andrew 
Whkin. Differential manip­ulation. Graphics Inter@ce, pages 61+57, June 1991. [14] Michael Gleicher and 
Andrew Witkin. Snap together math­ematics. In Edwin Blake and Peter Weisskirchen, edhors, Advances in 
Object Oriented Graphics 1: Proceedings of the 1990 Eurographics Workshop on Object Oriented Graphics. 
Springer Verlag, 1991. Also appears as CMU School of Computer Science Technical Report CMU-CS­90-164. 
[15] David Lowe. Solving for the parameters of object models from image descriptions, In Proc. DARPA 
Inrage Under­standing Workshop, pages 121 127, 1980. [16] Jock Mackirday, Stuart Card, and George Robertson. 
Rapid controlled movement through a virtual 3d workspace. Com­puter Graphics, 24(4): 171-176, August 
1990. [17] Chris McGlone. Automated image-map registration using active contour models and photogrammetric 
techniques. In Proceedings of the SPIE, Volume 1070, January 1989. [18] Francis H. Moffitt. Photogrammetiy. 
International Text­book Company, 1959. [19] John Platt and Alan Barr. Constraint methods for flexible 
models. Computer Graphics, 22:279-288, 1988. Proceed­ings SIGGRAPH 88. [20] William Press, Brian Flannery, 
Saul Teukolsky, and Wdliam Vetterling. Numerical Recipes in C. Cambridge University Press, Cambridge, 
England, 1986. [21] K. Schwidefsky. An Outline of Photogrammetry. Pitman Publishing Corporation, first 
english edition, 1959. [22] Ken Shoemake. Animating rotations with quatemion curves. Computer Graphics, 
19(3):245 254, July 1985. [23] Mark Surles. Interactive modeling enhanced with con­straints and physics 
 with applications in molecular mod­eling. In Proceedings of the 1992 Symposium on Interactive Computer 
Graphics, pages 175 182, March 1992. [24] Konstantinos Tarabamis, Roger Tsai, and Peter Allen. Au­tomated 
senor planning for robotic vision tasks. In Proceed­ings of th 1991 IEEE International Conference on 
Robotics and Automation, pages 76-82, April 1991. [25] Russell Turner, Francis Balaguer, Enrico Gobbetti, 
and Daniel Thalmarm. Physically-based interactive camera mo­tion using 3d input devices. In N. M. Patrikalakis, 
editor, Scientific Visualization of Physical Phenomena: Proceed­ings of CC International 1991, pages 
135 145, Tokyo, 1991. Springer-Verlag. [26] Colin Ware and Steven Osborne. Exploration of virtual camera 
control in virtual three dimensional environments. Computer Graphics, 24(2): 175 1 84, March 1990. Pro­ceedings 
1990 Symposium on Interactive 3D Graphics. [27] William Welch, Michael Gleicher, and Andrew Whkin. Manipulating 
surfaces differentially. In Proceedings, Com­pugraphics 91, September 1991. Also appears as CMU School 
of Computer Science Technical Report CMU-CS­91-175. [28] Andrew Whkin, Kurt Fleischer, and Alan Barr. 
Energy constraints on parametrized models. Computer Graphics, 21(4):225-232, Jrdy 1987. [29] Andrew Whkh, 
Michael Gleicher, and William Welch. Interactive dynamics. Computer Graphics, 24(2): 11-21, March 1990. 
Proceedings 1990 Symposium on Interactive 3D Graphics. [30] Andrew Witkin, Michael Kass, Demetn Terzopoulos, 
and Kurt Fleischer. Physically based modeling for vision and graphics. In Proc. DARPA Image Understanding 
Work­shop, pages 254-278, 1988. [31] Andrew Whkin and Wllliarn Welch. Fast animation and control of non-rigid 
structures. Computer Graphics, 24(4):243-252, August 1990. Proceedings SIGGRAPH 90.  
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134089</article_id>
		<sort_key>341</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>40</seq_no>
		<title><![CDATA[An object-oriented 3D graphics toolkit]]></title>
		<page_from>341</page_from>
		<page_to>349</page_to>
		<doi_number>10.1145/133994.134089</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134089</url>
		<keywords>
			<kw><![CDATA[direct manipulation]]></kw>
			<kw><![CDATA[interactive 3D graphics]]></kw>
			<kw><![CDATA[object-oriented design]]></kw>
			<kw><![CDATA[scene representation]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Animation</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>I.3.4</cat_node>
				<descriptor>Application packages</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.4</cat_node>
				<descriptor>Graphics packages</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.6</cat_node>
				<descriptor>Interaction techniques</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.2</cat_node>
				<descriptor></descriptor>
				<type></type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010147.10010371.10010387</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Graphics systems and interfaces</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003120.10003121.10003125.10010391</concept_id>
				<concept_desc>CCS->Human-centered computing->Human computer interaction (HCI)->Interaction devices->Graphics input devices</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010387</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Graphics systems and interfaces</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010387</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Graphics systems and interfaces</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010387</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Graphics systems and interfaces</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010520.10010521.10010542.10011714</concept_id>
				<concept_desc>CCS->Computer systems organization->Architectures->Other architectures->Special purpose systems</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010352</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Animation</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
			<gt>Design</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>PP39052397</person_id>
				<author_profile_id><![CDATA[81539516356]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Paul]]></first_name>
				<middle_name><![CDATA[S.]]></middle_name>
				<last_name><![CDATA[Strauss]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Silicon Graphics Computer Systems, 2011 North Shoreline Blvd., Mountain View, CA]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P243637</person_id>
				<author_profile_id><![CDATA[81100227602]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[Rikk]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Carey]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Silicon Graphics Computer Systems, 2011 North Shoreline Blvd., Mountain View, CA]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[DorP Programmer's Guide, Release 5.0, Kubota Pacific Compuler, Incorporated, Santa Clara, Calif., 1991.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Graphics LihraJT Programming Guide, Silicon Graphics Computer Systems, Mounlain View, Calif., 199 i.]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[International Standards Organization, international Stan- ~h~rd It!formation Processing Systems ~ Computer Graphi~'s- Graphical Kernel System for Three Dimensions (GKS-3D ) Fum'tional Description, ISO Document Number 8805:1988(E), American National Standards Institute, New York, 1988.]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[Iris Inventor Programming Guide, Silicon Graphics Computer Systems, Mountain View, Calif., 1992.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[Mark Linton, Paul Caulder, John A. Interrante, Steven Tang, and John M. Vlissides, InterViews Reference Manual. Version 3.0.1., Stanford University, October 1991.]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_obj_id>51684</ref_obj_id>
				<ref_obj_pid>51683</ref_obj_pid>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[PHIGS+ Committee, Andries van Dam, chair, "PHIGS+ Functional Description, Revision 3.0," Computer Graphtcs, 22(3j, pp. 125-218 (July 1988).]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Starhase Graphics Te~'hniques and Display List Programmer's Guide, Hewlett-Packard Company, Fort Collins, Colo., 1991.]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[Steve Upstili, Tire RenderMan Companion, Addison- Wesley, Reading, Mass., 1990.]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Garry W iegand and Bob Covey, HOOPS Reference Manual, Version 3.0, Ithaca Software, 1991.]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122730</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[Robert C. Zeleznik, D. Brookshire Conner, Matthias M. Wloka, Daniel G. Aliaga, Nathan T. Huang, Philip M. Hubbard, Brian Knep, Henry Kaufman, John F. Hughes, and Andries van Dam, "An Object-Oriented Framework t'or the Integration of Interactive Animation Techniques," ('omputer Graphi~s (SIGGRAPH '91 Proceedings) 25(4) pp. 1()5-111(July, 1991).]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 Comcruter Graphics, 26,2, July 1992 An Object-Oriented 3D Graphics Toolkit Paul S. Strauss Rikk Carey 
 Silicon Graphics Computer Systems 2011 North Shoreline Blvd. Mountain View, CA 94039-731 I pss@sgi.tom, 
rikkf@sgi.com Abstract This paper presents an object-oriented toolkit for developers of in­teractive 
3D graphics applications. The primary goal of the toolkit is (o make it easier for programmers to create 
3D graphics applica­tions that employ direct manipulation techniques in addition to con­ventional 2D-widgets. 
Such techniques have generally been ig­nored in previous graphics packages and systems. The toolkit provides 
a general and extensible framework for repre­senting 3D scenes so that applications can integrate their 
data with graphical objects rather than having duplicate copies. A simple, in­tegrated event model that 
enables direct interaction with 3D objects is also included. CR Categories and Subject Descriptors 1.3.2 
Graphics Systems; 1.3.4 Graphics Utilities, Application Pack­ages, Graphics Packages: 1.3.6 Methodology 
and Techniques -in­teraction Techniques; 1.3.7 Three-Dimensional Graphics and Real­ism. Animation Keywords 
 Interactive 3D graphics, object-oriented design, scene representa­tion, direct manipulation.  Introduction 
 Writing interactive 3D graphics applications has traditionally been a tedious, time-consuming, and difficult 
task requiring a high level of expertise by the programmer. Because it has been so difficult, de­velopers 
and researchers have either invented their own software abstractions above the low-level graphics commands 
or produced portable, lowest common denominator applications with little or no direct 3D interaction. 
The former choice yields short-term soh­tions that are rarely given sufficient design and implementation 
ef­fort. The latter approach is more common in industry and results in disjoint user interfaces in which 
users view 3D areas but can inter­act only through remote user interface widgets or keyboard com- Pcrmlssmn 
10 COPYwithout FCCJll or part of this material is granted provided that the copm arc not made or distributed 
for direcl commercial tidvmrtagc, {he ACM copyright notice and the [Itlc of the publica~ionand Its date 
appmr, and notice is given th~tcopying is by fxrmission of the Ashomtmn fnr Compuling Machinery. To copy 
o!herwiw. or t{) republish. rcquirc~ a fee tind/or specitic permission. t IW2 ACM-O-8979 1-479-lKK!/(M)7/034I 
$01.50 mand languages. A 3D graphics toolkit could Facilitate writing interactive applica­tions. A truly 
interactive 3D toolkit should provide a rich and exten­sible set of 3D objects and should support direct 
manipu/a(ion, al­lowing users to interact with those objects in the same window in which they appear. 
This technique is common in 2D graphics appli­cations, yet it bas rarely appeared in 3D applications. 
There are three fundamental areas in which a toolkit can enable the develop­ment of such interactive 
3D programs: Object representation. Graphical data should be stored as edit­able objects and not just 
as collections of drawing primitives used to represent fhem. That is, applications should be able to 
specify n,haf it is and not have to worry about how /o dran, II. . Interactivity. An event model for 
direct interactive program­ming must be integrated with the representation of graphical ob­jects.  Architecture. 
Applications should not have to adapt to object representation or interaction policies imposed by the 
toolkit. in­stead, the toolkit mechanisms should be used to implement the desired policies. Such flexibility 
should also be reflected in the ability to extend tbe toolkit when necessary. Traditional 3D graphics 
application systems can he characterized as taking one of two approaches to object representation. GKS 
[3] and PHIGS+ [6] represent the display Iisr approach in which objects are defined as sequences of drawing 
commands and cannot be treated as first-class 3D objects. Dor6T~ [ Ij and HOOPST~ [9] significant­ly 
improve the display list model by providing additional editing ca­pabilities, but they still fall short 
of true 3D object representation. /mmediafe mode libraries such as Iris GLTM[2], StarbaseT~ [71, and 
RenderManT~ [8] are streamlined drawing packages; they have no notion of retained or represented 3D objects 
(although CL and Star­base also support display lists). These libraries are focused on pro­viding flexible 
and efficient interfaces to specific graphics devices or programs. The main problem with both of these 
approaches is that they con­centrate solely on the rendering or display aspects of application writing 
(a worthy task, especially considering advances in render­ing hardware and algorithms during the 1970 
s and 1980 s). How­ever, rendering is only a small part of the task of writing an interac­tive application. 
3D graphics packages, for the most part, have ig­nored user input; they often provide little more than 
gross-object picking. Furthermore, the programming models for these packages do not treat 3D objects 
as geometric, physical entities, Thus, previ­ous systems are committed to display-oriented application 
develop­ment and provide little help for direct, 3D interaction support. 34 I SIGGRAPH 92 Chicago, July 
26-31, 1992 Another shortcoming of traditional graphics packages is that they proliferate the duplicate 
database problem. Applications store their objects in a form suited to their needs, but must convert 
them into structures required by the graphics package, which maintains an additional copy. Furthermore, 
graphics packages are typically closed systems that do not aHow applications to add their own ob­ject 
geometries, properties, or operations. There have been few published descriptions of 3D toolkits which 
attempt to solve the problems presented here. The InterViews [5] system successfully integrates rendering 
and interaction in the world of 2D graphics and text, but it does not extend to 3D. The Brown Animation 
Generation System [10] is one published system that successfully integrates abstract, 3D object representation 
and dynamics. It is designed primarily for animation but does include support for interactive techniques. 
The toolkit described in this paper attempts to meet the needs de­scribed above. It defines an object-oriented 
framework for descri­bingscenes containing 3D objects and operations on them. 3D ob­jects are abstract 
representations that can render themselves when requested; they are not merely display lists. The methods 
by which objects are rendered can vary from machine to machine, but their representations are constant. 
The framework of this toolkit is designed with application extensi­bility in mind. Application writers 
are able to add new, application­specific objects to the toolkit when necessary. By allowing applica­tion 
data to be incorporated into the toolkit, the need for duplicate databases is greatly reduced. Extensibility 
also includes object op­erations such as new rendering methods and geometric computa­tions. A simple, 
yet effective, model for handing events to 3D objects is integrated into the toolkit. Several interactive 
3D objects are pro­vided, allowing applications to add interactive operations, such as rotation, easily. 
This set of interactive objects is also extensible, and the toolkit provides several levels of support 
to make it easy for ap­plications to create their own objects for direct interaction.  Overview The 
3D toolkit library consists of three main sections, as illustrated in Figure 1. Furthermore, there are 
two window system utility li­braries built on top of the toolkit that provide window objects and handle 
event translation.  EKE) To%!kit Scene Database  Ffgure 1. Overall toolkit architecture. Each of the 
three toolkit sections provides a different level of pro­ gramming support. They are introduced herein 
order from low-lev­el to high-level. The foundation of the 3D toolkit is the scene database. Itstores 
dy­namic representations of 3D scenes as graphs (typically directed acyclic graphs) of objects called 
nodes. Various classes of nodes implement different geometries, properties, and database traversal behaviors. 
The database provides a set of actions that can be applied to scenes or parts of scenes; examples of 
actions are rendering, picking, computing a bounding box, handling an event, and writing to a file. The 
format and methods for storing scenes in files and re­trieving them are defined by the database. Also 
included are objects for adding animation to scenes and for tracking changes to them. The interaction 
section of the toolkit introduces event classes and smart nodes that process events. Event classes define 
an extensi­ble set of abstract events such as ButtonEvent and Location2-Event. An example of a smart 
node is the selection node, which provides an easy way for applications to maintain lists of selected 
objects. Selection tracks picking, supports various policies for re­placing and extending selections, 
and graphically highlights select­ed objects. Another type of smart node is a manipulator, which re­sponds 
to interaction events and edits other nodes in a database. A manipulator typically employs a surrogate 
object (e.g., bounding sphere or box) that represents the manipulator visually and provides a means for 
translating events into changes to the database. For ex­ample, the Trackbal 1 manipulator uses a bounding 
sphere around an object to modify the rotation of that object, Other manipulators perform object-specific 
functions, such as changing the iHumina­tion direction of a light source or dragging a vertex of a polyhedral 
shape. Manipulators provide an easy way for applications to incor­porate direct 3D interaction. The third 
section of the toolkit defines node kits, which make it eas­ier to create structured, consistent databases. 
Each node kit object combines some scene database subgraph, attachment rules, and oth­er policies into 
a single class. For example, the SphereKi t is a wrapper around a sphere node that adds material, geometric 
trans­formation, and other properties in the correct place when needed. Node kits also allow programmers 
to create higher-level objects that encapsulate application-specific behavior. Note that the 3D toolkit 
itself does not include any objects that rep­resent windows on the display screen. This decision was 
made to ensure window system independence and greater portability. Urility libraries tied to specific 
window systems (such as X and GL) are built on top of the toolkit to provide convenience to application 
pro­grammers. Each utility library provides a basic RenderArea object that maintains a resizable window 
that handles automatic redraw­ing, translates window system events into toolkit events, and dis­tributes 
events to objects rendered in the window. Furthermore, the utility libraries can also provide a set of 
application-level compo­nents that implement common interactive functions. Examples of components are 
color editors, surface material editors, light source editors, and viewers, which process user interaction 
to edit cameras. Architecture The 3D toolkit is implemented in C++, which supports many of the object-oriented 
paradigms essential to extensible systems. C bind­ings are also provided, although much of the extensibility 
is not ac­cessible from C. Nodes Each node in a scene database performs some specific function. There 
are shape nodes that represent geometric or physical objects (see Figure 7), properry nodes that describe 
various attributes of ComputerGraphics,26,2, July 1992 those objects (see Figure 8), and group nodes, 
which connect other nodes into graphs and subgraphs. Other nodes, such as cameras and lights, are also 
provided. A representative sampling of node classes is given in Table 1. Shape nodes: Group nodes: Cone 
GrouP Cube Separator Cylinder Switch Face Set Selection Index edFace Set Manipulator IndexedLineSet 
LayerGroup IndexedTriangleMesh Array LlneSet MultipleCopy NurbsCurve  NurbsSurface Property nodes: 
Point Set BaseColor QuadMesh Complexity Sphere Coordinate Text2 DrawStyle Text3 Environment TriangleStripSet 
 Font LightModel Material   Light/camera nodes: MaterialBinding OrthographicCamera Normal Perspect 
iveCamera NormalBinding DlrectlonalLight Texture2 PointLight  TextureCoordinate2 SDoELiaht Transform 
 Table 1. Some node classes. Instance-specific information is stored within nodes in sub-objects called 
fiekfs. Each node class defines some number of fields, each withaspecific value type associated with 
it. Forexample, thecYl­ inder shape node contains tworeal-number (float) fields that rep­resent the radius 
and height of a specific cylinder instance. Field ob­jects provide a consistent mechanism for editing, 
querying, reading, writing, and monitoring instance data within nodes. The set of nodes is designed 
to allow most of the high-volume data tolx shared when possible. Forexample, coordinates and normal vectors 
are specified in separate (property) nodes that can be shared among various shapes. This scheme has the 
additional benefit of en­forcing consistency of representation. A variety of group node classes connect 
nodes into graphs. Each group node class determines if and how traversal of children is per­formed and 
how properties are inherited. A node typically inherits properties from its parent, and children of a 
group n-tie usually in­herit from prior siblings. Some groups provide inheritance from the group node 
to its parent, making insertion of properties in sub­graphs simple. Other groups, such as Separator nodes, 
save state before and restore state after traversing children, isolating their ef­fects from the rest 
of the graph. These groups represent traditional, hierarchical grouping objects found in most 3D systems, 
However, other behaviors can be imple­mented. For example, the Switch node selects one of its children 
to traverse; this can be useful for implementing Ievel-of-detail, for example, The Ar r aYnode traverses 
its children multiple times, ap­plying a transformation before each traversal to arrange the results 
ina3Darray. Figure 2 depicts a scene graph whose rendered result appears in Figure 9.  , eparatorgroup 
ranSfomtie  ~ rg w-oo er~ p ~nde ~ @o K Lightnoda @ @ Manipulator Shape node ~ Sensor @ A Appaarancenode 
/\ Subgraph @ ---- Key _ Path 1 Q Qsp (&#38;p Sinding Set Figure 2. A simple scene graph.  Paths A 
node may be a child of more than one group, allowing common subgraphs (multiple instances) to be shared. 
For example, a model of a bicycle may use a subgraph representing a wheel twice, with different transformation 
nodes applied to each instance of the wheel. This scheme can result in more compact and manageable scene 
representations in many cases. The downside is that it is not always possible to refer unambiguously 
to an object (such as the rear bicycle wheel) in the 3D scene simply by pointing to a single node. To 
remedy this problem, the toolkit supports parh objects, which point to nodes in a chain from some node 
in the graph down to the node in question (see Figure 3). For example, performing a pick operation returns 
a path from the red of the graph to the shape node under the cursor, unambiguously indicating the object 
that was picked. Note that a path actually defines a subgraph consisting of more than just the connected 
chain of nodes. The subgraph also includes all nodes (if any) below the last node in the chain and all 
nodes (typi­cally to the left of the chain) that have an effect on these nodes. This definition is extremely 
important when performing graph editing such as cut-and-paste; all of the subgraph nodes are necessary 
to fully represent the selected object.  Actions Objects called actions traverse scene graphs to perform 
specific op­erations, such as rendering, computing a bounding box, searching, or writing to a file. Several 
currently supported actions are listed in Table 2. An application performs an action on a scene in a 
database by applying it to a node in the scene graph, typically the root. Ac­tions may also be applied 
to paths. The next section discusses the mechanism of applying actions in more detail. 343 SIGGRAPH 92 
Chicago, July 26-31, 1992 FrorrWWree/ Coords Normals Face Figure 3. The Wheel node is multiply instanced, 
since it is a child of both FronrWhee/ and RearWheel. The path (heavy line) refers unambiguously from 
the local graph root to the shape de­fining the rear wheel. Within the parallelogram is the subgraph 
defined by the path. CallbackAct Ion Generic scene traversal with user callbacks. GLRenderActlon Renders 
objects in database. GetBoundingBoxAct ion Computes bounding box of scene or parl of scene. GetMat rlxAct 
lon Computes cumulative transformation matrix for object in scene. HandleEvent Action Gives nodes in 
database acbance to handle an event. RayPickAct ion Returns frontmost object or all objects inter­ sected 
by a ray cast into scene. PrintAct Ion Produces PostScript primitives or other print­ able form of rendered 
scene. SearchAct Ion Looks for specific node or type of node in da­ tabase. Table 2. Action classes. 
The 3D toolkit is designed to be extensible in many areas. It is as­sumed that users will often extend 
the set of nodes to create new shapes, properties, manipulators (which are derived from nodes), and other 
classes. Similarly, it may be useful in some applications to create actions to perform new tasks while 
traversing a scene graph. Unfortunately, the standard virtual method table implemen­tation in C++ makes 
this two-way extensibility very difficult: it is relatively easy to create a new node class that supports 
all of the standard actions, but it is not possible for application writers to add new action methods 
to existing standard node classes. This could be done by creating subclasses of all nodes that supported 
the new ac­tions, but this is an unattractive solution. To solve the two-way extensibility problem, the 
toolkit uses a two­dimensional virtual table to implement node/action methods. Each entry in the table 
is a method that implements a certain action for a particular node. Adding a new node is equivalent to 
adding a col­umn to this table, whereas adding a new action involves adding a new row. For convenience, 
standard action methods are implement­ed as regular virtual functions on nodes. This method lookup scheme 
is the justification for implementing actions as separate objects. The resulting syntax for applying 
an ac­tion to a graph, action ->apply (node) ,is fairly easy to use and understand. Applying Actions 
Applying an action to a scene graph usually results in a traversal of the graph, Although group node 
subclasses are free to define their own traversal behavior, standard groups visit their children in left­to-right 
order. Therefore, scene graph traversal is usually depth­first. Most actions require state to be accumulated 
during traversal. For example, when a shape node is encountered during rendering tra­versal, it may need 
to know the current material, set of coordinates, and drawing style. Each of these properties is stored 
in an element in the state. Typically, property nodes change one or more state el­ements, and shape nodes 
interpret the current values of the ele­ments. When a separator node (a type of group) is encountered, 
traversal state is saved before visiting its children and is restored afterwards. Because this node is 
used very often in scene graphs to segregate objects, state saving and restoration must be efficient. 
The state puts off saving element values until those values are modified after the save; this lazy scheme 
avoids copying data unnecessarily. Rendering and Picking Because the toolkit is designed for interactive 
graphics applica­tions, the action that performs rendering must be capable of interac­tive speeds. Therefore, 
the rendering methods built into nodes have been tuned for maximum performance. The toolkit can also 
boost rendering performance by caching state at crucial points. For exam­ple, once it has been determined 
how to render a subgraph, caching a display list can make the next traversal fast and easy. Caching is 
built into Sepa rat or nodes and can be activated by an application when desired. References to nodes 
used to build a cache are stored with it, so any changes to those nodes wi}l automaticallyy invalidate 
the cache. Additionally, it is possible to abort a rendering action during traversal; this is useful 
when implementing real-time appli­cations and for minimizing the wait for event processing in interac­tive 
applications. Some rendering features, such as texture mapping, are not imple­mented on all supported 
platforms. Users of the toolkit do not need to test whether a particular machine supports a feature; 
they can just specify the feature by inserting nodes in the scene database, and the toolkit does the 
rest. On architectures that do not support the fea­ture, the toolkit can simulate it in software (if 
this would not greatly compromise interactive performance) or elide it. Interactive applications require 
flexible and efficient picking. The Ray PickAction can be used to find a path to the frontmost object 
under the cursor. If an application requires more information, it can query the action for more details, 
such as the world-space and ob­ject-space points of intersection and the surface normals at those points. 
Each shape node class can define additional, specific infor­mation that can be queried. For example, 
objects constructed from sets of vertices can return the face containing the intersection point and the 
edge and vertex closest to it. Picking performance, like that of rendering, is improved by cach­ing. 
separator nodes automatically cache bounding boxes, which are used by the pick action for culling. This 
caching speeds picking enough to make locate highlighting (dynamic highlighting of the object under a 
moving cursor) possible. Computer Graphics, 26, 2, July 1992  Sensors .$ens(w ob@s are used to track 
changes to nodes and to implement simple an imatirm. There are two major types of sensors, each of which 
calls a user-defined callback function when triggered. A dura ,scns(w is attached to d node and is triggered 
when it detects changes In data in tha{ node or any descendant node. These sensors can be used by an 
interactive editor to update sliders or other indicators whenever any other program element changes values 
used by the editor. A data sensor can also be attached to the root of a graph to track changes to the 
entire scene (e.g., to determine when to re­draw). Tbe other type of sensor is a rimer sensor, which 
is triggered at a specified time or at regular intervals. For example, an application can set a timer 
sensor to trigger 30 times a second to animate parts of a graph. Figure 4 illustrates how sensors can 
be connected to a scene databaw. Redraw ~ I 130th Edit ~ Second @ TimerClock Sensor  +36-4- Figure 
.#. A scene graph with sensors attached, The data sensor at the top of the graph is triggered whenever 
a change is made to any node below the top: it is used to determine when to re­draw the graph, The timer 
sensor connected to the clock fires at regular intervals. animating the rotation of the object at the 
low­er right. 3D Event Model The toolkit and utility libraries use a very simple algorithm to dis­tribute 
user events to manipulators and other smart nodes, An event specific to the window sys[em is generated 
as the result of some user action (mouse motion, keyboard button press, etc. ) and is passed to the instance 
of the utility library s Rende rArea object that corresponds to the window in which the event occurred. 
If the Kt x~~eIA I<~+is part of a component, the component might handle the event itself. For ex~mple. 
a viewer component might process all mouse motitm to edi[ the position and orientation of a camera in 
the scene. It the component does not process the event, the Rende rA rea translates the window system 
event into a toolkit event (indepen­dent of any window system) and distributes it to the nodes in the 
3D scene. The [.~.~,.!t.~;,~,,a applies an instance of the Handle Ever. ,,-,,..:.:,[othe root node of 
the graph to distribute the event, This tiction performs a standard traversal of the graph. Any node 
that is interested in events may process the event and indicate that it has handled it, As with all other 
actions, each node class is free to define its own behavior when handling events. Some nodef. such as 
manipulators may be interested in mouse events only when the cursor is over their rendered objects. Such 
nodes may ;lsli the ,) . . j. ..! ..e::, .A-+ n for a path to the object under the cursor. To process 
this request, the action automatically performs a pick (using a Ray PickAct ,or.)to determine this path; 
it is cached so further inquiries do not require additional picks. Therefore, pick correlation is performed 
only when requested, speeding up the event handling process. Database traversal for the Har,d1eEver.tAct: 
~r,stops as soon as a node is found to handle tbe event. Nodes that want to monitor events without ending 
the tmversal can do so by omitting the step that marks the event as handled. Also, nodes that are interested 
in future events can perform a grab, meaning that they will receive all events until further notice. 
Event grabbing is useful for process­ing mouse press-move-release sequences, An example of the workings 
of the event model is illustrated in Fig­ure 5. User Action Window 1b System lWrrdowSysternt3ent 2 RenderArea 
a lToolkitEvent I f-g+ rack .  +I!A Figure 5. Event model example. ( I ) The window system pro­cesses 
a user action and produces a window system event. (2) The RecderArea associated with the window in which 
the ac­tion occurred translates the event into a toolkit event and passes itto a Handle Ever.tAct ~~n 
which it applies to the rcwt of its graph. (3) The root node of the graph passes the event to its chil­dren. 
(4)-(5) The camera and light nodes are not interested in events, and therefore they ignore this one. 
(6) Tire next child, a separator group, passes the event to its children. (7)-(8) The transform and cube 
nodes ignore the event. (9) The trackball manipulator checks if the event is a left-mouse-down. and, 
if so, determines whether the cursor is over the trackball object de­fined in its subgraph. If the cursor 
is over the object, the track­ball grabs future events and indicates that it has handled the event. Subsequent 
events are sent immediately to the trackball manipulator, which processes mouse motion events and edits 
the rotation field in the transform node. This process continues until a left-mouse-up event is processed 
by the trackball, which then releases its grdb. Manipulators The event model described above is designed 
to allow manipulators and other interactive nodes to be integrated easily into graphics ap­plications. 
As an illustration, this section explores the implementa­tion of the trackball manipulator (Figure 10) 
in more detail. As mentioned earlier, the trackball manipulator places an invisible 345 SIGGRAPH 92 
Chicaao, July 26-31, 1992 surrogateboundingsphere around the 3D object it is manipulating. The sphere 
is used to translate mouse motion into rotational chang­es to thk object. Thrte cylindrical bands around 
the sphere make it easy to specify rotations constrained to the principal axes. When a trackball is activated, 
it is given a path to the geometric transformation node it is to edit to achieve the rotation. The appli­cation 
inserts a Trackba 11 node into its scene graph, ensuring that the trackball is rendered with the rest 
of the scene and that it is given an opportunity to handle events. The Trackbal 1 node (derived from 
Separator) has as children a scene graph that defines the sur­rogate sphere and constraint bands. When 
a Trackba 11 node is encountered during traversa] by a Han­dleEventAction, the node checks if the event 
is a left-mouse­down. If so, it asks the action for the object under the cursor (com­puted by picking). 
If the cursor is over the trackball object, the node does two things. First, it announces to the action 
that it has handled the event, so traversal need not continue. Second, it performs a grab so that all 
future events will go directly to the trackball. The grab will be released when a left-mouse-up event 
is processed by the trackball. Each intervening mouse-motion event is processed by the trackball to compute 
rotational changes to its target object. The toolkit includes many simpfe manipulators,each of which 
per­forms a single task, such as translation in one dimension or cylin­drical rotation. Also in the toolkit 
are compound manipulators (such as the trackball) that combine several simple manipulators into a more 
complex, integrated tool. Figure 11 illustrates several manip­ulators. Node Kits Because the scene graph 
library is general enough to provide max­imum performance and flexibility, it can often be confusing 
to nov­ice users. There are no strict rules for forming scene graphs, so it is possible to create bizarre 
and sometimes meaningless collections of nodes unless some sort of structuralguidelines are imposed. 
(This situation is reminiscent of assembly code and structured program­ming.) Furthermore, class-specific 
traversal and inheritance rules make it difficult to examine a scene graph and determine exactly how 
subgraphs of nodes relate to objects (chairs, bicycles) in the 3D scene. Node kits provide one way to 
make these tasks easier by enforcing a consistent policy for database construction, editing, and inquiry. 
Each node kit effectively contains some structured subgraph of da­tabase nodes. A template associated 
with the node kit determines which nodes can be added when necessary, and where they should be added. 
For example, the Sphere Kit node represents a sphere object; its template allows a material, geometric 
transformation, and other properties to be inserted in the correct place when needed (Figure 6). Another 
use of node kits is to define application-specific objects and semantics. For example, consider a flight 
simulation package that includes a variety of objects representing airplanes. Each of these airplanes 
consists of the same general scene graph structure (e.g., fuselage, wings, and landing gear) as well 
as some airplane­specific methods (e.g., bank-left, raise-handing-gear). To an appli­cation writer using 
this package, each type of airplane can be dealt with in a similar way. There is no need to know the 
details of the structure of the subgraph representing the landing gear to raise it, since there is a 
general method for doing so. SDhereKfi I Trans-Material Draw Light Texture Corn-S~ere form Style Model 
plexity F~ure 6. Sphere node kit. When-an application creates an in­ stance of the kit, a template of 
the above graph is constructed, opaque to the application. The application makes chmges to the sphere 
only though the node kit. Nodes connected by dashed lines are cteated only when necessary. For example, 
applying a transformation to the node klt is implemented internally as a change to the transform node, 
which is created first if neces­ sary. Calibacks No toolkit can ever be comple~, users will always want 
to add something. One way to extend the set of objects provided by the toolkit is to derive new classes 
from existing ones. Although the toolkit is designed to make such extensions as easy as possible, sometimes 
an easier mechanism is useful. For this reason, several objects in the toolklt provide callback mechanisms 
for quick proto­typing of new features. The ca 1 lback node, for example, invokes a user-defined function 
whenever it is encountered during traversal for any action; this node makes it easy to introduce specialized 
behavior into a scene graph or to prototype new nodes without subclassing. Similarly, the Ca 1lbackAct 
ion allows functions to be called before and after each node encountered during traversal, giving them 
access to the current traversal state. Other classes provide callbacks during various interactive process­es, 
such as direct manipulation and selection of objects. Conclusions and Future Work The toolkit presented 
here is an attempt to make it easier for graph­ics application developers to design and implement 3D 
applications with direct interaction. The flexible and extensible 3D database makes it possible for applications 
to use only one representation of application data. By integrating interactive objects into the data 
with a simple event model, the toolkit allows applications to sup­port direct manipulation of 3D data, 
which is often more friendly and intuitive than conventional widget-driven interfaces. Of course, the 
3D toolkit still allows standard widgets to be integrated into ap­plications in addition to the direct 
interfaces. Sample applications showing a variety of interactive techniques are shown in operation in 
Figure 12 through Figure 15. An obvious direction for the future is extending the toolkit to have more 
nodes, actions, manipulators, and components. Chief among these are volumes, more 2D shapes, shape-specific 
manipulators, photorealistic rendering, and the ability to generate and return prim­itives (polygons, 
lines, etc. ) for all shapes. This last feature can be used to implement radlosity, simulation, and analysis. 
Other potential directions for the toolkit include: Animation. Sensors provide the mechanism upon which 
to build more complex animation and constraint schemes. The toolkit could provide higher-level classes 
to facilitate the creation and storage of constrained, timed, and scripted motion. Shared databases. 
Running dktinct components or applications as separate processes requires databases to be stored in shared 
memo­         
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134091</article_id>
		<sort_key>351</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>41</seq_no>
		<title><![CDATA[Using deformations to explore 3D widget design]]></title>
		<page_from>351</page_from>
		<page_to>352</page_to>
		<doi_number>10.1145/133994.134091</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134091</url>
		<categories>
			<primary_category>
				<cat_node>H.5.2</cat_node>
				<descriptor>Theory and methods</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Curve, surface, solid, and object representations</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.6</cat_node>
				<descriptor>Interaction techniques</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>H.5.2</cat_node>
				<descriptor>Interaction styles (e.g., commands, menus, forms, direct manipulation)</descriptor>
				<type>S</type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010147.10010371.10010387</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Graphics systems and interfaces</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010401</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Volumetric models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003120.10003121.10003125.10010391</concept_id>
				<concept_desc>CCS->Human-centered computing->Human computer interaction (HCI)->Interaction devices->Graphics input devices</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003120.10003121.10003124</concept_id>
				<concept_desc>CCS->Human-centered computing->Human computer interaction (HCI)->Interaction paradigms</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010399</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Parametric curve and surface models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003120.10003123.10011758</concept_id>
				<concept_desc>CCS->Human-centered computing->Interaction design->Interaction design theory, concepts and paradigms</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003120.10003121.10003126</concept_id>
				<concept_desc>CCS->Human-centered computing->Human computer interaction (HCI)->HCI theory, concepts and models</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Design</gt>
			<gt>Human Factors</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>P261164</person_id>
				<author_profile_id><![CDATA[81100023637]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Scott]]></first_name>
				<middle_name><![CDATA[S.]]></middle_name>
				<last_name><![CDATA[Snibbe]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Brown University, Department of Computer Science, Providence, RI]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P160097</person_id>
				<author_profile_id><![CDATA[81332503677]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[Kenneth]]></first_name>
				<middle_name><![CDATA[P.]]></middle_name>
				<last_name><![CDATA[Herndon]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Brown University, Department of Computer Science, Providence, RI]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P59283</person_id>
				<author_profile_id><![CDATA[81100066066]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>3</seq_no>
				<first_name><![CDATA[Daniel]]></first_name>
				<middle_name><![CDATA[C.]]></middle_name>
				<last_name><![CDATA[Robbins]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Brown University, Department of Computer Science, Providence, RI]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>PP31023465</person_id>
				<author_profile_id><![CDATA[81100019411]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>4</seq_no>
				<first_name><![CDATA[D.]]></first_name>
				<middle_name><![CDATA[Brookshire]]></middle_name>
				<last_name><![CDATA[Conner]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Brown University, Department of Computer Science, Providence, RI]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>PP40027057</person_id>
				<author_profile_id><![CDATA[81452592989]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>5</seq_no>
				<first_name><![CDATA[Andries]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[van Dam]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Brown University, Department of Computer Science, Providence, RI]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_obj_id>808573</ref_obj_id>
				<ref_obj_pid>800031</ref_obj_pid>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Alan H. Barr. Global and local deformations of solid primitives. In Proceedings of the ACM SIGGRAPH, Computer Graphics, volume 18(3), pages 21-30, July 1984.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_obj_id>147199</ref_obj_id>
				<ref_obj_pid>147156</ref_obj_pid>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[D. Brookshire Conner, Scott S. Snibbe, Kenneth P. Herndon, Daniel C. Robbins, Robert C. Zeleznik, and Andries van Dam. Three-dimensional widgets. In Proceedings of the 1992 Symposium on Interactive 3D Graphics, pages 183-188, 1992.]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122730</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Robert C. Zeleznik, D. Brookshire Conner, Matthias M. Wloka, Daniel G. Aliaga, Nathan T. Huang, Philip M. Hubbard, Brian Knep, Henry Kaufman, John E Hughes, and Andries van Dam. An object-oriented framework for the integration of interactive animation techniques. In Proceedings of the ACM SIGGRAPH, Computer Graphics, volume 25(4), pages 105-112, July 1991.]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 z Computer Graphics, 26, 2, July 1992 Using Deformations to Explore 3D Widget Design Scott S. Snibbe, 
Kenneth P. Hemdon, Daniel C. Robbins, D. Brookshire Conner and Andries van Dam Brown University Department 
of Computer Science Providence, RI 02912 (401) 863-7693; {sss,kph,dcr,dbe,avd}@ cs.brown.edu CR Categories 
 H.5.2 [Information Interfaces and Presentation]: User Interfaces; Interaction Styles; Theory and Methods; 
1.3.5 [Computer Graph­ics]: Computational Geometry and Object Modeling; Curve, Sur­face, Solid, and Object 
Representations; 1.3.6 [Computer Gmphics]: Methodology and Techniques; Interaction Techniques 1 A 3D 
Interface for Deformations We are developing a framework for creating interactive 3D environ­ments for 
applications in design, education, and the communication of information and ideas [3]. Our most recent 
work focuses on providing a useful and powerful interface to such a complex envi­ronment. To this end 
we have developed 3D widgets, objects that encapsulate 3D geometry and behavior, to control other objects 
in the scene [2]. We build 3D widgets as first-class objects in our real-time animation system. Becauseour 
system allows tapid pro­totyping of objects, we hope to enlarge today s surprisingly small vocabulary 
of 3D widgets that includes menus floating in 3D, ges­tural picking, translation and rotation, cone trees, 
and perspective walls. As a way to focus on issues of 3D widget design, we have developed widgets to 
perform a particular task: applying high-level deformations to 3D objects [ 1]. The complexity of these 
operations makes numerical specification or panels of sliders difficult to use, and yet direct manipulation 
interfaces cannot provide meaningful feedback without fixing most parameters. In this video paper, we 
show a set of new 3D widgets to control deformations called racks. A simple rack consists of a bar specifying 
the axis of deforma­tion and some number of handles attached to the bar speci~ing additional deformation 
parameters. For example, a taper rack has two additional handles. Moving the ends of the handles towards 
or away from the axis bar changes the amount of taper of the de­formed object; changing the distance 
between the handles changes the region over which the deformation is applied. A mom complex rack can 
have multiple handles specifying dif­ferent deformations. The racks in Figures 1 3 all have handles for 
twisting (purple), tapering (blue), and bending (red) an object. The deformation range is the region 
between the twist and taper handles. Permission m copy without fee all or part of this material is granted 
provided that the copies are not made or distributed for direct commercial advantage, the ACM copyright 
notice and the title of the publication and its date appear, and notice is given that copying is by permission 
of the Asscclatinn for Computing Machinery. To copy otherwise. or to republlsb, requires a fee and/nr 
specific permission.  2 The Issues in 3D Widget Design Many of the issues in designing 3D widgets are 
similar to those in designing a good 2D interface. However, good answers that serve in 2D are not necessarily 
good answers in more complex 3D environments. For example, two common 2D interface solutions are control 
panels (e.g., sliders, buttons, and menus) and the di­rect manipulation of objects (e.g., dragging files 
in the Macintosh Finder). A control panel for a deformation can require as many as a dozen sliders and 
thus consumes a great deal of screen real estate; it also artificially differentiates related parameters 
and does not pro­vide good correlation to its 3D effects. In addition, although these controls may be 
arranged so that related sliders (say, for the three components of a vector) are logically grouped, users 
are rarely able to correlate changes in these controls with corresponding changes in the deformed objects. 
A 3D direct manipulation interface to control the same defor­mation might be implemented in which the 
user clicks and drags the faces of an object. One problem with this approach is that most computer graphics 
objects look rigid, as though they do not permit deformation. Rigid objects appear to afford six degrees 
of freedom, three translational and three rotational, and direct ma­nipulation techniques like virtual 
sphere rotation work very well because they exploit this apparent rigidity. To compensate for the lack 
of feedback in certain direct manipulation techniques, we can introduce tools that make additional degrees 
of freedom available; the rack is an example of such a tool. However, the widget s ge­ometry, while possibly 
suggesting the kinds of actions that can be performed, may at the same time obscure the object of interest 
or unnecessarily complicate the scene. In addition to showing this tradeoff, we consider the following 
issues in widget design: . Selfdisclosure A widget whose geometry indicates its behavior is called se~­ 
 disclosing. For example, a handle that twists an object can itself be a twisted object, thereby suggesting 
its action. . Implicit versus explicit control of parameters Widgets usually explicitly control one 
or more parameters of an action. For example, a handle in a taper rack controls the amount that the object 
is tapered. A widget may simplify an action by implicitly controlling other parameters. For exam­ple, 
a widget can implicitly control the tessellation of objects by varying the tessellation with the amount 
of deformation. There is no handle to explicitly control the tessellation. . Degrees of freedom A 3D 
environment offers multiple degrees of freedom that  can hinder as well as help a particular operation. 
A tool can be made more effective by removing unnecessa~ degrees of freedom with constraints. 351 c 
1992 ACM-(LW79 1-479-I/92/007/035 I $ot.50  
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134092</article_id>
		<sort_key>353</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>42</seq_no>
		<title><![CDATA[Interactive inspection of solids]]></title>
		<subtitle><![CDATA[cross-sections and interferences]]></subtitle>
		<page_from>353</page_from>
		<page_to>360</page_to>
		<doi_number>10.1145/133994.134092</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134092</url>
		<keywords>
			<kw><![CDATA[clipping]]></kw>
			<kw><![CDATA[cross-section]]></kw>
			<kw><![CDATA[interferences]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>J.6</cat_node>
				<descriptor>Computer-aided design (CAD)</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>I.3.3</cat_node>
				<descriptor>Display algorithms</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Curve, surface, solid, and object representations</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Visible line/surface algorithms</descriptor>
				<type>S</type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010382</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Image manipulation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010382</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Image manipulation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010372.10010377</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Rendering->Visibility</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010372</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Rendering</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010399</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Parametric curve and surface models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010401</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Volumetric models</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010405.10010469.10010472.10010440</concept_id>
				<concept_desc>CCS->Applied computing->Arts and humanities->Architecture (buildings)->Computer-aided design</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010405.10010432.10010439.10010440</concept_id>
				<concept_desc>CCS->Applied computing->Physical sciences and engineering->Engineering->Computer-aided design</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
			<gt>Design</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>PP14068595</person_id>
				<author_profile_id><![CDATA[81100166952]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Jarek]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Rossignac]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Interactive Geometric Modeling, IBM T.J. Watson Research Center]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>PP31043287</person_id>
				<author_profile_id><![CDATA[81100460445]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[Abe]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Megahed]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Interactive Geometric Modeling, IBM T.J. Watson Research Center]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>PP39030060</person_id>
				<author_profile_id><![CDATA[81100155521]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>3</seq_no>
				<first_name><![CDATA[Bengt-Olaf]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Schneider]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Interactive Geometric Modeling, IBM T.J. Watson Research Center]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Kurt Akeley, Silicon Graphics Inc. Private communication subsequent to the SIGGRAPH review process. March 1992.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[David Dobkin and Herbert Edelsbrunner, Space Searching for Intersecting Objects. ACM &amp; IEEE Sum. on Foundations of Computer Science, IEEE Computer Society Press, New York, NY, 387-392, 1984.]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[John Ellis, Gershon Kedem, Rich Marisa, Jay Menon, and Herbert Voelcker, Breaking Barriers in Solid Modeling. CIME, pages 28-34, February 1991.]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[Dave Epstein, Friderik Jansen, and Jarek Rossignac, Z-buffer Rendering from CSG: The Trickle Algorithm. Research Report, RC 15182, IBM T.J. Watson Research Center, Yorktown Heights, NY, December 1990.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_obj_id>617484</ref_obj_id>
				<ref_obj_pid>616005</ref_obj_pid>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[Jack Goldfeather, Steve Molnar, Greg Turk, and Henry Fuchs, Near Real-Time CSG Rendering Using Tree Normalization and Geometric Pruning. IEEE Computer Graphics and Applications, 9(3):20-28, May 1989.]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[Starbase Reference Manual. "set_capping_planes" command. Hewlett Packard.]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Martti M&amp;ntyl~, An Introduction to Solid Modeling. Computer Science Press, Rockville, Maryland, 1988.]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[Aristides Requicha and Robert Tilove, Mathematical Foundations of Constructive Solid Geometry: General Topology of Regular Closed Sets. Production Automation Project, Tech. Memo. No. 27a, Univ. of Rochester, June 1978.]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Jarek Rossignac, Accurate scanconversion of triangulated surfaces, in A. Kaufman, editor, Advances in Computer Graphics Hardware VI, Springer-Verlag, Berlin, 1992.]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_obj_id>51123</ref_obj_id>
				<ref_obj_pid>49155</ref_obj_pid>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[Jarek Rossignac and Herbert Voelcker, Active Zones in CSG for Accelerating Boundary Evaluation, Redundancy Elimination, Interference Detection and Shading Algorithms. ACM Transactions on Graphics, 8(I):51-87, January 1989.]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
			<ref>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[Jarek Rossignac and Jeffey Wu, Correct Shading of Regularized CSG Solids Using a Depth-Interval Buffer. Eurographics Workshop on Graphics Hardware, Lausanne, Switzerland, September 1990.]]></ref_text>
				<ref_id>11</ref_id>
			</ref>
			<ref>
				<ref_obj_id>1098652</ref_obj_id>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[Jean Serra, Image Analysis and Mathematical Morphology. Academic Press, New York, 1982.]]></ref_text>
				<ref_id>12</ref_id>
			</ref>
			<ref>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[Graphics Library-Reference Manual, Iris 4D VGX. Silicon Graphics, Inc., 1990.]]></ref_text>
				<ref_id>13</ref_id>
			</ref>
			<ref>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[Robert Tilove, Line/Polygon Classification: A Study of the Complexity of Geometric Computation. IEEE Computer Graphics and Applications, 1(2):75-88, April 1981.]]></ref_text>
				<ref_id>14</ref_id>
			</ref>
			<ref>
				<ref_obj_id>358195</ref_obj_id>
				<ref_obj_pid>358105</ref_obj_pid>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[Robert Tilove, A Null Object Detection Algorithm for Constructive Solid Geometry. Comm. ACM, 27(7):684-694, July 1984.]]></ref_text>
				<ref_id>15</ref_id>
			</ref>
			<ref>
				<ref_obj_id>325224</ref_obj_id>
				<ref_obj_pid>325165</ref_obj_pid>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[Fujio Yamaguchi, A unified approach to interference problems using a triangle processor. Proceedings SIGGRAPH'85, 19(3):141-149, 1985.]]></ref_text>
				<ref_id>16</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
  Computer Graphics, 26, 2, July 1992 A standard way to produce the image of Figure 4 is to perform 
the Boolean difference operation between the solids and the cut-volume and to display the result. A slightly 
better approach combines surface clipping with the display of a cross-sections computed as the geomet­ric 
intersection of the solid with a plane [7]. A CSG for­mulation of the result may also be us&#38;d with 
special-purpose direct CSG rendering hardware [3-5, 11], The technique described in this section provides 
an al­ternative which neither requires the hardware used for efficiently rendering CSG models nor any 
complex ge­ometric intersection calculations. It works with any boundary representation for solids, provided 
that the scan-conversion method used by the graphics hardware satisfies the following parity condition, 
Men the entire solid fits between the front and the back clipping planes, each pixel is visited an even 
number of times during the scan-conversion of the soiid s faces. Eariy scan-conversion techniques did 
not guarantee the parity condition at pixeis traversed by the projection of a common edge between two 
faces, A reiiable imple­mentation of the methods presented here requires a true point-sampiing scan-conversion 
[9]. To estabiish which points of a clipping plane lie inside any given soiidl we use the foiiowing property 
[14]. A point Q iies inside a bounded soiid S if and only if Q is not on the boundary of S and if a semi-infinite 
iine (ray) starting at Q intersects the boundary of S at an odd number of isoiated transversal intersection 
pointsl. Since the resuit is independent of the direction for the ray, the viewing direction may be used. 
Suppose that the location of (2 is stored in the z-buffer as Z(q), the depth of the pixel q corresponding 
to the projection of Q onto the screen. Q Iiea in the interior of S if and oniy if the number of times 
q is visited during the scan-conversion of the faces of S with a depth greater than Z(q) is odd. Furthermore: 
A point Q, projecting on a pixel q and lying on a clipping plane C, ia inside a solid S if and only if 
q ia visited an odd number of times whiie scan-converting the faces of S af­ter they have been ciipped 
using C. Note that aii points Q of C that correspond to pixels of the screen may be classified during 
a singie pass over S, We use the above property to construct a pixel mask (one bit per pixel), Mp, for 
the cross-section region where the clipping piane intersects any given soiid. The process is illustrated 
in Figure 5. When the outward normai of a cut-volume face points away from the viewer, it corresponds 
to a potential front face of the soiid resulting from the cut. Therefore, we use the term front clipping 
plane when referring to the pianes containing such a back face of the cut-voiume. We need to fiil oniy 
the cross-sections of front ciipping pianes, be­cause other (back) ciipping pianes are never visibie. 
To make the classification results consistent with the mathematical definition of the regularized difference 
be­tween the originai soiid and the cut-voiume [8], the clip­ping of faces coincident with the ciipping 
plane must be performed using a iess than depth test for clipping pianes and a less or equai depth-test 
otherwise. The technique assumes that the soiids are not clipped by the back piane of the viewing volume. 
if the depth span of the object is known, it suffices to temporarily adjust the back plane. However, 
changes to the z-resolution may produce side-effects. It is also possible to set the per­spective such 
that the back plane coincides with the ho­rizon,s to guarantee that no object is ciipped by the back 
clipping-piane. Semen Ac . ... ... ...... ....­ .. odd -......even .. odd Figure 5. Parity-based mask 
construction: The pixel-mask, Mp, for the iritersectlon of plane C with so/id S /s computed by togg/­irrg 
the mask durhrg the scan-conversion of the faces of S behhrd C. RIs the projection of S onto the screen 
and R the projection of S onto C. A high-levei algorithm for rendering assemblies ciipped by a cut-volume 
composed of a single half-space is pre­sented below. It renders the cross-section through each soiid 
using the coior (surface properties) of that solid4. if C is a back clipping piane, the standard surface 
clipping approach may be used, otherwise, we proceed as foiiows. Single-plane sol id-cl ipping: 01 Activate 
C as a front clipping plane 02 For all pixels do Z=Et, 1=0, Mp=O 03 For each solid S do 04 Render all 
the faces of S toggling Mp es Deactivate C 06 Shade C and reset Mpwhere t4p==l 1 Tangential intersection 
cases, where the ray touches a primitive s boundary wlthoul crossing it, must be treated properly by 
the hardware scan­converslon, so as to ensure the correct panty at all pixels [9] Cases where a one-dimensional 
subset or the ray lies on a face are ignored by scan­conversion procedures without compromising the parity 
condition 2 Scan-conversion inaccuracies, which produce inconsistencies when displaying overlapping coplanar 
faces, may be addressad by Introducing tolerances in the depth-test [11] 3 The screen lies exactly between 
the viewpo)nt and the horizon-plane of all the vanishing peints 4 Interference areas may exhibit color 
mixing unless the interference highlighting technique of the next section is used 355 Computer Graphics, 
26, 2, July 1992 . performance on an affordable platform has not been Iscreen demonstrated. Boxing techniques 
provide only a neces­ / sary condition for interference. Consequently, the ap­proach described in this 
section constitutes an important 1 r /-~ Atool for detecting and displaying interferences. The first 
 W s Mp cross-emotion .~ B Figure 7. A4asking for a clipping-product Two front clipping planes A and 
B and one back clipping plane C bound a c/ipping-producL L4p is constructed by scan-converting S c/ipped 
byAand B.The visible cross-sections are obtained by rendering A (clipped to B and C) and B (clipped to 
A and C) over pixels where Mp IS 1. 3. Interferences Usually, a mechanical assembly must be free from 
inter­ferences, but may contain lower-dimensional contact re­gions z between its components. Intersections 
between pairs of solids may be computed in various ways. A geometric approach evaluates the boundary 
of the regularized Boolean intersection of the two solids. The existence of a single vertex in the inter­section 
suffices to indicate interference. Efficient Null Object Detection techniques may be used, especially 
if the solids are in CSG form [1 O, 15]. Hardware architec­tures for testing interferences between triangulated 
boundaries have also been proposed [16]. Although asymptotically efficient computational geometry tech­niques 
for finding the minimum distance between two polyhedra are available [2], these numeric approaches are 
too expensive for interactive inspection and should be reserved for the final stages of the assembly 
verifica­tion. Two hardware-assisted graphics techniques are relevant to interference detection: (1) 
a discretized (ray casting) approach reduces interference detection to a series of one-dimensional interval-intersection 
tests and is sup­ported by special-purpose ray-casting hardware [3] and (2) the ability to automatically 
select and report which of the scan-converted objects interfere with an application­defined block provides 
a mechanism for eliminating un­necessary interference calculations. (Solids that are clearly disjoint 
from any solid S because they are disjoint from a box containing S may be efficiently identified that 
way. ) Geometric intersection techniques are too expensive. Ray-casting can be efficiently parallelized, 
but interactive portion of this section focuses on an extension of the solid-clipping technique to highlight 
interferences in the cross-sections (Figure 9). The second portion presents a technique for automatically 
locating the beginning of in­terference regions along a user-specified search direc­tion. This search 
facility is used interactively for two purposes: (1) to quickly and reliably establish that a par­titular 
region is free of interferences or (2) to automat­ically loc~te the first interference region a nd position 
the clipping plane at its beginning to facilitate the visual in­spection of the extent of the interference. 
Subsequent interferences are located automatically by starting the search past the current interference 
region. 3,1 HighiighCing interference areas The algorithm for highlighting the interference is pre­sented 
below in its simplified version for a clipping product restricted to a single front ciipping piane C. 
The successive steps are illustrated in Figure 8, The aigorithm computes a parity pixel mask, Mp, for 
the cross-section of the current soiid, a cumulative (union) pixel mask, Mu, for the union of the cross-sections 
of all previously proc­ essed solids, and an intersection-mask, section of the solid, restricted to (Mp 
rendered with the soiid s colors. The is rendered at the end in a highlighted Algorithm for highl ighting 
interferences: Mi, The cross-AND NOT Mu), is interference area mode over Mi. 01 For all pixels do Z=O, 
1=0, Mu-O, Mi=O, and Mp=O 02 For each solid S do 03 Activate C as a clipping plane 04 Scan S toggling 
Mpand rendering where Mu==O 05 Oisable writing into z-buffer 06 Deactivate C 07 Render C where Mp==l 
and Mu==O 08 For all pixels in R do 09 If (Mu==l &#38;&#38;Mp==l) Mi=l 10 If (Np==l) Nu=l and t!p=O 11 
Enable writing into the z-buffer 12 Oisable writing into z-buffer 13 Select color and style for the interference 
14 Render R on C for pixels where Hi==l 15 Enable writing into the z-buffer 16 Oisable writ{ng into the 
frame buffer 17 Render R on C for oixels where Mu==l in Line 04, all the front and by C and then scan-converted. 
during that scan-conversion is toggied. Furthermore, if back faces For each the pixei s at that pixei 
of S are ciipped access to a pixei parity mask, Mp, the mask Mu is not set, the z-buffer and frame buffer 
are updated. (Note that this update is not necessary for the back faces of S. ) Testing Mu prior to update 
avoids overwriting previously computed cross-sections for which the z-buffer has not yet been properly 
set. 6 The interference between two solids A and B is their regularized intersection (A n*B) Regularization 
removes lower dimensional parts, ihus, the regu. Iarized intersection IS the closure of the interior 
of the Intersection [8] 7 The contact between two solids Is ((A n B) (A n*B)), the set theoretic difference 
between their set theoretic Intersection and their regularized inter­ section 357   3.2 Locating interference 
regions This subsection is devoted to the automatic detection and location of interferences and contacts 
along a user­defined search direction and within a given search inter­val. Without loss of generality, 
the search direction is chosen orthogonal to the cross-sectioning plane C. The search interval is confined 
to a slice between C and another plane C parallel to C. The location of C may be specified by the user 
or computed automatically from a bounding box, so as to extend past the entire assembly. The posi­tions 
of C and C are indicated by the starting and ending parameters Z,ati and Z,nd along the search direction 
D. Using a stack of parallel cross-sections evenly distributed between Ztian and ZOn~and testing if any 
of them contains an interference region will not guarantee the detection of interferences, since these 
may occur between two consecutive cross-sections. The cost of testing a suffi­cient number of cross-sections 
to reduce the size (in depth) of possibly missed interferences is prohibitive. Instead of such a discrete 
probing, the technique pre­sented here uses the procedure IntersectionFreeSlice to compute a sufficient 
but not necessary condition for interference. If the answer is negative, the designer may be reassured 
immediately. Otherwise, the following al­gorithm recursively subdivides the search interval (Ztifi, Z.~) 
until a user-defined maximum level (i.e. mini­mal slice thickness), L, is reached (in which case, the 
beginning of a possible interference region is returned) or until all branches of the search tree that 
correspond to positive test result have been explored (in which case there is no interference and Z.ti 
is returned). The mini­mal slice thickness, the depth resolution, and the z­scaling factors control the 
accuracy of the test and define the ability to differentiate between interference and con­tact. The command 
Search(Ztiati, Zon&#38; Ml), where Ml de­fines the maximum recursion level, starts the search. Ml may 
be adjusted to ensure the desired accuracy. The parameters, 2s, Ze, and level define the current status 
of the recursion, Algorithm for interval 1ocation: 91 Search (Zs, Ze,level) e2 If (Intersect ionFreeSl 
ice(Zs, Ze)) return Zend 03 If (level -=L) return Zs 04 Zm=(Zs+Ze)/2 05 Zf=Search (Zs, Zm,level+l) 06 
If (Zf!=Z,nd) return Zf 07 Else return Search (Zm,Ze,level+l)  A 2D bounding box around the discovered 
interference is used to position an arrow highlighting the potential in­terference region. The clipping 
plane C is automatically placed at the beginning of that interval, so that the user can inspect the area, 
then move C past the current in­terference, and finally resume the search. The IntersectionFreeSlice 
test is implemented in the following algorithm by generating a mask Mp for the projection of the intersection 
of the current solid S with the slice and by testing if this mask intersects the Mu mask for the union 
of the projection of previously proc- Computer Graphics, 26, 2, July 1992 essed solids. The approach 
is based on the following property. If the projections of the slices through the solide are die­joint, 
there is no interference within the ailce. Intersect ionFreeSl ice: 01 Activate C as a front clipping 
plane 02 For all pixels do Mu=tl, Mi=O, 14p=0 03 For each solid S do 04 Scan-convert S toggling Mp 05 
Activate C as a back clipping plane 06 Scan-convert S forcing i4p=l 07 For all pixels in R do 08 If (Hu==l 
~&#38; Mp==l) return O 09 If (Hp.-l) Mu-1 and Mp=O To avoid missing thin interferences that fall between 
pixels, it suffices, as part of the shading of a solid, to draw the edges of each solid in lines 3 pixels 
wide. Each edge must be drawn twice to maintain the parity condition. (We simply draw the edges of each 
face after shading it. ) On the other hand, to distinguish contact regions from true interferences, we 
apply a two-dimensionai discretized morphological shrinking operation [12], i.e. a 3x3 filter over ali 
pixels, to the mask Mi so as to remove interfer­ences that are thinner than two pixeis. By acting on 
the scaling factor (i.e. the space distance corresponding to the inter-pixel resolution), one can ad­just 
the thresholds between clearance, non-invasive cent act, and true interference. By performing the lntersectionFraeSlice 
test twice (once with drawing the edges and once with eroding the mask) one can distin­guish ciearance 
(if both test return false), from contacts (if the results of imth tests are different), from interfer­ences 
(if both tests return true). However, searching true interferences (through mask erosion) for regions 
with oblique contact areas between overlapping faces of dif­ferent objects forces the adaptive subdivision 
to visit all the branches of the search tree down to a depth corre­sponding to a slice thickness for 
which there is no inter­ference between the projections of the solids. The interference search automatically 
positions the cross-sectioning plane at the beginning of an interference region. The user examines the 
interference by moving the viewpoint and the clipping piane. The interfering ob­jects may be selected 
by a graphic pick and the corre­sponding CAD modeis which require engineering changes may be identified. 
Facilities for interactively hiding some models or for producing exploded views also help decide which 
of the interfering parts must be redesigned. The search algorithms described above require exten­sions 
to the functions supported by currently available graphics iibraries and may also involve some hardware 
modifications. For example, Line 08 of the lntersectionFreeSlice algorithm requires a feedback from the 
buffer to the application. Such a feedback exists for reporting enclosing boxes around pixels traversed 
by the scan-conversion, but does not take into account any result of testing mask values for these pixels. 
This step is handled trxfay by the application software which must inspect each pixel of Mi. Similarly, 
the erosion operation is also currently performed in software, which consider­ ably reduces the performance 
of the search algorithm. SIGGRAPH 92 Chicago, July 26-31, 1992 Nevertheless, except for regions where 
two or more ob­jects are in contact, the search algorithm only visits a few branches of the search tree, 
and thus its software imple­mentation requires the inspection of only a small number of pixel-masks within 
a limited domain (R).  Conclusion Simple algorithms for displaying cross-sections through solids, for 
highlighting interference areas, and for auto­matically detecting interferences and contacts between 
solids have been presented. Because the additional cost for filling the cross-sections and for highlighting 
interfer­ence areas does not significantly exceed the original rendering cost, these algorithms exhibit 
realtime per­formance for small assemblies with the exception of in­terference detection. They provide 
the engineering visualization techniques needed to replace the expensive c1ay models, traditionally used 
during the design­inspection phases, by electronic virtual solid models. The algorithms have been integrated 
in an experimental system developed by the Interactive Geometric Modeling group at IBM Research and have 
been successfully tested on industrial assembly models. Acknowledgements We are very grateful to Kurt 
Akeley for his comments on this paper and for allowing us to compare both his and our implementations. 
We also wish to thank Dan Brokenshire for pointing out the limitations of the stand­ard clipping technique 
for solid modeling applications and for participating in the early phases of this work. References [1] 
Kurt Akeley, Silicon Graphics Inc.. Private communi­cation subsequent to the SIGGRAPH review process. 
March 1992. [2] David Dobkin and Herbert Edelsbrunner, Space Searching for Intersecting Objects. ACM 
&#38; IEEE Sum. on Foundations of Computer Science, IEEE Computer Society Press, New York, NY, 387-392, 
1984. [3] John Ellis, Gershon Kedem, Rich Marisa, Jay Menon, and Herbert Voelcker, Breaking Barriers 
in Solid Model­ing. Cl ME, pages 28-34, February 1991. [4] Dave Epstein, Friderik Jansen, and Jarek Rossignac, 
Z-buffer Rendering from CSG: The Trickle Algorithm. Re­search Report, RC 15182, IBM T.J. Watson Research 
Center, Yorktown Heights, NY, December 1990. [5] Jack Goldfeather, Steve Molnar, Greg Turk, and Henry 
Fuchs, Near Real-Time CSG Rendering Using Tree Normalization and Geometric Pruning. IEEE Computer Graphics 
and Applications, 9(3):20-28, May 1989. [6] Starbase Reference Manual. set_capping_planes command. Hewlett 
Packard. [7] Martti M~ntylli, An Introduction to Solid Modeling. Computer Science Press, Rockville, Maryland, 
1988. [8] Aristides Requicha and Robert Tilove, Mathematical Foundations of Constructive Solid Geometry: 
General Topology of Regular Closed Sets. Production Automation Project, Tech. Memo. No. 27a, Univ. of 
Rochester, June 1978. [9] Jarek Rossignac, Accurate scanconversion of trian­gulated surfaces, in A. Kaufman, 
editor, Advances in Computer Graphics Hardware Vl, Springer-Verlag, Berlin, 1992. [10] Jarek Rossignac 
and Herbert Voelcker, Active Zones in CSG for Accelerating Boundary Evaluation, Redun­dancy Elimination, 
Interference Detection and Shading Algorithms. ACM Transactions on Graphics, 8(1)51-87, January 1989. 
[11] Jarek Rossignac and Jeffey Wu, Correct Shading of Regularized CSG Solids Using a Depth-interval 
Buffer. Eurographics Workshop on Graphics Hardware, Lausanne, Switzerland, September 1990. [12] Jean 
Serra, Image Analysis and Mathematical Morphology. Academic Press, New York, 1982. [13] Graphics Library-Reference 
Manual, Iris 4D VGX. Silicon Graphics, Inc., 1990. [14] Robert Tilove, Line/Polygon Classification: A 
Study of the Complexity of Geometric Computation. IEEE Com­puter Graphics and Applications, 1(2):75-88, 
April 1981. [15] Robert Tilove, A Null Object Detection Algorithm for Constructive Solid Geometry. Comm. 
ACM, 27(7):684-694, July 1984. [16] Fujio Yamaguchi, A unified approach to interference problems using 
a triangle processor. Proceedings SIGGRAPH 85, 19(3):141-149, 1985. 36a 
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134093</article_id>
		<sort_key>361</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>43</seq_no>
		<title><![CDATA[A collision-based model of spiral phyllotaxis]]></title>
		<page_from>361</page_from>
		<page_to>368</page_to>
		<doi_number>10.1145/133994.134093</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134093</url>
		<keywords>
			<kw><![CDATA[cactus]]></kw>
			<kw><![CDATA[flower head]]></kw>
			<kw><![CDATA[modeling of plants]]></kw>
			<kw><![CDATA[realistic image synthesis]]></kw>
			<kw><![CDATA[spiral phyllotaxis]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Curve, surface, solid, and object representations</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>I.3.7</cat_node>
				<descriptor>Color, shading, shadowing, and texture</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>J.3</cat_node>
				<descriptor>Biology and genetics</descriptor>
				<type>S</type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010405.10010444.10010095</concept_id>
				<concept_desc>CCS->Applied computing->Life and medical sciences->Systems biology</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010382.10010384</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Image manipulation->Texturing</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010405.10010444.10010935</concept_id>
				<concept_desc>CCS->Applied computing->Life and medical sciences->Genetics</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010382</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Image manipulation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010405.10010444.10010087</concept_id>
				<concept_desc>CCS->Applied computing->Life and medical sciences->Computational biology</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010401</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Volumetric models</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010399</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Parametric curve and surface models</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>P64995</person_id>
				<author_profile_id><![CDATA[81100062479]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Deborah]]></first_name>
				<middle_name><![CDATA[R.]]></middle_name>
				<last_name><![CDATA[Fowler]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Departmentof Computer Science University of Calgary and University of Regina]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>PP14162862</person_id>
				<author_profile_id><![CDATA[81100465812]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[Przemyslaw]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Prusinkiewicz]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Departmentof ComputerScience, University of Calgary]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P142560</person_id>
				<author_profile_id><![CDATA[81100304287]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>3</seq_no>
				<first_name><![CDATA[Johannes]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Battjes]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Hugo de Vries Labmmry, University of Amsterdam]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[I. Adler. A model of contact pressure in phyllotaxis. Journal of Theoretical Biology, 45:1-79, 1974.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[J. Battjes, K. Bachmann, and F. Bouman. Early development of capitula in Microseris pygmaea D. Don strains C96 and A92 (Asteraceae: Latium). Botanische Yahrbacher Systematik, 113(4):461-475, 1992.]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[H. S. M. Coxeter. Introduction to Geometry. J. Wiley &amp; Sons, New York, 196 I.]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[S. Douady and Y. Couder. Phyllotaxis as aphysical selforganized growth process. Manuscript, Laboratoire de Physique Statistique, Paris, 1991.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[R. O. Erickson. The geometry of phyllotaxis. In J. E. Dale and F. L. Milthrope, editors, The Growth and Functioning of Leaves, pages 53-88. University Press, Cambridge, 1983.]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_obj_id>83821</ref_obj_id>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[J. D. Foley, A. Van Dam, S. K. Feiner, and J. F. Hughes. Computer Graphics: Principles and Practice. Addison-Wesley, Reading, Massachusetts, 1990.]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[D. R. Fowler, I. Hanan, and P. Prusinkiewicz. Modelling spiral phyllotaxis, computers &amp; graphics, 13(3):291-296,1989.]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[G. Van Iterson. Mathematische und mikr~sk~pish" anatomische Studien fiber Blattstellungen. Gustav Fischer, Jena, 1907.]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[R. V. Jean. Mathematical modelling in phyUotaxis: The state of the art. Mathematical Biosciences, 64:1- 27, 1983.]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_obj_id>83596</ref_obj_id>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[P. Prusinkiewicz and A. Lindenmayet. The Algorithmic Beauty of Plants. Springer-Verlag, New York, 1990. With J. Hanan, F. D. Fracchia, D. R. Fowler, M. J. M. de Boer, and L. Merc~.]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
			<ref>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[F. Van der Linden. Creating phyllotaxis: The dislodge,. merit model. Mathematical Biosciences, 100:161-199, 1990.]]></ref_text>
				<ref_id>11</ref_id>
			</ref>
			<ref>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[H. Vogel. A better way to construct the sunflower head. Mathematical Bio$ciences, 44:179-189, 1979.]]></ref_text>
				<ref_id>12</ref_id>
			</ref>
			<ref>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[C. H. Waddington. Canalization of development and the inheritance of acquired characteristics. Nature, 150:563-565, 1942.]]></ref_text>
				<ref_id>13</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 z Computer Graphics, 26,2, July 1992 A Collision-base-d Model of Spiral Phyllotaxis Deborah R. Fowler 
Pmemyslaw Prusinkiewicz JohannesBattjes Departmentof Computer Science Departmentof ComputerScience Hugo 
de Vries Labmmry University of Calgary University of Calgary University of Amsterdam and University of 
Regina ABSTRACT Plant organs are often arrangedin spiratpatterns. This effwt is termed spiral phyllotaxis. 
Well known examples include the layout of seeds in a sunflower head and the arrangement of scales on 
a pineapple. l%is paper presents a method for modeling spiral phyllotaxis based on detecting and elimi­nating 
collisions between the organs while optimizing their packing. In contrast to geometric models previously 
used for computer graphics purposes, the new method arranges organs of varying sizes on arbitrarysurfaces 
of revolution. Consequently, it w be applied to synthesize a wide range of naturalplant structures. 
CR Categoriw 1.3.5[ComputerGraphics]: Computa­tionalGeometryandObjectModeling: Curve, surface, solid 
and object reprt?sentation. 1.3.7 [Computer Graphics]: Three-DimensionalGraphics and Realism. J.3 [Life 
and Medical Sciences]: Biology. Keyword.w realistic image synthesis, modeling of plants, spiralphyllotaxis, 
flowerhead,cactus. 1 INTRODUCTION Phyllotaxis, or a regular arrangement of organs such as leaves, flowers, 
or scales, can be observed in many plants. The patternof seeds in a sunflower head and the arrange­ment 
of scales on a pineapple are good examples of this phenomenon. It is characterized by conspicuous spirals, 
Pcrmlssinn 10 copy withnut fee all or part of this material is granted provided [hat the copies are nnt 
made or distributed for direct commermd advantage. the ACM copyright notice and the title of the publication 
and its date appear, and notice is given that copying is by permission of the Aww.ciation fnr Computing 
Machinery. Trr copy otherwise. or m republish. requires a fee imd/nr specItic permission, or parastichies, 
formed by sequences of adjacent organs composing the structure. I%enumbersof parastichiesrun­ning in 
opposite directions usually are two consecutive FI­bonacci numbers. The divergence angle between ccmsecu­tively 
formedorgans(measuredfromthecenterof thestruc­ture) is close to the Fibonacci angle of 360°T-2 s 137.5°, 
where ~ = (1 + @/2 [3]. Computersimulation has shown that the quality of the pattern depends in a crucial 
way on thisanglevalue [10, Chapter4]. l%eintriguingmathematical properties have led to many models of 
phyllotaxis, which can be broadly categorized as descriptive and explanatory [9]. Descriptivemodelsattempttocapturethegeometryof 
phyl­lotactic patterns. WO models in this group, proposed by Vogel [12] and van Iterson [5, 8], characterize 
spiral ar­rangementsof equally-sized organs on the surfxe of a disk or a cylinder, and have been applied 
to synthesize images of plantstructureswith predominantlyflator elongated geom­etry[7, 10]. Unfortunately,theassumptionsthatsimplified 
the mathematicalanalysis of these models limited Iherange of their applications. In nature, the individual 
organs of­ten vary in size, and the surfaces on which they are placed diverge significantly from ideal 
disks and cylinders. Spher­ical]y shaped c~tus bodies provide a striking example, but even elongated 
structures,such as spruce cones, are not ad­equately described by the cylindrical model, which fails 
to characterizepatternchanges observed near the base and the top of a cone. A largervariety of organ 
sizes and surface shapes can be ac­commodated using explanato~ models, which focus on the dynamicprcxessescontrollingthe 
formationof phyllotactic patterns in nature. It is usually postulated that the spirals result from local 
interactions between developing organs, mechanically pushing each other or communicating through the 
exchange of chemical substances. Unfortunately,no uni­versal y accepted explanatory model has yet emerged 
from the largenumberof competing theories [9]. In this paper we propose a collision-based model of phyl­lotaxis, 
combining descriptive and explanatory components,  (i! Iy)? ACM-O-89791-479-l/92/007/0361 SOI.50  
 Figure 3: Wriables used in the description of the collision­based model  2.4 Formalization Inorderto 
catcuhte positions of consecutive primordia,we assume that the model is placed in a cylindrical coordinate 
system q, p, h (F@ure 3). I%ereceptxle is described by the parametricequation p = p(t), h = h(t), and 
can be conceptualized as the result of the rotation of a generating curveC(p = O,p(t), h(t)) aroundtheaxis 
h. Inourimple­mentation, C is specified as one or more Bt%iexcurves [6]. Parametert changes from t~i., 
corresponding to the base of the receptacle, to tin.=, corresponding to the tip. Thus, a point P on the 
receptacle can be representedby a pair of numbers: p E [0, 360) ~d t E [tmin, ~moz ] Assuming that . 
 the radii of consecutive primordia foxm a given sequence {ro, rl, rz,. . .}, the pattern generatedby 
the collision-based model satisfies the following recursive formulax 93=01 to = t~i~, { %+1 = ~n+ 137.5° 
= (n+ 1) .137.5°, tn+l = min{t 6 [~min, kc ]:(Vi=O,l,..., n) II l (~i,ti) -p(p +lj~) II2 ri + rn+l}. 
{ The expression IIp(~i, P(pn+l, t) 11denotes the Eu­ ~i) clidean disttM(x between the points (Pi, 
~(ti), h(ti)) ad (Pn+l, P(i)) h(t)). The fOmIU~for tn+l h~ a simple in@r­ pretation it specifies t +1 
asthe smaIlestvatueof param­ eter t, for which the center of the newly added primordium P(pn+l, t) will 
be _ by ti l~t ri + rn+l tim the center of any previously pked primordium P(Pi, t). The angle ~n+l at 
which the new primordiumwill be placed is fixed at (n + 1) 0137.5°. Inpractice, the value tn+l is computed 
using a binary search Computer Graphics, 26,2, July 1992 of the interval [trnin,tma= . ] Ihe recursion 
ends when no value t E [t~in, tmc=] MtiSfieSthe inequality  (Vi=o,l,..., n) II P(~i,ti) P(~n+l ,t) 
IIz ~i+rn+l. A modification of the fom mlafor tn+l is usefid when con­secutive primordia&#38;crease in 
size (ro>rl>n.. .).h this case, small primordium that should be positioned near thetopof therecepacle 
mayuidentally fitinagapbetween muchlargerprimordianearthebase. Thisundesirableeffect, distortingthe phyllotalicpattern, 
can be avoided by limiting the maximum &#38;crease of pmmetex t between consecutive primordia to a heuristically 
selectedvalue 6. The changein the fonmda for t.+l consists of repltuing the constant value tmin by thin= 
m{tmin, tn 6}.We have f~d 6 CXW­respondingtotheradiusofthenewprhordium satisfwtory inmost cases.  2.5 
Model Validation The collision-based model deseribes the formation of a ca­ pitulum in a simplified way. 
The crudest assumption is that primordiaemerge on an aheady developed receptacle, while innaturethedifferentiationisconcurrentwiththere 
ceptacle s growth. Despite this simplifying assumption, the placement of primordia resulting from the 
collision-based model correspondsclosely to the microscopic obsemtions. 3 APPLICATION TO COMPUTER GRAPHICS 
 3.1 Principles Once the phyllotactic pattern has been formed in the early stages of bud development, 
the bud grows and develops into a matureflower head. l%e actual organs florets or seeds mayhavetotallydifferentshapesfromtheprimord@yet 
the original spiral arrangementwill be retained. Thecollision-based model is applitxlto image synth~is 
fol­ lowings similarscheme fwstthephyllotacticpatternisgem­ erated by placing spheres on a receptacle, 
themthe spheres are replacxxlby realistic models of specific organs. In our implementation,the organsareconstructedfromB6ziersur­ 
fxes. For placement purposes, each organ is repmsent.edby a con­tact point and a pair of orthogonal vectors 
Z and ti. tie organis translatedto makeits contactpoint matchthecenter of the sphere that it will replace, 
then rotated to align the vectors Oand d with the normal vector to the receptacle and the vector tangent 
to the generating curve. The radius of thesphererepresentingtheprimordiummaybeusedto determinethefinalsizeof 
thematureorgan.       SIGGRAPH 92 Chicago, July 26-31, 1992 In spite of its simplicity, the collision-based 
model captures [9] a wide range of plant structure with phyllotactic patterns (F@re 15). It also illustrates 
one of the most stimulating aspects of the modeling of naturalphenomena the close [10] coupling of visualimtion 
with ongoing researchin a fimda­mental science. Acknowledgements [11] l his research was sponsored by 
an operadng grant from the Natural Sciences and Engineering Research Council of Cana@ and by a graduate 
scholarship ffom the Univer­sity of Regina The Canadii-Dutch cooperation was made [12] possible by a 
SIR grant from the Dutch Research Organiza­tion (NWO). me images were ray-tracedusing the program [13]ray 
shade written by Craig Kolb, in computer graphics laboratoriesattheUniversityof CalgaryandPrincetonUni­versity. 
We are indebted to Craig for his excellent and well supportedprogram,to Pat Hanmhanfor providing Deborah 
withaccess tohis researchfacilities atPrinceton,andtoJim Hananforrecordingtheimages attheUniversityof 
Regina. Also, we would like to thank Jules BloomenthaI and Lynn Mercerfor many helpful comments.   
 References [1] I. Adler. A model of contact pressure in phyllotaxis. Journal of Theoretical Biology, 
45: 1 79, 1974. [2] J. Battjes, K. Bachmann, and F. Bouman. Early de­velopment of capitula in Microsen 
spygmaea D. Don strainsC% andA92 (AstemceaeLactuceae).Botanis­che Jahrbiicher Systematic, 113(4):461-475, 
1992. [3] H. S. M. Coxeter. Iwvduction to Geometry. J. Wiley &#38; Sons, New York, 1961. [4] S. Douady 
and Y.Couder.Phyllotaxis as a physical self­organized growth process. Manuscript, Laboratoire de Physique 
Statistique,Paris, 1991. [51 R. O. Erickson. The geometry of phyllotaxis. In J. E. Dale and F. L. Milthrope, 
editors, The Growth and Functiom ngof L.+?aves,pages 53-88. University Press, Cambridge, 1983. [6] J. 
D. Foley, A. Van Dam, S. K. Feiner, and J. F. Hughes. Computer Graphics: Principles and Prac­tice. Addison-Wesley, 
Reading, Massachusetts, 1990. [7] D. R, Fowler, J. Hanan, and P. Prusinkiewicz. Mod­elling spiral phylloraxis. 
computers &#38; graphics, 13(3):291-296, 1989. [8] G. Van Iterson. Mathematische und mikroskopish­anatomische 
Studien iiber Blaustellungen. Gustav Fis- cher,Jena 1907. R. V. Jean. Mathematical modelling in phyllotaxis: 
The state of the ~. Mathematical Biosciences, 64:1­27,1983. P.PrusinkiewiczandA. Lindenmayer.The Algorithmic 
Beauty of Plants. Springer-Verlag, New York, 1990. W%hJ. Hanan, F. D. Fracchm D. R. Fowh?r,M, J. M. de 
Boer, and L. Mercer. F.VandexLinden.Creatingphyllotaxiw Thedislodge­ment model. MathemadcalBfosciences, 
lCM):161-199, 1990. H.Vogel. Abetterway toconstructthesunflowerhead.  Mathematical Biosciences, 44:179-189,1979. 
C. H. Waddington. Canalization of development and the inheritance of acquired characteristics. Naturv, 
150:563 565, 1942. 
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134094</article_id>
		<sort_key>369</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>44</seq_no>
		<title><![CDATA[Generative modeling]]></title>
		<subtitle><![CDATA[a symbolic system for geometric modeling]]></subtitle>
		<page_from>369</page_from>
		<page_to>378</page_to>
		<doi_number>10.1145/133994.134094</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134094</url>
		<keywords>
			<kw><![CDATA[geometric modeling]]></kw>
			<kw><![CDATA[parametric shape]]></kw>
			<kw><![CDATA[sweep]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Curve, surface, solid, and object representations</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Geometric algorithms, languages, and systems</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.7</cat_node>
				<descriptor></descriptor>
				<type></type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010147.10010371.10010352</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Animation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010178.10010224.10010226.10010239</concept_id>
				<concept_desc>CCS->Computing methodologies->Artificial intelligence->Computer vision->Image and video acquisition->3D imaging</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003752.10010061</concept_id>
				<concept_desc>CCS->Theory of computation->Randomness, geometry and discrete structures</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010401</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Volumetric models</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010399</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Parametric curve and surface models</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
			<gt>Design</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>PP39079343</person_id>
				<author_profile_id><![CDATA[81100167784]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[John]]></first_name>
				<middle_name><![CDATA[M.]]></middle_name>
				<last_name><![CDATA[Snyder]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[California Institute of Technology, Pasadena, CA]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>P132648</person_id>
				<author_profile_id><![CDATA[81100653012]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[James]]></first_name>
				<middle_name><![CDATA[T.]]></middle_name>
				<last_name><![CDATA[Kajiya]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[California Institute of Technology, Pasadena, CA]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_obj_id>102723</ref_obj_id>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[Adobe Systems Incorporated, PostScript Lansuafe Reference Manual, Addison-Wesley, Reading, Massachusetts, 1985.]]></ref_text>
				<ref_id>ADOB85</ref_id>
			</ref>
			<ref>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[Bart', Alan H,. "Superquadrics and Angle Preserving Transformations." Computer Graphics, 15(3), August 1981, pp I 1-23.]]></ref_text>
				<ref_id>BARR81</ref_id>
			</ref>
			<ref>
				<ref_obj_id>15918</ref_obj_id>
				<ref_obj_pid>15886</ref_obj_pid>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[Barr, Alan H., "Ray Tracing Defmmed Surfaces," Computer Graphics, 20(4). August 1986, pp. 287-296.]]></ref_text>
				<ref_id>BARR86</ref_id>
			</ref>
			<ref>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[Binfotd, T., in Visual Perception by Computer, Proceedings of the IEEE Conference on Systems and Control, Miarrfi, FI,, December 197 i.]]></ref_text>
				<ref_id>BINF71</ref_id>
			</ref>
			<ref>
				<ref_obj_id>910661</ref_obj_id>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[Carlson, W.E., Techniques for Generation of Three Dimensiomal Dam for use in Complex Image Synthesis, Ph.D. Thesis, Ohio State University, Sept. 1982.]]></ref_text>
				<ref_id>CARL82b</ref_id>
			</ref>
			<ref>
				<ref_obj_id>1300363</ref_obj_id>
				<ref_obj_pid>1299963</ref_obj_pid>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[Cohen, E., "Some Mathematical Tools for a Modeler's Workbench," IEEE Computer Graphics and Applications, 5(2), pp. 63-66.]]></ref_text>
				<ref_id>COHE83</ref_id>
			</ref>
			<ref>
				<ref_obj_id>808602</ref_obj_id>
				<ref_obj_pid>964965</ref_obj_pid>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[Cook, Robert L., "'Shade Trees," Computer Graphics, 18(3), July 1984, pp. 223-232.]]></ref_text>
				<ref_id>COOK84</ref_id>
			</ref>
			<ref>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[Coquillm. S. "'A Control Point Based Sweeping Technique," IEEE Com, purer Graphics and Applications, 7( 1 I), 1987, pp. 36-45.]]></ref_text>
				<ref_id>COQU87</ref_id>
			</ref>
			<ref>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[Franklin, W.F. and Alan H. Ban', "Faster Calculation of Superquadric$," IEEE Computer Graphics and Applications, 1(3). 1981, pp. 41-47.]]></ref_text>
				<ref_id>FRAN81</ref_id>
			</ref>
			<ref>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[Goldman, R.N., "Quadrics of Revolution," IEEE Computer Graphics and Applications, 3(2), 1983, pp. 68-76.]]></ref_text>
				<ref_id>GOLD83</ref_id>
			</ref>
			<ref>
				<ref_obj_id>74361</ref_obj_id>
				<ref_obj_pid>74334</ref_obj_pid>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[Kajiya, James T., and Timely L. Kay, "Readering Fur with Three Dimensional Textures," Computer Graphics, 23(3). July 1989, pp. 271-280,]]></ref_text>
				<ref_id>KAJI89</ref_id>
			</ref>
			<ref>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[Laidlaw. David, J. Snyck,, A. Woodbary, and A. Bat-r, "Model Extraction using Omi~catim." manuscript in Wogress.]]></ref_text>
				<ref_id>LAID92</ref_id>
			</ref>
			<ref>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[l.assing, D.L. and A.L. Eshleman, "Planning a Ccmmme Data Base fog En~ and Mam~actuting," SHARE XUII, Chicago. IL, Aug. 1974,]]></ref_text>
				<ref_id>LOSS74</ref_id>
			</ref>
			<ref>
				<ref_obj_id>325247</ref_obj_id>
				<ref_obj_pid>325165</ref_obj_pid>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[Pedin. Kea, "An haage Syria," Computer Graph/cs, 19(3), July 1985, pp. 287-296.]]></ref_text>
				<ref_id>PERL85</ref_id>
			</ref>
			<ref>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[Pguu, William H., Brian P. Flammv, Saul A. Teukohky, and William T. Vettedin~ N~tical Recipe&amp; Cambridge University Press, ~lte, ~. t986.]]></ref_text>
				<ref_id>PRES86</ref_id>
			</ref>
			<ref>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[Snytha', John, C,e~rat/vw Modeling: An Approach to Higk Level Shape Desifnfor C~r Graph,s and CAD, Ph.D. Thesis. California Imtiutte Of T~, 1991.]]></ref_text>
				<ref_id>SNYD91</ref_id>
			</ref>
			<ref>
				<ref_seq_no>17</ref_seq_no>
				<ref_text><![CDATA[S.,ydet.loha.'IatervalAaalysisforCompmerGrWhk,."tobepublished in Siwaph 92.]]></ref_text>
				<ref_id>SNYD92a</ref_id>
			</ref>
			<ref>
				<ref_obj_id>130368</ref_obj_id>
				<ref_seq_no>18</ref_seq_no>
				<ref_text><![CDATA[Snydef, John, Gcncrat/w Modtlin8 for Computer Graphics and CAD: Symbolic Shape De#ign Using Interval Analysis, to be ~ by Academic Press, July 1992.]]></ref_text>
				<ref_id>SNYD92b</ref_id>
			</ref>
			<ref>
				<ref_seq_no>19</ref_seq_no>
				<ref_text><![CDATA[TluaapaeL Joe F., Z.U.A. Warsi. and C, Wayne Mauin, Numev/ca/Gr/d Genera/m, North-Holland, New Yedr., 1985.]]></ref_text>
				<ref_id>THOM85</ref_id>
			</ref>
			<ref>
				<ref_obj_id>37415</ref_obj_id>
				<ref_obj_pid>37402</ref_obj_pid>
				<ref_seq_no>20</ref_seq_no>
				<ref_text><![CDATA[Von ~, Brian p. md Alas H. Barr,"Accun~ Samplinlg of Dcfmmod, Inlasec~g Surfaces with Quadtfees," Computer Graphics. 21(4). July 1987,pp. 103-110,]]></ref_text>
				<ref_id>VONH87</ref_id>
			</ref>
			<ref>
				<ref_seq_no>21</ref_seq_no>
				<ref_text><![CDATA[Wang, W.P. and K.K. Wang "Geometric Modelling for Swep~ Volume of Moving Solids," IEEE Computer Graphics and Applications, 6(12), 1986, pp. 8-17.]]></ref_text>
				<ref_id>WANG86</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 Generative Modeling: A Symbolic System for Geometric Modeling John M. Snyder James T. Kajiya California 
Institute of Technology Pasadena, CA 91125 Abstract This paperdiscusaes a new, symbolic approach to 
geometric modeling called generative modeling. Tbc approach allows specification, rendering, and maiysis 
of a wide variety of ahapes including 3D curves, strrfaees, and solids, as well as higfrer-dimenaionsd 
shapes such as surfaces deforming in time, and volumes with a spatially varying mass &#38;nsity. The 
system also supports powerful operations on shapes such as repammeterize this curve by arclengtb , compute 
the volume, center of mass, and moments of inertia of the solid bounded by these surfaces , or solve 
this constraint or ODE system . The system haa been used for a wide variety of applications, in­cluding 
creating surfaces for computer graphics animations, modeling the fur and body shape of a teddy bear, 
constructing 3D solid models of elastic bodies, and extracting surfaces from magnetic resonance (MR) 
data. Shapes in the system are specified using a language which builds mtrkidi­merrsiorralparametric 
functions. Tbc Imgustgc is baaed on a set of symbolic operators on continuous, pieccwise differentiable 
parametric functions. We present several shape examples to show bow conveniently shapes can be specified 
in the system. We also discuss tbe kinds of operators useful in a geometric modeling system, including 
arithmetic operators, vector and matrix operators, imegration, differentiation, constraint solution, 
and con­strained minimisation. Associated with each operator are several methmta, which compute proprties 
about the parametric functions represented with the operxom. We show how marrypowerful rendering and 
snafyricsf opera­tions can be supported with only three methods: evahsation of the parametric function 
at a point, symbolic dlffererrtiation of the parametric function, md evacuation of artinclusion function 
for the parametric function. Like CSG, and unfike most other geometric modeling approaches, 3Ms modeling 
approach is closed, meaning that further modeling operations cart be applied to any results of modeling 
operations, yielding valid models. Be­cause of this closure propeny, the symbofic operatoracartbs composed 
very flexibly, stlowing the construction of higher-level operators witbout charrg­ing the underlying 
implementation of the system. Because the modeling operations are described symbolically, specified models 
can capture the de­sigtw s intent without approximation error. CR categnriex 1.3.5 [Computer Graphics]: 
Computational Georne~ and Object Modeling -curve, surface, solid, and object representatio~, g­metric 
algorithms, languages, and systems Additional Key Words: geometric modeling, parametric shape, SW*P 1 
Introduction One way of representing a limited class of shapes uses sweeps. A sweep rep resents a shape 
by moving artobjed (called a generator) afonga trajectory Permission to copy without fee all or part 
of this material is granted provided that the copies are not made or distributed for direct commercial 
advamage, the ACM copyright notice and the title of the publlcatiorr and m date appear, and notice is 
gwen that copyingis by pmnission of the Association for Computing Machinery. To copy otherwise. or to 
repuhllsh. requmes a fee and/or specific permission. through space. The simplest sweeps are extrusions 
and srsrfaccsof revo­lution, which sweep 2D curves. SWezpawhose generator can change sixe, orientation, 
or shape are calfed general aweepa. General sweeps that use 2D curve generators are esrfkd gerrerafii 
cylinders [BINF71 ]. Several maearchersbave sturfkd sweeps [GOLD83,CARL82b,WANG86, COQU87]. Barr s sphericolpro&#38;rct 
[BARR81], is an exampleofa aweep thatusesaconstant2Dcurvegeneratorandacaliig.Carfaon withtranalatiorr 
 [CARU32b] introduced the idea of varying the sweep generator. Wang and Wang [WANG86] explored sweeps 
of surfaced for use in manipulating nu­merical] y controlled milting machine cutter paths. Sweepa have 
been used in solid modeling systems for many years (e.g., GMStrtid, ROMULUS). Loss­ing and Esbtemarr 
[LOSS74] developed a system using sweeps of cmnstant 2D curves. Alpha. 1, a modeling system developed 
at the University of U* has a much more sophisticated sweeping facility [COHE83]. One of the advantages 
of sweeps is tfreii naturatnesa, cmmpcmeaa, and controllability in representing a huge class of man-made 
objects. For exattt­ple, artairplane wing is naturafly viewed as so airfoil cross section which is translated 
from the root to the tip of the wing. At the same time its thickness is modified, it is twisted, swept 
bwk and translated Wrticdy according to other schedules. Two crucial questiona remain concerning bow 
sweq tit into a general shape tilgn and manipulation program: . how cart sweeps be specified by the human 
designer in a general and powerful way? . what tads am appropriate to aflow swept shapes to b rendered 
and simulated?  w generative modeling approach presented here extends the kinds of sweeps that can be 
conveniently specified, and providea high-level tools for their rendering and simulation. llte approach 
specifies sweeps pmcedmfly, in a fashion similar to other procedural specification methods in cumptrter 
graphics: shade trees [cOOK84], Perlin s texturing language -5], and the POSTSCRIPT language [ADOB85]. 
A prototype system cafkd GENMOD has beersdeveloped implementing these ideaa, which includes a C irrterpmter,a 
curve sdkor, methods for sev­eral dosen primitive symbolic operatom, and a mukidimerrsional visuafka­tion 
library. WbiIe each piece of the system is fairly simple, we have found that combining atl the pieces 
into a single system produces an extremely powerful geometric modefing tool. 2 Generative Modeling Overview 
 A genercafivemodel is a shape generated by the continuoustransformation of asba~ cafledthegenerator.As 
anexample,consideracurvegenerator ~(u) Rt ~ 6(P,v)R3xR~ R3, anda parsmeterizedtranaformation,R3, thatsumonpointspE 
R3 given a parameter v. A gertcrstive surface, S(si, v), may be formed consisting of all tbe points generated 
by the transformation 6 acting on the curve T, i.e., S(u,v) = (f( y(u), v) A cyfinder is an example 
of a generative model. The generator, a citck in the .ry plane, is translated along the z axis. l%e set 
of points generated 88 the circle is translated yield a cylinder. Mathematically, the generata and ACM 
-0-89791-479-1/92/007/0369 $01.50 SIGGRAPH 92 Chicago, July 26-31, 1992 transformation for a cylinder 
are ( )= (~ ? @v)=(P:O yielding the surface cos(27ru) ~(Is, V) = 6(7(u), V) = sin(2ff u) () v 2.1 Parametric 
Functions and the Closure Property If a generator is expressed as a parametric function, then a generative 
model built by fransforrning this generator is afao a parametric function. General­izing from the cylirtdsr 
example, 1* a generator &#38; represented by the para­metric function F(x): 1# ~ R A continuoussetof 
transformations can be represented as a pararneterked transformation T~, q) R XRk* R where p~ R isa point 
to be transformed, and qE Rk is anaddkional parameter that defines a continuous set of transformations. 
The generative model is the parametric tltnction 1 T(F(x] q): R *+ R Thetillity to usea generative mcdel 
as a generator in another genera­tive model will be cafkd the closure propsrfy of the generative modeling 
representation. The use of parametric generators and transformations yields closure because transformation 
of a generator can be exprssaed as a simple composition of parametric functions, resulting in another 
parametric func­tion. In fact, the use of pararrwtricgenerators and transformations blurs the distinction 
between generstorand tranaformatirm. Both are parametric frmc­tion~ the domain of a generator must he 
c0mple4ely specified, while the domain of a transformation is partly specified and psrtfy &#38;termined 
as the image of a generator. 22 Terminology M FR + R be a pmumtric function with scalar variables X1,X2, 
. . ..%. Cdkd h PISmtnetriC variobfss or paranrstric coomlnafes. The number of pssametric coordinates 
on which F depends, n, is called the inptu dimension of the parametric function. The number of components 
in the result of F, m, is cafkd the outpuf dirnenswn of the parantdc function. In this work the domain 
of F is a rectilinear region of R ,cafkdahypsr­recrongle, of the form: [al, bl] X [caz,bz] X . . . X 
[a ,b ] Hyper-rsctangks are convenient for sampling and integration of the para­metric functions in 
a computer implementation. The image of F over a spec­ified byper-rectangle defines the shape of interest. 
 2.3 Operatom and Methoda Onewayofs~ifying pmumlrw functionsisbyselectingasetofopem­10rs.Anoperstorisafunctionfunctions 
thattakesparametricasinputand produces a parametric firrtction as output. For example, addition is an 
op erator that wts on two parametric functions ~ and g, and produces a new parametric furrction,~ + g. 
llre addition operator is recursive, in that we can continue to use it on its own results or on the results 
of other operators, in order to build more complicated pammdric functions (e.g., (f+ g) + h). Lke the 
addition operahx, all operators in the system are recursive; their resul!s can he used as inputs to other 
operators. 2 Together with the closure lMw~y, *~w*ltiti*Of*u htie0fnmk9)--­ u c d+k. 2ttkmkdtiti ddMwwti4wapkd 
**b~w. ch- ~Y~ ttteautpurdimmuOOmcipamamyaaeptdya oftkir~(e.g., aut8rfundi0n umusumerll Mdfdtibiltttc 
Use0ffurA0080ftligber 0ulput dlmmtka). h! Ipccid citcumuawes, it q be dniik to wtumin OdterptoQe&#38;s 
OfqcntcaqUmenU. Fuunnpk, PXY of -c gcnemtora, this recursive natr2reof operators yields a modeling system 
with closure. That is, the designer is not prevented from using any reasonable combiiiorr of operations 
to specify shapes. For ex­ample, the addition operafor can be applied to pararnhc functions of my input 
dimemion ( e.g., curvss or surfaces). It can also k applied to parsnwt­ric functions of any output dknension, 
to perform vector addition, as long as the output dimension of its two arguments is identical. of courss, 
it is not enough to rspreaent pammetmo functiotq we must alm he able to compute properties about the 
parametric functions for rendering and analysis. Such computations can be implemented by defining a set 
of methods for each operator. One method evaluates the pametric function at a @rtt in its pammeter space. 
other methods include symbolic differentia­tion of the parametric function and evsfustion of an inclusion 
function (see [SNYD92a] for a discussion of inclusion functions). Section 3,2 discusses methods in more 
detaiL 3 Symbolic Operators 3.1 specific operatora Inthis section, we examine specific operators that 
fcfrtt a bask for a flexible variety of shapes. TIds set of operators wifl be used in Section 4 to show 
the capability of the generstivemodeling approach forcomblning swh operators to build interesting shapes. 
Elementary Operators Elemsrrtary opcrafcm irrchdeconatarrts, paramet­ric coordhates, arithmetic opsratom, 
square root, trigonometric functions, exponentistiow and logarithm. 3 The constant operator representa 
a paramet­ric function with a real, constant value, such SS$(X) = 2.5. The pammeuic coordkate operator 
reprcssnta a particular parametric comxhate, such as ~(x) = XZ, where X* is the second comfxxtent of 
the pmnwtric domain, in a global rmordhate system. ArithrtAc operators are addkion, subtractimk, multiplication, 
divisio~ and negation of pmmetric functions. They are use­ful for such geometric operations as scaling 
and interpolstio~ and in many other snore complicated operations. They cso also be cornbii to represent 
bicubic patches, NIJRBS, and other parametric polynomials. other elementary operators srv uaefid in sprciaf 
c UcrmWances. The square root operator, for example, is useful to compute the dutamx between points. 
The sine and cosine operators are useful in buildlng pmmetric cir­cles and arcs. Vector and Matrix Operators 
Vectoroperatorsareprojection,cartesian sian product aflow extraction and rearrangement of coordi&#38;tes 
of paramet­ric functions. Vector length, dot product, and cross product find many appli­cations in defining 
geometric cmrm-aints on pammeterizuf shqxm Veztor operator analogs of the aritfunedc operators are also 
usefuf for ge­ometric modeliig. These operators inchsde ddkion and subfraction of vec­tors, and multiplication 
and dhidon of vectors by scafara. Matrix operators include mtdtiplicatiott and addkion of rnatri=, matrix 
determinant, and in­verse. Matrix multiplication is especially trseftd to define aftine trsnsfortna­timts, 
which are used extensively in simple swosps (see Section 4.2). While these operators can be defined in 
terms of simple projecti~ cartesiarrprod­uct, and arithmetic operators, they are included as primitive 
opators for the sake of efficiency. Differentiation and Integration Operators The differentiationoperator 
returnsthepartialderivativeof aparametricfimUionwithrespecttooneof its parametriccoordkrates. This is 
useful, for example, in findhtg tangent or normal vectors on curves and surfaces. Ths integration operator 
integrates a parametric function with respct tn one of its parametric cmrdinafea, given two parametric 
functions represent­ ing the upper and lower limits of integration. Forexarnpk, the function afu,v) S(v, 
T)d7 / b(.) rbciO-OpumOrsspectsscatuflmclim.rOrbiscaltezLchOm irs~IObcamnmrOmc ofdte8u ofqxratmim@ksdutm 
~noruMmritywoMbi[my %aoonabk qnatmm, givmrk-oftkoprmlm 3~-oo ~ IDMYI=C ~iqk ~ w tt=e, w iOFNVOMM. can 
be formed by the integration operator applied to three pammtric func­tions, where J@, 7) is the integrand, 
a(u, v) tlw upfrw limit of integration, and b(u) the lower limit of integration. In general, pammehic 
frmclions hav­ing any nurnberofinputparameterscanbeusedastheintegrand,orlimits of integration. Integration 
can be used to compute arckngth of curves, surface men of surfac4a, and volumes and moments of inertia 
of solids. IndexIng and Branching Oparaton A uscfuf operation in geometric modeling is concatenation, 
the piccewiac linking together of a colkc­tion of abapcs. For example, the concate~ion of the set of 
n curves m(u),­ nt(~),. . . . TR(IO. -h &#38;fi~ OVLWtbc pammebic variable u E [0, 1], maybe detinedas 
-n Ofu) u G [0, I/n] f -y2(nu 1) u C (1/rr,2/nl \ -yn(fru-(n -1)) u E ((n-1)/n,l] The concatcn~ion 
of surf= or functions with many Parartrelerscart be &#38;fined simikrty, wham tbc concatenation is done 
with rqrcct to one of the cmrdinatca. Tlria tdnd of concatenation is uniform cmncatctiiom bccausc each 
concatenated segment is defined in an interval of equal length ( 1/n) in parameter space. It is cmnmonly 
uacd in defining picccwise curves CUWIC suchasB-splines. Uniform concatenation is implemented using 
an irrdexingopcrotor, which takea as input an array of parametric functions and an indsx function that 
controls which hmction is to be evaluated. Given tbc same T i(u) curves used in the previous example, 
and an index function q(x), the index opxator is defined as indcx(q(x), -fl (u), .... h@)) = ?LAx)J (u) 
 where q(x) . nu results in tbc uniform concatenation of tbc T i functions. In addition to the indexing 
operator, it is afao useful to haves substirulion operofor to define uniform concatenation. The substitution 
operator sym­bolically subatitutcs a given parametric function for one of the parametric coordktates 
of another parametric function. For example, this can be used to represcru~i(nu (i-1)) given ~i(~). 
by substituting the function nu -(i-1) for the parametric coordkmte u. The index operator is a speciaJ 
caac of a branching opcroror, an operator that takes as inputa sequence of condhionrd functions and evacuation 
func­tions. The rcsuh of the branching operator is tbc result of the first evaluation function whose 
corresponding conditkmal is true. This mukiway branch op­erator can be uacd to define a nommijorm concatenation 
of parametric func­tions where each concatenated aegmcnt need not bc &#38;fincd on an equally sired intend. 
Branching operators are also usefid for tindkg the minimum and maximum of a pair of functions, for dcfming 
deformations that act only on certain parts of space, and for rfctecting error conditions (e.g., tafringthe 
aquarc root of a negative number, or nortrtdzing a mu length vector). Relational and Logfcal Operatora 
In order to support the dctinition of useful conditional expressions for the branching operators (and 
the con­straint solution operator to be presented), wc include fhc standard matbc­matical relational 
nprators such as equatit y, irrequafity, greater than, etc., and the logical operators (such as and, 
% , and not ). Curve and Table Operators Curve and table operators aflow sbapcs to bc specified from 
data produced outside ttrc system. tltc curve operator spec­ ifies continuous curvca such as pieccwisc 
cubic splinca, produced using an intemlive curve editor. Tfrctable operator is used to specify an interpolation 
of a multidinensiomd data set (GENMOD implements both linear and btcu­bic inteqxdation). For example, 
a simulatioir program may produce data dctincd over a discrete collection of points on a solid. The table 
opsrator interplatcs this data to yield a continuous parametric function. Inversion Operator Inversion 
of monotonic functions can bc uacd, for example, to repararncterise a curve by arclength, as shown in 
Figure 1. Let -f(f) be a continuc4ts curve specifying the cbject s trajectory, starting at f = O and 
ending at r = 1. The ardength rdong-I, TWC(t)is given by r WC(f) = Itr (r)lld? / o . ...* ......... 
. . . .. .. . . . . . J . . . . .. ).. . . .... ... ... . . . . . . .. .. .. .. . : ......# ., . . 
... . . . .. .. . . .. .. . . . .,.. . . .. ,. .. . . .. .. . .. . 2 .. ... . .. .. ., . .. . . . 
.. Ftgurcis qammtmir.cd Each dot1: A pararnetriccttrve by arckrrgtk. rcpreacnts a point on the curve 
along uniform increments of the curve s input _er. flte integration and differentiation opcrafors mentioned 
previously acrve to dctinc -ym . Tllc rcparamda rationof-y by ardength, -I-, is then gh crr by4 %aw(d 
= -7 (72 (~ %14))) This mparameterization involves the inversion of the monotonic arckngth fimction, 
~arc. Many other useful operations can ako be formuktcd in terms of fbc inver­sion of monotonic ftmctkm, 
incltilng the mpametm zing Of curves and surfaces so that fbcii pmmetcm are matched by arckngth, pokr 
angle, or output coordinate to aomc otbcr curve m surface Invasion of monotonic functions in a single 
variable maybe computed using fast atgo@mrs, smch as Brent s mctbod [PRESS6]. Conatdnt Solutkn Operator 
The constraint solution operator takes a ~c function mprcsenting a system of conamints, andproducesao 
lution to the comtrained system or an indhtion that no sofution exists. s Two forma of solution are useful: 
finding any point that solves the systcnu or find­ing all points that solve it, assuming tbcre is a finite 
W of sohttions. 6 The operator afso requires a pmmetric function apccifying the hypcr-mctangie in which 
to solve the comtrainta. For example, the constraint solution operator can bc used to find an intcr­acction 
bctwccn two pknarcurves. 1A T t (s) andv2(/) be two curva in R2. These cuwcs could be represented using 
tbc curve operator of Section 3.1, or any of the otbcr operators. fhc appropriate constraint is F(s, 
f) s (-/ (.)= +(r)) which can he represented using the equality relational operator. llw con­straint 
solution operator appficd to F prtducxa a cunsbutt tirnction tqne­aenting a point, (s, I), wbcrc tbc 
two curvca intersect. Such an opcmtkm can be used to define bookan operations on planar m boundrdby ~ 
curves, which we will use in the screwdriver tip example of Section 4.4. k constraint systcm can ako 
be sofvcd over a subsel of its pammetm, to yield a non-constant pammtrk function. For exampfe, tbc mrmaint 
system -yt(r,s) =-y2(t)canbcaolvcdovers and1,resulting inafunctkn that depends on r. Tlte user tbcrcforc 
spccifiea not only a parammkfuncrkn rcprcacnting the constraint systerm but ako which pmmctric ~ the 
system should bs solvad over, and wh~b canrdnatca pVaNMAefbe ayatem. Conatram t solution has appkation 
to pmbkrna involving intemdom collision &#38;tection, and finding appropriate parameters for pmm@abd 
shapes. A robust algorithm for evaluating this operator trseninterval artaly­sia, and is described in 
[SNYD92a]. SIGGRAPH 92 Chicago, July 26-31, 1992 Constrained Mirdmlaation minimization Operetor Theconstrainedop­eratortakestwoparametricrepnting 
a system of constraints functionsand m objective function, and produces a point that globally rnisrimiz.csthe 
objective function, subject to the constraints. The operator also requires a parametric function specifying 
a hyper-rectsmgte in which to perform the minimization. The minimization operator has many applications 
to gamet­ric modeling, inchrdlng . finding intersections of rays with surfaces . finding the point on 
a shape closest to given point . finding the minimum dkt~ between shapes . finding whether a point 
is inside or orstsi&#38; a region defined with para­metric boundaries  A robust atgonthm for evaluating 
parametric functions definul with the min­ imization operator uses interval anatysia, and is described 
in [SN1 D92@. ODE Solution Operator The ODE operator solves a first order, initial vahse ordhmry deferential 
equation. It is useful for defining limited kinds of physical simulations within the modeling envirorrrncnt. 
For example, we can simulate rigid body mechanics, or find flow lines through vector fields. F@re 12 
illustrates the results of the ODE operator for a simple simulation specified entirely in GENMoD. Let 
~ be a specified parametric function of the form 1(1, Y1, .Yz,. . . ,.Y.): R + + R The ODE operator 
returns the solution ,y(r)to the system of n first order equations with the initial condition YOo) = 
Yo Parametrized ODEa, in which f andV. (and thus the result y) depend on an additional m parameters 
x 1, . . . .Xm,are also allowed. The user supplies the ODE operator with an indication of which parametric 
cocdnates of f are the t and~i variables,andWhicharetheaddidmratxi. parameters GENMOD implements the 
ODE operators using a Numerical Algorithms Group(NAG) ODE solver. Similar operators, for solution of 
boundary vatue problems and PDEs, are also useful in a geometric modeling environment, but have not been 
implemented in the present GENMOD system.  3.2 Operator Methods Ut P be an operator that takes n parametric 
functions as inputs and produces the parametric function p = P(fl, ... ,f ). A methodfor P is a fimction 
that can be evaluated by evaluating similar methcnla for the functions f,, ...,f . A method on parametric 
functions is called locally recursivefor P if its re­sult on p is completely determined by the set of 
its results on each of the n parametric functions f i ,... ,f.. Thus, a melhodto evaluate a parametric 
function at a point in parameter space is locally recursive for the addkion operator because f +g canbe 
evaluated by evaluating f, evahsating g, and addhtg the result. A method to symbolically integrate a 
parametric function is not local] y recursive for the division operator, because ff /g cannotbe computed 
given only ~j and ~ g. Generally, a locally recursive method cm be simply implemented and efficiently 
computed. We now examine specific methods useful in a geometric modeling system. Evahratlosr st a Point 
Computation of points on a ahape is neceaaary to approximatetheshape for visualhation and simulation. 
A method to CVdU­ ate a parametric function at a pint in parameter space is locally recursive for most 
of the operatofsdktsaed previously. Several operators are exceptions: the integration, inversion, and 
ODE solution operatora. 7 AU three of these o~rators require their input parametric functions to be cvafuated 
repeatedly over marrydomain points. For example, evaluation of the integration op­ erator can be computed 
numerically using Romberg integration PRE.S86, ldutiOn mi0imiAa10paUca8ae stso exceptions. As w will 
discw her, rk cvslustian mslhod fos the diflemntiatim qerstos ck­podsonlhedi ffcrenriaimm ettwd,w tsikrhsevahrion 
mestdforrhc mmursint mluiiandcm­ ssraincdminimiz.slim openlon w the inclusim Ihc!km mdmd. 71Rcduivaliwqxruor,mdIbscowmnMdcoOwskd 
372 pages 12>125], which adds evaluations of the irstegrandover merrypoints in its domain. Two forms 
of the evaluation method have proved useful: evaluation at a single, specified pint in parameter space 
and evacuation over a muttidl­mensional, reztitinear lattice of points in parameter spiwe. Evaluation 
of a ~c function over a rectilinear lattice gives information hut how the fimction hehavaovera whole 
domain, and is useful in quickand dirty rendering schemes. Afthorsgh evaluation over a rectihear lattice 
can be im­plemented by repeated evahration at specified points, much greater compu­tational sprA can 
be achieved with a special method, 55 we will see in the AppedIx. The evaluation methods return an error 
condition as well as a numerical result. The emor condition signifies whether the pmmetric function has 
heen evsduated at an invdld point in its domain (e.g., f /g whereg evsduates to O, or W where h < O). 
A failure error condition is atan returned when the constraint solution or constrained rnirsimiration 
operators are evaluated in a domain in which there are no solutions. D{fferersthtion The differentiation 
method is used to implement the dif­ferentiation operator introduced in Section 3.1. The differentiation 
method computes a parametric function that is the partial derivative of a given para­metric function 
with respect to one of the parametric eoodnates. fbe partial derivative is computed symbolically; that 
is, the partird derivative result is represented using the set of symbolic operators. Forexample, the 
partial derivative with respt to x I of the parametric function x I + ~ yields the parametric function 
1 + x2/(2@Zj), which is represented with the al­dition, multiplication, division, square rcmt, constant, 
md parametric coor­dinate operatora. Alttsoughthe differentiation method is not locally recursive for 
most oper­ators discussed previously, it is still relatively easy to compute. For example, the partisdderivative 
of the parametric function h = coa (f) depends not only on the partial derivative of f, butalso on f 
itself, since The differentiation method is therefore not locatly recursive for the cosine operator, 
but may be computed simply if a sine operator exista. Similar situ­ations arise for marryof the other 
operators. Fortunately, it is a simple matter to extend a set of operators such that the set is closed 
with respect to the dlf­fererrtiationmethod, meaning thatany partisd&#38;rivarive may he represented 
in terms of available operatcm. s Evaluatiorr of an Inclusion Function An inclusion function computes 
a hyper-rectangular bound for the range of a parametric function, given a hyper-rectangular domain. It 
is used in interval analysis algorithms to eval­uate pmmetric functions defined with the constrained 
minimization and emstraint solution operators. It is also useful to approximate shapes to user-defined 
tolerances, and compute CSG and offset operations. The uses and implementation of inclusion functions 
are fully discussed in [SNYD9~ SNYD92b]. Although an inclusion function cmnputes a global property of 
a paramet­ric function, it can often be computed using locally recursive methods. For example, an inclusion 
function method for the multiplication operator cartbe computed using interval arithmetic on the results 
of the inclusion functions for ifs parametric function multiplicands. Other Metbnde Another useful method 
determines whether a paramet­ric function is continuous or differentiable to a specified order over a 
given hyper-mctangle. Mmy times, algorithms for rendering and analysis require differentiability of input 
functions (e.g., multidimensional root frndkig rneth­oda). The differentiatdity operator can therefore 
be used to select whether an algorithm that assumes differentiability is appropriate, or if a mom mbuat 
and slower algorithm must be used instead. The differentiaMlity/mntimrity method is locally recursive 
for most of the operators discussed previously, but there are exceptions. For example, the differentiability 
method for the division operator cao not simply ctwzk that the two parametric functions behg divided 
are differentiable. It must also check whether the &#38;nominator is O in the given domain. Ilk can be 
accomplished using an inclusion function method. Other operator methods, whose implementation is still 
a research issue, include determining whether a function ~: RM+ Rrnis one-to-ormover a hyper-rectaogle. 
A similar method is degree, &#38;fined as d(f, D,p) = cerdinality {x E D If(x) = p} where D C R ,  3.3 
Operator Llbrariea While the primitive operstors described in Section 3.1 forma powerful bask for a 
shape representation, they do nor always match the operations the&#38;­signer wishes to perform. In these 
cases, the designer can employ operators formed by composition of the primitive operatora. The GENMOD 
syslem includes operator libraries which predefine hundreds of such higher level op eratots. The definitions 
of these operators are loaded from interpreted files when the program is first run, and can be dynamically 
modified and added to by the user, For example, a simple but useful non-primitive operator is the linear 
in­terpolation operator, m. int erp, whose GENMOD definition is 9 MAE.-inttsrp(MA1 h ,IIAE f ,f4AI g) 
{ return f + h*(g-f) ; }  The HAMty~ (for nrarri@f) is the basic data structure in GENMOD, rep resenting 
a parametric function. he +, -, and . operators have been over­loaded to perform addition, subfraction, 
and multiplication of manifolds. The m-int erp operator takes three parametric functions es input: f 
and g are functions to be interpolated, end h is the interpolation variable. The parametric functions 
j and g can he of any input or output dimension, as long as they have equal output dimension. This allows 
linear interpolation between two curves, surfaces, or even higher dimensional shapes. 10 The closure 
property of the generative modeling approach means that such non-primitive operators can be very powerful. 
For example, the .-arc-2pt -height non-primitive operator used in the next section forms a circular arc 
connecting two 2D points and having a spezified height above their line of connection. The 2D points 
supplied as arguments to this opera­tor need not &#38; constants but can depend on parameters, allowing 
convenient definition of the spoon of Section 4.3. 4 Examples fIrissection presents examples of generative 
shapes and their specification in GENMOD. Itis meant to show how the generative modeling approach leads 
a designer to think about shape, and the size nf the domain of shapes that can be represented. Mrmy other 
examples can be found in [SNYD92b].  4.1 Lamp Bases and ProfileProducts A profile product [BARR81] 
is perhaps the simplest nontrivial generative surface, It is formed by scaling and translating a 2D cross 
section according to a 2D profile. More precisely, a profile prdrct surface, S(u, v), is defined using 
a cross section curve, ~(u) = (T,, w), and a profile curve, 6(v) = (61, 62), where -rI(u)ft(v) S(U, v) 
= W(U)61(V) 62(v) () A profile product maybe defined in the GENMOD language es follows: 9rjw~s -we is 
w on ANSIC,withseveralexlauims. T&#38;exlemiamSttow OVer­ toadiq of b C qemlors. in mdtr to mum nmrumtlyexpressparametric 
huctims. Ssvsral 81dibanal opemmlxumrstmsdlkd. %b~~ti**tiGWMOO~h*hm*. lftiwo~ flUICdOnsr@mcnMbe k ,snx 
OUt~tdimension,I&#38;cfemtian u pmhlred UflUstdy foreuh componentm thecmmqondinn compmmts of h two qunwnts. 
If Ik oulpul dimensim of me ~.alist. A~&#38;~~ti l,tinhpti k@d. -b.~tof~ mullicrvnpomu USunrmu wilb ttx 
5arrM value of rbcscataru~ununt.Tbur,f + .Sdmmr.m vaaor ddition off m-dg wbenf and g trovertx sameculput 
dhwrmim, but/ . 2*A mmpment ofJ byafw[m of 2. mA1 cross = .-crv( cross. crv ,D-x(0)) ; IIA1 profilo = 
m_crv( prof ilo .crv ,m-x(l)) ; HAI lampbasa = .-prof ila(cross ,profilo) ; cross.crv prof ilc. crv 
Figure 2: f-amp base example A lamp base shape is represented by a profile surface. The GENMOD &#38;finition 
of a lamp base is shown, followed by graphs of the two curves (plotted between -1 and 1 in x and v) used 
in fbe definition, and a wire frsme image of the shape, MAEm-prof ila(MAl cross ,WM prof ila) { return 
@(cross [Ol*prOfile[Ol , cross Cl]eprofile CO], profile[l]) ; } The @() operator, a C extension in GENMOD 
S language, is the cartesian product operator, which, in this case, combines three acafar functions into 
a 3D point. The [] operator returns a single output coordinate of a parametric function. In keeping with 
C language convention (and unfike the matbemat­icsl notation used in the definition of S(U, v)), coordinate 
indexing ia done startingwith indexOforthefirstccxmdinafe,ratherthanindex 1. Figure 2 presents so example 
of a profile product surface for a lamp base shape. It uses the ~-prof il . operator defined above, and 
the primitive curve operator m-crv. fIrecurve operator takes the name of a file, produced using a curve 
editor program, and creates a parametric curve that is evaluated over the Parametric function specified 
as its second argument. In this case, the shape of the cross section curve is specified in the file cross. 
crv, and is evafoafed over a-x(O), mpreserrting parametric coordinate x 0. The profile curve is evafueted 
over parametric cmrdinate x 1 (m-x(1)). 4.2 Impeller Blades and Affine Transformation An affine transformation 
shape uses a 2D or 3D curve generator and a trana­formafion represented by a linear transformation and 
a translation. Let -I(u) be a 3D curve, M(v) be a linear transformation on 3D space, and T(v) bt antiher 
3D curve. An affine transformation surface, S(u, v), is given by S(u, v) = A4(vh(u) + T(v) One method 
of representing affine fransformations is to use 4 x 4 matrices (homogeneous transformations), allowing 
the composition of fine tfans­fnrmafions using simple matrix multiplies. F@re 3 presents an example of 
an sffine tratraformetion representing the impeller blade of a centrifugal compressor. The m-t rastsf 
orm3d non­primitive GENMOD oprator takes a vector and appliea an affine trarrafor­mation to it. Note 
that because the matrix transforms the cross section by SIGGRAPH 92 Chicaqo, Julv 26-31, 1992 u = m-x(o) 
; v = LX(1); cross = m-crv( bladacros. crv , rr); blado = .-trarrsfom3d(@( cross ,0), .-transz(m_intorp( 
v,-l ,1)) . .-transx(-O.6) . m-rotz(pi--crv( bladerot. crv ,v) [1] ) . .-transx(O. 6) . n-scalcx(m_crv( 
bladexscl. crv ,v) [11 ) . .-scalay(wcrv( bladeyscl. crv ,v) [1] ) bladecros. crv bladarot. crv bladaxscl. 
crv bladayscl. crv Figure 3: Irnpcllcr blade example An impeller black surface is rcprc­serrtedusing 
an aftirretrrrnsformziion. A squarecross section in the xy plane, wbicb forms tbe bottom of the blade, 
is scaled separately in x and y, trarra­latcd in x, rotated aroundz, trsrrslatcdbackin x, andtranslatedup 
the z axis. premultiplyingi~ transformations that affect the cross section tirst must ap pear last in 
the list of multiplied transformations. The m-transz, urotz, rn-scalex, and m-scaloy are non-primitive 
operators that produce 4 x 4 matrices rcprcaenting trmslztion along z, rotation Sround G ~ se-ding of 
the x and y axes, respectively. They are multiplii together to &#38;tine the complete affine transformation 
applied to a square cross seztion. 4.3 Spoons and Closed Offsets Curve offsetting can also be used to 
&#38;fine across section with a given thick­ ness that surrounds a given rron-closed curve (see F@rre 
4). An offset curve of radius r around a 2D curve ~(f) is given by 7(1) + m(t) where n(~) is the unit 
normal to the curve. The closed offset of a 2D curve ~(t) of rarWs r cart therefore be defined as the 
uniform concatemtion of 4 curve segments: the offset curveof~ ofradiusr, thereversedoffsetctrrvc nf 
T of radius -r, and two semicircles of dius r with centers at T(O) and ~(l). he non-primitive GENMOD 
operator . closadmf f sat creates the closed offset to a 2D curve (first argument), of a given radius 
(second argument). Pigure 5 shows a spoon whose cross section is formed using this tech­nique. In this 
case, the curve that is offset is a circular arc whose endpoints md radkrs arc varied. 4.4 Screwdriver 
Tips and CPG Corrstructivepfarrur geometry (cPG) is the analog of constructive solid ge-OmSIIYfor 2D 
areas. It is a modelingoperationthatuses Bcolean w oper­ationson closed planar areas to produce new planar 
areas. I@rre 6 shows some examples of CPO operations. Many objects ran he represented as surfaces where 
each cross sccrion is a Boolean set subtraction of one closed srca from another. The fact that Pigure 
4: Defining a cross scctiorr using offsets andcircular end caps A closed cross section maybe defined 
in terms of a non-closed curve by concatenating two offset curves and two circular end caps. HAI U=m.x(o) 
,V= .-x(l); HA1 shap-= kcrv( shape. crv ,v); ttA1 boul = m-crv( boul. crv ,v); HA1 band = m-crv( borrd. 
crv ,v); HA1pi = ~(-StiSpO[l] ,0) ; NM p2= ~(shapa[l] ,0); HA1 arc = m-arc-2pt-height (pl ,P2 ,boul [1] 
,u) ; tlA1 closed = .-closed-offset (arc,0 .01); RAI spoon = Q(shapo [0] ,clos@d[O] ,clossd[l]+band [1] 
) ; shape. crv bowl . CZV bond. crv F@rre 5: Spoon example-A spoon surface is formed using a cross scctiorr 
formed by the closed offset of an arc. The curve that is offset is deformed as it is extruded -its radius 
is increased to give the spoon its bowl, and its length is changed to shape the width of the spoon. the 
two planar arczs maybe swept accordiig to different scheduks before Wtng srrbtracled makes the operation 
more powerful. figure 7 shows two screwdriver blade tips specified using CPG. The Phillips blade, for 
exam­ple, is specified by sweeping a circle with a varying radius, from which is su&#38;racted a notch 
of varying sire. CPG operations requite computation of the intersections between piarrar curves bounding 
the 2D regions. Often, the intersections between boundary curves can be computed analytically, such as 
for regions whose bmmdary is represented as a piecctise series of line segments. When intersections can 
not be anzlyticatly computed, the constraint solution operator can bc used. The resulting segments can 
then be combined by concatenation as described in Section 3.1. 5 Rendering Most methods of rendering 
shapes require approximatkm of the shape into units such as cubes, polygom, or line segments, Such approximation 
in turn, require sampling -computation of points over the sbapc. Two sampling techniques are available 
in the GENMOD system: uniform sampliig, rrssd to qrdckty preview ttrcshape, sod adaptive ssmptirrg, used 
to obtain a more accurate approximation. AuB AnB  W!ilP A-.9 B-A @o  FIgttm 6 Constructive planar 
geometry -Two planar regions, A and B, art usedin four binary CPO operations. We can compute the boundary 
of the result of a CPG opation by computing the intersections of the boundaries of the regions, dividing 
the boundaries into segments at these intersections, md concatenating appropriate segments. . -0 F@re 
7: Scrcwdriverexampk - Thetipa of two screwdriver blades are con­stmcted using CPG. Tite regular screwdriver 
on the letl is generafed using a cross section formed by subtracting two baff-plane regions from a circle. 
Tiw tWOitdf-phltU3 are gl$tdttdy StlOVd tOWSS deach OtiUX ss ti3cCfOSSWC­ tion is translated to the tip 
of the screwdriver. The Piillipa acrewdriveron the tight has a cross section formed by subtrwdrrg four 
wedge shaped regions from a circle. Itsthis case, the wedge shaped regions are moved toward the circle 
s center as the cross section is translated to the tip of the screwdriver. while the circle is scaled 
down near the tip to yield a pointed blade. 5.1 Sampllng Uniform sampling of a parametric function involves 
evaluating the function over a rectilinear lattice of domain points. For each parametric inordinate 
xi. we pick a number of samples, Ni. The parametric function S is then evaiuateri over rite ~~=1 Ni samples 
given by ~i + il(bl -al) i.(b a.) ,.. .,am+ ( iv[-1 Af -1 ) where ai ~d bi dditE the h~-~gttk doti of 
the ~C func­tion. Escbof theindkcsij indqrerrdcntfyrangesfrom O to N} 1. Thi6 evaluation is done by 
calling the uniform evaluation method of S (from Sec­tion 3.2). Uniform evaiuatioa carsbe optisttizxxtso 
that it computes much faster than simple evaluation at each point in the rectilinear lattice of do­ ti 
points, as discussed in the Appendix. Adaptive sampling carsbe used to generate approxisstationsthat 
satisfy criteria [VONH87], where the samplingdensity variesoverthe pramder SPIX. Robustappraximatiorttecfsniqueatbsfuse 
inchtsion functions ~ dis­cussed in [SNYD92b]. fhe simple evaluation at a specified point mefbod is used 
to compute the aamplea Such evaluation cart be ~imimd using caching, as discussedin the Appendix.  5.2 
Interactive Viaualizatlon A visualization mefhod takesa a shape and prmtuces renderable object, of @uces 
a tranaforfnafion that cars be applied to a renderable object. There are fourkittds of interactively 
rcorferableobjects in GENh40D poinfa, curves, planar areas, and surfaces. A point is rendered as a dot 
in 2D or 3D SPW. A curveis renderedas a sequenceof line segments. A planarregion is rendered as a single 
polygon formed by the interior of an appoxirrsatcd ~me. II A s~w is rcndemd ss a collection of triangles. 
A frattaf~ can ix applied to so y of the other ren&#38;rsble objects, transforming it via the 4x3 affine 
transfomsafion p4.Up+T whereMisa3x 3matrixand T is a 3D vector. Each of the visualization metbmis expcts 
a shape of a given output di­mension (e.g., a function S(u, v) must have output dimension three to be 
used as input to the surface visualization method). Each visuslixatioss method also expects an input 
dhswnsion at least as large as the intrinsic input dimension of the shape. For example, a function C(r): 
R ~ R ~ beusedinthecurve visualization method, as can D(t, s): R2+ R3,since Canal D have inpt di­mension 
at least 1. On the other hand,a constantfunctionis notappro@ate for the curve method, nor is a function 
of a single coordinate appropriate for the surface method. The following table shows the number of intrinsic 
input parameters and output parameters of GENMODS visrsafixation metbodx name intrinsic dim. output dim. 
point o 2or3 curve 1 2or3 1 J piansf area 1 2a3 surface 2 3 transformation o 12 Functions tbaf have an 
input dimension greater tbsn the visualization method s intrinsic dimension (e.g., a surface that deforms 
in time) are afiil valid input to the visualization method. fire extra input coorhatea, caiied variable 
inpur pammefers, can be visualized with two techniques:arrinsa­rionor supen nsposilion. The shaped are 
first sampled at various poinfx in the variabie input parameter space. Superimposition combines fbeae 
sbapc instances in a singie image, while animation ren&#38;rs the inatartca one at a time, according 
to the values of graphics input devices. Aa an example, consider a parameterised fsmiiy of 3D iines, 
L.(I,u, v) defined as ~1, u,v) = S(S4,v) + rv(tt, v) where S(u, v) represents tbe iine origin, and V(u, 
v), theline direction. The r _ter is ~ in~mic P@er of t~ iine; ~-sod v sfe v~~fe input parameters. This 
family of lines cars be visualized by superimpositionas in F@rre 8, resuiting in an image containing 
a 2D famiiy of line segments. Alternatively, the u and v parameters can be animated, resulting in an 
image of a single line segment which interactively changes as the user controls, say, two diais. The 
user couid also superimpose the u parameter and animate v, resulting in a lD famiiy of line segments 
that cbangesin response to a single dial. Vkualization methods therefore require artargument specifying 
which of the variable input coordinates are to be superimposed,and whlcb am to   Conclusions The generative 
modelingappmachrepresents ashapeastheimageofapara­metric function over a hyper-mctangle in R . Parametric 
fttnetions are btdlt using a seI of symbolic operatora. Associated with each operator is a set of methods, 
which perform afl the primitive shape computation needed by the ren&#38;ring andanalysistook. what is 
the advastfageof mscha representation? Fret, the reprexmtation is sufficient for shapes of different 
dimcmionaUty. It can represent both curves snd SUfi~, tip ~fi?l!d by tit22c of OfhCf Vtidd-, d ~ embedded 
in space of any number of dimensions. Ttte abiiity of GBNMOD able in many projects, such as the modefiig 
of combed teddy bear fur used in [KJM189](P@sre 11), the modefing of elastic volumes using networks of 
masses and springs, and the modeling of time-dependent tmrfrtcu used in the1988S1OORAPHFtlm andVideo 
ShowanimationY30ing Bananas (Figure lo). Second, the representation is high-level. Shapes can be defined 
using m phisticatcd operators such as integrstiw dlffercntiation, and constraint * lution. Unlike simple 
representations such as polyhedra and NURBS, the qreaertationCanlx matchedtoahigh-levelinterfacewithout 
conversions or approximationerror.Tbii, thercpseaentadon is extensible.Extemion is accomplishednew attendant 
by adding primitive operators, with a few methods. We have added operators many times in the development 
of GEN-MOD, most recently m operator which aflowsbicubicinterpolationthrough 3Ddata[LAID92] (seeFigure13). 
Onceanopsratorisdehed, itcatsbe combkted with any of fhs other opators afready in the system to make 
new shapes, tsecauseofthe closure property of the generative modeling approach. The interface advccated 
here is artinterprewd languag% easentiaffy a tex­tuat spexificafion of the operators used in the refsreseotation. 
Wklr a language interface, be human designer can rmssstructnon-primitive openttors such as the profile 
product or fincar interpolation operators. The tilgstes can w and build libraries of such operators, 
using combinations of the primitive and non-primitive operators. Augmented with such libraries, the rnakfing 
interface can be quite complex andpowerful, while the bxtic implementation of the system (i.e., the primitive 
operators and methods) remains simple. Acknowledgments Many thanks are due to Al Barr, for his support 
and encouragertwtt of the publication of this research. This work was funded, in part, by IBM, Hewlett-Packard, 
and the National Science Foundation. References IADOB85] Adobe Systems Incorpnmtsd, PosfScripsLanguage 
Reference Manual, Addii-Wadey, Rding, M-husetts, 1985. [BARR81 ] Barr. Afsn H., Supequdics and Angte 
Pmsemn g Transfccmatiass, Cusapufcr Gmphic$, 15(3), August 1981, pp 11-23. [BARR86] Bsrr, Alan H., Ray 
TrAng Defosmed Surfaces, Cosnptucr Gmphics, 20(4), August 1986, pp. 287-2%, [BtN~l ] Binfad. T., in Vissw/ 
Perception by CompuScr, Prweedings qfthe IEEE Ccwfercncc cm systems ondMiami, ConmSI,FL,December 197t. 
 ICARL82bl Carkon. W.E..TcchniaIKsfor Gessemrionof Three Dinwnsiomd Da&#38;s .. foru.se i. Complex IsnogeSyrthcsis, 
Ph.D. Thesii, Ohio Stste Univcssity, Sept. 1982. [COHE83] Cnhen. E,, Some Msthemsticat Toots f-a Mdctc#s 
Workbeds, IEEE ComputerGmphics and&#38;siicatians, 5(2), pp. 63-66. [CKtC3K84] Cook, RobcsI L., ShadeTrees, 
Computer Graphics, 18(3), Jufy 1984, pp. 223-232. [COQU87] Coquihrr. S. A Control Point Bssed SwcepingTachnique, 
JE.EEGmI­pu/cr Gmphic$andAppficotion.s,7( 1l), 1987, pp. 3645. [FRAN81] Frsnklin, W.F. and Atsn H. Barr, 
Fsster Catcuhtion of S~Us&#38;iCS: IEEEComputerGmphics arsdApplicatians, 1(3), 1981, IQ. 41-47. [OOLD83] 
Goldman. R.N., Qusdrics of Revolution, lEEEConpurerGmphics and A@icatians, 3(2), 1983, pp. 68-76. [KAJ189] 
Kajiys, Jsmes T.,andTtiyL. withlluu Kay, RessdcrissgFurOimen­sionsl Textures. CompsrerGraphics, 23(3), 
July 1989, pp. 271-280. Computer Graphics, 26,2, July 1992 [LAJr392] Laidkw, David,J.SIIydsr, Model A. 
Wdhuy, andA. Barr,ExuAm usingctassi6cad0n, ~~~. [LOSS74] Lossins, D.L., and A.L. f?drfensau, PJmning 
. Commnn Oats Base for EI@DCC@and Maoufacmring. SHAJtEXUIl, =qO, m, AUS. 1974. [PERL85] ~ h AII ~ $sslbasizr,-Comfwtcr 
Gr@icJ, 19(3). hdy 1985, pp. 287-2%. Press, W* H., &#38;ian P. Ftannsry Ssut A. Tcukohky, snd W@ T. 
Veuesf@ Nmwn cdReeifsc;,Csn&#38;idgeUoivcssityCamk idga, b, EnglMd,1986. [SNYD91] Snyder, Jc4m, Gcrsertsliu 
A40dcling: An Appswrh to High fNCl Mope Dcsignfor Com#er Graphics 4 CAD, Ph.D. Thesis, Catifosnis Irnti­tsne 
of Tdmc40gy, 1991. [SNYo92s] Snydec,John. Imervathatysis forcaqwtecorsphic$, robpubkhad ins-92. [sNYD92b]Sssyda,hhn, 
GesKM veModeling for Compsster Gmphics and CAD: &#38;snboiicS@se Design Using IntesvalAnOfysis, to be 
#isfrcd by Am. dcmdcPrass, JUty1992. mOM85] Tbmpon, JosF..ZU.A. Warsi snd C. Wayne Masdn, Nwnerirol Grid 
Genemths, Nostts-HoUamf,New Yak. f985. [VtlNH871 Vno Hcrz.ea.Bsixn P. A Akn H. BMT, Accunte Ssmpting 
of Dsfarnad. fntamecbn g surfaces with ouadtmcs, Computer Graphics, 21(4), Jsdy 1987, PP. 103-I 10. WANG86] 
Wing,W.P,andK.K.Wang GeometricMndsUingfor Swept Volume of Moving Soli&#38;, IEEE ComputerGmphics and 
Applicotihss, 6(12), 1986, F9, 8-17.  Appendix -Sampling Speedups UnffornssamplingSpaedup suing Tabk 
bokup A wbstsntid.-d Unifnslsspammeme avsluxtinn carsbe Sccosnfstished by cmstmcdng evstuuina tsbks fnrsubfuncrions,wbeseasubtimcrionisa 
Subtmeinthctmeofqmlbntknfmtnss m--mta~ functicm[FltAN81]. Fmexssnpk, ktfi R 3 _ It barbs fulwtksm f(~l. 
X2,Xd = (X1X2+x2x3)eX2 Wtdchwc wishtounifdy~k ni SUDPISS fWSCM k dMS USiISCf~-h~i. by .vshssdngf st ads 
oftbe. ,.2.3 tatdce points in psmmderspsce. Attccnsdvefy, we Canccmstmct evahmtiontabtel fnrthe Subfuncticasf,(X1, 
X2)=X,X2,fz(xl, x3)= X2X3,XIMffj(xl) =dz, SOM * SllbfUnCb= ItOt~VStti Bt* ktdCC point.H-katiofk nu&#38;of~tim 
~tifwtiwo~tof Svslustingf [ function II . ofss T +W ~­ evatuation point by point [ f -(X,X2 + x2x3w~ 
I 3n,nys3 mn2n3 [ nln2n3 1 evshlstion using tables fl = X1X2 n1n2 o0 o0 0 0n? f :3:3 n2n3 i-(f, +f2) 
. f~ II nln2n3 nln2n3 I i total n,qsq+ I atn2n3 n2 I n1n2+-np3 J The tsble show thatdsstmtiat Cc4nputstimslsavings 
ramlt whenthe kswes­d~ suhtiIncdonsSsxfSrnsedhl geamt, -~ us Svatuarcdin *ks. tdltasbnutdba ma#mdcd raraasb 
sxsMlmrtlOaMk aa~~ smalkrtbaa ttsfsarcat. Fmrn~b&#38;mb*tie~.ofti~t-bl, Shosddtserabsdsd becsuscits psrentfuncdonf 
hssinpsudinsesuion3. Suchasssb fussedon skndd be tsbulated st the kttice points nf ita pardculx input 
vuisbks (e.g., evstustions frotntbe subrimctione~ arestomd inalDtabk ofsizen2, whikevshss­ti-fmti sutitix 
lx2=-ba2D* &#38;stin1xn2). AdaptiveSampling Speedup UrissgCaching Ads@ivcsmptingcanbe crs­W~=hgtibI_dvdWda 
suhtim. Wti*t*d thesubfunctionrasuttSICsrosed.If.inaSinureevshmim. theinsutonintmatchesttrs may bs used 
WkhOUtWbfunctiomtimeIowt reevstusdon. Cadkfstem= thosetbt inputtbstare repeated (i.e., ~). dimmsionthantheirpsrent, 
0s shued Caching carsbe used fas inclusion function evshmtinn m wetf as pint evslustim. Caching is especially 
useful in cucs mch as when m iotegrsndcnntains. sub funcdon thatisnnt depcdmtmltlrs pmmetec ofintegradon, 
whenmsuMuK­tionof input d-ion O ix defined using conspststionstty expensive qesarms (e.g.,   
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
	<article_rec>
		<article_id>134096</article_id>
		<sort_key>379</sort_key>
		<display_label></display_label>
		<article_publication_date>07-01-1992</article_publication_date>
		<seq_no>45</seq_no>
		<title><![CDATA[Modeling seashells]]></title>
		<page_from>379</page_from>
		<page_to>387</page_to>
		<doi_number>10.1145/133994.134096</doi_number>
		<url>http://dl.acm.org/citation.cfm?id=134096</url>
		<keywords>
			<kw><![CDATA[logarithmic helico-spiral]]></kw>
			<kw><![CDATA[modeling of natural phenomena]]></kw>
			<kw><![CDATA[reaction-diffusion pattern model]]></kw>
			<kw><![CDATA[realistic image synthesis]]></kw>
			<kw><![CDATA[seashell]]></kw>
			<kw><![CDATA[sweep representation]]></kw>
		</keywords>
		<categories>
			<primary_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Curve, surface, solid, and object representations</descriptor>
				<type>S</type>
			</primary_category>
			<other_category>
				<cat_node>I.3.5</cat_node>
				<descriptor>Geometric algorithms, languages, and systems</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>J.3</cat_node>
				<descriptor>Biology and genetics</descriptor>
				<type>S</type>
			</other_category>
			<other_category>
				<cat_node>I.3.7</cat_node>
				<descriptor></descriptor>
				<type></type>
			</other_category>
		</categories>
		<ccs2012>
			<concept>
				<concept_id>0.10010405.10010444.10010087</concept_id>
				<concept_desc>CCS->Applied computing->Life and medical sciences->Computational biology</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010178.10010224.10010226.10010239</concept_id>
				<concept_desc>CCS->Computing methodologies->Artificial intelligence->Computer vision->Image and video acquisition->3D imaging</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010405.10010444.10010095</concept_id>
				<concept_desc>CCS->Applied computing->Life and medical sciences->Systems biology</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10003752.10010061</concept_id>
				<concept_desc>CCS->Theory of computation->Randomness, geometry and discrete structures</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010405.10010444.10010935</concept_id>
				<concept_desc>CCS->Applied computing->Life and medical sciences->Genetics</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010352</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Animation</concept_desc>
				<concept_significance>100</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010401</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Volumetric models</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396.10010399</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling->Parametric curve and surface models</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
			<concept>
				<concept_id>0.10010147.10010371.10010396</concept_id>
				<concept_desc>CCS->Computing methodologies->Computer graphics->Shape modeling</concept_desc>
				<concept_significance>500</concept_significance>
			</concept>
		</ccs2012>
		<general_terms>
			<gt>Algorithms</gt>
			<gt>Design</gt>
		</general_terms>
		<authors>
			<au>
				<person_id>P64995</person_id>
				<author_profile_id><![CDATA[81100062479]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>1</seq_no>
				<first_name><![CDATA[Deborah]]></first_name>
				<middle_name><![CDATA[R.]]></middle_name>
				<last_name><![CDATA[Fowler]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Department of Computer Science, University of Calgary, and University of Regina Canada]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>PP31088743</person_id>
				<author_profile_id><![CDATA[81100407379]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>2</seq_no>
				<first_name><![CDATA[Hans]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Meinhardt]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Max-Planck-Institut, fltrEntwicklungsbiologie 7400 Tttbingen,Germany]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
			<au>
				<person_id>PP14162862</person_id>
				<author_profile_id><![CDATA[81100465812]]></author_profile_id>
				<orcid_id></orcid_id>
				<seq_no>3</seq_no>
				<first_name><![CDATA[Przemyslaw]]></first_name>
				<middle_name><![CDATA[]]></middle_name>
				<last_name><![CDATA[Prusinkiewicz]]></last_name>
				<suffix><![CDATA[]]></suffix>
				<affiliation><![CDATA[Department of Computer Science, University of Calgary, Alberta CanadaT2N 1N4]]></affiliation>
				<role><![CDATA[Author]]></role>
				<email_address><![CDATA[]]></email_address>
			</au>
		</authors>
		<references>
			<ref>
				<ref_seq_no>1</ref_seq_no>
				<ref_text><![CDATA[R. Baker and G. T. Herman. Simulation of organisms using a developmental model, parts I and iI. int. Journal of Bio- Medical Computing, 3:201-215 and 251-267, 1972.]]></ref_text>
				<ref_id>1</ref_id>
			</ref>
			<ref>
				<ref_seq_no>2</ref_seq_no>
				<ref_text><![CDATA[R. Bartels and I. Hardtke. Speed adjustment for key-frame interpolation. In Proceedings of Graphics Interface' 89, pages 14-19, 1989.]]></ref_text>
				<ref_id>2</ref_id>
			</ref>
			<ref>
				<ref_obj_id>6118</ref_obj_id>
				<ref_obj_pid>6116</ref_obj_pid>
				<ref_seq_no>3</ref_seq_no>
				<ref_text><![CDATA[W. Bronsvoort and F. Klok. Ray tracing generalized cylinders. ACM Transactions on Graphics, 4(4):291-303, 1985.]]></ref_text>
				<ref_id>3</ref_id>
			</ref>
			<ref>
				<ref_seq_no>4</ref_seq_no>
				<ref_text><![CDATA[T.A. Cook. Curves of Life. Dover Publications, New York, 1979. Originally published in 1914, by Constable and Company, London.]]></ref_text>
				<ref_id>4</ref_id>
			</ref>
			<ref>
				<ref_seq_no>5</ref_seq_no>
				<ref_text><![CDATA[M.B. Cortie. Models for mollusc shell shape. South African Journal of Science, 85:454-460, 1989.]]></ref_text>
				<ref_id>5</ref_id>
			</ref>
			<ref>
				<ref_seq_no>6</ref_seq_no>
				<ref_text><![CDATA[H. S, M. Coxeter. Introduction to Geometry. J. Wiley &amp; Sons, New York, 1961.]]></ref_text>
				<ref_id>6</ref_id>
			</ref>
			<ref>
				<ref_seq_no>7</ref_seq_no>
				<ref_text><![CDATA[M. do Carmo. D~fferemial Geometry of Curves and Surfaces. Prentice Hall, Englewood Cliffs, 1976.]]></ref_text>
				<ref_id>7</ref_id>
			</ref>
			<ref>
				<ref_seq_no>8</ref_seq_no>
				<ref_text><![CDATA[B. Ermentrout, J. Campbell, and G. Oster. A model for shell patterns based on neural activity. The Veliger, 28:369-388, 1986.]]></ref_text>
				<ref_id>8</ref_id>
			</ref>
			<ref>
				<ref_obj_id>83821</ref_obj_id>
				<ref_seq_no>9</ref_seq_no>
				<ref_text><![CDATA[J.D. Foley, A. Van Dam, S.K. Feiner, andJ. F. Hughes. Cornpater Graphics: Principles and Practice. Addison-Wesley, Reading, Massachusetts, 1990.]]></ref_text>
				<ref_id>9</ref_id>
			</ref>
			<ref>
				<ref_seq_no>10</ref_seq_no>
				<ref_text><![CDATA[L. Fox and D. F. Mayers. Numerical Solution of Ordinary Differential Equations. Chapman and Hall, London, 1987.]]></ref_text>
				<ref_id>10</ref_id>
			</ref>
			<ref>
				<ref_seq_no>11</ref_seq_no>
				<ref_text><![CDATA[A. Gierer and H. Meinhardt. A theory of biological pattern formation. Kybernetik, 12:30-39, 1972.]]></ref_text>
				<ref_id>11</ref_id>
			</ref>
			<ref>
				<ref_seq_no>12</ref_seq_no>
				<ref_text><![CDATA[N.R. Gordon. Seashells: A PhotographicCelebration. Friedman Group, New York, 1990.]]></ref_text>
				<ref_id>12</ref_id>
			</ref>
			<ref>
				<ref_seq_no>13</ref_seq_no>
				<ref_text><![CDATA[L. G. Harrison. What is the status of the reaction-diffusion theory thirty-four years after Turing? Journal of Theoretical Biology, 125:369-384, 1987.]]></ref_text>
				<ref_id>13</ref_id>
			</ref>
			<ref>
				<ref_seq_no>14</ref_seq_no>
				<ref_text><![CDATA[C. Illert. Formulation and solution of the classical seashell problem, li NuovoCimento, 11 D(5):761-780, 1989.]]></ref_text>
				<ref_id>14</ref_id>
			</ref>
			<ref>
				<ref_obj_id>801284</ref_obj_id>
				<ref_obj_pid>965145</ref_obj_pid>
				<ref_seq_no>15</ref_seq_no>
				<ref_text><![CDATA[Y. Kawaguchi. A morphological study of the form of nature. Computer Graphics, 16(3):223-232, 1982.]]></ref_text>
				<ref_id>15</ref_id>
			</ref>
			<ref>
				<ref_seq_no>16</ref_seq_no>
				<ref_text><![CDATA[H. Meinhardt. Models of Biological Pattern Formation. Academic Press, London, 1982.]]></ref_text>
				<ref_id>16</ref_id>
			</ref>
			<ref>
				<ref_seq_no>17</ref_seq_no>
				<ref_text><![CDATA[H. Meinhardt. Models for positional signalling, the threefold subdivision of segments and the pigmentation patterns of molluscs. J. Embryol. exp. Morph., 83:289-311, 1984. Supplement.]]></ref_text>
				<ref_id>17</ref_id>
			</ref>
			<ref>
				<ref_seq_no>18</ref_seq_no>
				<ref_text><![CDATA[H. Meinhardt and M. Klinger. A model for pattern formation on the shells of molluscs. Journal of Theoretical Biology, 126:63-89, 1987.]]></ref_text>
				<ref_id>18</ref_id>
			</ref>
			<ref>
				<ref_seq_no>19</ref_seq_no>
				<ref_text><![CDATA[H. Meinhardt and M. Klinger. Pattern formation by coupled oscillations: The pigmentation patterns on the shells of molluscs. In Lecture Notes in Biomathematics, volume 71, pages 184-198. Springer-Verlag, Berlin, 1987.]]></ref_text>
				<ref_id>19</ref_id>
			</ref>
			<ref>
				<ref_seq_no>20</ref_seq_no>
				<ref_text><![CDATA[H. Meinhardt and M. Klinger. Schnecken- und Muschelschalen: Modellfall der Musterbildung. Spelarum der Wissenschafl, pages 60-69, August 1991.]]></ref_text>
				<ref_id>20</ref_id>
			</ref>
			<ref>
				<ref_seq_no>21</ref_seq_no>
				<ref_text><![CDATA[H. Moseley. On the geometrical forms of mrbinated and discold shells. Philosophical Transactions of the Royal Society of London, pages 351-370,1838.]]></ref_text>
				<ref_id>21</ref_id>
			</ref>
			<ref>
				<ref_seq_no>22</ref_seq_no>
				<ref_text><![CDATA[J.D. Murray, MathematicalBiology. Springer-Verlag, Berlin, 1989.]]></ref_text>
				<ref_id>22</ref_id>
			</ref>
			<ref>
				<ref_obj_id>15892</ref_obj_id>
				<ref_obj_pid>15886</ref_obj_pid>
				<ref_seq_no>23</ref_seq_no>
				<ref_text><![CDATA[P. Oppenheimer. Real time design and animation of fractal plants and trees. Computer Graphics, 20(4):55---64, 1986.]]></ref_text>
				<ref_id>23</ref_id>
			</ref>
			<ref>
				<ref_obj_id>617519</ref_obj_id>
				<ref_obj_pid>616008</ref_obj_pid>
				<ref_seq_no>24</ref_seq_no>
				<ref_text><![CDATA[C.A. Pickover. A short recipe for seashell synthesis. IEEE Computer Graphics and Applications, 9(6):8-11, 1989.]]></ref_text>
				<ref_id>24</ref_id>
			</ref>
			<ref>
				<ref_obj_id>99712</ref_obj_id>
				<ref_seq_no>25</ref_seq_no>
				<ref_text><![CDATA[C.A. Pickover. Computers and the Imagination. St. Martin's Press, New York, 1991.]]></ref_text>
				<ref_id>25</ref_id>
			</ref>
			<ref>
				<ref_obj_id>16592</ref_obj_id>
				<ref_obj_pid>16564</ref_obj_pid>
				<ref_seq_no>26</ref_seq_no>
				<ref_text><![CDATA[P. Prusinkiewicz and D. Streibel. Constraint-based modeling of three-dimensional shapes. In Proceedings of Graphics Interface ~86 m Vision Interface '86, pages 158-163,1986.]]></ref_text>
				<ref_id>26</ref_id>
			</ref>
			<ref>
				<ref_seq_no>27</ref_seq_no>
				<ref_text><![CDATA[D.M. Raup. Computer as aid in describing form in gastmlx~d shells. Science, 138:150-152,1962.]]></ref_text>
				<ref_id>27</ref_id>
			</ref>
			<ref>
				<ref_seq_no>28</ref_seq_no>
				<ref_text><![CDATA[D. M. Raup. Modeling and simulation of morphology by computer. In Proceedings of the North American Paleontol. ogy Convention, pages 71-83, 1969.]]></ref_text>
				<ref_id>28</ref_id>
			</ref>
			<ref>
				<ref_seq_no>29</ref_seq_no>
				<ref_text><![CDATA[D. M. Raup and A. Michelson. Theoretical morphology of the coiled shell. Science, 147:1294-1295,1965.]]></ref_text>
				<ref_id>29</ref_id>
			</ref>
			<ref>
				<ref_seq_no>30</ref_seq_no>
				<ref_text><![CDATA[B. Sabelli. Guide to Shells. Simon &amp; Schuster, New York, 1979. Edited by H. S. Feinberg.]]></ref_text>
				<ref_id>30</ref_id>
			</ref>
			<ref>
				<ref_seq_no>31</ref_seq_no>
				<ref_text><![CDATA[d'Arcy Thompson. On Growth and Form. University Press, Cambridge, 1952.]]></ref_text>
				<ref_id>31</ref_id>
			</ref>
			<ref>
				<ref_seq_no>32</ref_seq_no>
				<ref_text><![CDATA[d'Arcy Thompson. On Growth and Form, Abridged Edition. University Press, Cambridge, 1961.]]></ref_text>
				<ref_id>32</ref_id>
			</ref>
			<ref>
				<ref_seq_no>33</ref_seq_no>
				<ref_text><![CDATA[A. Turing. The chemical basis ofmorphogenesis. Philosophical Transactions of the R o yal Society of London B, 237:37-72, 1952.]]></ref_text>
				<ref_id>33</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122749</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>34</ref_seq_no>
				<ref_text><![CDATA[G. Turk. Generating textures on arbitrary surfaces using reaction-diffusion. Computer Graphics, 25(4):289-298, 1991.]]></ref_text>
				<ref_id>34</ref_id>
			</ref>
			<ref>
				<ref_seq_no>35</ref_seq_no>
				<ref_text><![CDATA[C. H. Waddington and J. Cowe. Computer simulations of a molluscan pigmentation pattern. Journal of Theoretical Biology, 25:219-225, 1969.]]></ref_text>
				<ref_id>35</ref_id>
			</ref>
			<ref>
				<ref_obj_id>122750</ref_obj_id>
				<ref_obj_pid>127719</ref_obj_pid>
				<ref_seq_no>36</ref_seq_no>
				<ref_text><![CDATA[A. Witkin and M. Kass. Reaction-diffusion textures. Com. purer Graphics, 25(4):299-308,1991.]]></ref_text>
				<ref_id>36</ref_id>
			</ref>
			<ref>
				<ref_seq_no>37</ref_seq_no>
				<ref_text><![CDATA[S. Wolfram. Cellular automata as models of complexity. Nature, 311:419-424, 1984.]]></ref_text>
				<ref_id>37</ref_id>
			</ref>
		</references>
		<fulltext>
			<file>
				<seq_no></seq_no>
				<fname></fname>
			</file>
			<ft_body><![CDATA[
 Computer Graphics, 26, 2, July 1992 Modeling seashells Deborah R. Fowler Hans Meinhardt Przemyslaw 
Prusinkiewicz _ent of ComputerScience University of Catgary Max-Planck-Institut fltrEntwicklttngsbiologie 
Departmentof ComputerScienee University of Calgary and University of ReginaCanada 7400 Tttbingen,Germany 
Al&#38;r@ CanadaT2N 1N4 (Authors listed alphabetically) ABSTRACT This paper presents a method for modeling 
seashelfs, suitable for image synthesis purposes. It combines a geometric description of shelf shapes 
with an activator-inhibitor model of pigmentation patterns on shell surfaces. The technique is illustrated 
using models of selected sheUs found in nature. CR Categorks: 1.3.5 [Computer Graphka]: Computational 
Ge­ ometry and Object Modeling: Curve, siufue, solid and object represenfutwn. 1.3.7 [Computer Graphka]: 
l%ree-f)imensionaf Graphics and Reafism. J.3 Life and Medkal Sciences]: Biology. Keyworda: realistic 
image synthesis, modeling of natural phe­nomenq seashell, logarithmic helico-spiral, sweep representation, 
reactiondfision pattern model. 1 INTRODUCTION The beauty of shells invites us to construct their mathematical 
mod­els. The motivation is to synthesize realistic images that could be incorporated into computer-generated 
scenes and to gain a better understanding of the mechanism of shelf formation. The latter objective was 
crisply justified by Raup, the pioneer of computer modeling of shelf morphology [28]: Successful simulation 
provides confirmation of the underlying models as valid descriptions of the actuaf biological situation; 
Unsuccess!id simulation shows flaws in the pstu­lated model and may suggest the changes that should be 
made in the model to correct the flaws; Nonacurring forms, perhaps intermediate between actuaf species, 
may be simulated and thus may lead to a better understanding of tie relationships between the reaf forms. 
In this paper,weproposea modelirtgtechniquethat combines two key components: a model of shelf shapes 
derived from a descriptive Pcrmiskion to c<)py wl{hcwt fee idl w part of this mtrterid IS granted prnvlcfed 
th~t the copws arc nut made or distributed for direct commercltil advmtagc. the ACM copyright nol]ce 
and the title of the publication mrd it, date ~ppear, and notice is given !ha! copying is by permission 
{lf the Awoclatmn for Computing Machinery. To copy otberw ise, (Ir t{) republlib, requires a fee ~nd,or 
\pccllic p+xrnissi~m characterizationby d Arty Thompson[31],andareactiondiffusion model of pigmentation 
patterns originated by Meinhardt [17]. The resultsare evaluatedby comparing modefs with the real shells. 
Historically, the logarithmic spimt, capturing the essence of the shelf shape, was first &#38;scribed 
in 1638 by Descartes [31, page 754] and apptied to characterize sheff coiling by Mosetey [21]. By the 
beginning of the twentieth century, it was observed in many artiticiaf and organic forms [4]. Moseley 
s characterization was supported experimentally and popularized by Thompson[31 ], who presented careful 
measurements of a wide variety of taxonomic and fttrtctionaf types of shells, and showed their conformity 
with the logarithmic model. The application of computers to the visualization and analysis of shetf shapes 
was originated by Raup. In the 6rat paper &#38;voted to this topic [27], he presented twodirnensionaf 
plots of tongitudmal cross-sections of shells as a form of blueprints that may sasist a person who is 
drawing shetl forms. Subsequently, Raup extended his model to three dnensions [29], and visusdized shell 
models as stereo pairs, using a wire-frame representation [28]. Kawaguchi [15] developed the first shell 
model intended speci6­cally for computer graphics purposes. He enhartced the appearance of shell modefs 
using a polygon mesh instead of a wire !hrnc. Sim­ilar representations were used subsequently by Oppenheimer 
[23], and Prusinkiewicz and Streibel [26]. Pursuing a different approach, Pickover [24, 25] approximated 
shell surf-s using interpenetrat­ing spheres, placed at carefully chosen d~tances from esch other and 
rendered using periodically altering colors to create the appear­ance of a ribbed surface with stripes. 
The recent work on the modeling of shetfs has been characterized by an increased attention to detail. 
Iflert [14] introduced Prenet frames [3, 7] to precisely orient the opening of the shetl. His model also 
captured a form of surface sculpture. Cortie [5] altowed for independent Wing of the opening in three 
directions, presented models with the apertures defying simple mathematical &#38;scription, and extended 
the range of surface ornamentations captured by the model. Our model of shefl geomeny is similar to that 
originated by Raup and culminating in the work of Cortie. h enhances previous modefs by applying free-form 
parametric curves (in the B4zier form) to capture the shape of shell aperture. However, the most conspic­uous 
improvement results from the incorporation of pigmentation patterns into the models. Mathematical modeling 
of pigmentation patterns was pioneered in 1969 by Waddington and Cowe [35], who reproducedpatternsof 
Ofiva porphyria using cellular automata. A similar formalism was ACM-()-8979 1-479-l/92/ol)7/0379 $01.50 
. SIGGRAPH 92 Chicago, July 26-31, 1992 applied by Baker andHerman [1], and Wolfhrn [37]. According 
to Murray [22, page 506], these models had no basis in the underlying biological processes involved in 
the mollusc s growth. In 1984, Meinhardt introduced a biologically-motivated reactiondiffusion model 
[17], subsequently refined with KUnger [18, 19, 20]. Er­mentrouL CarnpbeU md Oster [8] proposed an alternative 
model employing neural neta. These two models share the basic mathemat­ical concepts of short-range activation 
and long-range inhibition, and consequently yield similar patterns. Weemploy Meinhardt s model in our 
implementation. Fmm the computer graphics perspective, the use of reaction­dfision processes[11, 16, 
33] for image synthesis proposes was pioneered by Turk [34], and Whkin and Kass [36]. They fo­cused on 
patterns defined by the distribution of morphogens in twodimensional surfaces. fn contraaL pigmentation 
patterns in sheUs are formed only along the growing edge of a sheU. The see­ond dimension results from 
the deposition of new shell material, which continually changes the position of the growing edge over 
time. Thus, the pattern on a shell can be viewed as a record of what has happened at the growing edge 
during the life span of a particular animal. This dynamic aspect sets rhe pigmentation pat­terns in shells 
apart from the reactionditTusion models previously considered in computer graphics. The organization 
of the paper follows the main division of the topic into the modeling of sheU shapes (Section 2) and 
the generation of pigmentation patterns (Section 3). The results are evaluated in Section 4, which is 
concluded with a Ust of open problems. 2 MODELING SHELL GEOMETRY In Chapter XI of On Growthand Form 
[31], d Arty Thompson provided a detaUed description of sheU geometry, supported by measurements of selected 
sheUs. Some of his observations are quoted below in a slightly edited form. The surfaceof any sheU may 
be generated by the revolution about a fixed axis of a closed curve, which, remaining always geometrically 
similar to itself, in­creases its dimensions continually. [...] Let us imag­ine some characteristic point 
within this closed curve, such as its centre of gravity. Starting from a fixed ori­gin, this characteristic 
point describes an equiangular spiral in space about a fixed axis (namely the axis of the sheU), with 
or without a simultaneous movement of translation along the axis. The scale of the figure increases in 
geometrical progression while the angle of rotation increases in arhhmetical. and the centre of sirniUtude 
remains fixed. [...] The form of the gen­erating curve is seldom open to easy mathematical expressions. 
Our modeUng method is derived 6om this description. 2.1 The hdiCMpi~! The modeUngof a shell surface starts 
with the construction of a log­arithmic (equiangukr) helico-spiral H (Figure 1). fn a cylindrical coordinate 
system (shown in Figure 1 as embedded in the Cartesian zyz system) it has the parametric description 
[6]: e =t, r= ro(rt, z = Zo(gt. (1) Parameter f ranges from O at the apex of the sheU to t~a= at the 
opening. The first two equations represent a logarithmic spiral lying 380  center of similitude ~ of 
the shell . shell surface he M(t) %...... shell sxis --------------- ... generating curve c i z Figure 
1: Construction of the shell surface in the plane z = O. The third equation stretches the spiral along 
the z-axis, thus contributing a helical component to its shape. Distances r and z are exponential timctions 
of the parameter t, and USUWYhave tie s~e bsse. <~ = t. = t. AS a resul~ the generating helico-spiral 
is self-similar, with the center of similitude located at the origin of the coordinate system zyz. Given 
the inhial values O., ro, and Zo, a sequence of points on the helico-spiral can be computed incrementally 
using the formulae: @i+l = tl+At = 61+AO, ~1+1 = ro(~i <~t = rl~r, (2) 21+1 = Zo<:iet = 2:.X*. While 
the angle of rotation 8 increases in arithmetic progression with the step Ad, the radius r forms a geometric 
progression with the scaling factor A, = ~~t, and the vetical displacement z forms a geometric progression 
with the scaling factor AZ = <~t. In many sheUs, parameters A. and ~. are the same. Variations of sheU 
shapes due prirnarUy fo different parameters of the helieo-spiral are shown in Figure 2. They correspond 
closely to the shell types identified by d Arty Thompson [32, page 192]. 2.2 The generating cume The 
surface of the shell is determined by a generating cuwe C, sweeping along the helico-spiral H. The size 
of the curve C in­creases as it revolves around the sheU axis. The shape of C &#38;ter­mines the profile 
of the whorls and of the shell opening. In order to capture the variety and complexity of possible shapes, 
we con­struct the generating curves from one or more segments of B4zier curves [9]. The impact of the 
generating curve on the shape of a sheU is shown in Figures 3 and 4. 2.3 Incorporation of the generating 
curve into the model The generating curve C is specitkd in a local coordinate system UVW. Given a point 
?l(t) of the helico-spiral, C is tirat scaled up by the factor ~ct with respect to the origin O of this 
system, then rotated and translated so that the point O matches M(t) (Figure 1). The axes uvw are used 
to orient the generating curve ~ sp~e. The           Computer Graphics, 26,2, July 1992 References 
[21] H. Moseley. On the geometrical forms of turbinated and dia­ [1] [2] [3] [4] [5] [6] [7] [8] [9] 
[10] [11] [12] [13] [14] [15] [16] [17] [18] [19] [20] R. Baker and G. T. Herman. Simulation of organisms 
using a developmental mode~ parts I and II. ht. .lournal of Bio-Medical Corr@ng, 3:201-215 and 251-267,1972. 
R. Bartels and I. Hardtke. Speed adjustment for key-th.rne interpolation. In ProceedingsofGraphicsInterface 
89,pages 14-19,1989. W. Bronsvoort and F. Klok. Ray tracing generalized cylinders. ACM Transactwruon 
Graphics, 4(4):291-303, 1985. T. A. Cook. Curves of L.ife. Dover Publications, New York 1979. Origi.naUypublished 
in 1914, by Constable and Com­pany, London. M. B. Cortie. Models for molhrsc shell shape. SouIh African 
Journal of Science, 85:454460,1989. H. S. M. Coxeter. [rrtroduclwn to Geometry. J. Wiley &#38; Sons, 
New York 1961. M. do Carmo. D#erential Geometry of Curves and Surfmes. PrenticeHall, Englewood Cliffs, 
1976. B. Errnentmu~ J. Campbell, and G. Oster. A model for sheU patterns based on neural activity. The 
Veliger,28:369-388, 1986. J. D. Foley, A. Van Dam, S. K. Feiner, and J. F. Hughes. Com­puter Graphics: 
Principlesand Practice. Addison-Wesley, Reading, Massachusetts, 1990. L. Fox and D. F. Mayers. Numerical 
Solution of Ordinary Differential Equatwns. Chapman and Hall, London, 1987. A. Gierer and H. Meinhardt. 
A theory of biological pattern formation. Kybernetik,12:30-39, 1972. N. R. Gordon. Seashells: A PhotographicCelebratwn.Fried­man 
Group, New York, 1990. L. G. Hamison. What is the status of the reactiondiffusion theory thirty-four 
years after Turing? Journalof Theoretical Bwlogy, 125:369-384,1987. C. Illett. Formulation and solution 
of the classical seashell problem. 1/ Niwvo C&#38;nento, 11 D(5):761-780, 1989. Y. Kawaguchi. A morphological 
study of the form of nature. Coqw.ter Graphics, 16(3]:223-232, 1982. H. Meinhardt. Models of Bwlogical 
Pattern Formation. Aca­demic Ress, I.mdon, 1982. H. Meinhardt. Mcdels for positional signaling, the 
three­fold subdivision of segments and the pigmentation patterns of molluscs. J. EmbryoL exp. Morph., 
83:289-311, 1984. Supplement. H. Meinhardt and M. Klinger. A model for pattern formation on the shells 
of moUuscs. Journal of TheoreticalBiology, 126:63-89,1987. H. Meinhardt and M. Klinger. Pattern formation 
by coupled oscillations: The pigmentation patterns on the shells of mol-lUSCS.In Lecture Notes in Biornathematics, 
volume 71, pages 184-198. Springer-Verlag, Berlin, 1987. H. Meinhardt and M. Klinger. Schnecken-und Muschelschalen: 
Modellfall der Musterbildung. Spektrum der Wi.rsenrch@, pages 60-69, August 1991.  wid shells. PhilosophicalTranractionrof 
the RoyafSociety ofLondo&#38;pages 351-370,1838. [22] J. D. Murray. MatkmaticalBwfogy. Springer-Verlag,Balin, 
1989. [23] P. Oppenheimer. Real time design and animation of fsactal plants and trees. Computer Graphics, 
20(4)55-64, 1986. [24] C. A. Pickover. A short recipe for seashell synthesis. IEEE ConputerGr@ics andApplications,9(6)8-1 
1,1989. [25] C. A. Pickover. Corrqwters and the hnuginatwn. St. Martin s Press, New York, 1991. [26] 
P. Rusinkiewicz and D. Streibel. Constraint-based modeling of threedimensional shapes. Jn Proceedings 
of Gr@ics lnter@e 86 Viiwn Interface 86, pages 158-163,1986. [27] D. M. Raup. Computer as aid in describing 
form in gaatmpod shells. Science, 138:15*152, 1962. [28] D. M. Raup. Modeling and simulation of morphology 
by computer. In Proceedings of [k North American Paleontol­ogy Conventwn, pages 71-83, 1969. [29] D. 
M. Raup and A. Michelson. Theoretical morphology of the coiled shell. Science, 147:1294-1295,1965. [30] 
B. Sakdli. Guide to Shells. Simon &#38; Schuster, New York 1979. Edited by H. S. Feinberg. [31] d Arty 
Thompson. On Growthand Form. University Press, Cambridge, 1952. [32] d Arty Thompson. On Growth and Form, 
Abridged &#38;fitwn. University Press, Cambridge, 1961. [33] A. Turing. The chemical basis of morphogenesis. 
Philosophi­calTransactionroftk RoyalSocietyofLondonB,237:37-72, 1952. [34] G. Turk. Generating textures 
on arbhary surfaces us­ing reactiondiffusion. Corrqw.terGraphics, 25(4>289-298, 1991. [35] C. H. Waddington 
and J. Cowe. Computer simulations of a molluscan pigmentation pattern. Journal of Theoretical Biology,25:219-225,1969. 
[36] A. Wltkin and M. Kass. Reactiondiffusion textures. Com­puter Graphics, 25(4)299-308, 1991. [37] 
S. Wolfram. Cellular automata as models of complexity. Na­ture, 311:419424,1984.  
			]]></ft_body>
		</fulltext>
		<ccc>
			<copyright_holder>
				<copyright_holder_name>ACM</copyright_holder_name>
				<copyright_holder_year>1992</copyright_holder_year>
			</copyright_holder>
		</ccc>
	</article_rec>
</content>
</proceeding>
